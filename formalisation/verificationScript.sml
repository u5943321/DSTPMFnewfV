open HolKernel Parse boolLib bossLib;
open stringTheory pred_setTheory listTheory;
open finite_mapTheory;
val _ = new_theory "verification";


Datatype: term = Var string sort | Fn string (term list);
          sort = St string (term list)
End


Datatype:
  form = False
       | Pred string (term list)
       | IMP form form
       | FALL string sort form
       | fVar string ((string # sort) list) (term list)
End

(* one key fact that we can remove the sort parameter of Fn is that this slot, though can have other terms, cannot have extra variables. 
*)

Definition tfv_def:
  tfv (Var n s) = {(n,s)} ‚à™ sfv s ‚àß
  tfv (Fn n tl) = BIGUNION (set (MAP tfv tl)) ‚àß
  sfv (St n tl) = BIGUNION (set (MAP tfv tl))
Termination
WF_REL_TAC ‚Äòmeasure (Œªs. case s of INL t => term_size t
                                | INR s => sort_size s)‚Äô                        
End

Definition ffv_def[simp]:
  ffv False = {} ‚àß
  ffv (Pred p tl) = BIGUNION (set (MAP tfv tl)) ‚àß
  ffv (fVar p _ tl) = BIGUNION (set (MAP tfv tl)) ‚àß
  ffv (FALL n s f) = ffv f DELETE (n,s) ‚àß
  ffv (IMP f1 f2) = ffv f1 ‚à™ ffv f2
End

val original_tm_induction =
TypeBase.induction_of ``:term``
  
Theorem better_tm_induction =
TypeBase.induction_of ``:term``
|> Q.SPECL [‚ÄòPt‚Äô,‚ÄòPs‚Äô,‚ÄòŒªtl. ‚àÄt. MEM t tl ‚áí Pt t‚Äô]
|> SRULE [DISJ_IMP_THM,FORALL_AND_THM]
|> UNDISCH_ALL
|> (fn th => CONJ (cj 1 th) (cj 2 th))
|> DISCH_ALL
|> Q.GENL [‚ÄòPt‚Äô,‚ÄòPs‚Äô] 
 
Theorem tfv_thm[simp]:
  tfv (Var n s) = {(n,s)} ‚à™ sfv s ‚àß
  tfv (Fn n tl) = BIGUNION {tfv t | MEM t tl} ‚àß
  sfv (St n tl) = BIGUNION  {tfv t | MEM t tl}
Proof
  simp[tfv_def,PULL_EXISTS] >> simp[Once EXTENSION,PULL_EXISTS,MEM_MAP]  
QED




Definition tinst_def[simp]:
  (tinst (œÉ:string # sort |-> term) (Var n s) =
   if (n,s) ‚àâ FDOM œÉ then Var n (sinst œÉ s)
   else œÉ ' (n,s)) ‚àß
  (tinst œÉ (Fn f tl) =  Fn f (MAP (tinst œÉ) tl)) ‚àß
  sinst œÉ (St n tl) = St n (MAP (tinst œÉ) tl)
Termination
  WF_REL_TAC
   ‚Äòmeasure
    (Œªs. case s of
           INL (_,t) => term_size t
         | INR (_,s) => sort_size s)‚Äô 
End            

Definition finput_def:
  finput Œ£f f = SND  (Œ£f ' f)
End


Definition foutput_def:
  foutput Œ£f f = FST (Œ£f ' f)
End

(*                                       
Definition fsig_size_def:
  fsig_size Œ£f =
End  
*)



(*

Definition tmatch_def:
  (tmatch Œ£f (lcs:string # sort -> bool) (Var n s) ct (f:string # sort |-> term) =
   if  (n,s) ‚àà lcs then
     if Var n s = ct then SOME f else NONE
   else 
     if (n,s) ‚àà FDOM f then
       if ct = f ' (n, s) then SOME f else NONE
     else
       let cs =
           (case ct of
             (Var name sort) => sort
           | Fn fname arg =>
               sinst (THE (tlmatch Œ£f {} (MAP (UNCURRY Var) (finput Œ£f fname)) arg FEMPTY)) (foutput Œ£f fname))
       in
       case smatch Œ£f lcs s cs f of
         SOME f0 => SOME (f0 |+ ((n, s),ct))
       | _ => NONE) ‚àß
  (tmatch Œ£f lcs (Fn f1 tl1) (Fn f2 tl2) f =
   if f1 = f2 then tlmatch Œ£f lcs tl1 tl2 f else NONE) ‚àß
  (tmatch Œ£f lcs (Fn _ _ ) (Var _ _)  f = NONE) ‚àß
  (smatch Œ£f (lcs:string # sort -> bool) (St n1 tl1) (St n2 tl2) f =
   if n1 = n2 then tlmatch Œ£f lcs tl1 tl2 f else NONE) ‚àß
  tlmatch Œ£f lcs [] [] f = SOME f ‚àß
  tlmatch Œ£f lcs [] (h :: t) f = NONE ‚àß
  tlmatch Œ£f lcs (h :: t) [] f = NONE ‚àß
  (tlmatch Œ£f lcs (h1 :: t1) (h2 :: t2) f =
   case tmatch Œ£f lcs h1 h2 f of
     SOME f1 => tlmatch Œ£f lcs t1 t2 f1
   | _ => NONE)
Termination
 WF_REL_TAC
   ‚Äòmeasure
    (Œªs. case s of
           INL (_,_,t1,t2,_) => term_size t1 
         | INR (INL (_,_,s1,s2,_)) => sort_size s1
         | INR (INR (_,_,tl1,tl2,_)) => term1_size tl2)‚Äô >>
 
  ‚ÄòŒªx y.
   case (x,y) of
   (INR (INL (_,_,s,cs,_)), INL (_,_,pt,ct,_)) =>
    sort_size s < term_size pt
   | (INR (INR (_,_,ptl,_,_)), INL (_,_,pt,ct2,_)) =>
     term1_size ptl < term_size pt
   | (INR (INR (_,_,ptl,_,_)), INR (INL (_,_,s,cs,_))) =>
     term1_size ptl < sort_size s
   | (INL (_,_,pt,ct,_), INR (INR (_,_,ptl,ctl,_))) =>
     term_size pt < term1_size ptl ‚àß term_size ct < term1_size ctl
   | (INR (INR (_,_,ptl1,_,_)),INR (INR (_,_,ptl2,_,_))) =>
     term1_size ptl1 < term1_size ptl2
   | _ => F‚Äô >> simp[]
End

*)

Definition tmatch_def:
  (tmatch Œ£f (lcs:string # sort -> bool) (Var n s) ct (f:string # sort |-> term) =
   if  (n,s) ‚àà lcs then
     if Var n s = ct then SOME f else NONE
   else 
     if (n,s) ‚àà FDOM f then
       if ct = f ' (n, s) then SOME f else NONE
     else
       case smatch Œ£f lcs s (sort_of Œ£f ct) f of
         SOME f0 => SOME (f0 |+ ((n, s),ct))
       | _ => NONE) ‚àß
  (tmatch Œ£f lcs (Fn f1 tl1) (Fn f2 tl2) f =
   if f1 = f2 then tlmatch Œ£f lcs tl1 tl2 f else NONE) ‚àß
  (tmatch Œ£f lcs (Fn _ _ ) (Var _ _)  f = NONE) ‚àß
  (smatch Œ£f (lcs:string # sort -> bool) (St n1 tl1) (St n2 tl2) f =
   if n1 = n2 then tlmatch Œ£f lcs tl1 tl2 f else NONE) ‚àß
  tlmatch Œ£f lcs [] [] f = SOME f ‚àß
  tlmatch Œ£f lcs [] (h :: t) f = NONE ‚àß
  tlmatch Œ£f lcs (h :: t) [] f = NONE ‚àß
  (tlmatch Œ£f lcs (h1 :: t1) (h2 :: t2) f =
   case tmatch Œ£f lcs h1 h2 f of
     SOME f1 => tlmatch Œ£f lcs t1 t2 f1
   | _ => NONE) ‚àß
  (sort_of Œ£f (Var n s) = s) ‚àß
  (sort_of Œ£f (Fn fn tl) =
  sinst (THE (tlmatch Œ£f {} (MAP (UNCURRY Var) (finput Œ£f fn)) tl FEMPTY)) (foutput Œ£f fn))
Termination
 WF_REL_TAC
  ‚ÄòŒªx y.
   case (x,y) of
   (INR (INL (_,_,s,cs,_)), INL (_,_,pt,ct,_)) =>
    sort_size s < term_size pt
   | (INR (INR (INL (_,_,ptl,_,_))), INL (_,_,pt,ct2,_)) =>
     term1_size ptl < term_size pt
   | (INR (INR (INL (_,_,ptl,_,_))), INR (INL (_,_,s,cs,_))) =>
     term1_size ptl < sort_size s
   | (INL (_,_,pt,ct,_), INR (INR (INL (_,_,ptl,ctl,_)))) =>
     term_size pt < term1_size ptl ‚àß term_size ct < term1_size ctl
   | (INR (INR (INL (_,_,ptl1,_,_))),INR (INR (INL (_,_,ptl2,_,_)))) =>
     term1_size ptl1 < term1_size ptl2
   | (INR (INR (INR (_,ct1))), INL (_,_,pt,ct2,_)) => ct1 = ct2
   | (INR (INR (INL (_,_,ptl,ctl,_))),INR (INR (INR (_,ct)))) =>
     term1_size ctl < term_size ct
   | _ => F‚Äô >> cheat
End
(*
  WF_REL_TAC
   ‚Äòmeasure
    (Œªs. case s of
           INL (_,_,t1,t2,_) => term_size t1 + term_size t2
         | INR (INL (_,_,s1,s2,_)) => sort_size s1 + sort_size s2
         | INR (INR (INL (_,_,tl1,tl2,_))) => term1_size tl1 + term1_size tl2
         | INR (INR (INR (_,t))) => term_size t)‚Äô >>
 simp[]
+ (the whole dictionary,))‚Äô 
previously the following works
      
   WF_REL_TAC
   ‚Äòmeasure
    (Œªs. case s of
           INL (_,t1,t2,_) => term_size t1 + term_size t2 
         | INR (INL (_,s1,s2,_)) => sort_size s1 + sort_size s2
         | INR (INR (_,tl1,tl2,_)) => term1_size tl1 + term1_size tl2)‚Äô   >>
   rw[] >> Cases_on ‚Äòct‚Äô >> rw[]
*)
        
Definition stms_def[simp]:
  stms (St n tl) = tl
End

Theorem tm_induction2 =
        better_tm_induction
          |> Q.SPECL [‚ÄòP‚Äô,‚ÄòŒªs. ‚àÄt. MEM t (stms s) ‚áí P t‚Äô]
          |> SRULE []
          |> cj 1
          |> Q.GEN ‚ÄòP‚Äô 

val _ = update_induction tm_induction2;
          
Theorem tfv_FINITE[simp]:
 (‚àÄt. FINITE (tfv t)) ‚àß (‚àÄs. FINITE (sfv s))
Proof
 ho_match_mp_tac better_tm_induction >> simp[PULL_EXISTS] >>
 ‚Äò‚àÄl. {tfv t | MEM t l} = IMAGE tfv (set l)‚Äô  suffices_by simp[] >>
 simp[EXTENSION]
QED     
        
Theorem ffv_FINITE[simp]:
 ‚àÄf. FINITE (ffv f)
Proof
 Induct_on ‚Äòf‚Äô >> simp[MEM_MAP,PULL_EXISTS]
QED


(*prove under current definition Var n s cannot match any bound variable?
 input is a finite map, not be an option, since we know that it will terminate and will not continue when NONE is hit. 
*)        

Definition ffVar_def[simp]:
  ffVar False = {} ‚àß
  ffVar (IMP f1 f2) = ffVar f1 ‚à™ ffVar f2 ‚àß
  ffVar (FALL n s œï) = ffVar œï ‚àß
  ffVar (Pred _ _) = {} ‚àß
  ffVar (fVar p vl tl) = {(p,vl)}
End   


Theorem ffVar_FINITE[simp]:
 ‚àÄf. FINITE (ffVar f)
Proof
 Induct_on ‚Äòf‚Äô >> simp[MEM_MAP,PULL_EXISTS]
QED

                    
val term_size_def = DB.fetch "-" "term_size_def"
val _ = export_rewrites ["term_size_def"]


Definition EQ_def:
  EQ t1 t2 = Pred "=" [t1;t2]
End


Definition NEG_def:
  NEG f = IMP f False
End


Definition DISJ_def:
  DISJ f1 f2 = IMP (NEG f1) f2
End

Definition CONJ_def:
  CONJ f1 f2 = NEG (IMP f1 (NEG f2))
End

Definition True_def:
  True = NEG False
End          

Definition IFF_def:
  IFF f1 f2 = CONJ (IMP f1 f2) (IMP f2 f1)
End               

Definition EX_def:
  EX n s b = NEG (FALL n s (NEG b))
End  


Definition EXL_def:
  EXL [] f = f ‚àß
  EXL ((n,s) :: t) f = EX n s (EXL t f)
End  


Definition FALLL_def:
  FALLL [] f = f ‚àß
  FALLL ((n,s) :: t) f = FALL n s (FALLL t f)
End  
     
  
Definition new_psym_def:
  new_psym (fsig,psig) P vl = (fsig,psig |+ (P,vl))
End


Definition new_fsym_def:
  new_fsym (fsig,psig) f s vl = (fsig |+ (f,(s,vl)),psig)
End


Definition isfsym_def:
  isfsym fsig f ‚áî f ‚àà FDOM fsig 
End


Definition ispsym_def:
  ispsym psig p ‚áî p ‚àà FDOM psig
End        


Definition wft_def:
  (wft Œ£f (Var n s) ‚áî wfs Œ£f s) ‚àß
  (wft Œ£f (Fn f tl) ‚áî
     (‚àÄt. MEM t tl ‚áí wft Œ£f t) ‚àß
     isfsym Œ£f f ‚àß
     IS_SOME
     (tlmatch Œ£f {} (MAP (UNCURRY Var) (SND (Œ£f ' f))) tl FEMPTY)) ‚àß
  (wfs Œ£f (St n tl) ‚áî EVERY (wft Œ£f) tl)
Termination
 WF_REL_TAC
   ‚Äòmeasure
    (Œªs. case s of
           INL (_,t) => term_size t
         | INR (_,st) => sort_size st)‚Äô 
End
           
(*all
the variables of sort ùë† must also be in Œì \ {ùë• } automatically satisfied?
 not true ,because x might be completely fresh

‚àÄx:s1. P(x:s2) just means the quantifier is not on x:s2.

allI x does not occur in the assumption list automatically true?       
*)

  
Definition wffVar_def:
  wffVar Œ£f (fVar P vl tl) ‚áî
    EVERY (wft Œ£f) (MAP (UNCURRY Var) vl) ‚àß
    EVERY (wft Œ£f) tl ‚àß
    IS_SOME (tlmatch Œ£f {} (MAP (UNCURRY Var) vl) tl FEMPTY)
End
  
Definition tsubst_def[simp]:
  (tsubst n s t (Var n0 s0) =
  if n = n0 ‚àß s = s0 then t else Var n0 (ssubst n s t s0)) ‚àß
  tsubst n s t (Fn f tl) =
  Fn f (MAP (tsubst n s t) tl) ‚àß
  ssubst n s t (St sn tl) = St sn (MAP (tsubst n s t) tl)
Termination
  WF_REL_TAC
  ‚Äòmeasure
    (Œªs. case s of
           INL (_,_,_,a) => term_size a
         | INR (_,_,_,s) => sort_size s)‚Äô 
End  
  
  
  
Definition fsubst_def[simp]:
  fsubst n (s:sort) (t:term) False = False ‚àß
  fsubst n s t (IMP f1 f2) = IMP (fsubst n s t f1) (fsubst n s t f2) ‚àß
  (fsubst n s t (FALL n0 s0 b) =
  if n = n0 ‚àß s = s0 then (FALL n0 s0 b)
  else FALL n0 s0 (fsubst n s t b)) ‚àß
  fsubst n s t (Pred p tl) = Pred p (MAP (tsubst n s t) tl) ‚àß
  fsubst n s t (fVar p vl tl) = fVar p vl (MAP (tsubst n s t) tl)
End
 



(*this assumes no sort depends on itself, so if (n,s) ‚àà FDOM œÉ, then (n,s) does not occur in s, each s depends only on other s*)

Definition finst_def[simp]:
  finst œÉ False = False ‚àß
  finst œÉ (Pred p tl) = Pred p (MAP (tinst œÉ) tl) ‚àß
  finst œÉ (IMP f1 f2) = IMP (finst œÉ f1) (finst œÉ f2) ‚àß
  finst œÉ (fVar p vl tl) = fVar p vl (MAP (tinst œÉ) tl) ‚àß
  finst œÉ (FALL n s f) =
  if (n,s) ‚àà FDOM œÉ then
    FALL n (sinst (œÉ \\ (n,s)) s) (finst (œÉ \\ (n,s)) f)
  else FALL n (sinst œÉ s) (finst œÉ f)
End

Definition fVar_subst_def:
 fVar_subst Œ£f (P,vl,œï:form) False = False ‚àß
 fVar_subst Œ£f (P,vl,œï) (Pred p tl) = Pred p tl ‚àß
 fVar_subst Œ£f (P,vl,œï) (IMP f1 f2) = IMP (fVar_subst Œ£f (P,vl,œï) f1)
                                       (fVar_subst Œ£f (P,vl,œï) f2) ‚àß
 fVar_subst Œ£f (P,vl,œï) (FALL n s f) = FALL n s 
                                       (fVar_subst Œ£f (P,vl,œï) f) ‚àß
 fVar_subst Œ£f (P,vl,œï) (fVar Pname Pvl tl) =
 if P = Pname ‚àß vl = Pvl then 
  finst (THE (tlmatch Œ£f {} (MAP (Œª(n,s). Var n s) vl) tl (FEMPTY:string # sort |-> term))) œï   
 else fVar Pname Pvl tl
End

Definition wff_def[simp]:
  (wff (Œ£f,Œ£p) False ‚áî T) ‚àß
  (wff (Œ£f,Œ£p) (Pred p tl) ‚áî
     ispsym Œ£p p ‚àß
     IS_SOME (tlmatch Œ£f {} (MAP (UNCURRY Var) (Œ£p ' p)) tl FEMPTY)) ‚àß
  (wff (Œ£f,Œ£p) (IMP f1 f2) ‚áî wff (Œ£f,Œ£p) f1 ‚àß wff (Œ£f,Œ£p) f2) ‚àß
  (wff (Œ£f,Œ£p) (FALL n s b) ‚áî wfs Œ£f s ‚àß wff (Œ£f,Œ£p) b) ‚àß
  (wff (Œ£f,Œ£p) (fVar P vl tl) ‚áî
     EVERY (wft Œ£f) (MAP (UNCURRY Var) vl) ‚àß
     EVERY (wft Œ£f) tl ‚àß
     IS_SOME (tlmatch Œ£f {} (MAP (UNCURRY Var) vl) tl FEMPTY))
End
 
(*well-formed variable map*)        
Definition wfvmap_def:
  wfvmap Œ£f œÉ ‚áî
  (‚àÄn s. (n,s) ‚àà FDOM œÉ ‚áí wfs Œ£f s ‚àß wft Œ£f (œÉ ' (n,s)) ‚àß
   sort_of Œ£f (œÉ ' (n,s)) = sinst œÉ s)
End

(*slash u plus ‚äé*)

Theorem FUNION_IDEM:
 œÉ ‚äå œÉ = œÉ
Proof
  cheat
QED   

Theorem tmatch_FUNION_lemma:
  (case a of
     NONE => NONE
   | SOME a0 => f a0) = SOME c <=>
  (‚àÉa0. a = SOME a0 ‚àß f a0 = SOME c)
Proof
  Cases_on ‚Äòa‚Äô >> simp[]
QED


(*        
              
Theorem tmatch_FUNION:
  ‚àÄt1 t2 t3 œÉ œÉ1 œÉ2.
  (tlmatch Œ£f lcs t1 t2 œÉ) = SOME œÉ1 ‚àß (tlmatch Œ£f lcs t2 t3 œÉ) = SOME œÉ2 ‚áí
  tlmatch Œ£f lcs t1 t3 œÉ = SOME (œÉ2 o_f œÉ1)
Proof
  Induct_on ‚Äòt1‚Äô >> Induct_on ‚Äòt2‚Äô >> Induct_on ‚Äòt3‚Äô >>
  gs[tmatch_def,FUNION_IDEM] >> rpt strip_tac >>
  gs[tmatch_FUNION_lemma,PULL_EXISTS] >>
  rename [‚Äòtmatch Œ£f lcs h2 h1 œÉ = SOME f1‚Äô]
  ‚Äò‚àÄh' h œÉ œÉ1 œÉ2.
          tlmatch Œ£f lcs t1 t2 () ‚àß
          SOME œÉ1 ‚àß tlmatch Œ£f lcs (h'::t2) t3 œÉ = SOME œÉ2 ‚áí
          tlmatch Œ£f lcs (h::t1) t3 œÉ = SOME (œÉ1 ‚äå œÉ2)‚Äô
  Cases_on ‚ÄòŒ£f lcs h'' h' œÉ‚Äô >> 
  Cases_on ‚ÄòŒ£f lcs h' h œÉ‚Äô >> Cases_on ‚ÄòŒ£f lcs h'' h œÉ‚Äô
  >- rw[FUNION_IDEM] >>
*)
  
(*DRESTRICT_SUBSET*)  
Theorem fmap_tfv_tinst_eq:
  DRESTRICT œÉ1 (tfv t) = DRESTRICT œÉ2 (tfv t) ‚áí tinst œÉ1 t = tinst œÉ2 t
Proof
  Induct_on ‚Äòt‚Äô >> simp[]
  >- (Cases_on ‚Äòs‚Äô >> gs[stms_def] >>
     rw[] >> rename [‚ÄòSt sn l‚Äô] (* 4 *)
     >- (simp[MAP_EQ_f] >> rw[] >> first_x_assum $ irule_at Any >>
        simp[] >> irule DRESTRICT_SUBSET >>
        first_x_assum $ irule_at Any >> rw[SUBSET_DEF] >> metis_tac[]) >>
     gs[DRESTRICT_EQ_DRESTRICT_SAME,PULL_EXISTS,EXTENSION] >> 
     metis_tac[]) >>
  rw[MAP_EQ_f] >> first_x_assum irule >> irule_at Any DRESTRICT_SUBSET >>
  last_x_assum (irule_at Any) >> simp[SUBSET_DEF] >> metis_tac[]
QED  
     

Theorem fmap_sfv_sinst_eq:
  DRESTRICT œÉ1 (sfv s) = DRESTRICT œÉ2 (sfv s) ‚áí sinst œÉ1 s = sinst œÉ2 s
Proof
  cheat
QED  

Definition o_vmap_def:
  o_vmap Œ£f œÉ2 œÉ1 =
  fmap_ABS
    (Œª(n,s).
       if (n,s) ‚àà FDOM œÉ1 then INL (tinst œÉ2 (œÉ1 ' (n,s))) else
         if (n,s) ‚àà FDOM œÉ2 then INL (œÉ2 ' (n,s)) else INR ())
End

Theorem tinst_vmap_id:
  ‚àÄt œÉ. (‚àÄn s. (n,s) ‚àà FDOM œÉ ‚à© tfv t ‚áí œÉ ' (n,s) = Var n s) ‚áí tinst œÉ t = t
Proof
  Induct_on ‚Äòt‚Äô >> rw[tinst_def] (* 2 *)
  >- (Cases_on ‚Äòs‚Äô >>
      ‚ÄòMAP (Œªa. tinst œÉ a) l = MAP I l‚Äô suffices_by simp[] >>
      rw[MAP_EQ_f] >> gvs[PULL_EXISTS] >>
      first_x_assum irule >> rw[] >> first_x_assum irule >> metis_tac[]) >>
  ‚ÄòMAP (Œªa. tinst œÉ a) l = MAP I l‚Äô suffices_by simp[] >>
  rw[MAP_EQ_f] >> gvs[PULL_EXISTS] >>
  first_x_assum irule >> rw[] >> first_x_assum irule >> metis_tac[]
QED  

(*t and its instance can match iff œÉ and f do not send local constants to somewhere else *)

Definition vmap_fix_def:
  vmap_fix œÉ vs ‚áî (‚àÄn s. (n,s) ‚àà FDOM œÉ ‚à© vs ‚áí œÉ ' (n,s) = Var n s)
End

Theorem vmap_fix_FEMPTY[simp]: 
  vmap_fix FEMPTY vs
Proof
  simp[vmap_fix_def]
QED

(*if matchable then fix local constants
  for each step the f obtained resp to lcs.
  matchable iff exists a œÉ such that it is a inst.
  what if there is no local constants in the term?
  if equal on intersection than can glue to a new subst map
  
*)

Definition complete_def:
  complete œÉ ‚áî ‚àÄn s. (n,s) ‚àà FDOM œÉ ‚áí ‚àÄv. v ‚àà sfv s ‚áí v ‚àà FDOM œÉ
End  
        
Theorem DRESTRICT_UNION_SING:
  x ‚àà FDOM œÉ ‚áí DRESTRICT œÉ (s ‚à™ {x}) = DRESTRICT œÉ s |+ (x, œÉ ' x)
Proof
  rw[fmap_EXT,DRESTRICT_DEF]
  >- (rw[EQ_IMP_THM,EXTENSION] >> metis_tac[])
  >- (Cases_on ‚Äòx' = x‚Äô >> rw[FAPPLY_FUPDATE,DRESTRICT_DEF,NOT_EQ_FAPPLY]) >>
  rw[FAPPLY_FUPDATE]
QED



Theorem vsort_tfv_closed:
  (‚àÄh n s v. (n,s) ‚àà tfv h ‚àß v ‚àà sfv s ‚áí v ‚àà tfv h) ‚àß
  (‚àÄst n s v. (n,s) ‚àà sfv st ‚àß v ‚àà sfv s ‚áí v ‚àà sfv st)
Proof
  ho_match_mp_tac better_tm_induction >> rw[] (* 4 *)
  >- simp[] >- (disj2_tac >> first_x_assum irule >> metis_tac[])
  >- (simp[PULL_EXISTS] >> first_assum $ irule_at Any >>
     first_assum irule >> metis_tac[]) >>
  last_assum $ irule_at Any >> metis_tac[]
QED

(* in the case that start with an f a:1->A and have not assigned a to anywhere else, A is not stores*)
Theorem IS_SOME_tmatch:
   (‚àÄt f.
     complete f ‚àß wfvmap Œ£ œÉ ‚àß
     (tfv t ‚äÜ FDOM œÉ) ‚àß
     (‚àÄn s. (n,s) ‚àà FDOM f ‚à© FDOM œÉ ‚à© tfv t ‚áí f ' (n,s) = œÉ ' (n,s)) ‚áí
     tmatch Œ£ {} t (tinst œÉ t) f = SOME (FUNION f (DRESTRICT œÉ (tfv t)))) ‚àß
   (‚àÄst f.
     complete f ‚àß wfvmap Œ£ œÉ ‚àß
     (sfv st ‚äÜ FDOM œÉ) ‚àß
     (‚àÄn s. (n,s) ‚àà FDOM f ‚à© FDOM œÉ ‚à© sfv st ‚áí f ' (n,s) = œÉ ' (n,s)) ‚áí
     smatch Œ£ {} st (sinst œÉ st) f = SOME (FUNION f (DRESTRICT œÉ (sfv st))))
Proof       
  ho_match_mp_tac better_tm_induction >> rw[PULL_EXISTS] (* 3 *)
  >- (gs[tmatch_def,AllCaseEqs()] >>
     Cases_on ‚Äò(s0,st) ‚àà FDOM f‚Äô >> gs[] (* 2 *)
     >- (Cases_on ‚Äòst‚Äô >> gs[tmatch_def,PULL_EXISTS] >>
        rw[fmap_EXT,Once EQ_SYM_EQ,Once UNION_COMM,GSYM SUBSET_UNION_ABSORPTION] (* 2 *)
        >- (gs[SUBSET_DEF,complete_def,DRESTRICT_DEF] >> rw[] (* 2 *)
            >- first_x_assum irule >>
            first_x_assum irule >>
            first_x_assum $ irule_at Any >> gs[tfv_def,MEM_MAP] >>
            metis_tac[]) >>
        rw[FUNION_DEF])
     >- (gs[wfvmap_def,Once UNION_COMM] >> drule_then strip_assume_tac DRESTRICT_UNION_SING >>
        simp[FUNION_FUPDATE_2]))
  >> (gs[tmatch_def] >>
     rpt (pop_assum mp_tac) >>
     Q.ID_SPEC_TAC `f` >> Q.ID_SPEC_TAC `l`  >> Induct_on ‚Äòl‚Äô
     >- rw[tmatch_def,DRESTRICT_IS_FEMPTY] >>
     rw[tmatch_def] >>
     ‚Äòtmatch Œ£ ‚àÖ h (tinst œÉ h) f = SOME (f ‚äå DRESTRICT œÉ (tfv h))‚Äô
      by (first_x_assum irule >> rw[] >> irule_at Any SUBSET_TRANS >>
          first_x_assum $ irule_at Any >> rw[SUBSET_DEF] >> metis_tac[]) >>
     rw[] >>
     ‚Äòtlmatch Œ£ ‚àÖ l (MAP (Œªa. tinst œÉ a) l) (f ‚äå DRESTRICT œÉ (tfv h)) =
      SOME ((f ‚äå DRESTRICT œÉ (tfv h)) ‚äå DRESTRICT œÉ (BIGUNION {tfv t | MEM t l}))‚Äô
        by (first_x_assum irule >>
        simp[DRESTRICT_DEF] >> (irule_at Any) SUBSET_TRANS >>
        qexists_tac ‚ÄòBIGUNION {tfv t | t = h ‚à® MEM t l}‚Äô >> simp[] >> rw[SUBSET_DEF] (* 4 *)
        >- metis_tac[]
        >- (rw[FUNION_DEF] >> first_x_assum irule >> metis_tac[])
        >- rw[FUNION_DEF,DRESTRICT_DEF] >>
        gs[complete_def,DRESTRICT_DEF] >> rw[] (* 2 *)
        >- (disj1_tac >> first_x_assum irule >> metis_tac[]) >>
        disj2_tac >> gs[SUBSET_DEF,PULL_EXISTS] >> first_assum $ irule_at Any >>
        qexists_tac ‚Äòh‚Äô >> simp[] >> metis_tac[vsort_tfv_closed]) >>
     rw[DRESTRICT_FUNION,GSYM FUNION_ASSOC] >>
     rpt AP_TERM_TAC >> rw[EXTENSION] >> metis_tac[])
QED



(*
Theorem tmatch_FDOM:
  (‚àÄt1 t2 f f1.
     complete f ‚àß wfvmap Œ£ œÉ ‚àß
     (tfv t ‚äÜ FDOM œÉ) ‚àß
     (‚àÄn s. (n,s) ‚àà FDOM f ‚à© FDOM œÉ ‚à© tfv t ‚áí f ' (n,s) = œÉ ' (n,s)) ‚àß
     tmatch Œ£ {} t2 t2 f = SOME f1 ==) ‚àß
   (‚àÄst f.
     complete f ‚àß wfvmap Œ£ œÉ ‚àß
     (sfv st ‚äÜ FDOM œÉ) ‚àß
     (‚àÄn s. (n,s) ‚àà FDOM f ‚à© FDOM œÉ ‚à© sfv st ‚áí f ' (n,s) = œÉ ' (n,s)) ‚áí
     smatch Œ£ {} st (sinst œÉ st) f = SOME (FUNION f (DRESTRICT œÉ (sfv st))))
Proof
*)

(*todo:tmatch gives a map records each variable once start with a complete map *)

Theorem tlmatch_LENGTH:
  ‚àÄtl1 tl2 f œÉ.
  tlmatch Œ£ lcs tl1 tl2 f = SOME œÉ ‚áí
  LENGTH tl1 = LENGTH tl2
Proof
  Induct_on ‚Äòtl1‚Äô >> Induct_on ‚Äòtl2‚Äô >>
  gs[tmatch_def,AllCaseEqs(),PULL_EXISTS] >>
  metis_tac[]
QED


(*                  
Theorem original_tm_induction':
  ‚àÄP0 P1 P2.
       (‚àÄs. P1 s ‚áí ‚àÄs0. P0 (Var s0 s)) ‚àß (‚àÄl. P2 l ‚áí ‚àÄs. P0 (Fn s l)) ‚àß
       (‚àÄl. P2 l ‚áí ‚àÄs. P1 (St s l)) ‚àß P2 [] ‚àß (‚àÄt l. P0 t ‚àß P2 l ‚áí P2 (SNOC t l)) ‚áí
       (‚àÄt. P0 t) ‚àß (‚àÄs. P1 s) ‚àß ‚àÄl. P2 l
Proof
  rpt gen_tac >> disch_tac>>
  ho_match_mp_tac original_tm_induction >>
  gs[] >>
  qspec_then ‚ÄòŒªl. ‚àÄt. ‚Äô
  ‚Äò‚Äô
  
  ‚Äò‚àÄl t. P0 t ‚àß P2 l ‚áí P2 (t::l)‚Äô
    suffices_by metis_tac[] >>
  Induct_on ‚Äòl‚Äô >- cheat >>
  
  
  ho_match_mp_tac SNOC_INDUCT >> gs[] >> conj_tac
  >- (rw[] >>
     first_x_assum (qspecl_then [‚Äòt‚Äô,‚Äò[]‚Äô] assume_tac)>>
     gs[SNOC]) >>
  rw[] >>  
  first_x_assum (qspecl_then [‚Äòx‚Äô,‚Äòt:: l‚Äô] assume_tac) >>
  
  list_INDUCT
*)





Definition is_cont_def:
  is_cont ct ‚áî ‚àÄn s. (n,s) ‚àà ct ‚áí sfv s ‚äÜ ct
End

Theorem tfv_is_cont:
 (‚àÄt. is_cont (tfv t)) ‚àß
 (‚àÄs. is_cont (sfv s))
Proof
 ho_match_mp_tac better_tm_induction >>
 gs[tfv_def,is_cont_def,SUBSET_DEF,PULL_EXISTS] >>
 rw[] (* 3 *)
 >- simp[]
 >- (disj2_tac >> first_x_assum irule >> metis_tac[]) >>
 qexists_tac ‚Äòs‚Äô >> gs[MEM_MAP] >>
 metis_tac[]
QED

Theorem fmap_sfv_sinst_eq:
  DRESTRICT œÉ1 (sfv s) = DRESTRICT œÉ2 (sfv s) ‚áí
  sinst œÉ1 s = sinst œÉ2 s
Proof
  Cases_on ‚Äòs‚Äô >> gs[tinst_def,MAP_EQ_f] >>
  rw[] >> irule fmap_tfv_tinst_eq >>
  irule DRESTRICT_SUBSET >>
  first_x_assum $ irule_at Any >>
  rw[SUBSET_DEF] >> metis_tac[]
QED  
            

Theorem wfvmap_cont_DRESTRICT:
  wfvmap Œ£ œÉ ‚àß complete œÉ ‚àß is_cont s ‚áí wfvmap Œ£ (DRESTRICT œÉ s)
Proof
  rw[wfvmap_def,is_cont_def,DRESTRICT_DEF] (* 2 *)
  >- metis_tac[] >>
  irule fmap_sfv_sinst_eq >>
  rw[Once EQ_SYM_EQ] >> AP_TERM_TAC >>
  rw[Once INTER_COMM,GSYM SUBSET_INTER_ABSORPTION] >>
  first_x_assum irule>> metis_tac[]
QED 

(*matchable to a map implies matchable to a submap*)    
(*Theorem tmatch_SUBMAP:
  tlmatch Œ£ {} t1 t2 f = SOME œÉ ‚áí
  ‚àÄn. n < LENGTH tl1 ‚áí
  ‚àÉœÉ1. tmatch Œ£ {} (EL n tl1) (EL n tl2) f = SOME œÉ1
Proof*)  




(*****)
Theorem tmatch_complete:
  (‚àÄt1 t2 f œÉ.
     complete f ‚àß
     tmatch Œ£ {} t1 t2 f = SOME œÉ ‚áí
     tfv t1 ‚äÜ FDOM œÉ ‚àß FDOM f ‚äÜ FDOM œÉ ‚àß complete œÉ) ‚àß
  (‚àÄs1 s2 f œÉ.
     complete f ‚àß
     smatch Œ£ {} s1 s2 f = SOME œÉ ‚áí
     sfv s1 ‚äÜ FDOM œÉ ‚àß FDOM f ‚äÜ FDOM œÉ ‚àß complete œÉ) ‚àß
  (‚àÄtl1 tl2 f œÉ.
     complete f ‚àß
     tlmatch Œ£ {} tl1 tl2 f = SOME œÉ ‚áí
     (‚àÄt. MEM t tl1 ‚áí tfv t ‚äÜ FDOM œÉ) ‚àß
     FDOM f ‚äÜ FDOM œÉ ‚àß complete œÉ)
Proof
  ho_match_mp_tac original_tm_induction >> rw[] (* 16 *)
  >- (gs[tmatch_def,AllCaseEqs()] >>
     pop_assum (assume_tac o GSYM) >> rw[])
  >- (gs[tmatch_def,AllCaseEqs()] (* 2 *)
     >- metis_tac[complete_def,SUBSET_DEF] >>
     first_x_assum drule_all >> rw[] >>
     gs[SUBSET_DEF])
  >- (gs[tmatch_def,AllCaseEqs()] >>
     first_x_assum drule_all >>
     rw[] >> gs[complete_def,SUBSET_DEF] >>
     metis_tac[])
  >- (gs[tmatch_def,AllCaseEqs()] >>
     first_x_assum drule_all >>
     rw[] >> gs[complete_def,SUBSET_DEF] >>
     metis_tac[])
  >- (Cases_on ‚Äòt2‚Äô >> gs[tmatch_def] >>
     rw[SUBSET_DEF] >>
     first_x_assum drule_all >> rw[] >>
     gs[SUBSET_DEF] >> metis_tac[])
  >- (Cases_on ‚Äòt2‚Äô >> gs[tmatch_def] >>
     first_x_assum drule_all >> rw[])
  >- (Cases_on ‚Äòt2‚Äô >> gs[tmatch_def] >>
     first_x_assum drule_all >> rw[]) (*9 remains*)
  >- (Cases_on ‚Äòs2‚Äô >> gs[tmatch_def] >>
     rw[SUBSET_DEF] >>
     first_x_assum drule_all >> rw[] >>
     gs[SUBSET_DEF] >> metis_tac[])
  >- (Cases_on ‚Äòs2‚Äô >> gs[tmatch_def] >>
     first_x_assum drule_all >> rw[])
  >- (Cases_on ‚Äòs2‚Äô >> gs[tmatch_def] >>
     first_x_assum drule_all >> rw[]) (* 6 *)
  >- (drule tlmatch_LENGTH >> rw[] >> gs[tmatch_def])
  >- (drule tlmatch_LENGTH >> rw[] >> gs[tmatch_def]) (* 4 *)
  >- (Cases_on ‚Äòtl2‚Äô >> gs[tmatch_def,AllCaseEqs()] >>
     rename [‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1 = SOME œÉ‚Äô] >>
     rename [‚Äòtmatch Œ£ ‚àÖ t1 t2 f = SOME f1‚Äô] >> 
     rpt (pop_assum mp_tac)>>
     Q.ID_SPEC_TAC ‚Äòf‚Äô >> Q.ID_SPEC_TAC ‚Äòf1‚Äô >>
     Q.ID_SPEC_TAC ‚ÄòœÉ‚Äô >>
     Q.ID_SPEC_TAC ‚Äòt2‚Äô >> Q.ID_SPEC_TAC ‚Äòt1‚Äô >>
     Q.ID_SPEC_TAC ‚Äòtl2‚Äô >> Q.ID_SPEC_TAC ‚Äòtl1‚Äô >>
     Induct_on ‚Äòtl1‚Äô >> gs[tmatch_def] >> rw[] (* 2 *)
     >- (drule tlmatch_LENGTH >> rw[] >> gs[tmatch_def] >>
        last_x_assum drule_all >> rw[]) >>
     rename [‚Äòh1::tl1‚Äô] >>
     Cases_on ‚Äòtl2‚Äô >> gs[tmatch_def,AllCaseEqs()] >>
     rename [‚Äòtmatch Œ£ ‚àÖ h1 h2 f1 = SOME f2‚Äô] >>
     rename [‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f2 = SOME œÉ‚Äô] >>
     last_x_assum
     (qspecl_then [‚Äòtl2‚Äô,‚Äòh1‚Äô,‚Äòh2‚Äô,‚ÄòœÉ‚Äô,‚Äòf2‚Äô,‚Äòf1‚Äô]
      assume_tac) >>
     gs[]>>
     ‚Äòtfv t1 ‚äÜ FDOM f1 ‚àß FDOM f ‚äÜ FDOM f1 ‚àß complete f1‚Äô
       by (first_x_assum irule >> simp[] >>
          qexists_tac ‚Äòt2‚Äô >> simp[]) >>
      ‚Äò(‚àÄt. t = h1 ‚à® MEM t tl1 ‚áí tfv t ‚äÜ FDOM œÉ) ‚àß
       FDOM f1 ‚äÜ FDOM œÉ ‚àß
       complete œÉ‚Äô
       by (first_x_assum irule >> simp[] >>
          qexists_tac ‚Äòh2 :: tl2‚Äô >> gs[tmatch_def]) >>
     ‚Äòtfv h1 ‚äÜ FDOM œÉ‚Äô
     suffices_by
     (rw[] >>
      irule SUBSET_TRANS >> qexists_tac ‚ÄòFDOM f1‚Äô >>
      simp[]) >>
     first_x_assum irule >> simp[])
  >- (Cases_on ‚Äòtl2‚Äô >> gs[tmatch_def,AllCaseEqs()] >>
     rename [‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1 = SOME œÉ‚Äô] >>
     ‚Äòtfv t1 ‚äÜ FDOM f1 ‚àß FDOM f ‚äÜ FDOM f1 ‚àß complete f1‚Äô
      by (first_x_assum irule >> simp[] >>
         qexists_tac ‚Äòh‚Äô >> gs[]) >>
     ‚Äò(‚àÄt. MEM t tl1 ‚áí tfv t ‚äÜ FDOM œÉ) ‚àß FDOM f1 ‚äÜ FDOM œÉ ‚àß complete œÉ‚Äô
      by (first_x_assum irule >> simp[] >>
          metis_tac[]) >>
     metis_tac[])
  >- (Cases_on ‚Äòtl2‚Äô >> gs[tmatch_def,AllCaseEqs()] >>
     rename [‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1 = SOME œÉ‚Äô] >>
     rename [‚Äòtmatch Œ£ ‚àÖ t1 t2 f = SOME f1‚Äô] >> 
     ‚Äòtfv t1 ‚äÜ FDOM f1 ‚àß FDOM f ‚äÜ FDOM f1 ‚àß complete f1‚Äô
      by (first_x_assum irule >> simp[] >>
         qexists_tac ‚Äòt2‚Äô >> gs[]) >>
     ‚Äò(‚àÄt. MEM t tl1 ‚áí tfv t ‚äÜ FDOM œÉ) ‚àß FDOM f1 ‚äÜ FDOM œÉ ‚àß complete œÉ‚Äô
      by (first_x_assum irule >> simp[] >>
          metis_tac[]) >>
     metis_tac[SUBSET_TRANS]) >>
  Cases_on ‚Äòtl2‚Äô >> gs[tmatch_def,AllCaseEqs()] >>
     rename [‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1 = SOME œÉ‚Äô] >>
     rename [‚Äòtmatch Œ£ ‚àÖ t1 t2 f = SOME f1‚Äô] >> 
     ‚Äòtfv t1 ‚äÜ FDOM f1 ‚àß FDOM f ‚äÜ FDOM f1 ‚àß complete f1‚Äô
      by (first_x_assum irule >> simp[] >>
         qexists_tac ‚Äòt2‚Äô >> gs[]) >>
     ‚Äò(‚àÄt. MEM t tl1 ‚áí tfv t ‚äÜ FDOM œÉ) ‚àß FDOM f1 ‚äÜ FDOM œÉ ‚àß complete œÉ‚Äô
      by (first_x_assum irule >> simp[] >>
          metis_tac[])
QED          


Theorem tm_tree_WF:
  (‚àÄt:term s n l. (n,St s l) ‚àà tfv t ‚áí ¬¨MEM t l) ‚àß
  (‚àÄs n.(n,s) ‚àâ sfv s)
Proof
(* ho_match_mp_tac better_tm_induction >>
 simp[tfv_def] >> rw[] >>
 gs[tfv_def,MEM_MAP,GSYM IMP_DISJ_THM,PULL_FORALL]
 >- (first_x_assum irule >> simp[tfv_def] >> metis_tac[])
 >- (strip_tac >>
    ‚Äò(s0,s) ‚àà  sfv s‚Äô suffices_by  metis_tac[] >>
    cheat)
 >- (gvs[] >>
     strip_tac >> first_x_assum $ drule_then assume_tac >>
     ‚Äò‚Äô )




(gvs[] >> rename [‚ÄòSt s1 l1‚Äô] >>
     first_x_assum irule >>
     simp[tfv_def,MEM_MAP,PULL_EXISTS] >> )
 rename [‚Äò_ ‚àâ s0‚Äô] >> rw[GSYM IMP_DISJ_THM] >>
 
  rw[]>> Cases_on ‚Äòs‚Äô>>
  rename [‚ÄòSt s l‚Äô] >>
  Induct_on ‚Äòl‚Äô >> gs[tfv_def]  >>*) 
  cheat
QED  
             

Theorem tmatch_SUBMAP:
  (‚àÄt1 t2 f œÉ.
     complete f ‚àß
     (‚àÄn s. (n,s) ‚àà tfv t1 ‚áí (n,s) ‚àâ sfv s) ‚àß
     tmatch Œ£ {} t1 t2 f = SOME œÉ ‚áí
     f ‚äë œÉ ‚àß FDOM œÉ ‚äÜ FDOM f ‚à™ tfv t1) ‚àß
  (‚àÄs1 s2 f œÉ.
     complete f ‚àß
     (‚àÄn s. (n,s) ‚àà sfv s1 ‚áí (n,s) ‚àâ sfv s) ‚àß 
     smatch Œ£ {} s1 s2 f = SOME œÉ ‚áí
     f ‚äë œÉ ‚àß FDOM œÉ ‚äÜ FDOM f ‚à™ sfv s1) ‚àß
  (‚àÄtl1 tl2 f œÉ.
     complete f ‚àß 
     (‚àÄt n s. MEM t tl1 ‚àß (n,s) ‚àà tfv t ‚áí (n,s) ‚àâ sfv s) ‚àß
     tlmatch Œ£ {} tl1 tl2 f = SOME œÉ ‚áí
     f ‚äë œÉ ‚àß FDOM œÉ ‚äÜ FDOM f ‚à™ BIGUNION {tfv t | MEM t tl1}) 
Proof
  ho_match_mp_tac original_tm_induction >> rw[] (* 10 *)
  >- (gs[tmatch_def,AllCaseEqs()] >>
     first_x_assum drule_all >> rw[] >>
     irule SUBMAP_TRANS >> 
     qexists_tac ‚Äòf0‚Äô >>  
     rw[SUBMAP_FUPDATE_EQN] >> disj1_tac >>
     gs[SUBSET_DEF] >> metis_tac[])
  >- (gs[tmatch_def,AllCaseEqs()] >>
     first_x_assum drule_all >> rw[] >>
     gs[SUBSET_DEF] >> metis_tac[]) 
  >- (Cases_on ‚Äòt2‚Äô >>
     gs[tmatch_def,AllCaseEqs(),PULL_EXISTS] >> metis_tac[])
  >- (Cases_on ‚Äòt2‚Äô >>
     gs[tmatch_def,AllCaseEqs(),PULL_EXISTS] >> metis_tac[])
  >- (Cases_on ‚Äòs2‚Äô >> 
     gs[tmatch_def,AllCaseEqs(),PULL_EXISTS] >> metis_tac[])
  >- (Cases_on ‚Äòs2‚Äô >> 
     gs[tmatch_def,AllCaseEqs(),PULL_EXISTS] >> metis_tac[])
  >- (drule tlmatch_LENGTH >> rw[] >>
     gs[tmatch_def])
  >- (drule tlmatch_LENGTH >> rw[] >>
     gs[tmatch_def])
  >- (Cases_on ‚Äòtl2‚Äô >> gs[tmatch_def,AllCaseEqs()] >>
     rename [‚Äòtmatch Œ£ ‚àÖ t1 t2 f‚Äô,‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1‚Äô]>>
     last_x_assum (drule_all_then strip_assume_tac) >>
     ‚Äòcomplete f1‚Äô by metis_tac[tmatch_complete] >>
     ‚Äòf1 ‚äë œÉ ‚àß
      FDOM œÉ ‚äÜ FDOM f1 ‚à™ BIGUNION {tfv t | MEM t tl1}‚Äô
      by metis_tac[] >>
     metis_tac[SUBMAP_TRANS]) >>
  Cases_on ‚Äòtl2‚Äô >> gs[tmatch_def,AllCaseEqs()] >>
  rename [‚Äòtmatch Œ£ ‚àÖ t1 t2 f‚Äô,‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1‚Äô]>>
  last_x_assum (drule_all_then strip_assume_tac) >>
  ‚Äòcomplete f1‚Äô by metis_tac[tmatch_complete] >>
  ‚Äòf1 ‚äë œÉ ‚àß
   FDOM œÉ ‚äÜ FDOM f1 ‚à™ BIGUNION {tfv t | MEM t tl1}‚Äô
    by metis_tac[] >>
  gs[SUBSET_DEF] >> metis_tac[]
QED


Theorem tmatch_FDOM_SUBMAP:
  (‚àÄt1 t2 f œÉ.
        complete f ‚àß (‚àÄn s. (n,s) ‚àà tfv t1 ‚áí (n,s) ‚àâ sfv s) ‚àß
        tmatch Œ£ ‚àÖ t1 t2 f = SOME œÉ ‚áí
        complete œÉ ‚àß
        f ‚äë œÉ ‚àß FDOM œÉ = FDOM f ‚à™ tfv t1) ‚àß
     (‚àÄs1 s2 f œÉ.
        complete f ‚àß (‚àÄn s. (n,s) ‚àà sfv s1 ‚áí (n,s) ‚àâ sfv s) ‚àß
        smatch Œ£ ‚àÖ s1 s2 f = SOME œÉ ‚áí
        complete œÉ ‚àß
        f ‚äë œÉ ‚àß FDOM œÉ = FDOM f ‚à™ sfv s1) ‚àß
     ‚àÄtl1 tl2 f œÉ.
       complete f ‚àß (‚àÄt n s. MEM t tl1 ‚àß (n,s) ‚àà tfv t ‚áí (n,s) ‚àâ sfv s) ‚àß
       tlmatch Œ£ ‚àÖ tl1 tl2 f = SOME œÉ ‚áí
       complete œÉ ‚àß
       f ‚äë œÉ ‚àß FDOM œÉ = FDOM f ‚à™ BIGUNION {tfv t | MEM t tl1}
Proof
 rw[]
 >- metis_tac[tmatch_complete]
 >- metis_tac[tmatch_SUBMAP]
 >- (rw[GSYM SUBSET_ANTISYM_EQ] (* 3 *)
    >> metis_tac[tmatch_SUBMAP,tmatch_complete])
 >- metis_tac[tmatch_complete]
 >- metis_tac[tmatch_SUBMAP]
 >- (rw[GSYM SUBSET_ANTISYM_EQ] (* 3 *)
    >> metis_tac[tmatch_SUBMAP,tmatch_complete])
 >- metis_tac[tmatch_complete]
 >- metis_tac[tmatch_SUBMAP] >>
 rw[GSYM SUBSET_ANTISYM_EQ] (* 3 *)
 >- metis_tac[tmatch_SUBMAP]
 >- metis_tac[tmatch_complete] >>
 rw[SUBSET_DEF] >> metis_tac[tmatch_complete,SUBSET_DEF]
QED 



(*
Theorem tmatch_wfvmap:
  (‚àÄt1 t2 f œÉ.
     complete f ‚àß wfvmap Œ£ f ‚àß 
     tmatch Œ£ {} t1 t2 f = SOME œÉ ‚áí
     wfvmap Œ£ œÉ) ‚àß
  (‚àÄs1 s2 f œÉ.
     complete f ‚àß
     (‚àÄn s. (n,s) ‚àà sfv s1 ‚áí (n,s) ‚àâ sfv s) ‚àß 
     smatch Œ£ {} s1 s2 f = SOME œÉ ‚áí
     f ‚äë œÉ ‚àß FDOM œÉ ‚äÜ FDOM f ‚à™ sfv s1) ‚àß
  (‚àÄtl1 tl2 f œÉ.
     complete f ‚àß 
     (‚àÄt n s. MEM t tl1 ‚àß (n,s) ‚àà tfv t ‚áí (n,s) ‚àâ sfv s) ‚àß
     tlmatch Œ£ {} tl1 tl2 f = SOME œÉ ‚áí
     f ‚äë œÉ ‚àß FDOM œÉ ‚äÜ FDOM f ‚à™ BIGUNION {tfv t | MEM t tl1})
Proof
*)

val tmatch_property = cj 1 tmatch_FDOM_SUBMAP
val smatch_property = cj 2 tmatch_FDOM_SUBMAP
val tlmatch_property = cj 3 tmatch_FDOM_SUBMAP



(*    
Theorem tmatch_SOME_tinst:
 (‚àÄt1 t2 f œÉ.
     complete f ‚àß
     (‚àÄn s. (n,s) ‚àà tfv t1 ‚áí (n,s) ‚àâ sfv s) ‚àß 
     tmatch Œ£ {} t1 t2 f = SOME œÉ ‚áí
     tinst œÉ t1 = t2 ‚àß wfvmap Œ£ œÉ) ‚àß
 (‚àÄst1 st2 f œÉ.
    complete f ‚àß
    (‚àÄn s. (n,s) ‚àà sfv st1 ‚áí (n,s) ‚àâ sfv st1) ‚àß
    smatch Œ£ {} st1 st2 f = SOME œÉ  ‚áí
    sinst œÉ st1 = st2 ‚àß wfvmap Œ£ œÉ) ‚àß
 (‚àÄtl1 tl2 f œÉ.
    complete f ‚àß
    (‚àÄt n s. MEM t tl1 ‚àß (n,s) ‚àà tfv t ‚áí (n,s) ‚àâ sfv s) ‚àß
    tlmatch Œ£ {} tl1 tl2 f = SOME œÉ ‚áí
    (‚àÄn. n < LENGTH tl1 ‚áí tinst œÉ (EL n tl1) = EL n tl2) ‚àß
    wfvmap Œ£ œÉ)
Proof
 ho_match_mp_tac original_tm_induction >> rw[] (* 9 *)
 >- (‚Äò(s0,st1) ‚àà FDOM œÉ‚Äô
      by (drule tmatch_property >> rw[] >>
         first_x_assum
         (qspecl_then [‚ÄòŒ£‚Äô,‚ÄòVar s0 st1‚Äô,‚Äòt2‚Äô,‚ÄòœÉ‚Äô]
          assume_tac) >>
         gs[] >>
         first_x_assum (drule_then strip_assume_tac)>>
         gs[EXTENSION]) >>
     gs[tmatch_def,AllCaseEqs(),fmap_EXT,SUBMAP_DEF] >>
     first_x_assum (qspecl_then [‚Äò(s0,st1)‚Äô]assume_tac) >>
     gs[FAPPLY_FUPDATE])
 >- simp[wfvmap_def]
         

Cases_on ‚Äò(s0,st1) ‚àà FDOM œÉ‚Äô (* 2 *)
     gs[tmatch_def,AllCaseEqs(),fmap_EXT,SUBMAP_DEF] >>

  gs[]
    Cases_on ‚Äò(s0,st1) ‚àà FDOM f‚Äô >>
    
    gs[DISJ_IMP_THM])
 >- (Cases_on ‚Äòt2‚Äô >> gs[tmatch_def] >>
    rename [‚Äòtlmatch Œ£ ‚àÖ l1 l2 f‚Äô] >>
    drule tlmatch_LENGTH >> rw[] >> 
    ‚ÄòMAP (Œªa. tinst œÉ a) l1 = MAP I l2‚Äô
      suffices_by simp[] >>
    rw[MAP_EQ_EVERY2,LIST_REL_EL_EQN] >>
    first_x_assum irule>> simp[] >>
    qexists_tac ‚Äòf‚Äô>> gs[PULL_EXISTS])
 >- (Cases_on ‚Äòst2‚Äô >> gs[tmatch_def] >>
    rename [‚Äòtlmatch Œ£ ‚àÖ l1 l2 f‚Äô] >>
    drule tlmatch_LENGTH >> rw[] >> 
    ‚ÄòMAP (Œªa. tinst œÉ a) l1 = MAP I l2‚Äô
      suffices_by simp[] >>
    rw[MAP_EQ_EVERY2,LIST_REL_EL_EQN] >>
    first_x_assum irule>> simp[] >>
    qexists_tac ‚Äòf‚Äô>> gs[PULL_EXISTS]) >>
 gs[PULL_EXISTS] >>
 Cases_on ‚Äòtl2‚Äô >> fs[tmatch_def,AllCaseEqs()] >>
 rename [‚Äòtmatch Œ£ ‚àÖ t1 t2 f = SOME f1‚Äô,
         ‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1 = SOME œÉ‚Äô] >>
 Cases_on ‚Äòn = 0‚Äô >> gs[] (* 2 *)
 >-
    ‚Äòtinst f1 t1 = t2‚Äô suffices_by cheat >>
    first_x_assum irule >> gs[PULL_EXISTS] >>
    qexists_tac ‚Äòf‚Äô>> gs[] >> tmatch_complete
*)            



Theorem SUBMAP_DRESTRICT_IFF:
  f ‚äë g ‚áî f = DRESTRICT g (FDOM f)
Proof
  rw[SUBMAP_DEF,DRESTRICT_DEF,fmap_EXT,EQ_IMP_THM] (* 3 *)
  >- (rw[EXTENSION,INTER_DEF] >> metis_tac[])
  >- (gs[EXTENSION,INTER_DEF] >> metis_tac[]) >>
  gs[EXTENSION,INTER_DEF] >>
  first_assum (drule o iffLR) >> rw[]
QED

Theorem complete_FDOM_is_cont:
 complete f ‚áî is_cont (FDOM f)
Proof         
 rw[complete_def,is_cont_def,SUBSET_DEF]
QED



Theorem UNION_is_cont:
  is_cont s1 ‚àß is_cont s2 ‚áí is_cont (s1 ‚à™ s2)
Proof         
 rw[is_cont_def,SUBSET_DEF,UNION_DEF] (* 2 *)
 >> metis_tac[]
QED         
              
Theorem tmatch_SOME_tinst:
 (‚àÄt1 t2 f œÉ.
     complete f ‚àß wfvmap Œ£ œÉ ‚àß
     (‚àÄn s. (n,s) ‚àà tfv t1 ‚áí (n,s) ‚àâ sfv s) ‚àß
     tmatch Œ£ {} t1 t2 f = SOME œÉ ‚áí
     tinst œÉ t1 = t2) ‚àß
 (‚àÄst1 st2 f œÉ.
    complete f ‚àß wfvmap Œ£ œÉ ‚àß
    (‚àÄn s. (n,s) ‚àà sfv st1 ‚áí (n,s) ‚àâ sfv st1) ‚àß
    smatch Œ£ {} st1 st2 f = SOME œÉ  ‚áí
    sinst œÉ st1 = st2) ‚àß
 (‚àÄtl1 tl2 f œÉ.
    complete f ‚àß wfvmap Œ£ œÉ ‚àß
    (‚àÄt n s. MEM t tl1 ‚àß (n,s) ‚àà tfv t ‚áí (n,s) ‚àâ sfv s) ‚àß
    tlmatch Œ£ {} tl1 tl2 f = SOME œÉ ‚áí
    ‚àÄn. n < LENGTH tl1 ‚áí tinst œÉ (EL n tl1) = EL n tl2)
Proof
 ho_match_mp_tac original_tm_induction >> rw[] (* 4 *)
 >- (‚Äò(s0,st1) ‚àà FDOM œÉ‚Äô
      by (drule tmatch_property >> rw[] >>
         first_x_assum
         (qspecl_then [‚ÄòŒ£‚Äô,‚ÄòVar s0 st1‚Äô,‚Äòt2‚Äô,‚ÄòœÉ‚Äô]
          assume_tac) >>
         gs[] >>
         first_x_assum (drule_then strip_assume_tac)>>
         gs[EXTENSION]) >>
     gs[tmatch_def,AllCaseEqs(),fmap_EXT,SUBMAP_DEF] >>
     first_x_assum (qspecl_then [‚Äò(s0,st1)‚Äô]assume_tac) >>
     gs[FAPPLY_FUPDATE])
 >- (Cases_on ‚Äòt2‚Äô >> gs[tmatch_def] >>
    rename [‚Äòtlmatch Œ£ ‚àÖ l1 l2 f‚Äô] >>
    drule tlmatch_LENGTH >> rw[] >> 
    ‚ÄòMAP (Œªa. tinst œÉ a) l1 = MAP I l2‚Äô
      suffices_by simp[] >>
    rw[MAP_EQ_EVERY2,LIST_REL_EL_EQN] >>
    first_x_assum irule>> simp[PULL_EXISTS] >>
    qexists_tac ‚Äòf‚Äô>> gs[PULL_EXISTS] >> metis_tac[])
 >- (Cases_on ‚Äòst2‚Äô >> gs[tmatch_def] >>
    rename [‚Äòtlmatch Œ£ ‚àÖ l1 l2 f‚Äô] >>
    drule tlmatch_LENGTH >> rw[] >> 
    ‚ÄòMAP (Œªa. tinst œÉ a) l1 = MAP I l2‚Äô
      suffices_by simp[] >>
    rw[MAP_EQ_EVERY2,LIST_REL_EL_EQN] >>
    first_x_assum irule>> simp[PULL_EXISTS] >>
    qexists_tac ‚Äòf‚Äô>> gs[PULL_EXISTS] >> metis_tac[]) >>
 gs[PULL_EXISTS] >>
 Cases_on ‚Äòtl2‚Äô >> fs[tmatch_def,AllCaseEqs()] >>
 rename [‚Äòtmatch Œ£ ‚àÖ t1 t2 f = SOME f1‚Äô,
         ‚Äòtlmatch Œ£ ‚àÖ tl1 tl2 f1 = SOME œÉ‚Äô] >>
 Cases_on ‚Äòn = 0‚Äô >> gs[] (* 2 *)
 >- (drule_then assume_tac tmatch_property >>
    ‚Äòcomplete f1 ‚àß f ‚äë f1 ‚àß FDOM f1 = FDOM f ‚à™ tfv t1‚Äô
     by metis_tac[] >>
    drule_then assume_tac tlmatch_property >>
    ‚Äòcomplete œÉ ‚àß f1 ‚äë œÉ ‚àß
     FDOM œÉ = FDOM f1 ‚à™ BIGUNION {tfv t | MEM t tl1}‚Äô
     by metis_tac[] >>
    ‚Äòtinst f1 t1 = t2‚Äô
     suffices_by
       (rw[] >> irule fmap_tfv_tinst_eq >>
       gs[DRESTRICT_EQ_DRESTRICT_SAME,SUBMAP_DEF] >>
       rw[EXTENSION] >> metis_tac[]) >>
    first_x_assum irule >> gs[PULL_EXISTS] >>
    qexists_tac ‚Äòf‚Äô >> gs[] >>
    ‚Äòf1 = DRESTRICT œÉ (FDOM f1)‚Äô
     by metis_tac[SUBMAP_DRESTRICT_IFF] >>
    gs[] >>
    irule_at Any wfvmap_cont_DRESTRICT >>
    simp[] >> irule UNION_is_cont >>
    rw[tfv_is_cont,GSYM complete_FDOM_is_cont])
 >> (‚Äò‚àÉm. n = SUC m‚Äô
      by metis_tac[arithmeticTheory.num_CASES] >>
    gs[] >> first_x_assum irule >> gs[PULL_EXISTS] >>
    qexists_tac ‚Äòf1‚Äô  >> gs[] >>
    ‚Äòcomplete f1‚Äô by metis_tac[tmatch_property] >>
    metis_tac[])
QED

val tmatch_tinst = cj 1 tmatch_SOME_tinst
val smatch_sinst = cj 2 tmatch_SOME_tinst
val tlmatch_EL_tinst = cj 3 tmatch_SOME_tinst



Theorem wfvmap_SUBMAP:
  wfvmap Œ£ f ‚àß f ‚äë œÉ ‚àß complete f ‚àß
  (‚àÄn s. (n,s) ‚àà FDOM œÉ ‚àß (n,s) ‚àâ FDOM f ‚áí
  wfs Œ£ s ‚àß
  wft Œ£ (œÉ ' (n,s)) ‚àß sort_of Œ£ (œÉ ' (n,s)) = sinst œÉ s) ‚áí
  wfvmap Œ£ œÉ
Proof
 rw[wfvmap_def] (* 3 *)
 >- (Cases_on ‚Äò(n,s) ‚àà FDOM f‚Äô >> gs[]
    >> metis_tac[])
 >- (Cases_on ‚Äò(n,s) ‚àà FDOM f‚Äô >> gs[SUBMAP_DEF]) >>
 drule $ iffLR SUBMAP_DRESTRICT_IFF >>
 rw[] >>
 Cases_on ‚Äò(n,s) ‚àà FDOM f‚Äô (* 2 *)
 >- (last_x_assum (drule_then strip_assume_tac) >>
    gs[SUBMAP_DEF] >> irule fmap_sfv_sinst_eq >>
    rw[DRESTRICT_DEF,fmap_EXT,EXTENSION] >>
    gs[complete_def] >> metis_tac[]) >>
 first_x_assum (drule_all_then strip_assume_tac)   
QED



Theorem wft_tfv:
  (‚àÄt. wft Œ£ t ‚áí ‚àÄn s. (n,s) ‚àà tfv t ‚áí wfs Œ£ s) ‚àß
  (‚àÄs. wfs Œ£ s ‚áí ‚àÄn st. (n,st) ‚àà sfv s ‚áí wfs Œ£ st) (* ‚àß
  ‚àÄl. (‚àÄt. MEM t l ‚áí wft Œ£ t) ‚áí ‚àÄn s t. MEM t l ‚àß (n,s) ‚àà tfv t ‚áí wfs Œ£ st*)
Proof  
  ho_match_mp_tac better_tm_induction >> 
  gs[wft_def,EVERY_MEM] >> rw[] (* 4 *)
  >- simp[]
  >> metis_tac[]
QED  

Theorem tmatch_TRANS:
 tmatch Œ£ {} t1 t2 f = œÉ1 ‚àß 
 tmatch Œ£ {} t2 t3 f = œÉ2 

Theorem wft_wfs:
  ‚àÄt. wft Œ£ t ‚áí wfs Œ£ (sort_of Œ£ t)
Proof
  Cases_on ‚Äòt‚Äô >> rw[wft_def]
  >- rw[tmatch_def] >> Cases_on ‚Äò‚Äô

gs[optionTheory.IS_SOME_DEF]
  
QED
         
Theorem tmatch_SOME_wfvmap:
 (‚àÄt1 t2 f œÉ.
     complete f ‚àß wfvmap Œ£ f ‚àß
     (‚àÄn s. (n,s) ‚àà tfv t1 ‚áí (n,s) ‚àâ sfv s) ‚àß
     wft Œ£ t1 ‚àß wft Œ£ t2 ‚àß
     tmatch Œ£ {} t1 t2 f = SOME œÉ ‚áí
     wfvmap Œ£ œÉ ‚àß tinst œÉ t1 = t2) ‚àß
 (‚àÄst1 st2 f œÉ.
    complete f ‚àß wfvmap Œ£ f ‚àß
    (‚àÄn s. (n,s) ‚àà sfv st1 ‚áí (n,s) ‚àâ sfv s) ‚àß
    wfs Œ£ st1 ‚àß wfs Œ£ st2 ‚àß 
    smatch Œ£ {} st1 st2 f = SOME œÉ ‚áí
    wfvmap Œ£ œÉ ‚àß sinst œÉ st1 = st2) ‚àß
 ‚àÄtl1 tl2 f œÉ.
    complete f ‚àß wfvmap Œ£ f ‚àß
    (‚àÄt n s. MEM t tl1 ‚àß (n,s) ‚àà tfv t ‚áí (n,s) ‚àâ sfv s) ‚àß
    (‚àÄt. MEM t tl1 ‚áí wft Œ£ t) ‚àß
    (‚àÄt. MEM t tl2 ‚áí wft Œ£ t) ‚àß
    tlmatch Œ£ {} tl1 tl2 f = SOME œÉ ‚áí
    wfvmap Œ£ œÉ ‚àß
    (‚àÄn. n < LENGTH tl1 ‚áí tinst œÉ (EL n tl1) = EL n tl2)
Proof
  ho_match_mp_tac original_tm_induction>> rw[]
  >- ‚Äòcomplete œÉ ‚àß f ‚äë œÉ ‚àß
      FDOM œÉ = FDOM f ‚à™ tfv (Var s0 st1)‚Äô
      by (irule tmatch_property >>
         gs[tfv_def,PULL_EXISTS] >>
         qexistsl [‚Äòt2‚Äô,‚ÄòŒ£‚Äô] >> metis_tac[]) >>
     drule_then assume_tac wfvmap_SUBMAP >>
     first_x_assum irule >> simp[] >>
     rpt gen_tac >> disch_tac >>
     gs[wft_def,tmatch_def,AllCaseEqs()] (* 2 *)
     >- (gs[complete_def] >> metis_tac[])
     >- ‚ÄòœÉ ' (s0,st1) = t2‚Äô
        by (gs[fmap_EXT] >>
        first_x_assum (qspecl_then [‚Äò(s0,st1)‚Äô] assume_tac)
        >> gs[FAPPLY_FUPDATE]) >> gs[] >>
        ‚Äòsort_of Œ£ t2 = sinst f0 st1‚Äô suffices_by cheat >>
        ‚Äòwfvmap Œ£ f0 ‚àß sinst f0 st1 = sort_of Œ£ t2‚Äô
         suffices_by metis_tac[] >>
        first_x_assum irule >>
        
     drule tmatch_tinst >> 
     simp[wfvmap_def]

        drule_then assume_tac tmatch_property >>
    
        
Theorem tinst_wft:
 wft Œ£f t ‚áí ‚àÄœÉ. wfvmap Œ£f œÉ ‚áí wft Œ£f (tinst œÉ t)
Proof
 Induct_on ‚Äòt‚Äô >> rw[tinst_def,wft_def] (* 2 *) 
 >- (Cases_on ‚Äòs‚Äô >> rw[] >> gs[wft_def,EVERY_MEM] (* 2 *) >>
    rename [‚ÄòSt s l‚Äô]
    >- (rw[MEM_MAP] >> last_x_assum irule >> simp[]) >>
    gs[wfvmap_def]) >>
    
    
 
QED
     

Theorem matchs_trans:
  IS_SOME (tlmatch Œ£f lcs t1 t2 œÉ) ‚àß
  IS_SOME (tlmatch Œ£f lcs t2 t3 œÉ) ‚áí 
  IS_SOME (tlmatch Œ£f lcs t1 t3 œÉ)
Proof 
  Cases_on ‚Äòt1‚Äô >> Cases_on ‚Äòt2‚Äô >> Cases_on ‚Äòt3‚Äô >>
  Cases_on ‚Äòtmatch Œ£f lcs h h' œÉ‚Äô >> 
  Cases_on ‚Äòtmatch Œ£f lcs h' h'' œÉ‚Äô >> gs[tmatch_def] >>
  rw[] >> 
  
Theorem finst_subst_wff:
 wff (Œ£f,Œ£p) œï ‚áí ‚àÄœÉ. wfvmap Œ£f œÉ ‚áí wff (Œ£f,Œ£p) (finst œÉ œï)
Proof
 Induct_on ‚Äòœï‚Äô >> rw[finst_def] (* 2 *) >> gs[] >>
 cheat
QED

        
Theorem fVar_subst_wff:
 wff (Œ£f,Œ£p) œï ‚àß wff (Œ£f,Œ£p) f ‚àß wfarg Œ£f vl ‚áí
 wff (Œ£f,Œ£p) (fVar_subst Œ£f (P,vl,œï:form) f)
Proof
 Induct_on ‚Äòf‚Äô >> rw[fVar_subst_def] (* 2 *) >> gs[] >>
 cheat
QED 

(*‚àÄA a:mem(A). P(a).
 inst to \B b:mem(B). Q(a:mem(A))
 then need to rename A a into A' a':mem(A). *)


Definition fVar_substs_def:
  fVar_substs Œ£f [] f = f ‚àß
  fVar_substs Œ£f (h :: t) f = fVar_substs Œ£f t (fVar_subst Œ£f h f)
End 
 

Definition fVar_insts_def:
  fVar_insts Œ£ f = {fVar_substs (FST Œ£) l f | EVERY (wff Œ£) (MAP (SND o SND) l)}
End

(*fVar concrete instances*)
         
Definition fVar_concr_insts_def:
  fVar_concr_insts Œ£ f = fVar_insts Œ£ f ‚à© {œï | ffVar œï = {}}
End  

Definition is_concr_def:
  is_concr f ‚áî (ffVar f = {})
End  
                
(*                     

Definition pvariantt_def:
  pvariantt vs (Var n s) =
  if (n,s) ‚àà vs then pvariantt vs (Var (n ^ "'") s)
  else 
*)
  
(*
Definition is_eqv_def:
  is_eqv 
End
*)

Overload TO_FMAP = ‚ÄúFUPDATE_LIST FEMPTY‚Äù        




(*say, if we start with a:mem(A),b:mem(B), we do not want to make it a':mem(A') b':mem(B'), but only a':mem(A),b':mem(B),
 therefore we do not just add prim to every variable we spot, bu try to do it uniformly by tinst *)          

Definition refl_of:
 refl_of (vl1,vl2) œï = finst (TO_FMAP (ZIP (vl1 ++ vl2,MAP (UNCURRY Var) (vl1 ++ vl1)))) œï
End 


Definition sym_of:
 sym_of (vl1,vl2) œï =
 IMP œï (finst (TO_FMAP (ZIP (vl1 ++ vl2,MAP (UNCURRY Var) (vl2 ++ vl1)))) œï)
End 

(*assume the list are all distinct*)
(*
Definition mk_prim_fmap:
  mk_prim_fmap œÉ [] = (œÉ,[]) ‚àß
  mk_prim_fmap œÉ ((n,s) :: t) = mk_prim_fmap (œÉ |+ ((n,s),Var(n',s))) (MAP )
*)

(*abs of A,B a in A, b in B
         C D c in C, d in D are equal.
 no way for a:A b:B, and c:C,d:D to be equal, since A B C D are free.
 abs of a:mem(A),a':mem(A) are equal.*)

(* 
Definition mk_abs_vl:
  mk_abs_vl œÉ [] = (œÉ,[]) ‚àß
  mk_abs_vl œÉ ((n,s) :: t) =
  let œÉ1 = (œÉ |+ ((n,s),Var(toString 0,s)))
  in
  mk_abs_vl œÉ1 (MAP (Œª(n,s). (n,sinst œÉ1 s)) t)
End
*)

(*require all the names are different, UNZIP to two list, both of the list satisfies ALL_DISTINCT
  if do so then do not require keeping information in an accumulator.
  only former variables can affect later variables but not vice versa.
*)

        

Definition abs_list_eqv_def:
  (abs_list_eqv ([]:(string # sort) list) ([]:(string # sort) list) ‚áî T) ‚àß
  (abs_list_eqv ((n1,s1) :: vl1) ((n2,s2) :: vl2) ‚áî
   s1 = s2 ‚àß (let œÉ = FEMPTY |+ ((n2,s1),Var n1 s1) in abs_list_eqv vl1 (MAP (Œª(n,s). (n,sinst œÉ s)) vl2))) ‚àß
  (abs_list_eqv [] (h :: t) = F) ‚àß
  (abs_list_eqv (h :: t) [] = F)
End

Definition tlfv_def:
   tlfv tl = BIGUNION (IMAGE tfv (set tl))
End
   
Definition sdepend_def:
  sdepend (St n tl) v ‚áî v ‚àà tlfv tl
End

Definition wfv_def:
  wfv Œ£f (n,s) ‚áî EVERY (wft Œ£f) (stms s)
End  

(*so f:A->B A is ill-formed*)       
Definition wfarg_def:
  wfarg Œ£f vl ‚áî
  ALL_DISTINCT vl ‚àß
  EVERY (wfv Œ£f) vl ‚àß
  ‚àÄn1 n2. n1 < n2 ‚àß n2 ‚â§ LENGTH vl ‚áí ¬¨(sdepend (SND (EL n1 vl)) (EL n2 vl))
End



Definition vlcanmch_def:
  vlcanmch Œ£f vl1 vl2 ‚áî
  IS_SOME
  (tlmatch Œ£f {} (MAP (UNCURRY Var) vl1) (MAP (UNCURRY Var) vl2) FEMPTY)
End


Definition tlcanmch_def:
  tlcanmch Œ£f tl1 tl2 ‚áî
  IS_SOME (tlmatch Œ£f {} tl1 tl2 FEMPTY)
End

Definition arg_eqv_def:
  arg_eqv Œ£f vl1 vl2 ‚áî (vlcanmch Œ£f vl1 vl2 ‚àß vlcanmch Œ£f vl2 vl1)
End  

(*     
Theorem tlcanmch_refl:
  tlmatch Œ£f {} tl tl FEMPTY =
  let vl = SET_TO_LIST 
  SOME (TO_FMAP (ZIP (tl, MAP (UNCURRY Var) tl)))
Proof
*)
        
(*
Theorem vlmatchable_sym:
 vlmatchable Œ£f vl1 vl2 ‚áî vlmatchable Œ£f vl2 vl1
Proof
 metis_tac[vlmatchable_def]
QED              



Theorem vlmatchable_refl:
 vlmatchable Œ£f vl vl
Proof
 
QED                 
*)

          
(*Theorem abs_list_sym:
  ‚àÄl1 l2.
  ALL_DISTINCT (MAP FST (l1 ++ l2)) ‚áí
  (abs_list_eqv l1 l2 ‚áî abs_list_eqv l2 l1)
Proof
  Induct_on ‚Äòl1‚Äô >> Induct_on ‚Äòl2‚Äô >> simp[abs_list_eqv_def] >>
  Cases_on ‚Äòh‚Äô >> Cases_on ‚Äòh'‚Äô >>
  rename [‚ÄòFST (n1,s1) ‚â† FST (n2,s2)‚Äô] >> simp[abs_list_eqv_def] >>
  rw[] >> Cases_on ‚Äòs1 = s2‚Äô >> simp[] >> rw[EQ_IMP_THM] (* 2 *) >> cheat
QED  *)
  
(*        
Definition abs_list_eqv:
  (abs_list_eqv ([]:(string # sort) list) ([]:(string # sort) list) ‚áî T) ‚àß
  (abs_list_eqv ((n1,s1) :: vl1) ((n2,s2) :: vl2) ‚áî
   s1 = s2 ‚àß (let œÉ = FEMPTY |+ ((n2,s1),Var (n1,s1)) in abs_list_eqv (MAP ((sinst œÉ) o SND) vl1) (MAP ((sinst œÉ) o SND) vl2)))
End   
*)

(*            
Definition trans_of:
 trans_of (vl1,vl2,vl3) œï =
 let vl3 = MAP (tinst (TO_FMAP (MAP (Œª(n,s) => Var (n^"'"))))) vl2
 in
 IMP (CONJ œï (finst (TO_FMAP (ZIP (vl1 ++ vl2,MAP (UNCURRY Var) (vl2 ++ vl1)))) œï)
End 
*)
                        
((‚àÄax. ax ‚àà axs ‚áí wff Œ£ ax) ‚áí
        (‚àÄaxs. ax ‚àà axs ‚áí Thm Œ£ axs (ffv ax) {} ax)) ‚àß


Definition wffs_def:
 wffs Œ£ fs ‚áî (‚àÄf. f ‚àà fs ‚áí wff Œ£ f)
End 
                  
Inductive Thm:
[~AX:] (‚àÄaxs ax. wffs Œ£ axs ‚àß ax ‚àà axs ‚áí Thm Œ£ axs (ffv ax) {} ax) ‚àß
[~FalseE1:]
  (‚àÄŒì A f. Thm Œ£ axs Œì (A ‚à™ {NEG f}) False ‚áí Thm Œ£ axs Œì A f) ‚àß
[~FalseE2:]
  (‚àÄŒì A f. Thm Œ£ axs (Œì ‚à™ ffv f) A False ‚áí Thm Œ£ axs Œì A f) ‚àß
[~assume:]
  (‚àÄc:form. wff Œ£ c ‚áí Thm Œ£ axs (ffv c) {c} c) ‚àß
[~mp:]
  (‚àÄŒì1 Œì2 A1 A2 f1 f2.
     Thm Œ£ axs Œì1 A1 (IMP f1 f2) ‚àß Thm Œ£ axs Œì2 A2 f1 ‚áí
     Thm Œ£ axs (Œì1 ‚à™ Œì2) (A1 ‚à™ A2) f2) ‚àß
[~disch:]
  (‚àÄŒì A f a.
     Thm Œ£ axs Œì A f ‚àß wff Œ£ a ‚àß ffv a ‚äÜ Œì ‚áí 
     Thm Œ£ axs Œì (A DELETE a) (IMP a f)) ‚àß
[~refl:]
  (‚àÄt. wft (FST Œ£) t ‚áí 
     Thm Œ£ axs (tfv t) {} (EQ t t)) ‚àß
[~sym:]
  (‚àÄŒì A t1 t2.
     Thm Œ£ axs Œì A (EQ t1 t2) ‚áí
     Thm Œ£ axs Œì A (EQ t2 t1)) ‚àß
[~trans:]
  (‚àÄŒì1 Œì2 A1 A2 t1 t2 t3.
     Thm Œ£ axs Œì1 A1 (EQ t1 t2) ‚àß Thm Œ£ axs Œì2 A2 (EQ t2 t3) ‚áí
     Thm Œ£ axs (Œì1 ‚à™ Œì2) (A1 ‚à™ A2) (EQ t1 t3)) ‚àß
[~ALLI:]
  (‚àÄŒì A f x s.
     Thm Œ£ axs Œì A f ‚àß wfs (FST Œ£) s ‚àß
     (sfv s) ‚äÜ Œì ‚àß
     (‚àÄn0 s0. (n0,s0) ‚àà Œì ‚áí (x,s) ‚àâ sfv v) ‚àß
     (‚àÄa. a ‚àà A ‚áí (x,s) ‚àâ ffv a) ‚áí
     Thm Œ£ axs (Œì DELETE (x,s)) A (FALL x s f)) ‚àß
[~ALLE:]
  (‚àÄŒì A n s f t.
    Thm Œ£ axs Œì A (FALL n s f) ‚àß wft (FST Œ£) t ‚àß sort_of (FST Œ£) t = s ‚áí
    Thm Œ£ axs (Œì ‚à™ tfv t) A (fsubst n s t f)) ‚àß
[~fvar_inst:]
  (‚àÄŒì A f P:string vl:(string # sort) list œï:form.
     Thm Œ£ axs Œì A f ‚áí Thm Œ£ axs (Œì ‚à™ (ffv œï)) (IMAGE (fVar_subst (FST Œ£) (P,vl,œï)) A)
                     (fVar_subst (FST Œ£) (P,vl,œï) f)) ‚àß
[~pred_spec:]
  ‚àÄpname argl œï.
  wff Œ£ œï ‚àß wfarg (FST Œ£) argl ‚àß
  ffv œï ‚äÜ set argl ‚áí
  (Thm (new_psym Œ£ pname argl) axs (ffv œï) {}
   (IFF (Pred pname (MAP (UNCURRY Var) argl)) œï))
End


        

(*
(*   
[~fun_spec:]
  
  Thm Œ£ axs Œì {} (EXL vl1 True) ‚àß
  ALL_DISTINCT (vl1 ++ vl2 ++ vl3) ‚àß
  arg_eqv (FST Œ£) vl1 vl2 ‚àß arg_eqv (FST Œ£) vl2 vl3 ‚àß
  Thm Œ£ axs Œì0 A0
  (mk_eqv œï vl1 vl2 vl3) 

  
  (*same pattern*)
  IS_SOME (tlmatch (FST Œ£) {} (MAP (UNCURRY Var) vl1)
                              (MAP (UNCURRY Var) vl2) FEMPTY) ‚àß
  IS_SOME (tlmatch (FST Œ£) {} (MAP (UNCURRY Var) vl2)
                              (MAP (UNCURRY Var) vl3) FEMPTY) ‚àß
  Thm Œ£ axs Œì0 A0
  (FALL vl1 (finst (THE (tlmatch (FST Œ£) ‚àÖ (MAP (UNCURRY Var) (vl1++vl2))
                (MAP (UNCURRY Var) (vl1++vl1))  FEMPTY)) œï)) ‚àß
  Thm Œ£ axs Œì0 A0
  FALL (vl1 ++ vl2)
  (IMP œï
      (finst (THE (tlmatch (FST Œ£) ‚àÖ (MAP (UNCURRY Var) (vl1++vl2))
                   (MAP (UNCURRY Var) (vl2++vl1))  FEMPTY)) œï)) ‚àß
  FALL (vl1 ++ vl2 ++ vl3)              
  (IMP
      (CONJ
       (finst (THE (tlmatch (FST Œ£) ‚àÖ (MAP (UNCURRY Var) (vl1++vl2))
                    (MAP (UNCURRY Var) (vl2++vl1))  FEMPTY)) œï)
       (finst (THE (tlmatch (FST Œ£) ‚àÖ (MAP (UNCURRY Var) (vl1++vl2))
                    (MAP (UNCURRY Var) (vl2++vl3))  FEMPTY)) œï))
      (finst (THE (tlmatch (FST Œ£) ‚àÖ (MAP (UNCURRY Var) (vl1++vl2))
                   (MAP (UNCURRY Var) (vl1++vl3))  FEMPTY)) œï)) ‚àß

         
  ‚áí Thm (new_fsym Œì f s vl) axs A (fVar_subst (FST Œ£) )  *) 
*)        

(*To prove:
-- every free variable is included by Œì
-- fvar stuff
-- tranalation
-- sig extend, ax extend
-- thm inst can be derived from allI and allE
-- sufficient to prove results for theorems without assumptions
-- sometimes do need to strip quantifiers first before inst.
   ‚àÄA B f:A->B. ...
   ‚àÄA B a:mem(A) b:mem(B).

*)

        (*
Theorem Thm_no_assum_equiv:
  Thm Œ£ axs Œì A f ‚áî Thm Œ£ axs {} {} (GENL Œì)
Proof
cheat
QED
*)

                        
(*sig extend*)

(*      
Theorem Sig_extend:
  Œ£1 ‚äÜ Œ£2 ‚áí Thm Œ£1 axs Œì A f ‚áí Thm Œ£2 axs Œì A f
Proof
cheat
QED
*)

              
(*‚ä• implies everything and ~phi |- ‚ä• *)

(*formalise *)    
Inductive Thm1:
[~AX:] (‚àÄax. ax ‚àà axs ‚áí Thm1 Œ£ axs (ffv ax) {} ax) ‚àß
[~FalseE1:]
  (‚àÄŒì A f. Thm1 Œ£ axs Œì (A ‚à™ {NEG f}) False ‚áí Thm1 Œ£ axs Œì A f) ‚àß
[~FalseE2:]
  (‚àÄŒì A f. Thm1 Œ£ axs (Œì ‚à™ ffv f) A False ‚áí Thm1 Œ£ axs Œì A f) ‚àß
[~assume:]
  (‚àÄc:form. Thm1 Œ£ axs (ffv c) {c} c) ‚àß
[~TrueI:]
  (‚àÄŒì A. Thm1 Œ£ axs Œì A True) ‚àß
[~mp:]
  (‚àÄŒì1 Œì2 A1 A2 f1 f2.
     Thm1 Œ£ axs Œì1 A1 (IMP f1 f2) ‚àß Thm1 Œ£ axs Œì2 A2 f1 ‚áí
     Thm1 Œ£ axs (Œì1 ‚à™ Œì2) (A1 ‚à™ A2) f2) ‚àß
[~disch:]
  (‚àÄŒì A f.
     Thm1 Œ£ axs Œì A f ‚áí
     Thm1 Œ£ axs Œì (A DELETE a) (IMP a f)) ‚àß
[~refl:]
  (‚àÄt.
     Thm1 Œ£ axs (tfv t) {} (EQ t t)) ‚àß
[~sym:]
  (‚àÄŒì A t1 t2.
     Thm1 Œ£ axs Œì A (EQ t1 t2) ‚áí
     Thm1 Œ£ axs Œì A (EQ t2 t1)) ‚àß
[~trans:]
  (‚àÄŒì1 Œì2 A1 A2 t1 t2 t3.
     Thm1 Œ£ axs Œì1 A1 (EQ t1 t2) ‚àß Thm1 Œ£ axs Œì2 A2 (EQ t2 t3) ‚áí
     Thm1 Œ£ axs (Œì1 ‚à™ Œì2) (A1 ‚à™ A2) (EQ t1 t3)) ‚àß
[~ALLI:]
  (‚àÄŒì A f x s.
     Thm1 Œ£ axs Œì A f ‚àß
     (sfv s) ‚äÜ Œì ‚àß
     (‚àÄn0 s0. (n0,s0) ‚àà Œì ‚áí (x,s) ‚àâ sfv v) ‚àß
     (‚àÄa. a ‚àà A ‚áí (x,s) ‚àâ ffv a) ‚áí
     Thm1 Œ£ axs (Œì DELETE (x,s)) A (FALL x s f)) ‚àß
[~ALLE:]
  (‚àÄŒì A n s f t.
    Thm1 Œ£ axs Œì A (FALL n s f) ‚àß sort_of t = s ‚áí
    Thm1 Œ£ axs (Œì ‚à™ tfv t) A (fsubst n s t f)) ‚àß
[~pred_spec:]
  ‚àÄpname argl œï.
  ffv œï ‚äÜ set argl ‚áí
  (Thm1 (Œ£ ‚à™ {(pname,argl)}) axs (ffv œï) {}
   (IFF (Pred pname (MAP (UNCURRY Var) argl)) œï)) ‚àß
[~fun_spec:]
  
End

(*start with the LHS, subst one by one. So if P |-> Q, Q |->R, the result would be P |-> R. In particular, can subst a subst*)


(*subst with all well formed formula yields a wf formula.*)        

Definition isfsym_def:
  isfsym fsig f = IS_SOME (fsig ' f)
End


Definition ispsym_def:
  ispsym psig p = IS_SOME (psig ' p)
End
                   


         


() not correc because might by multiple occurrence of fvar in the same axiom.

Theorem remove_fVar_is_fine:
  ‚àÄœï. ffVar œï = {} ‚áí
  Thm Œ£ axs Œì {} œï ‚áî Thm Œ£ ((BIGUNION (IMAGE (fVarinsts Œ£) axs)) ‚à© {f | ffVar f = {}}) Œì {} œï
Proof    
  

        

Datatype: thm = thm ((string # sort) set) (form set) form
End

Definition tmatchable_def:
  tmatchable lcs t1 t2 f ‚áî ‚àÉœÉ. tmatch lcs t1 t2 f = SOME œÉ
End  


Definition tlmatchable_def:
  tlmatchable lcs tl1 tl2 f ‚áî ‚àÉœÉ. tlmatch lcs tl1 tl2 f = SOME œÉ
End     

(*well-formed abstraction arguments, free variables in previous arguments does not appear as bound variable later*)        
Definition wfaa_def:
  wfaa vl = ‚àÄn1 n2. n1 < n2 ‚áí EL n1 vl ‚àâ sfv (SND (EL n2 vl)) ‚à™ {EL n2 vl}
End  
        
Definition ffVar_def:
  ffVar s False = s
  ffVar s (Pred _ _) = s
  ffVar s (IMP f1 f2) = s ‚à™ ffVar f1 ‚à™ ffVar f2
  ffVar s (FALL n st b) = s ‚à™ ffVar b
  ffVar s (fVar P tl) =
  if ‚àÉP0 tl0. (P0,tl0) ‚àà s ‚àß tlmatchable 
End  

Theorem remove_fVar_is_fine:
  ‚àÄaxs:thm set.
    (‚àÄax. ax ‚àà axs ‚áí
          ‚àÄP vl. (P,vl) ‚àà thmfVar ax ‚áí ()) ‚áí
    ‚àÄŒì A f. thmfV Thm Œì A f ‚áí Thm1 Œì A f
Proof    
  

        
val _ = export_theory();

