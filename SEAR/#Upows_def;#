
---------------------------------------------------------------------
       HOL-4 [Kananaskis 14 (stdknl, built Wed Oct 05 11:34:20 2022)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
> > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > datatype sort = srt of string * term list
datatype term =
    Bound of int
  | Fun of string * sort * term list
  | Var of string * sort
exception CLASH
val SortDB = ref ?: (string, (string * sort) list) Binarymap.dict ref
val SortInx = ref ?: (string, string) Binarymap.dict ref
exception TER of string * sort list * term list
val depends_on = fn: sort -> term list
val dest_fun = fn: term -> string * sort * term list
val dest_sort = fn: sort -> string * term list
val dest_var = fn: term -> string * sort
val eq_sort = fn: sort * sort -> bool
val eq_term = fn: term * term -> bool
val ground_sorts = fn:
   (string, (string * sort) list) Binarymap.dict -> string list
val inv_image_compare = fn: ('a -> 'b) -> ('b * 'b -> 'c) -> 'a * 'a -> 'c
val is_bound = fn: term -> bool
val is_fun = fn: term -> bool
val is_var = fn: term -> bool
val list_compare = fn: ('a * 'b -> order) -> 'a list * 'b list -> order
val listof_sorts = fn:
   (string, (string * sort) list) Binarymap.dict ->
     (string * (string * sort) list) list
val mk_bound = fn: int -> term
val mk_const0 = fn: string -> sort -> term
val mk_fun0 = fn: string -> sort -> term list -> term
val mk_sort = fn: string -> term list -> sort
val mk_var = fn: string * sort -> term
val new_sort = fn: string -> (string * sort) list -> unit
val new_sort_infix = fn: string -> string -> unit
val of_sort = fn: string -> term -> bool
val on_ground = fn: string -> bool
val pair_compare = fn:
   ('a * 'b -> order) -> ('c * 'd -> order) -> ('a * 'c) * ('b * 'd) -> order
val replaces = fn: int * term -> sort -> sort
val replacet = fn: int * term -> term -> term
val sort_cpr = fn: sort * sort -> order
val sort_infixes0 = ?: (string, string) Binarymap.dict
val sort_name = fn: sort -> string
val sort_of = fn: term -> sort
datatype sort_view = vSrt of string * term list
val sortname_of_infix = fn: string -> string
val sorts0 = ?: (string, (string * sort) list) Binarymap.dict
val srt2ns = fn: string -> string * sort
val substs = fn: (string * sort) * term -> sort -> sort
val substt = fn: (string * sort) * term -> term -> term
val term_compare = fn: term * term -> order
val term_cpr = fn: term * term -> order
datatype term_view =
    vB of int
  | vFun of string * sort * term list
  | vVar of string * sort
val tml_cmp = fn: term list * term list -> order
val view_sort = fn: sort -> sort_view
val view_term = fn: term -> term_view
val vreplaces = fn: int * (string * sort) -> sort -> sort
val vreplacet = fn: int * (string * sort) -> term -> term
val wrap_ter = fn: string -> sort list -> term list -> exn -> exn
val sort_compare = fn: sort * sort -> order
exception ERR of string * sort list * term list * form list
val EqSorts = ref []: string list ref
val FVS = fn: (string * sort) list -> sort -> (string * sort) list
val FVT = fn: (string * sort) list -> term -> (string * sort) list
val FVTL = fn: (string * sort) list -> term list -> (string * sort) list
val abbrdict = ref ?:
   (string * term list, string * term list) Binarymap.dict ref
val abbrdict0 = ?: (string * term list, string * term list) Binarymap.dict
val abstract = fn: string * sort -> form -> form
val bigunion = fn: ('a * 'a -> order) -> 'a set list -> 'a set
val dest_s = fn: string * sort -> sort * int -> sort
val dest_t = fn: string * sort -> term * int -> term
val emptyvd = ?: vd
val eqsorts0 = []: string list
val essps = HOLset{}: (string * sort) set
val filter_cont = fn: (string * sort) set -> (string * sort) set
datatype form =
    Conn of string * form list
  | Pred of string * bool * term list
  | Quant of string * string * sort * form
type fsymd = (string, sort * (string * sort) list) Binarymap.dict
val fsyms = ref ?: fsymd ref
val fsyms0 = ?: fsymd
val fsymss = fn: sort -> string set
val fsymst = fn: term -> string set
val fvs = fn: sort -> (string * sort) set
val fvsa = fn: (string * sort) set -> sort -> (string * sort) set
val fvt = fn: term -> (string * sort) set
val fvta = fn: (string * sort) set -> term -> (string * sort) set
val fvtl = fn: term list -> (string * sort) set
val fvtla = fn: (string * sort) set -> term list -> (string * sort) set
val fxty = fn: string -> int
val has_bound_s = fn: sort -> bool
val has_bound_t = fn: term -> bool
val has_eq = fn: string -> bool
val ill_formed_fv = fn: 'a * sort -> bool
val inst_sort = fn: vd -> sort -> sort
val inst_term = fn: vd -> term -> term
val is_const = fn: string -> bool
val is_fun = fn: string -> bool
val is_pred = fn: string -> bool
val lookup_fun = fn: fsymd -> string -> (sort * (string * sort) list) option
val lookup_pred = fn: psymd -> string -> (string * sort) list option
val lookup_t = fn: vd -> string * sort -> term option
val match_sort = fn: (string * sort) set -> sort -> sort -> vd -> vd
val match_term = fn: (string * sort) set -> term -> term -> vd -> vd
val match_tl = fn: (string * sort) set -> term list -> term list -> vd -> vd
val mk_fun = fn: string -> term list -> term
val mk_tenv = fn:
   ((string * sort) * term) list -> (string * sort, term) Binarymap.dict
val new_abbr = fn: string * term list -> string * term list -> unit
val new_fun = fn: string -> sort * (string * sort) list -> unit
val new_pred = fn: string -> (string * sort) list -> unit
val pinst_s = fn: vd -> sort -> sort
val pinst_t = fn: vd -> term -> term
val pmatch_s = fn:
   sort list -> (string * sort) set -> sort -> sort -> vd -> vd
val pmatch_t = fn:
   sort list -> (string * sort) set -> term -> term -> vd -> vd
val pmatch_tl = fn:
   sort list -> (string * sort) set -> term list -> term list -> vd -> vd
type psymd = (string, (string * sort) list) Binarymap.dict
val psyms = ref ?: psymd ref
val psyms0 = ?: psymd
val pvariantt = fn: (string * 'a) set -> term -> term
val pvd = fn: ('a, 'b) Binarymap.dict -> ('a * 'b) list
val recover_s = fn: int -> sort -> sort
val recover_t = fn: int -> term -> term
val shift_vd = fn:
   int -> ('a, term) Binarymap.dict -> ('a, term) Binarymap.dict
val shift_vd_eval = fn: int -> ('a, term) Binarymap.dict -> 'a -> term
val simple_fail = fn: string -> exn
val strtml_cmp = fn: (string * term list) * (string * term list) -> order
val subst_bound = fn: term -> form -> form
val substf = fn: (string * sort) * term -> form -> form
val unabbrdict = ref ?:
   (string * term list, string * term list) Binarymap.dict ref
val unabbrdict0 = ?: (string * term list, string * term list) Binarymap.dict
val v2t = fn: string * sort -> term -> vd -> vd
val var_bigunion = fn: (string * sort) set list -> (string * sort) set
val var_ord = fn: (string * sort) * (string * sort) -> order
type vd = (string * sort, term) Binarymap.dict
val wrap_err = fn: string -> exn -> exn
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holLl4tGgScript.sml:1177: warning: Matches are not exhaustive.
Found near
  case f of
     Conn sfs => vConn sfs |
     Quant ("!", ...) => let val ... = ... in vQ (...) end |
     Quant (...) => let val ... in ... ... end |
     ... ... => let ... in ... end |
     ... => ...
val FALSE = Pred ("F", true, []): form
val TRUE = Pred ("T", true, []): form
val dest_conj = fn: form -> form * form
val dest_dimp = fn: form -> form * form
val dest_disj = fn: form -> form * form
val dest_eq = fn: form -> term * term
val dest_exists = fn: form -> (string * sort) * form
val dest_exists0 = fn: form -> (string * sort) * form
val dest_f = fn: form -> (string * sort) * form
val dest_forall = fn: form -> (string * sort) * form
val dest_forall0 = fn: form -> (string * sort) * form
val dest_fvar = fn: form -> string * term list
val dest_imp = fn: form -> form * form
val dest_neg = fn: form -> form
val dest_pred = fn: form -> string * term list
val dest_quant0 = fn: form -> string * string * sort * form
val dest_uex = fn: form -> (string * sort) * form
val dest_uex0 = fn: form -> (string * sort) * form
val emptyfvd = ?: fvd
val eq_form = fn: form * form -> bool
val eq_forml = fn: form list -> form list -> bool
val fVars = fn: form -> string set
val fVarsl = fn: form list -> string set
val fmem = fn: form -> form list -> bool
datatype form_view =
    vConn of string * form list
  | vPred of string * bool * term list
  | vQ of string * string * sort * form
val fsymsf = fn: form -> string set
val fv2f = fn: string -> form -> fvd -> fvd
val fv2f' = fn: string -> form -> menv -> menv
type fvd = (string, form) Binarymap.dict
val fvd_of = fn: menv -> fvd
val fvf = fn: form -> (string * sort) set
val fvfl = fn: form list -> (string * sort) set
val inst_form = fn: menv -> form -> form
val inst_sort' = fn: menv -> sort -> sort
val inst_term' = fn: menv -> term -> term
val is_conj = fn: form -> bool
val is_dimp = fn: form -> bool
val is_disj = fn: form -> bool
val is_eq = fn: form -> bool
val is_exists = fn: form -> bool
val is_forall = fn: form -> bool
val is_imp = fn: form -> bool
val is_neg = fn: form -> bool
val is_quant = fn: form -> bool
val is_uex = fn: form -> bool
val is_var = fn: form -> bool
val is_wfmenv = fn: menv -> bool
val lookup_f = fn: fvd -> string -> form option
val lookup_f' = fn: menv -> string -> form option
val match_fl = fn:
   (string * sort) set ->
     string set -> form list -> form list -> menv -> menv
val match_form = fn:
   (string * sort) set -> string set -> form -> form -> menv -> menv
val match_sort' = fn: (string * sort) set -> sort -> sort -> menv -> menv
val match_tl' = fn:
   (string * sort) set -> term list -> term list -> menv -> menv
val mempty = (?, ?): menv
type menv = vd * fvd
val mk_P0 = fn: string -> term list -> form
val mk_conj = fn: form -> form -> form
val mk_conn = fn: string -> form list -> form
val mk_dimp = fn: form -> form -> form
val mk_disj = fn: form -> form -> form
val mk_eq = fn: term -> term -> form
val mk_exists = fn: string -> sort -> form -> form
val mk_fenv = fn: (string * form) list -> (string, form) Binarymap.dict
val mk_forall = fn: string -> sort -> form -> form
val mk_fvar = fn: string -> term list -> form
val mk_imp = fn: form -> form -> form
val mk_inst = fn:
   ((string * sort) * term) list -> (string * form) list -> menv
val mk_menv = fn: vd -> fvd -> menv
val mk_neg = fn: form -> form
val mk_pred = fn: string -> term list -> form
val mk_pred0 = fn: string -> term list -> form
val mk_quant = fn: string -> string -> sort -> form -> form
val mk_uex = fn: string -> sort -> form -> form
val name_clash = fn: string -> menv -> bool
val ok_dpdc = fn: menv -> (string * sort) * term -> bool
val pmenv = fn: menv -> ((string * sort) * term) list * (string * form) list
val psymsf = fn: form -> string set
val ril = fn: form -> form list -> form list
val strip_all_quants0 = fn: form -> (string * sort) list * form
val strip_exists = fn: form -> form * (string * sort) list
val strip_forall = fn: form -> form * (string * sort) list
val strip_forall0 = fn: form -> form * (string * sort) list
val strip_quants = fn: form -> form * (string * sort) list
val strip_uex = fn: form -> form * (string * sort) list
val vd_of = fn: menv -> vd
val view_form = fn: form -> form_view
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holLl4tGgScript.sml:1268: warning: Matches are not exhaustive.
Found near
  case f of
     Pred (P0, false, ...) => fVar_Inst_P bs pair f |
     Conn (co, ...) =>
     (let val ... in ... handle ... end handle _ => ... ...) |
     Conn (...) => Conn (...) |
     ... ... => raise ... |
     ... => ...
val fVar_Inst_P = fn:
   sort list -> string * ((string * sort) list * form) -> form -> form
val fVar_Inst_f = fn: string * ((string * sort) list * form) -> form -> form
val fVar_Inst_f0 = fn:
   sort list -> string * ((string * sort) list * form) -> form -> form
val pinst_f = fn: (string * sort, term) Binarymap.dict -> form -> form
val rename_bound = fn: string -> form -> form
val it = (): unit
> 
*** Emacs/HOL command completed ***

> # # # # val bs = []: sort list
> # # poly: : error: Value or constructor (set_sort) has not been declared
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Value or constructor (set_sort) has not been declared
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Value or constructor (fun_sort) has not been declared
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "X" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "Y" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Value or constructor (fun_sort) has not been declared
Found near [mk_var ("f", ... ... (... ...))]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "A" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [mk_var ("f", ... ... (... ...))]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "B" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [mk_var ("f", ... ... (... ...))]
Static Errors
> # # # # val bs = []: sort list
> # # poly: : error: Value or constructor (set_sort) has not been declared
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Value or constructor (set_sort) has not been declared
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Value or constructor (fun_sort) has not been declared
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "X" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "Y" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [("X", set_sort), ("Y", set_sort), ("f", ... ...)]
poly: : error: Value or constructor (fun_sort) has not been declared
Found near [mk_var ("f", ... ... (... ...))]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "A" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [mk_var ("f", ... ... (... ...))]
poly: : error: Type error in function application.
   Function: mk_set : ''a list -> ''a list
   Argument: "B" : string
   Reason:
      Can't unify ''a list (*In Basis*) with string (*In Basis*)
         (Different type constructors)
Found near [mk_var ("f", ... ... (... ...))]
Static Errors
> val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = srt ("set", []): sort
val it = (): unit
> 
*** Emacs/HOL command completed ***

> # # # # val bs = []: sort list
> # # val P = "P": string
val Q =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> 
*** Emacs/HOL command completed ***

> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred
        ("Q", false,
         [Var
           ("f",
            srt
             ("fun",
              [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))):
   form
> # # val b =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0])): form
val n = "B": string
val s = srt ("set", []): sort
> # val it =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))])):
   form
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred
        ("Q", false,
         [Var
           ("f",
            srt
             ("fun",
              [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))):
   form
> # # # # val b =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0])): form
val n = "B": string
val s = srt ("set", []): sort
> # val it =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))])):
   form
> # val b1 = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
val n1 = "f": string
val s1 = srt ("fun", [Var ("A", srt ("set", [])), Bound 0]): sort
> # Exception-
   ERR
     ("fVar_Inst_P.match_sort.attempting matching two different sorts: set , fun",
      [srt ("set", []), srt ("fun", [Var ("A", srt ("set", [])), Bound 0])],
      [], []) raised
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val it =
   [srt ("fun", [Var ("A", srt ("set", [])), Bound 0]), srt ("set", [])]:
   sort list
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val it = srt ("fun", [Var ("A", srt ("set", [])), Bound 0]): sort
> # val it = srt ("set", []): sort
> # val it =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # Exception-
   ERR
     ("fVar_Inst_P.match_sort.attempting matching two different sorts: fun , set",
      [srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]),
       srt ("set", [])], [], []) raised
> # val it = srt ("set", []): sort
> # val it = srt ("fun", [Var ("A", srt ("set", [])), Bound 0]): sort
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> Exception- NO_PROOFS raised
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val bs =
   [srt ("fun", [Var ("A", srt ("set", [])), Bound 1]), srt ("set", [])]:
   sort list
val f = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> > > # # # # val lcs =
   HOLset{("A", srt ("set", [])), ("B", srt ("set", [])),
          ("f",
           srt
            ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))}:
   (string * sort) set
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val args0 = [Var ("A", srt ("set", [])), Bound 1, Bound 0]: term list
> > # val it =
   [Var ("X", srt ("set", [])), Var ("Y", srt ("set", [])),
    Var
     ("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   term list
> # val it = [Var ("A", srt ("set", [])), Bound 1, Bound 0]: term list
> > # # # val venv = ?: vd
> Binarymap.listItems venv;
val it =
   [(("X", srt ("set", [])), Var ("A", srt ("set", []))),
    (("Y", srt ("set", [])), Bound 1),
    (("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))])),
     Bound 0)]: ((string * sort) * term) list
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> # val it =
   ([srt ("fun", [Var ("A", srt ("set", [])), Bound 1]), srt ("set", [])],
    ("P",
     ([("X", srt ("set", [])), ("Y", srt ("set", [])),
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
      Pred
       ("Q", false,
        [Var
          ("f",
           srt
            ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))),
    Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0])):
   sort list * (string * ((string * sort) list * form)) * form
> # val bs =
   [srt ("fun", [Var ("A", srt ("set", [])), Bound 1]), srt ("set", [])]:
   sort list
val f = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # val args0 = [Var ("A", srt ("set", [])), Bound 1, Bound 0]: term list
> > # # # val venv = ?: vd
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> # val f =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
val vd = ?: vd
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> # poly: : error: Type error in function application.
   Function: o : ({2: 'a, ...} -> 'a) * ('b -> {2: 'a, ...}) -> 'b -> 'a
   Argument: (#2, dest_fvar Q) : ({2: 'a, ...} -> 'a) * (string * term list)
   Reason:
      Can't unify 'a -> {2: 'b, ...} to string * term list
         (Incompatible types)
Found near #2 o dest_fvar Q
Static Errors
> # poly: : error: Type error in function application.
   Function: o : ({2: 'a, ...} -> 'a) * ('b -> {2: 'a, ...}) -> 'b -> 'a
   Argument: (#2, (dest_fvar Q)) :
      ({2: 'a, ...} -> 'a) * (string * term list)
   Reason:
      Can't unify 'a -> {2: 'b, ...} to string * term list
         (Incompatible types)
Found near #2 o (dest_fvar Q)
Static Errors
> # val tl =
   [Var
     ("f",
      srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]:
   term list
> pinst_t;
val it = fn: vd -> term -> term
> > > # # # # # # # # # # # # val pinst_f = fn: (string * sort, term) Binarymap.dict -> form -> form
> 
*** Emacs/HOL command completed ***

> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> > > # # # # # # # # # # # # # val pinst_f = fn: (string * sort, term) Binarymap.dict -> form -> form
> 
*** Emacs/HOL command completed ***

> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> Binarymap.listItems vd;
val it =
   [(("X", srt ("set", [])), Var ("A", srt ("set", []))),
    (("Y", srt ("set", [])), Bound 1),
    (("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))])),
     Bound 0)]: ((string * sort) * term) list
> # val tl =
   [Var
     ("f",
      srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]:
   term list
> > # val it =
   [Var
     ("f",
      srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]:
   term list
> # val it = ?: vd
> > # val it =
   [(("X", srt ("set", [])), Var ("A", srt ("set", []))),
    (("Y", srt ("set", [])), Bound 1),
    (("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))])),
     Bound 0)]: ((string * sort) * term) list
> # # # val it =
   Var
    ("f",
     srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))])):
   term
> # # # # val it = Bound 0: term
> > # val it =
   [(("X", srt ("set", [])), Var ("A", srt ("set", []))),
    (("Y", srt ("set", [])), Bound 1),
    (("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))])),
     Bound 0)]: ((string * sort) * term) list
> # # # # val it =
   Var
    ("f",
     srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))])):
   term
> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]):
   form
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val it =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("A", srt ("set", [])), Var ("B", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # # # val bs = []: sort list
> # # val P = "P": string
val Q =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("Q", false, [Bound 0]))): form
> # val it = fn: string -> sort * (string * sort) list -> unit
> # val it = fn: string -> (string * sort) list -> unit
> # > # # # # # val P = "P": string
val Q =
   Pred
    ("Inj", true,
     [Var
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Inj", true,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # # # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("Inj", true, [Bound 0]))): form
> Binarymap.listItems vd;
val it =
   [(("X", srt ("set", [])), Var ("A", srt ("set", []))),
    (("Y", srt ("set", [])), Bound 1),
    (("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))])),
     Bound 0)]: ((string * sort) * term) list
> > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > datatype sort = srt of string * term list
datatype term =
    Bound of int
  | Fun of string * sort * term list
  | Var of string * sort
exception CLASH
val SortDB = ref ?: (string, (string * sort) list) Binarymap.dict ref
val SortInx = ref ?: (string, string) Binarymap.dict ref
exception TER of string * sort list * term list
val depends_on = fn: sort -> term list
val dest_fun = fn: term -> string * sort * term list
val dest_sort = fn: sort -> string * term list
val dest_var = fn: term -> string * sort
val eq_sort = fn: sort * sort -> bool
val eq_term = fn: term * term -> bool
val ground_sorts = fn:
   (string, (string * sort) list) Binarymap.dict -> string list
val inv_image_compare = fn: ('a -> 'b) -> ('b * 'b -> 'c) -> 'a * 'a -> 'c
val is_bound = fn: term -> bool
val is_fun = fn: term -> bool
val is_var = fn: term -> bool
val list_compare = fn: ('a * 'b -> order) -> 'a list * 'b list -> order
val listof_sorts = fn:
   (string, (string * sort) list) Binarymap.dict ->
     (string * (string * sort) list) list
val mk_bound = fn: int -> term
val mk_const0 = fn: string -> sort -> term
val mk_fun0 = fn: string -> sort -> term list -> term
val mk_sort = fn: string -> term list -> sort
val mk_var = fn: string * sort -> term
val new_sort = fn: string -> (string * sort) list -> unit
val new_sort_infix = fn: string -> string -> unit
val of_sort = fn: string -> term -> bool
val on_ground = fn: string -> bool
val pair_compare = fn:
   ('a * 'b -> order) -> ('c * 'd -> order) -> ('a * 'c) * ('b * 'd) -> order
val replaces = fn: int * term -> sort -> sort
val replacet = fn: int * term -> term -> term
val sort_cpr = fn: sort * sort -> order
val sort_infixes0 = ?: (string, string) Binarymap.dict
val sort_name = fn: sort -> string
val sort_of = fn: term -> sort
datatype sort_view = vSrt of string * term list
val sortname_of_infix = fn: string -> string
val sorts0 = ?: (string, (string * sort) list) Binarymap.dict
val srt2ns = fn: string -> string * sort
val substs = fn: (string * sort) * term -> sort -> sort
val substt = fn: (string * sort) * term -> term -> term
val term_compare = fn: term * term -> order
val term_cpr = fn: term * term -> order
datatype term_view =
    vB of int
  | vFun of string * sort * term list
  | vVar of string * sort
val tml_cmp = fn: term list * term list -> order
val view_sort = fn: sort -> sort_view
val view_term = fn: term -> term_view
val vreplaces = fn: int * (string * sort) -> sort -> sort
val vreplacet = fn: int * (string * sort) -> term -> term
val wrap_ter = fn: string -> sort list -> term list -> exn -> exn
val sort_compare = fn: sort * sort -> order
exception ERR of string * sort list * term list * form list
val EqSorts = ref []: string list ref
val FVS = fn: (string * sort) list -> sort -> (string * sort) list
val FVT = fn: (string * sort) list -> term -> (string * sort) list
val FVTL = fn: (string * sort) list -> term list -> (string * sort) list
val abbrdict = ref ?:
   (string * term list, string * term list) Binarymap.dict ref
val abbrdict0 = ?: (string * term list, string * term list) Binarymap.dict
val abstract = fn: string * sort -> form -> form
val bigunion = fn: ('a * 'a -> order) -> 'a set list -> 'a set
val dest_s = fn: string * sort -> sort * int -> sort
val dest_t = fn: string * sort -> term * int -> term
val emptyvd = ?: vd
val eqsorts0 = []: string list
val essps = HOLset{}: (string * sort) set
val filter_cont = fn: (string * sort) set -> (string * sort) set
datatype form =
    Conn of string * form list
  | Pred of string * bool * term list
  | Quant of string * string * sort * form
type fsymd = (string, sort * (string * sort) list) Binarymap.dict
val fsyms = ref ?: fsymd ref
val fsyms0 = ?: fsymd
val fsymss = fn: sort -> string set
val fsymst = fn: term -> string set
val fvs = fn: sort -> (string * sort) set
val fvsa = fn: (string * sort) set -> sort -> (string * sort) set
val fvt = fn: term -> (string * sort) set
val fvta = fn: (string * sort) set -> term -> (string * sort) set
val fvtl = fn: term list -> (string * sort) set
val fvtla = fn: (string * sort) set -> term list -> (string * sort) set
val fxty = fn: string -> int
val has_bound_s = fn: sort -> bool
val has_bound_t = fn: term -> bool
val has_eq = fn: string -> bool
val ill_formed_fv = fn: 'a * sort -> bool
val inst_sort = fn: vd -> sort -> sort
val inst_term = fn: vd -> term -> term
val is_const = fn: string -> bool
val is_fun = fn: string -> bool
val is_pred = fn: string -> bool
val lookup_fun = fn: fsymd -> string -> (sort * (string * sort) list) option
val lookup_pred = fn: psymd -> string -> (string * sort) list option
val lookup_t = fn: vd -> string * sort -> term option
val match_sort = fn: (string * sort) set -> sort -> sort -> vd -> vd
val match_term = fn: (string * sort) set -> term -> term -> vd -> vd
val match_tl = fn: (string * sort) set -> term list -> term list -> vd -> vd
val mk_fun = fn: string -> term list -> term
val mk_tenv = fn:
   ((string * sort) * term) list -> (string * sort, term) Binarymap.dict
val new_abbr = fn: string * term list -> string * term list -> unit
val new_fun = fn: string -> sort * (string * sort) list -> unit
val new_pred = fn: string -> (string * sort) list -> unit
val pinst_s = fn: vd -> sort -> sort
val pinst_t = fn: vd -> term -> term
val pmatch_s = fn:
   sort list -> (string * sort) set -> sort -> sort -> vd -> vd
val pmatch_t = fn:
   sort list -> (string * sort) set -> term -> term -> vd -> vd
val pmatch_tl = fn:
   sort list -> (string * sort) set -> term list -> term list -> vd -> vd
type psymd = (string, (string * sort) list) Binarymap.dict
val psyms = ref ?: psymd ref
val psyms0 = ?: psymd
val pvariantt = fn: (string * 'a) set -> term -> term
val pvd = fn: ('a, 'b) Binarymap.dict -> ('a * 'b) list
val recover_s = fn: int -> sort -> sort
val recover_t = fn: int -> term -> term
val shift_vd = fn:
   int -> ('a, term) Binarymap.dict -> ('a, term) Binarymap.dict
val shift_vd_eval = fn: int -> ('a, term) Binarymap.dict -> 'a -> term
val simple_fail = fn: string -> exn
val strtml_cmp = fn: (string * term list) * (string * term list) -> order
val subst_bound = fn: term -> form -> form
val substf = fn: (string * sort) * term -> form -> form
val unabbrdict = ref ?:
   (string * term list, string * term list) Binarymap.dict ref
val unabbrdict0 = ?: (string * term list, string * term list) Binarymap.dict
val v2t = fn: string * sort -> term -> vd -> vd
val var_bigunion = fn: (string * sort) set list -> (string * sort) set
val var_ord = fn: (string * sort) * (string * sort) -> order
type vd = (string * sort, term) Binarymap.dict
val wrap_err = fn: string -> exn -> exn
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holJXiIToScript.sml:1177: warning: Matches are not exhaustive.
Found near
  case f of
     Conn sfs => vConn sfs |
     Quant ("!", ...) => let val ... = ... in vQ (...) end |
     Quant (...) => let val ... in ... ... end |
     ... ... => let ... in ... end |
     ... => ...
val FALSE = Pred ("F", true, []): form
val TRUE = Pred ("T", true, []): form
val dest_conj = fn: form -> form * form
val dest_dimp = fn: form -> form * form
val dest_disj = fn: form -> form * form
val dest_eq = fn: form -> term * term
val dest_exists = fn: form -> (string * sort) * form
val dest_exists0 = fn: form -> (string * sort) * form
val dest_f = fn: form -> (string * sort) * form
val dest_forall = fn: form -> (string * sort) * form
val dest_forall0 = fn: form -> (string * sort) * form
val dest_fvar = fn: form -> string * term list
val dest_imp = fn: form -> form * form
val dest_neg = fn: form -> form
val dest_pred = fn: form -> string * term list
val dest_quant0 = fn: form -> string * string * sort * form
val dest_uex = fn: form -> (string * sort) * form
val dest_uex0 = fn: form -> (string * sort) * form
val emptyfvd = ?: fvd
val eq_form = fn: form * form -> bool
val eq_forml = fn: form list -> form list -> bool
val fVars = fn: form -> string set
val fVarsl = fn: form list -> string set
val fmem = fn: form -> form list -> bool
datatype form_view =
    vConn of string * form list
  | vPred of string * bool * term list
  | vQ of string * string * sort * form
val fsymsf = fn: form -> string set
val fv2f = fn: string -> form -> fvd -> fvd
val fv2f' = fn: string -> form -> menv -> menv
type fvd = (string, form) Binarymap.dict
val fvd_of = fn: menv -> fvd
val fvf = fn: form -> (string * sort) set
val fvfl = fn: form list -> (string * sort) set
val inst_form = fn: menv -> form -> form
val inst_sort' = fn: menv -> sort -> sort
val inst_term' = fn: menv -> term -> term
val is_conj = fn: form -> bool
val is_dimp = fn: form -> bool
val is_disj = fn: form -> bool
val is_eq = fn: form -> bool
val is_exists = fn: form -> bool
val is_forall = fn: form -> bool
val is_imp = fn: form -> bool
val is_neg = fn: form -> bool
val is_quant = fn: form -> bool
val is_uex = fn: form -> bool
val is_var = fn: form -> bool
val is_wfmenv = fn: menv -> bool
val lookup_f = fn: fvd -> string -> form option
val lookup_f' = fn: menv -> string -> form option
val match_fl = fn:
   (string * sort) set ->
     string set -> form list -> form list -> menv -> menv
val match_form = fn:
   (string * sort) set -> string set -> form -> form -> menv -> menv
val match_sort' = fn: (string * sort) set -> sort -> sort -> menv -> menv
val match_tl' = fn:
   (string * sort) set -> term list -> term list -> menv -> menv
val mempty = (?, ?): menv
type menv = vd * fvd
val mk_P0 = fn: string -> term list -> form
val mk_conj = fn: form -> form -> form
val mk_conn = fn: string -> form list -> form
val mk_dimp = fn: form -> form -> form
val mk_disj = fn: form -> form -> form
val mk_eq = fn: term -> term -> form
val mk_exists = fn: string -> sort -> form -> form
val mk_fenv = fn: (string * form) list -> (string, form) Binarymap.dict
val mk_forall = fn: string -> sort -> form -> form
val mk_fvar = fn: string -> term list -> form
val mk_imp = fn: form -> form -> form
val mk_inst = fn:
   ((string * sort) * term) list -> (string * form) list -> menv
val mk_menv = fn: vd -> fvd -> menv
val mk_neg = fn: form -> form
val mk_pred = fn: string -> term list -> form
val mk_pred0 = fn: string -> term list -> form
val mk_quant = fn: string -> string -> sort -> form -> form
val mk_uex = fn: string -> sort -> form -> form
val name_clash = fn: string -> menv -> bool
val ok_dpdc = fn: menv -> (string * sort) * term -> bool
val pmenv = fn: menv -> ((string * sort) * term) list * (string * form) list
val psymsf = fn: form -> string set
val ril = fn: form -> form list -> form list
val strip_all_quants0 = fn: form -> (string * sort) list * form
val strip_exists = fn: form -> form * (string * sort) list
val strip_forall = fn: form -> form * (string * sort) list
val strip_forall0 = fn: form -> form * (string * sort) list
val strip_quants = fn: form -> form * (string * sort) list
val strip_uex = fn: form -> form * (string * sort) list
val vd_of = fn: menv -> vd
val view_form = fn: form -> form_view
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holJXiIToScript.sml:1268: warning: Matches are not exhaustive.
Found near
  case f of
     Pred (P0, false, ...) => fVar_Inst_P bs pair f |
     Conn (co, ...) =>
     (let val ... in ... handle ... end handle _ => ... ...) |
     Conn (...) => Conn (...) |
     ... ... => raise ... |
     ... => ...
val fVar_Inst_P = fn:
   sort list -> string * ((string * sort) list * form) -> form -> form
val fVar_Inst_f = fn: string * ((string * sort) list * form) -> form -> form
val fVar_Inst_f0 = fn:
   sort list -> string * ((string * sort) list * form) -> form -> form
val pinst_f = fn: (string * sort, term) Binarymap.dict -> form -> form
val rename_bound = fn: string -> form -> form
val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = srt ("set", []): sort
val it = (): unit
> 
*** Emacs/HOL command completed ***

> # # # val bs = []: sort list
> # # # # val P = "P": string
val Q =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
# # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> 
*** Emacs/HOL command completed ***

> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("Q", false, [Bound 0]))): form
> # # val b =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0])): form
val n = "B": string
val s = srt ("set", []): sort
> # val it =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred ("Q", false, [Bound 0])): form
> # val it =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred ("Q", false, [Bound 0])): form
> # # val b1 = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
val n1 = "f": string
val s1 = srt ("fun", [Var ("A", srt ("set", [])), Bound 0]): sort
> # val it = Pred ("Q", false, [Bound 0]): form
> # val it = srt ("set", []): sort
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val it = srt ("fun", [Var ("A", srt ("set", [])), Bound 1]): sort
> # val it = srt ("fun", [Var ("A", srt ("set", [])), Bound 0]): sort
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val args0 = [Bound 1, Bound 0]: term list
> > > # # # # val lcs = HOLset{}: (string * sort) set
> > # val it =
   [Var ("X", srt ("set", [])), Var ("Y", srt ("set", [])),
    Var
     ("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   term list
> # val it = [Bound 1, Bound 0]: term list
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val args0 = [Var ("A", srt ("set", [])), Bound 1, Bound 0]: term list
> > # # val it = fn: vd -> vd
> > # # # Exception-
   HOL_ERR
     {message = "index too large", origin_function = "el", origin_structure =
      "Lib"} raised
> > # # # Exception-
   HOL_ERR
     {message = "index too large", origin_function = "el", origin_structure =
      "Lib"} raised
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("Q", false, [Bound 0]))): form
> # # # # # # # # # poly: : error: Type error in function application.
   Function: dest_forall0 f : (string * sort) * form
   Argument: fVar_Inst_f0 :
      sort list -> string * ((string * sort) list * form) -> form -> form
   Reason: Value being applied does not have a function type
Found near dest_forall0 f fVar_Inst_f0 [... ... s] pair b
poly: : error: Type error in function application.
   Function: dest_forall0 b : (string * sort) * form
   Argument: fVar_Inst_P :
      sort list -> string * ((string * sort) list * form) -> form -> form
   Reason: Value being applied does not have a function type
Found near dest_forall0 b fVar_Inst_P [... ... s1, ... ...] pair b1
Static Errors
> # val b =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0])): form
val n = "B": string
val s = srt ("set", []): sort
> # # val it =
   Quant
    ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
     Pred ("Q", false, [Bound 0])): form
> # val b1 = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
val n1 = "f": string
val s1 = srt ("fun", [Var ("A", srt ("set", [])), Bound 0]): sort
> # val it = Pred ("Q", false, [Bound 0]): form
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val bs =
   [srt ("fun", [Var ("A", srt ("set", [])), Bound 1]), srt ("set", [])]:
   sort list
val f = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # poly: : error: ) expected but as was found
poly: : error: ; expected but as was found
Static Errors
> # val it = Pred ("Q", false, [Bound 0]): form
> # val it =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
> # val it = Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]):
   form
> # val P0 = "P": string
val args0 = [Var ("A", srt ("set", [])), Bound 1, Bound 0]: term list
> > # # # val venv = ?: vd
> > # val it =
   [Var ("X", srt ("set", [])), Var ("Y", srt ("set", [])),
    Var
     ("f",
      srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   term list
> # val it = [Var ("A", srt ("set", [])), Bound 1, Bound 0]: term list
> # val it = Pred ("Q", false, [Bound 0]): form
> # val f =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]):
   form
val vd = ?: vd
> # # # val bs = []: sort list
> > # # # val P = "P": string
val Q =
   Quant
    ("!", "a", srt ("set", []),
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))])):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Quant
      ("!", "a", srt ("set", []),
       Pred
        ("Q", false,
         [Var
           ("f",
            srt
             ("fun",
              [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))])))):
   string * ((string * sort) list * form)
# # # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> 
*** Emacs/HOL command completed ***

> # val it =
   Quant
    ("!", "a", srt ("set", []),
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))])):
   form
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Quant ("!", "a", srt ("set", []), Pred ("Q", false, [Bound 1])))):
   form
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> # # val bs = []: sort list
> > # # val P = "P": string
val Q =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
# # # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> 
*** Emacs/HOL command completed ***

> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("Q", false, [Bound 0]))): form
> # val it =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> # # val bs = []: sort list
> > # # val P = "P": string
val Q =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]))):
   string * ((string * sort) list * form)
# # # # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> 
*** Emacs/HOL command completed ***

> # val it =
   Pred
    ("Q", false,
     [Var
       ("f",
        srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]):
   form
> # val it = ?: vd
> # val it = Pred ("Q", false, [Bound 0]): form
> # # # # val bs = []: sort list
> > # # # val P = "P": string
val Q =
   Quant
    ("!", "a", srt ("set", []),
     Pred
      ("Q", false,
       [Var
         ("f",
          srt
           ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))])):
   form
val argl =
   [("X", srt ("set", [])), ("Y", srt ("set", [])),
    ("f",
     srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))]:
   (string * sort) list
val pair =
   ("P",
    ([("X", srt ("set", [])), ("Y", srt ("set", [])),
      ("f",
       srt ("fun", [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))],
     Quant
      ("!", "a", srt ("set", []),
       Pred
        ("Q", false,
         [Var
           ("f",
            srt
             ("fun",
              [Var ("X", srt ("set", [])), Var ("Y", srt ("set", []))]))])))):
   string * ((string * sort) list * form)
# > 
*** Emacs/HOL command completed ***

> # # # # val f =
   Quant
    ("!", "B", srt ("set", []),
     Quant
      ("!", "f", srt ("fun", [Var ("A", srt ("set", [])), Bound 0]),
       Pred ("P", false, [Var ("A", srt ("set", [])), Bound 1, Bound 0]))):
   form
> # val it = Quant ("!", "a", srt ("set", []), Pred ("Q", false, [Bound 1])):
   form
> 
Process HOL finished

---------------------------------------------------------------------
       HOL-4 [Kananaskis 14 (stdknl, built Wed Oct 05 11:34:20 2022)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
** Load path (see loadPath variable) now contains 2 entries
** after consulting Holmakefiles

> > > > use "SEARmaster.ML";
Exception raised Io {cause = SysErr ("No such file or directory", SOME ENOENT), function = "TextIO.openIn", name = "SEARmaster.ML"}

Process HOL exited abnormally with code 1
> Loading empty hol-mode.sml
> > > use "SEARmaster.ML";
val use = fn: string -> unit
******

Loading SEAR file SEARsorts.sml

******
val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = set: sort
val it = (): unit
******

Loading SEAR file SEARnewspec.sml

******
val define_fsym = fn: string * (string * sort) list -> term -> thm
val define_fsym_lemma_fun =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : fun(A#, B#)).
        ?!(newfsym : fun(A#, B#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_mem =
   {}, 
   |- !(A : set)  (newfsym0 : mem(A#)).
        ?!(newfsym : mem(A#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_rel =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : rel(A#, B#)).
        ?!(newfsym : rel(A#, B#)). newfsym# = newfsym0#: thm
val funeqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : fun(A#, B#)). i# = i#) &
        (!(i : fun(A#, B#))  (i' : fun(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : fun(A#, B#))  (i' : fun(A#, B#))  (i'' : fun(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val memeqeqvth =
   {}, 
   |- !(A : set).
        (!(i : mem(A#)). i# = i#) &
        (!(i : mem(A#))  (i' : mem(A#)). i# = i'# ==> i'# = i#) &
        !(i : mem(A#))  (i' : mem(A#))  (i'' : mem(A#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val qdefine_fsym = fn: string * term frag list list -> term frag list -> thm
val qsimple_uex_spec = fn: string -> term frag list list -> thm -> thm
val quex_spec = fn: string -> term frag list list -> thm -> thm -> thm
val releqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : rel(A#, B#)). i# = i#) &
        (!(i : rel(A#, B#))  (i' : rel(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : rel(A#, B#))  (i' : rel(A#, B#))  (i'' : rel(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val simple_uex_spec = fn: string -> (string * sort) list -> thm -> thm
val uex_spec = fn: string -> (string * sort) list -> thm -> thm -> thm
val it = (): unit
******

Loading SEAR file SEARrel.sml

******
val AX1 =
   {}, 
   |- !(A : set)  (B : set).
        ?!(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val Fun_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=> !(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#): thm
val R_EXT =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        (!(a : mem(A#))  (b : mem(B#)).
            Holds(R1#, a#, b#) <=> Holds(R2#, a#, b#)) <=> R1# = R2#: thm
val AX1_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val ao_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, c#)) <=>
        Holds(psi# @ phi#, a#, c#): thm
val ao_def0 =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (b : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, b#)) <=>
        Holds(psi# @ phi#, a#, b#): thm
val ao_uex =
   {(A : set), (B : set), (C : set), (phi : rel(A, B)), (psi : rel(B, C))}, 
   |- ?!(R : rel(A, C)).
        !(a : mem(A))  (b : mem(C)).
          Holds(R#, a#, b#) <=>
          ?(b : mem(B)). Holds(phi, a#, b#) & Holds(psi, b#, b#): thm
val Fun_expand =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=>
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) &
        !(a : mem(A#))  (b1 : mem(B#))  (b2 : mem(B#)).
          Holds(R#, a#, b1#) & Holds(R#, a#, b2#) ==> b1# = b2#: thm
val id_Fun = {},  |- !(A : set). isFun(id(A#)): thm
val id_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)).
        Holds(id(A#), a#, b#) <=> a# = b#: thm
val id_uex =
   {(A : set)}, 
   |- ?!(R : rel(A, A)).
        !(a : mem(A))  (b : mem(A)). Holds(R#, a#, b#) <=> a# = b#: thm
val idL = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). id(B#) @ f# = f#:
   thm
val idR = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). f# @ id(A#) = f#:
   thm
val Thm_2_7_ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val Thm_2_7_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val Thm_2_7_id =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#)).
        phi# @ id(A#) = phi# & id(B#) @ phi# = phi#: thm
val op_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(B#))  (b : mem(A#)).
        Holds(op(R#), a#, b#) <=> Holds(R#, b#, a#): thm
val op_uex =
   {(A : set), (B : set), (R : rel(A, B))}, 
   |- ?!(R' : rel(B, A)).
        !(a : mem(B))  (b : mem(A)). Holds(R'#, a#, b#) <=> Holds(R, b#, a#):
   thm
val ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val ao_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val op_DISTR =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#)). op(psi# @ phi#) = op(phi#) @ op(psi#): thm
val Refl_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> !(a : mem(A#)). Holds(R#, a#, a#): thm
val Sym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> Holds(R#, a2#, a1#): thm
val Trans_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Trans(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#))  (a3 : mem(A#)).
          Holds(R#, a1#, a2#) & Holds(R#, a2#, a3#) ==> Holds(R#, a1#, a3#):
   thm
val ER_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) <=> Refl(R#) & Sym(R#) & Trans(R#): thm
val Sym_Trans_Rright =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) & Trans(R#) ==>
        !(x : mem(A#))  (y : mem(A#)).
          Holds(R#, x#, y#) ==>
          !(z : mem(A#)). Holds(R#, x#, z#) <=> Holds(R#, y#, z#): thm
val op_op =
   {},  |- !(A : set)  (B : set)  (R : rel(A#, B#)). op(op(R#)) = R#: thm
val it = (): unit
******

Loading SEAR file SEARfun.sml

******
val rel2fun =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val rel2fun_ex =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val rel2fun_ex' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val asR_Fun =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). isFun(asR(f#)): thm
val asR_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- !(a : mem(A))  (b : mem(B)). Holds(asR(f), a#, b#) <=> App(f, a#) = b#:
   thm
val asR_uex =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- ?!(R : rel(A, B)).
        !(a : mem(A))  (b : mem(B)). Holds(R#, a#, b#) <=> App(f, a#) = b#:
   thm
val FUN_EXT =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        (!(a : mem(A#)). App(f1#, a#) = App(f2#, a#)) <=> f1# = f2#: thm
val P2fun_uex =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val fun_tm_compr = fn: string * sort -> term -> thm
val fun_tm_compr_uex = fn: string * sort -> term -> thm
val qfun_compr = fn: term frag list -> term frag list -> thm
val unique_lemma =
   {},  |- !(A : set)  (a : mem(A#)). ?!(a' : mem(A#)). a'# = a#: thm
val App_Id = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_def = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_uex =
   {(A : set)}, 
   |- ?!(f : fun(A, A)).
        !(a : mem(A))  (b : mem(A)).
          App(f#, a#) = b# <=> Holds(id(A), a#, b#): thm
val o_ex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val o_uex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?!(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val Inj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) <=>
        !(x1 : mem(A#))  (x2 : mem(A#)).
          App(f#, x1#) = App(f#, x2#) ==> x1# = x2#: thm
val o_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        App(psi# o phi#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#):
   thm
val Surj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) <=> !(b : mem(B#)). ?(a : mem(A#)). App(f#, a#) = b#: thm
val Bij_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> Inj(f#) & Surj(f#): thm
val Bij_op =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> ?(f' : fun(B#, A#)). asR(f'#) = op(asR(f#)): thm
val App_App_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val App_o_l =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val asR_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        asR(g# o f#) = asR(g#) @ asR(f#): thm
val asR_Id = {},  |- !(A : set). asR(Id(A#)) = id(A#): thm
val asR_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        asR(f1#) = asR(f2#) <=> f1# = f2#: thm
val Thm_2_7_bij =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#)).
        Bij(phi#) <=>
        ?(psi : fun(B#, A#)). psi# o phi# = Id(A#) & phi# o psi# = Id(B#):
   thm
val Inj_lcancel =
   {}, 
   |- !(A : set)  (B : set)  (m : fun(A#, B#)).
        Inj(m#) ==>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, A#)).
          m# o f# = m# o g# ==> f# = g#: thm
val IdL = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Id(B#) o f# = f#:
   thm
val IdR = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). f# o Id(A#) = f#:
   thm
val Inj_lift_R_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(R : rel(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?!(a2 : mem(A#)). Holds(R#, App(i#, a1#), App(i#, a2#))) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). Holds(R#, App(i#, a#), App(i# o f#, a#)): thm
val Inj_lift_fun_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val asR_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        Holds(asR(f#), a#, b#) <=> App(f#, a#) = b#: thm
val Inj_lift_fun_lemma' =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?!(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val Inj_eq_eq =
   {}, 
   |- !(X : set)  (Y : set)  (i : fun(X#, Y#)).
        Inj(i#) ==>
        !(x1 : mem(X#))  (x2 : mem(X#)).
          App(i#, x1#) = App(i#, x2#) <=> x1# = x2#: thm
val Inj_lift_fun =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?(f : fun(X#, A#)). !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#):
   thm
val Inj_lift_fun_uex =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?!(f : fun(X#, A#)).
            !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#): thm
val o_assoc =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (D : set)  (h : fun(C#, D#)). (h# o g#) o f# = h# o g# o f#: thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val P2fun_uex0 =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val it = (): unit
******

Loading SEAR file SEARsetting.sml

******
val AX0 = {},  |- ?(A : set)  (a : mem(A#)). T: thm
val Tab_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) <=>
        (!(x : mem(A#))  (y : mem(B#)).
            Holds(R#, x#, y#) <=>
            ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val AX2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        ?(TR : set)  (p : fun(TR#, A#))  (q : fun(TR#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              Holds(R#, x#, y#) <=>
              ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
          !(r : mem(TR#))  (s : mem(TR#)).
            App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Empty_unique =
   {}, 
   |- !(E1 : set)  (E2 : set).
        (!(a : mem(E1#)). F) & (!(a : mem(E2#)). F) ==>
        ?(i : fun(E1#, E2#))  (j : fun(E2#, E1#)).
          i# o j# = Id(E2#) & j# o i# = Id(E1#): thm
val Thm_2_2 = {},  |- ?(Empty : set). !(a : mem(Empty#)). F: thm
val Thm_2_3 =
   {},  |- ?(ONE : set)  (x : mem(ONE#)). !(x' : mem(ONE#)). x'# = x#: thm
val unique_fun_to_ONE =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#)).
        (!(a : mem(ONE#)). a# = x#) ==> !(A : set). ?!(f : fun(A#, ONE#)). T:
   thm
val ONE_unique =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#))  (ONE' : set)  (x' : mem(ONE'#)).
        (!(a : mem(ONE#)). a# = x#) & (!(a : mem(ONE'#)). a# = x'#) ==>
        ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
          i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso0_REFL =
   {}, 
   |- !(A : set).
        ?(i : fun(A#, A#))  (j : fun(A#, A#)).
          i# o j# = Id(A#) & j# o i# = Id(A#): thm
val iso0_SYM =
   {}, 
   |- !(A : set)  (A' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
        ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
          i# o j# = Id(A#) & j# o i# = Id(A'#): thm
val iso0_TRANS =
   {}, 
   |- !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_uex =
   {}, 
   |- ?(ONE : set).
        (?(x : mem(ONE#)). !(a : mem(ONE#)). a# = x#) &
        !(ONE' : set).
          (?(x : mem(ONE'#)). !(a : mem(ONE'#)). a# = x#) ==>
          ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
            i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso_Reqv =
   {}, 
   |- (!(A : set).
          ?(i : fun(A#, A#))  (j : fun(A#, A#)).
            i# o j# = Id(A#) & j# o i# = Id(A#)) &
      (!(A : set)  (A' : set).
          (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
              i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
          ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
            i# o j# = Id(A#) & j# o i# = Id(A'#)) &
      !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_def = {},  |- ?(x : mem(1)). !(a : mem(1)). a# = x#: thm
val dot_uex = {},  |- ?!(x : mem(1)). x# = x#: thm
val dot_def = {},  |- !(a : mem(1)). a# = dot: thm
val dot_def0 = {},  |- dot = dot: thm
val ONE = 1: term
val Thm_2_3_5 = {},  |- !(A : set). ?!(f : rel(A#, 1)). isFun(f#): thm
val To1_ex = {},  |- !(A : set). ?!(f : fun(A#, 1)). T: thm
val dot = dot: term
val To1_uex = {},  |- !(A : set). ?!(f : fun(A#, 1)). f# = f#: thm
val To1_def = {},  |- !(A : set)  (f' : fun(A#, 1)). f'# = To1(A#): thm
val To1_def0 = {(A : set)},  |- To1(A) = To1(A): thm
val Thm_2_4_R_ver =
   {}, 
   |- !(A : set)  (R : rel(1, A#)).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)).
            Holds(R#, dot, a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Rel_Pred1 =
   {}, 
   |- !(A : set).
        ?!(R : rel(1, A#)). !(a : mem(A#)). Holds(R#, dot, a#) <=> P(a#): thm
val Tab_App_Rel =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (x : mem(A#))  (y : mem(B#)).
          App(p#, r#) = x# & App(q#, r#) = y# ==> Holds(R#, x#, y#): thm
val Thm_2_4 =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Tab_mem_R =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#)). Holds(R#, App(p#, r#), App(q#, r#)): thm
val Tab_prop1 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(x : mem(A#))  (y : mem(B#)).
          Holds(R#, x#, y#) <=>
          ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#: thm
val T_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(T0 : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(T0#, a#, b#): thm
val T_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          (!(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#)) &
          !(R' : rel(A#, B#)).
            (!(a : mem(A#))  (b : mem(B#)). Holds(R'#, a#, b#)) ==> R'# = R#:
   thm
val Tab_prop2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Thm_2_5 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (T1 : set)
      (p1 : fun(T1#, A#))  (q1 : fun(T1#, B#))  (T2 : set)
      (p2 : fun(T2#, A#))  (q2 : fun(T2#, B#)).
        isTab(R#, p1#, q1#) & isTab(R#, p2#, q2#) ==>
        ?(b : fun(T1#, T2#)). Bij(b#): thm
val isPair_def =
   {(A : set), (AxB : set), (B : set), (p1 : fun(AxB, A)), (p2 : fun(AxB, B))},
   
   |- isPair(p1, p2) <=>
      !(x : mem(A))  (y : mem(B)).
        ?!(r : mem(AxB)). App(p1, r#) = x# & App(p2, r#) = y#: thm
val isPair_uex =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (p1 : fun(AB#, A#))
      (p2 : fun(AB#, B#))  (AB' : set)  (p1' : fun(AB'#, A#))
      (p2' : fun(AB'#, B#)).
        isPair(p1#, p2#) & isPair(p1'#, p2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          p1'# o i# = p1# &
          p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AxB : set)  (p1 : fun(AxB#, A#))  (p2 : fun(AxB#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              ?(r : mem(AxB#)). App(p1#, r#) = x# & App(p2#, r#) = y#) &
          !(r : mem(AxB#))  (s : mem(AxB#)).
            App(p1#, r#) = App(p1#, s#) & App(p2#, r#) = App(p2#, s#) ==>
            r# = s#: thm
val Pr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)).
          isPair(p1#, p2#) &
          !(AB' : set)  (p1' : fun(AB'#, A#))  (p2' : fun(AB'#, B#)).
            isPair(p1'#, p2'#) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_p12_def =
   {},  |- !(A : set)  (B : set). isPair(p1(A#, B#), p2(A#, B#)): thm
val Pr_ts_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)). T: thm
val isPair_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            p1# o i# = p1# & p2# o i# = p2# & p1# o j# = p1# & p2# o j# = p2#) &
      (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
        (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            p1# o i# = p1'# &
            p2# o i# = p2'# & p1'# o j# = p1# & p2'# o j# = p2#) &
      !(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
      (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B))  (AB'' : set)
      (p1'' : fun(AB''#, A))  (p2'' : fun(AB''#, B)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            p1'# o i# = p1# &
            p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            p1''# o i# = p1'# &
            p2''# o i# = p2'# & p1'# o j# = p1''# & p2'# o j# = p2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          p1''# o i# = p1# &
          p2''# o i# = p2# & p1# o j# = p1''# & p2# o j# = p2''#: thm
val p2_def =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#))  (y : mem(B#)).
            ?(r : mem(A# * B#)).
              App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#) &
        !(r : mem(A# * B#))  (s : mem(A# * B#)).
          App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
          App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val SetPr_def =
   {}, 
   |- !(A : set)  (AB : set)  (p1 : fun(AB#, A#))  (B : set)
      (p2 : fun(AB#, B#)).
        SetPr(p1#, p2#) <=>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
          ?!(fg : fun(X#, AB#)). p1# o fg# = f# & p2# o fg# = g#: thm
val Cross = fn: term -> term -> term
val Pa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        (p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#) &
        !(fg' : fun(X#, A# * B#)).
          p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==>
          fg'# = Pa(f#, g#): thm
val Pa_def0 =
   {(A : set), (B : set), (X : set), (f : fun(X, A)), (g : fun(X, B))}, 
   |- p1(A, B) o Pa(f, g) = f & p2(A, B) o Pa(f, g) = g: thm
val Thm_2_8_SetPr =
   {},  |- !(A : set)  (B : set). SetPr(p1(A#, B#), p2(A#, B#)): thm
val p12_of_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#: thm
val p1_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f#: thm
val p2_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p2(A#, B#) o Pa(f#, g#) = g#: thm
val is_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (fg' : fun(X#, A# * B#)).
        p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==> fg'# = Pa(f#, g#):
   thm
val AX3 =
   {}, 
   |- !(A : set).
        ?(PA : set)  (e : rel(A#, PA#)).
          !(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#): thm
val Pow_uex =
   {(A : set)}, 
   |- ?(PA : set)  (e : rel(A, PA#)).
        (!(S0 : rel(1, A)).
            ?!(s : mem(PA#)).
              !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        !(PA' : set)  (e' : rel(A, PA'#)).
          (!(S0 : rel(1, A)).
              ?!(s : mem(PA'#)).
                !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
          ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val Pow_unique =
   {}, 
   |- !(A : set)  (PA : set)  (e : rel(A#, PA#))  (PA' : set)
      (e' : rel(A#, PA'#)).
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA'#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
        ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
          i# o j# = Id(PA'#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val SetEz_def =
   {(A : set), (B : set), (E : set), (e : fun(E, A)), (f : fun(A, B)),
    (g : fun(A, B))}, 
   |- SetEz(f, g, e) <=>
      !(X : set)  (x : fun(X#, A)).
        f o x# = g o x# ==> ?!(x0 : fun(X#, E)). x# = e o x0#: thm
val Thm_2_10 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(M : set)  (e : fun(A#, M#))  (m : fun(M#, B#)).
          f# = m# o e# & Surj(e#) & Inj(m#): thm
val Thm_2_9_Eqlz =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
        ?(E : set)  (e : fun(E#, A#)). SetEz(f#, g#, e#): thm
val BC0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))).
        Holds(BC0(f#), a#, b#) <=>
        !(z : mem(Z#)).
          Holds(In(Z#), z#, b#) <=> Holds(In(Y#), App(f#, z#), a#): thm
val Pow = fn: term -> term
val Pow_REFL =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#)).
        ?(i : fun(PA#, PA#))  (j : fun(PA#, PA#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e# & asR(j#) @ e# = e#: thm
val Pow_SYM =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) ==>
        ?(i : fun(PA'#, PA#))  (j : fun(PA#, PA'#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA'#) & asR(i#) @ e'# = e# & asR(j#) @ e# = e'#: thm
val Pow_TRANS =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#))
      (PA'' : set)  (e'' : rel(A, PA''#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) &
        (?(i : fun(PA'#, PA''#))  (j : fun(PA''#, PA'#)).
            i# o j# = Id(PA''#) &
            j# o i# = Id(PA'#) & asR(i#) @ e'# = e''# & asR(j#) @ e''# = e'#) ==>
        ?(i : fun(PA#, PA''#))  (j : fun(PA''#, PA#)).
          i# o j# = Id(PA''#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e''# & asR(j#) @ e''# = e#: thm
val Pow_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val All0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(All0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, a#): thm
val All0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(All0(f#)): thm
val BC0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(BC0(f#)): thm
val Ex0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(Ex0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          ?(z : mem(Z#)). Holds(In(Z#), z#, a#) & App(f#, z#) = y#: thm
val Ex0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(Ex0(f#)): thm
val In_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). Holds(In(A#), x#, s1#) <=> Holds(In(A#), x#, s2#)) ==>
        s1# = s2#: thm
val In_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val In_def_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (s0 : fun(A0#, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)).
            (?(a0 : mem(A0#)). x# = App(s0#, a0#)) <=> Holds(In(A#), x#, s#):
   thm
val In_def_P =
   {}, 
   |- !(A : set).
        ?!(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> Holds(In(A#), a#, s#):
   thm
val PO_def =
   {}, 
   |- !(A : set)  (S1 : mem(Pow(A#)))  (S2 : mem(Pow(A#))).
        PO(S1#, S2#) <=>
        !(a : mem(A#)). Holds(In(A#), a#, S1#) ==> Holds(In(A#), a#, S2#):
   thm
val BC_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))). App(BC(f#), a#) = b# <=> Holds(BC0(f#), a#, b#):
   thm
val In_App_BC =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (z : mem(Z#))
      (ys : mem(Pow(Y#))).
        Holds(In(Z#), z#, App(BC(f#), ys#)) <=>
        Holds(In(Y#), App(f#, z#), ys#): thm
val Ex_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(Ex(f#), a#) = b# <=> Holds(Ex0(f#), a#, b#):
   thm
val In_App_Ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(Ex(f#), zs#)) <=>
        ?(z : mem(Z#)). Holds(In(Z#), z#, zs#) & App(f#, z#) = y#: thm
val All_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(All(f#), a#) = b# <=> Holds(All0(f#), a#, b#):
   thm
val In_App_All =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(All(f#), zs#)) <=>
        !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, zs#): thm
val Thm_2_11_SEx_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (zs : mem(Pow(Z#)))
      (ys : mem(Pow(Y#))).
        PO(App(Ex(f#), zs#), ys#) <=> PO(zs#, App(BC(f#), ys#)): thm
val Thm_2_11_SAll_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (ys : mem(Pow(Y#)))
      (zs : mem(Pow(Z#))).
        PO(App(BC(f#), ys#), zs#) <=> PO(ys#, App(All(f#), zs#)): thm
val Sub_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, R2#) <=>
        !(a : mem(A#))  (b : mem(B#)).
          Holds(R1#, a#, b#) ==> Holds(R2#, a#, b#): thm
val Meet_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Meet(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) & Holds(R2#, a#, b#): thm
val Sub_Meet =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(Meet(R1#, R2#), R1#) &
        Sub(Meet(R1#, R2#), R2#) &
        !(R0 : rel(A#, B#)).
          Sub(R0#, R1#) & Sub(R0#, R2#) ==> Sub(R0#, Meet(R1#, R2#)): thm
val Join_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Join(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) | Holds(R2#, a#, b#): thm
val Sub_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, Join(R1#, R2#)) &
        Sub(R2#, Join(R1#, R2#)) &
        !(R0 : rel(A#, B#)).
          Sub(R1#, R0#) & Sub(R2#, R0#) ==> Sub(Join(R1#, R2#), R0#): thm
val MODULAR_LAW =
   {}, 
   |- !(x : set)  (y : set)  (phi : rel(x#, y#))  (z : set)
      (psi : rel(y#, z#))  (chi : rel(x#, z#)).
        Sub(Meet(psi# @ phi#, chi#), psi# @ Meet(phi#, op(psi#) @ chi#)): thm
val left_o_pres_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (C : set)  (R : rel(B#, C#)).
        R# @ Join(R1#, R2#) = Join(R# @ R1#, R# @ R2#): thm
val right_o_pres_Join =
   {(C : set)}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (R : rel(C, A#)). Join(R1#, R2#) @ R# = Join(R1# @ R#, R2# @ R#): thm
val Div_ex =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (C : set)  (s : rel(A#, C#)).
        ?(sdr : rel(B#, C#)).
          !(t : rel(B#, C#)). Sub(t#, sdr#) <=> Sub(t# @ r#, s#): thm
val MF_def = {},  |- !(A : set)  (a : mem(A#)). App(MF(a#), dot) = a#: thm
val Pair_uex =
   {}, 
   |- !(A : set)  (B : set)  (x : mem(A#))  (y : mem(B#)).
        ?!(r : mem(A# * B#)).
          App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#: thm
val Thm_2_12 =
   {}, 
   |- !(B : set)  (A : set)  (R : rel(B#, A#)).
        ?!(fR : fun(B#, Pow(A#))).
          !(y : mem(B#))  (x : mem(A#)).
            Holds(R#, y#, x#) <=> Holds(In(A#), x#, App(fR#, y#)): thm
val Thm_2_3_5_el =
   {},  |- !(A : set)  (a : mem(A#)). ?!(R : fun(1, A#)). App(R#, dot) = a#:
   thm
val Pair_App_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val Pair_def =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val Pair_component =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)).
        Pair(App(p1(A#, B#), r#), App(p2(A#, B#), r#)) = r#: thm
val Pair_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
      (b2 : mem(B#)).
        Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#: thm
val Pair_p12 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        Pair(App(p1(A#, B#), ab#), App(p2(A#, B#), ab#)) = ab#: thm
val Ap1_def =
   {}, 
   |- !(A : set)  (X : set)  (x : mem(X#))  (B : set)  (f : fun(A# * X#, B#))
      (a : mem(A#)). App(Ap1(f#, x#), a#) = App(f#, Pair(a#, x#)): thm
val Ap1_uex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#))
      (x : mem(X#)).
        ?!(fx : fun(A#, B#)).
          !(a : mem(A#)). App(fx#, a#) = App(f#, Pair(a#, x#)): thm
val Cross_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val App_Pa =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (D : set)
      (g : fun(B#, D#))  (ab : mem(A# * B#)).
        App(Pa(f# o p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(f# o p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_o_p2 =
   {}, 
   |- !(B : set)  (C : set)  (f : fun(B#, C#))  (A : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p2(A#, B#), Pair(a#, b#)) = App(f#, b#): thm
val App_o_p1 =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p1(A#, B#), Pair(a#, b#)) = App(f#, a#): thm
val Fst_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p1(A, B), x) = Fst(x):
   thm
val Pair_def' =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#: thm
val Snd_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p2(A, B), x) = Snd(x):
   thm
val Pair_Fst_Snd =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)). Pair(Fst(r#), Snd(r#)) = r#:
   thm
val Pair_has_comp =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#): thm
val p12_of_Pair =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val dest_cross = fn: term -> term * term
val basic_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_fconv = fn: form -> thm
val mk_Pair = fn: term -> term -> term
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val Prla_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (D : set)
      (g : fun(C#, D#)). Prla(f#, g#) = Pa(f# o p1(A#, C#), g# o p2(A#, C#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Exp_ev_unique =
   {}, 
   |- !(A : set)  (B : set)  (A2B : set)  (ev : fun(A# * A2B#, B#))
      (A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B'#)).
              !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
        ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
          i# o j# = Id(A2B'#) &
          j# o i# = Id(A2B#) &
          ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#: thm
val Exp_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#): thm
val Exp_ex_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          (!(f : fun(A#, B#)).
              ?!(sf : mem(A2B#)).
                !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
          !(A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
            (!(f : fun(A#, B#)).
                ?!(sf : mem(A2B'#)).
                  !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
            ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
              i# o j# = Id(A2B'#) &
              j# o i# = Id(A2B#) &
              ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#:
   thm
val Thm_2_13 =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A2B# * A#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(sf#, a#)) = App(f#, a#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Ev_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_uex_refl =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B)).
        ?(i : fun(A2B#, A2B#))  (j : fun(A2B#, A2B#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B#) &
          ev# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_sym =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) ==>
        ?(i : fun(A2B'#, A2B#))  (j : fun(A2B#, A2B'#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B'#) &
          ev# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_trans =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B))  (A2B'' : set)  (ev'' : fun(A * A2B''#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) &
        (?(i : fun(A2B'#, A2B''#))  (j : fun(A2B''#, A2B'#)).
            i# o j# = Id(A2B''#) &
            j# o i# = Id(A2B'#) &
            ev''# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev''#) ==>
        ?(i : fun(A2B#, A2B''#))  (j : fun(A2B''#, A2B#)).
          i# o j# = Id(A2B''#) &
          j# o i# = Id(A2B#) &
          ev''# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev''#: thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val Tpm_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
        !(sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#): thm
val Tpm_def0 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#): thm
val is_Tpm =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sf' : mem(Exp(A#, B#))).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
        sf'# = Tpm(f#): thm
val Tp_def0 =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f: thm
val Tp_ex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#)).
        ?!(h : fun(X#, Exp(A#, B#))).
          Ev(A#, B#) o Pa(p1(A#, X#), h# o p2(A#, X#)) = f#: thm
val Tp_def =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f &
      !(h' : fun(X, Exp(A, B))).
        Ev(A, B) o Pa(p1(A, X), h'# o p2(A, X)) = f ==> h'# = Tp(f): thm
val is_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (h' : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), h'# o p2(A#, X#)) = f# ==> h'# = Tp(f#):
   thm
val Thm_2_14 =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        ?(B : set)  (q : fun(A#, B#)).
          Surj(q#) &
          !(x : mem(A#))  (y : mem(A#)).
            Holds(R#, x#, y#) <=> App(q#, x#) = App(q#, y#): thm
val IN_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#))).
        IN(a#, ss#) <=> Holds(In(A#), a#, ss#): thm
val IN_def_P_expand =
   {}, 
   |- !(A : set).
        ?(s : mem(Pow(A#))).
          (!(a : mem(A#)). P(a#) <=> IN(a#, s#)) &
          !(s' : mem(Pow(A#))).
            (!(a : mem(A#)). P(a#) <=> IN(a#, s'#)) ==> s'# = s#: thm
val IN_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) ==> s1# = s2#: thm
val SS_def =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) <=> !(a : mem(A#)). IN(a#, P1#) ==> IN(a#, P2#): thm
val SS_Trans =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) ==> !(P3 : mem(Pow(A#))). SS(P2#, P3#) ==> SS(P1#, P3#):
   thm
val SS_SS_eq =
   {}, 
   |- !(A : set)  (p1 : mem(Pow(A#)))  (p2 : mem(Pow(A#))).
        SS(p1#, p2#) & SS(p2#, p1#) ==> p1# = p2#: thm
val IN_def_P_ex =
   {}, 
   |- !(A : set). ?(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> IN(a#, s#):
   thm
val IN_def_P =
   {}, 
   |- !(A : set). ?!(s : mem(Pow(A#))). !(a : mem(A#)). IN(a#, s#) <=> P(a#):
   thm
val AX4 =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set).
        ?!(BI : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BI#, sss#)) <=>
            !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val BI_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BI(A#), sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val N0 = N0: term
val N0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val O0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val S0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_def =
   {(A : set), (sss : mem(Pow(Pow(A))))},  |- App(BI(A), sss) = BIGINTER(sss):
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        ?(isss : mem(Pow(A#))). App(BI(A#), sss#) = isss#: thm
val IN_BIGINTER =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGINTER(sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
******

Loading SEAR file SEARreln.sml

******
val mk_App = fn: term -> term -> term
SEARreln.sml:75: warning: Matches are not exhaustive.
Found near
  case (view_form ante, view_form conseq) of
     (vConn ("&", ...), vConn (...)) =>
     let val ip1 = ... ...; val ... = ... in conj_monotone ip1 ip2 end |
     (vConn (...), ... ...) => let val ... = ...; val ... in ... ... ip2 end
     |
     (... ..., ...) => let val ... in ... ... end |
     (...) => let ... in ... end
SEARreln.sml:247: warning: Pattern is not exhaustive.
Found near
  val [fnterm, LFP] = fLFP |> #3 o dest_fun handle _ => raise ... ...
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
val conj_monotone = fn: thm -> thm -> thm
val disj_monotone = fn: thm -> thm -> thm
val exists_monotone = fn: thm -> thm
val forall_monotone = fn: thm -> thm
val imp_induce = fn: thm -> form -> thm
val mk_LFP = fn: term -> thm
val mk_Pow = fn: term -> term
val mk_SS = fn: thm -> thm -> thm
val mk_cases = fn: thm -> thm -> thm -> thm
val mk_cond = fn: thm -> thm -> thm
val mk_fdef = fn: string -> thm -> thm
val mk_fex = fn: form -> string -> thm
val mk_ind = fn: thm -> thm
val mk_ind1 = fn: thm -> thm -> thm
val mk_monotone = fn: thm -> thm
val mk_prim = fn: thm -> thm
val mk_rules = fn: thm -> thm -> thm -> thm
val trivial_imp = fn: form -> thm
val PULL_CONJ = fn: (form -> bool) -> form -> thm option
val conj_assoc_fconv = fn: form -> thm
val conj_cossa_fconv = fn: form -> thm
val conj_swap_fconv = fn: form -> thm
val disj_imp_distr_fconv = fn: form -> thm
val exists_eq_fconv = fn: form -> thm
val forall_conj_split_fconv = fn: form -> thm
val forall_eq_fconv = fn: form -> thm
val mk_case1 = fn: thm -> thm -> thm
val mk_rules1 = fn: thm -> thm -> thm
val mk_rules2 = fn: thm -> thm
val pull_conj_fconv = fn: (form -> bool) -> form -> thm
val pull_exists_fconv1 = fn: form -> thm
SEARreln.sml:599: warning: Pattern is not exhaustive.
Found near val [qv, newtm] = conc |> dest_pred |> #2
val conj_imp_fconv = fn: form -> thm
val disj_imp_undistr_fconv = fn: form -> thm
val forall_in_eq_fconv = fn: form -> thm
val mk_incond = fn: form -> form * string
val mk_ind2 = fn: thm -> thm
val mk_rules3 = fn: thm -> thm
val remove_list_item = fn: ''a -> ''a list -> ''a list
val unpull_exists_fconv1 = fn: form -> thm
val it = (): unit
val inN's_def =
   {},  |- !(a : mem(Pow(N0))). IN(a#, inN's) <=> SS(App(inNf, a#), a#): thm
val inN_cases0 = {},  |- App(inNf, inNs) = inNs: thm
val inN_cases1 =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_incond =
   !(n : mem(N0)).
     IN(n#, inN1) <=>
     n# = O0 | ?(n0 : mem(N0)). IN(n0#, inN0) & n# = App(S0, n0#): form
val inN_ind =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_ind0 =
   {},  |- !(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> SS(inNs, ss#):
   thm
val inN_ind1 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        (!(a : mem(N0)).
            a# = O0 | (?(n0 : mem(N0)). IN(n0#, ss#) & a# = App(S0, n0#)) ==>
            IN(a#, ss#)) ==> !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#):
   thm
val inN_ind2 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_rules0 = {},  |- SS(App(inNf, inNs), inNs): thm
val inN_rules1 =
   {}, 
   |- !(a : mem(N0)).
        a# = O0 | (?(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#)) ==>
        IN(a#, inNs): thm
val inN_rules2 =
   {}, 
   |- !(a : mem(N0)).
        (a# = O0 ==> IN(a#, inNs)) &
        !(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#) ==> IN(a#, inNs):
   thm
val inN_rules3 =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val inNf_def =
   {}, 
   |- !(a : mem(Pow(N0)))  (n : mem(N0)).
        IN(n#, App(inNf, a#)) <=>
        n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_ex =
   {}, 
   |- ?!(f : fun(Pow(N0), Pow(N0))).
        !(a : mem(Pow(N0)))  (n : mem(N0)).
          IN(n#, App(f#, a#)) <=>
          n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_monotone =
   {}, 
   |- !(s1 : mem(Pow(N0)))  (s2 : mem(Pow(N0))).
        SS(s1#, s2#) ==> SS(App(inNf, s1#), App(inNf, s2#)): thm
val inNs_SS =
   {},  |- !(a : mem(Pow(N0))). SS(App(inNf, a#), a#) ==> SS(inNs, a#): thm
val inNs_cond =
   {}, 
   |- !(a : mem(N0)).
        (!(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, inNs): thm
val inNs_def = {},  |- inNs = BIGINTER(inN's): thm
val x1 = "inN0": string
val inN_cases =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_rules =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val N_def =
   {}, 
   |- Inj(iN) &
      !(a : mem(N0)). IN(a#, inNs) <=> ?(b : mem(N)). a# = App(iN, b#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val iN_Inj = {},  |- Inj(iN): thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val iN_inNs = {},  |- !(n : mem(N)). IN(App(iN, n#), inNs): thm
val SUC_ex_lemma =
   {},  |- !(n1 : mem(N)). ?(b : mem(N)). App(S0 o iN, n1#) = App(iN, b#):
   thm
val SUC_def = {},  |- !(a : mem(N)). App(iN o SUC, a#) = App(S0 o iN, a#):
   thm
val iN_eq_eq =
   {}, 
   |- !(x1 : mem(N))  (x2 : mem(N)).
        App(iN, x1#) = App(iN, x2#) ==> x1# = x2#: thm
val O_def = {},  |- O0 = App(iN, O): thm
val iN_ex_uex =
   {}, 
   |- !(b : mem(N0)).
        (?(a : mem(N)). App(iN, a#) = b#) <=>
        ?!(a : mem(N)). App(iN, a#) = b#: thm
val S0_eq_eq =
   {}, 
   |- !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) ==> n# = m#:
   thm
val SUC_Inj = {},  |- Inj(SUC): thm
val iN_O = {},  |- !(n : mem(N)). App(iN, n#) = O0 <=> n# = O: thm
val SUC_NONZERO = {},  |- !(n : mem(N)). ~App(SUC, n#) = O: thm
val Image_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(im : fun(Pow(A#), Pow(B#))).
          !(sa : mem(Pow(A#)))  (b : mem(B#)).
            IN(b#, App(im#, sa#)) <=>
            ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val Image_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sa : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Image(f#), sa#)) <=>
        ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val IMAGE_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (b : mem(B#)).
        IN(b#, IMAGE(f#, s0#)) <=>
        ?(a : mem(A#)). IN(a#, s0#) & b# = App(f#, a#): thm
val IMAGE_def0 =
   {(A : set), (B : set), (f : fun(A, B)), (s0 : mem(Pow(A)))}, 
   |- IMAGE(f, s0) = App(Image(f), s0): thm
val Whole_def = {},  |- !(A : set)  (a : mem(A#)). IN(a#, Whole(A#)): thm
val IN_IMAGE_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(s : mem(Pow(A#)))  (a : mem(A#)).
          IN(a#, s#) <=> IN(App(i#, a#), IMAGE(i#, s#)): thm
val N_ind_P =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(App(SUC, n#))) ==>
      !(n : mem(N)). P(n#): thm
val O_xor_SUC =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = App(SUC, pn#): thm
val SUC_eq_eq =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)).
        App(SUC, n1#) = App(SUC, n2#) <=> n1# = n2#: thm
val Suc_def = {},  |- !(n : mem(N)). Suc(n#) = App(SUC, n#): thm
val O_xor_Suc =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = Suc(pn#): thm
val Suc_eq_eq =
   {},  |- !(n1 : mem(N))  (n2 : mem(N)). Suc(n1#) = Suc(n2#) <=> n1# = n2#:
   thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val N_induct =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Eqv_def =
   {},  |- !(A : set)  (B : set). Eqv(A#, B#) <=> ?(f : fun(A#, B#)). Bij(f#):
   thm
val Asset_def =
   {}, 
   |- !(B : set)  (bs : mem(Pow(B#)))  (B0 : set).
        Asset(bs#, B0#) <=>
        !(B1 : set)  (i : fun(B1#, B#)).
          Inj(i#) &
          (!(b : mem(B#)).
              (?(b0 : mem(B1#)). App(i#, b0#) = b#) <=> IN(b#, bs#)) ==>
          Eqv(B0#, B1#): thm
val Sg_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (a0 : mem(A#)).
        IN(a0#, App(Sg(A#), a#)) <=> a0# = a#: thm
val Sing_def = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Empty_def = {},  |- !(X : set)  (a : mem(X#)). ~IN(a#, Empty(X#)): thm
val Sing_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Sing(a1#) = Sing(a2#) <=> a1# = a2#: thm
val Sing_NONEMPTY = {},  |- !(A : set)  (a : mem(A#)). ~Sing(a#) = Empty(A#):
   thm
val iscoPr_def =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (i1 : fun(A#, AB#))
      (i2 : fun(B#, AB#)).
        iscoPr(i1#, i2#) <=>
        !(X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
          ?!(fg : fun(AB#, X#)). fg# o i1# = f# & fg# o i2# = g#: thm
val tof_def =
   {(A : set), (B : set), (f0 : mem(Exp(A, B)))}, 
   |- !(a : mem(A)). App(Ev(A, B), Pair(a#, f0)) = App(tof(f0), a#): thm
val coPr_unique =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        iscoPr(i1#, i2#) & iscoPr(i1'#, i2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          j# o i1'# = i1# &
          j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val iscoPr_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          iscoPr(i1#, i2#) &
          Inj(i1#) &
          Inj(i2#) &
          (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
          !(ab : mem(AB#)).
            (?(a : mem(A#)). ab# = App(i1#, a#)) |
            ?(b : mem(B#)). ab# = App(i2#, b#): thm
val coPr_REFL =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
        ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB#) &
          j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#:
   thm
val coPr_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#) &
      (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
        (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            j# o i1# = i1'# &
            j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#) &
      !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_SYM =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
        ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB'#) &
          j# o i1# = i1'# &
          j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#: thm
val coPr_TRANS =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          (iscoPr(i1#, i2#) &
            Inj(i1#) &
            Inj(i2#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
            !(ab : mem(AB#)).
              (?(a : mem(A#)). ab# = App(i1#, a#)) |
              ?(b : mem(B#)). ab# = App(i2#, b#)) &
          !(AB' : set)  (i1' : fun(A#, AB'#))  (i2' : fun(B#, AB'#)).
            iscoPr(i1'#, i2'#) &
            Inj(i1'#) &
            Inj(i2'#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1'#, a#) = App(i2'#, b#)) &
            (!(ab : mem(AB'#)).
                (?(a : mem(A#)). ab# = App(i1'#, a#)) |
                ?(b : mem(B#)). ab# = App(i2'#, b#)) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val coPo_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i2_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val coPa_def0 =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#: thm
val coPa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        (coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#) &
        !(fg' : fun(A# + B#, X#)).
          fg'# o i1(A#, B#) = f# & fg'# o i2(A#, B#) = g# ==>
          fg'# = coPa(f#, g#): thm
val i1_Inj = {},  |- !(A : set)  (B : set). Inj(i1(A#, B#)): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val i1_or_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
        ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_xor_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) <=>
        ?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#): thm
val i2_xor_i1 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#)) <=>
        ?(a : mem(A#)). ab# = App(i1(A#, B#), a#): thm
val it = (): unit
******

Loading SEAR file SEARpred_set.sml

******
val tof_Tpm_inv =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). tof(Tpm(f#)) = f#: thm
val Tpm_tof_inv =
   {},  |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#))). Tpm(tof(f#)) = f#:
   thm
val Tpm_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        Tpm(f1#) = Tpm(f2#) <=> f1# = f2#: thm
val tof_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (g : mem(Exp(A#, B#))).
        tof(f#) = tof(g#) <=> f# = g#: thm
val IN_Sing =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)).
        IN(a#, Sing(a0#)) <=> a# = a0#: thm
val BU_ex =
   {}, 
   |- !(A : set).
        ?!(BU : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BU#, sss#)) <=>
            ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val EMPTY_def = {(A : set)},  |- EMPTY(A) <=> !(x : mem(A)). F: thm
val BU_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BU(A#), sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val BIGUNION_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        BIGUNION(sss#) = App(BU(A#), sss#): thm
val IN_BIGUNION =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGUNION(sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val IMAGE_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (s : mem(Pow(A#))). IMAGE(g# o f#, s#) = IMAGE(g#, IMAGE(f#, s#)): thm
val ex_eq_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#))).
        (!(b : mem(B#)). IN(b#, s#) ==> ?(a : mem(A#)). b# = App(f#, a#)) ==>
        ?(s0 : mem(Pow(A#))). s# = IMAGE(f#, s0#): thm
val App_IN_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))
      (a : mem(A#)). IN(a#, s#) ==> IN(App(f#, a#), IMAGE(f#, s#)): thm
val IMAGE_BIGUNION =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(Pow(A#)))).
        IMAGE(f#, BIGUNION(ss#)) = BIGUNION(IMAGE(Image(f#), ss#)): thm
val Prla_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(C : set)  (D : set)  (g : fun(C#, D#)).
          Inj(g#) ==> Inj(Prla(f#, g#)): thm
val Id_Inj = {},  |- !(X : set). Inj(Id(X#)): thm
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Pa_distr =
   {}, 
   |- !(A : set)  (X : set)  (a1 : fun(X#, A#))  (B : set)
      (a2 : fun(X#, B#))  (X0 : set)  (x : fun(X0#, X#)).
        Pa(a1#, a2#) o x# = Pa(a1# o x#, a2# o x#): thm
val Pa_eq_eq =
   {}, 
   |- !(A : set)  (X : set)  (f1 : fun(X#, A#))  (f2 : fun(X#, A#))
      (B : set)  (g1 : fun(X#, B#))  (g2 : fun(X#, B#)).
        Pa(f1#, g1#) = Pa(f2#, g2#) <=> f1# = f2# & g1# = g2#: thm
val p2_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(B#, C#)).
        f# o p2(A#, B#) = p2(A#, C#) o Prla(Id(A#), f#): thm
val p1_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(A#, C#)).
        f# o p1(A#, B#) = p1(C#, B#) o Prla(f#, Id(B#)): thm
val p1_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#)). p1(X#, Y#) o Prla(f#, g#) = f# o p1(A#, B#): thm
val IMAGE_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#))  (x : mem(X#))  (y : mem(Y#))
      (s : mem(Pow(A# * B#))).
        IN(Pair(x#, y#), IMAGE(Prla(f#, g#), s#)) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          IN(Pair(a#, b#), s#) & x# = App(f#, a#) & y# = App(g#, b#): thm
val exists_cross_fconv = fn: form -> thm
val Image_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        App(Image(f#), s#) = IMAGE(f#, s#): thm
val IMAGE_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        IMAGE(f#, Empty(A#)) = Empty(B#): thm
val IN_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        (?(a : mem(A#)). IN(a#, s#)) <=> ~s# = Empty(A#): thm
val IMAGE_Empty_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val BIGUNION_Empty_Empty =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        BIGUNION(ss#) = Empty(A#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val BIGUNION_NONEMPTY =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        ~BIGUNION(ss#) = Empty(A#) <=>
        ?(s : mem(Pow(A#))). IN(s#, ss#) & ~s# = Empty(A#): thm
val BIGUNION_Empty_Empty' =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        Empty(A#) = BIGUNION(ss#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val INTER_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(INTER(A), Pair(a'#, b#))) <=> IN(a#, a'#) & IN(a#, b#):
   thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Inter_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Inter(s1, s2) = App(INTER(A), Pair(s1, s2)): thm
val UNION_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(UNION(A), Pair(a'#, b#))) <=> IN(a#, a'#) | IN(a#, b#):
   thm
val COMPL_def =
   {(A : set)}, 
   |- !(a : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(COMPL(A), a#)) <=> ~IN(a#, a#): thm
val Compl_def =
   {(A : set), (s : mem(Pow(A)))},  |- Compl(s) = App(COMPL(A), s): thm
val IN_Compl =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Compl(s#)) <=> ~IN(a#, s#): thm
val IN_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Union(s1#, s2#)) <=> IN(a#, s1#) | IN(a#, s2#): thm
val Union_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Union(s1, s2) = App(UNION(A), Pair(s1, s2)): thm
val m2r_def =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (od : mem(Pow(A# * A#))).
        Holds(m2r(od#), a1#, a2#) <=> IN(Pair(a1#, a2#), od#): thm
val r2m_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(Pair(a1#, a2#), r2m(R#)) <=> Holds(R#, a1#, a2#): thm
val Union_Empty_Empty =
   {},  |- !(A : set). Union(Empty(A#), Empty(A#)) = Empty(A#): thm
val SS_Refl = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(s#, s#): thm
val NONE_def = {(X : set)},  |- NONE(X) = App(i2(X, 1), dot): thm
val Null_def =
   {},  |- !(X : set)  (n : mem(N)). App(Null(X#), n#) = App(i2(X#, 1), dot):
   thm
val PREIM_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#)))
      (a : mem(A#)).
        IN(a#, PREIM(f#, s#)) <=>
        ?(b : mem(B#)). IN(b#, s#) & App(f#, a#) = b#: thm
val SOME_def =
   {},  |- !(A : set)  (a : mem(A#)). SOME(a#) = App(i1(A#, 1), a#): thm
val Surj_Epi =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) ==>
        !(C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
          g1# o f# = g2# o f# ==> g1# = g2#: thm
val false_def = {},  |- false = App(i1(1, 1), dot): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val true_def = {},  |- true = App(i2(1, 1), dot): thm
val true_ne_false = {},  |- ~true = false: thm
val true_or_false = {},  |- !(tv : mem(1 + 1)). tv# = true | tv# = false: thm
val true_xor_false = {},  |- !(tv : mem(1 + 1)). ~tv# = true <=> tv# = false:
   thm
val false_xor_true = {},  |- !(tv : mem(1 + 1)). ~tv# = false <=> tv# = true:
   thm
val tv_eq_true =
   {}, 
   |- !(tv1 : mem(1 + 1))  (tv2 : mem(1 + 1)).
        tv1# = tv2# <=> tv1# = true <=> tv2# = true: thm
val tf_eq_true =
   {}, 
   |- !(A : set)  (tf1 : fun(A#, 1 + 1))  (tf2 : fun(A#, 1 + 1)).
        tf1# = tf2# <=>
        !(a : mem(A#)). App(tf1#, a#) = true <=> App(tf2#, a#) = true: thm
val basic_fconv_tac = fn: conv -> fconv -> tactic
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
******

Loading SEAR file lambda.sml

******
val TAUT = {},  |- A | ~A: thm
val cond_unique_lemma =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b# = b'#: thm
val cond_unique_lemma' =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b'# = b#: thm
val conj1 = fn: form -> form
val conj2 = fn: form -> form
val conjIs = fn: thm list -> thm
val disj1 = fn: form -> form
val disj2 = fn: form -> form
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val disj_neg_absorb = {},  |- A | ~A & B <=> A | B: thm
val disj_of_negconj = {},  |- ~A & ~B <=> ~(A | B): thm
val djE = fn: form * thm -> form * thm -> form * thm
val djEs = fn: (form * thm) list -> form * thm
val drop_last_cj = fn: form -> form * form
val iant = fn: form -> form
val iconc = fn: form -> form
val imp_dimp_distr = {},  |- A ==> (B <=> C) <=> A ==> B <=> A ==> C: thm
val strip_conj = fn: form -> form list
val strip_disj = fn: form -> form list
val cond_rw_fconv = fn: form -> thm
val conj_assoc_fm = fn: form -> form
val define_lambda = fn: form -> thm
val define_lambda_fun = fn: form -> thm
val nlist = fn: int -> int list
val normalise_lambda_input = fn: form -> form
val it = (): unit
val NOT_def = {},  |- App(NOT, true) = false & App(NOT, false) = true: thm
val OR_def =
   {}, 
   |- App(OR, Pair(true, true)) = true &
      App(OR, Pair(true, false)) = true &
      App(OR, Pair(false, true)) = true & App(OR, Pair(false, false)) = false:
   thm
val constf_def =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#))  (a : mem(A#)).
        App(constf(A#, b#), a#) = b#: thm
val f2r_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * B#, 1 + 1))  (a : mem(A#))
      (b : mem(B#)). Holds(f2r(f#), a#, b#) <=> App(f#, Pair(a#, b#)) = true:
   thm
val r2f_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = App(i2(1, 1), dot) <=> Holds(R#, a#, b#):
   thm
val r2f_def' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = true <=> Holds(R#, a#, b#): thm
val ss2f =
   {(A : set), (s : mem(Pow(A)))}, 
   |- !(a : mem(A)). App(ss2f(s), a#) = true <=> IN(a#, s): thm
val FIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : fun(A, B))}, 
   |- FIB(f, b) = PREIM(f, Sing(b)): thm
val Inj_Image_Inj =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(A#, B#)). Inj(i#) ==> Inj(Image(i#)):
   thm
val mApp_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (f : mem(Exp(A#, B#))).
        mApp(f#, a#) = App(tof(f#), a#): thm
val mFIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : mem(Exp(A, B)))}, 
   |- mFIB(f, b) = PREIM(tof(f), Sing(b)): thm
val Compl_Whole = {},  |- !(A : set). Compl(Whole(A#)) = Empty(A#): thm
val Compl_Empty = {},  |- !(A : set). Compl(Empty(A#)) = Whole(A#): thm
val Inter_Compl_Compl =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J)))}, 
   |- Inter(Compl(s1), Compl(s2)) = Compl(Union(s1, s2)): thm
val neg_or_distr = {},  |- ~(A | B) <=> ~A & ~B: thm
val SS_Union =
   {}, 
   |- (!(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
          SS(a#, Union(a#, b#))) &
      !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val SS_Union1 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(a#, b#)): thm
val SS_Union2 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val Ins_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (s0 : mem(Pow(X#)))  (a : mem(X#)).
        IN(a#, Ins(x0#, s0#)) <=> a# = x0# | IN(a#, s0#): thm
val Union_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Union(Sing(a#), s#) = Ins(a#, s#): thm
val SS_Ins =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(s#, Ins(a#, s#)):
   thm
val BIGINTER_Sing =
   {},  |- !(A : set)  (s : mem(Pow(A#))). BIGINTER(Sing(s#)) = s#: thm
val Whole_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Whole(A#), s#) = s#: thm
val Inter_Whole =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Whole(A#)) = s#: thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Empty_SS = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(Empty(A#), s#): thm
val BIGINTER_Empty = {(A : set)},  |- BIGINTER(Empty(Pow(A))) = Whole(A): thm
val BIGINTER_Ins_Empty =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#))). BIGINTER(Ins(x#, Empty(Pow(A#)))) = x#:
   thm
val Inter_same = {},  |- !(A : set)  (x : mem(Pow(A#))). Inter(x#, x#) = x#:
   thm
val BIGINTER_Ins =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#)))  (xs0 : mem(Pow(Pow(A#)))).
        BIGINTER(Ins(x#, xs0#)) = Inter(x#, BIGINTER(xs0#)): thm
val imp_or_distr = {},  |- A | B ==> C <=> (A ==> C) & (B ==> C): thm
val BIGINTER_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(Pow(A#))))  (s2 : mem(Pow(Pow(A#)))).
        BIGINTER(Union(s1#, s2#)) = Inter(BIGINTER(s1#), BIGINTER(s2#)): thm
val Empty_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Empty(A#), s#) = Empty(A#):
   thm
val Union_EMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val neg_and_distr = {},  |- ~(A & B) <=> ~A | ~B: thm
val SS_Union_split =
   {}, 
   |- !(W : set)  (A : mem(Pow(W#)))  (B : mem(Pow(W#)))  (s : mem(Pow(W#))).
        SS(s#, Union(A#, B#)) <=>
        ?(s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
          SS(s1#, A#) & SS(s2#, B#) & s# = Union(s1#, s2#): thm
val Inter_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Empty(A#)) = Empty(A#):
   thm
val SS_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        SS(s#, Sing(a#)) <=> s# = Sing(a#) | s# = Empty(A#): thm
val Empty_Union =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(Empty(A#), s#) = s#: thm
val SS_Empty =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))). SS(s#, Empty(A#)) <=> s# = Empty(A#):
   thm
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val Union_assoc =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Union(Union(s1#, s2#), s3#) = Union(s1#, Union(s2#, s3#)): thm
val Inter_Whole_Whole =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Whole(A#) <=> s1# = Whole(A#) & s2# = Whole(A#):
   thm
val Union_SS1 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(Union(s1#, s2#), s#) <=> SS(s1#, s#) & SS(s2#, s#): thm
val SS_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s#, Inter(s1#, s2#)) <=> SS(s#, s1#) & SS(s#, s2#): thm
val Union_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        SS(Inter(s1#, s2#), s1#) & SS(Inter(s1#, s2#), s2#): thm
val Whole_SS =
   {}, 
   |- !(A : set)  (X : mem(Pow(A#))). SS(Whole(A#), X#) ==> X# = Whole(A#):
   thm
val SS_Whole = {},  |- !(A : set)  (X : mem(Pow(A#))). SS(X#, Whole(A#)): thm
val Sing_Ins_Empty =
   {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = Ins(a#, Empty(A#)): thm
val EMPTY_Empty_Whole =
   {},  |- !(A : set). EMPTY(A#) <=> Empty(A#) = Whole(A#): thm
val NOT_EMPTY = {},  |- !(A : set). ~EMPTY(A#) <=> ?(a : mem(A#)). T: thm
val NEQ_IN =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val PSS_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- PSS(s1, s2) <=> SS(s1, s2) & ~s1 = s2: thm
val PSS_alt =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) <=>
        SS(s1#, s2#) & ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val Inter_Compl =
   {},  |- !(A : set)  (a : mem(Pow(A#))). Inter(a#, Compl(a#)) = Empty(A#):
   thm
val neg_iff = {},  |- ~(A <=> B) <=> A & ~B | B & ~A: thm
val Union_Empty2 =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(s#, Empty(A#)) = s#: thm
val Inter_eq_Empty =
   {}, 
   |- !(W : set)  (s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
        Inter(s1#, s2#) = Empty(W#) <=> SS(s2#, Compl(s1#)): thm
val PSS_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) ==> SS(s1#, s2#): thm
val SS_BIGUNION =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(Pow(A#)))))
      (s0 : mem(Pow(Pow(A#)))).
        IN(s0#, ss#) & SS(s#, s0#) ==> SS(s#, BIGUNION(ss#)): thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val Del_def =
   {}, 
   |- !(X : set)  (s0 : mem(Pow(X#)))  (x0 : mem(X#))  (a : mem(X#)).
        IN(a#, Del(s0#, x0#)) <=> IN(a#, s0#) & ~a# = x0#: thm
val c31_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c31(abc) = Fst(abc): thm
val c32_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c32(abc) = Fst(Snd(abc)): thm
val c33_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c33(abc) = Snd(Snd(abc)): thm
val Del_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        ~IN(x0#, xs0#) ==> Del(Ins(x0#, xs0#), x0#) = xs0#: thm
val Ins_absorb =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        IN(x0#, xs0#) ==> Ins(x0#, xs0#) = xs0#: thm
val Ins_Del =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, s#) ==> Ins(a#, Del(s#, a#)) = s#: thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
        IMAGE(f#, ss#) = Empty(B#) <=> ss# = Empty(A#): thm
val NOTIN_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        ~IN(a#, s#) ==> Del(s#, a#) = s#: thm
val Inj_IMAGE_Del =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#)))
      (a : mem(A#)).
        Inj(f#) ==>
        IMAGE(f#, Del(ss#, a#)) = Del(IMAGE(f#, ss#), App(f#, a#)): thm
val disj_not_imp = {},  |- A | ~B <=> B ==> A: thm
val exists_forall = fn: string * sort -> thm
val exists_forall_th =
   {(A : set)},  |- (?(a : mem(A)). f0(a#)) <=> ~!(a : mem(A)). ~f0(a#): thm
val not_disj_imp = {},  |- ~B | A <=> B ==> A: thm
val set_NEQ =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). ~IN(a#, s1#) & IN(a#, s2#): thm
val Pa_Inj =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#)).
        Inj(f#) ==> !(B : set)  (g : fun(X#, B#)). Inj(Pa(g#, f#)): thm
val o_Inj_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_restrict =
   {}, 
   |- !(D : set)  (D0 : set)  (i1 : fun(D#, D0#)).
        Inj(i1#) ==>
        !(C : set)  (C0 : set)  (i2 : fun(C#, C0#)).
          Inj(i2#) ==>
          !(f0 : fun(D0#, C0#)).
            (!(d : mem(D#)).
                ?!(c : mem(C#)). App(f0# o i1#, d#) = App(i2#, c#)) ==>
            ?!(f : fun(D#, C#)). i2# o f# = f0# o i1#: thm
val SS_Del =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(Del(s#, a#), s#):
   thm
val Inj_o_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        Inj(g# o f#) ==> Inj(f#): thm
val SS_Ins_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#)))  (G : mem(Pow(A#))).
        SS(ss#, Ins(a#, G#)) ==> SS(Del(ss#, a#), G#): thm
val SOME_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (x2 : mem(X#)).
        SOME(x1#) = SOME(x2#) <=> x1# = x2#: thm
val option_xor =
   {}, 
   |- !(A : set)  (a1 : mem(A# + 1)).
        ~a1# = NONE(A#) <=> ?!(a0 : mem(A#)). a1# = SOME(a0#): thm
val NOT_true_iff_false =
   {},  |- !(tv : mem(1 + 1)). App(NOT, tv#) = true <=> tv# = false: thm
val SOME_NOTNONE = {},  |- !(X : set)  (x : mem(X#)). ~SOME(x#) = NONE(X#):
   thm
val OM_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- App(OM(f), NONE(A)) = NONE(B) &
      !(a : mem(A)). App(OM(f), SOME(a#)) = SOME(App(f, a#)): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val Diff_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Diff(s1#, s2#)) <=> IN(a#, s1#) & ~IN(a#, s2#): thm
val Inter_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        ~Inter(s#, Sing(a#)) = Empty(A#) <=> IN(a#, s#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val Diff_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Diff(s#, Empty(A#)) = s#: thm
val Diff_Empty_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Diff(s1#, s2#) = Empty(A#) <=> SS(s1#, s2#): thm
val Ins_Union =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Ins(a#, s#) = Union(Sing(a#), s#): thm
val Union_Empty_both_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Inter(s1#, Union(s2#, s3#)) = Union(Inter(s1#, s2#), Inter(s1#, s3#)):
   thm
val Inter_Diff_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Sing(x#)) = Empty(A#) <=>
        IN(x#, Diff(s1#, s2#)): thm
val Diff_Ins_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Ins(x#, s3#)) = Empty(A#) <=>
        ~Inter(Diff(s1#, s2#), s3#) = Empty(A#) | IN(x#, Diff(s1#, s2#)): thm
val Inter_Empty2 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Empty(A#) ==>
        !(a : mem(A#)). IN(a#, s2#) ==> ~IN(a#, s1#): thm
val Inter_both_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~Inter(s1#, s2#) = Empty(A#) ==> ~s1# = Empty(A#) & ~s2# = Empty(A#):
   thm
val neg_imp_conj = {},  |- ~(A ==> B) <=> A & ~B: thm
val forall_exists_dual =
   {},  |- !(A : set). (!(a : mem(A#)). P(a#)) <=> ~?(a : mem(A#)). ~P(a#):
   thm
val neg_conj_imp = {},  |- ~(A & B) <=> A ==> ~B: thm
val it = (): unit
******

Loading SEAR file SEARNarith.sml

******
val Nind's_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        IN(a#, Nind's(f0, x0)) <=> SS(App(Nindf(f0, x0), a#), a#): thm
val Nind_cases0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- App(Nindf(f0, x0), Ninds(f0, x0)) = Ninds(f0, x0): thm
val Nind_cases1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_incond =
   !(nx : mem(N * X)).
     IN(nx#, Nind1) <=>
     nx# = Pair(O, x0) |
     ?(nx0 : mem(N * X)).
       IN(nx0#, Nind0) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): form
val Nind_ind =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), ss#), ss#) ==> SS(Ninds(f0, x0), ss#): thm
val Nind_ind1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        (!(a : mem(N * X)).
            a# = Pair(O, x0) |
            (?(nx0 : mem(N * X)).
                IN(nx0#, ss#) & a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_rules0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- SS(App(Nindf(f0, x0), Ninds(f0, x0)), Ninds(f0, x0)): thm
val Nind_rules1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        a# = Pair(O, x0) |
        (?(nx0 : mem(N * X)).
            IN(nx0#, Ninds(f0, x0)) &
            a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
        IN(a#, Ninds(f0, x0)): thm
val Nind_rules2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (a# = Pair(O, x0) ==> IN(a#, Ninds(f0, x0))) &
        !(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))) ==>
          IN(a#, Ninds(f0, x0)): thm
val Nind_rules3 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nindf_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
        IN(nx#, App(Nindf(f0, x0), a#)) <=>
        nx# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nindf_ex =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(N * X), Pow(N * X))).
        !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
          IN(nx#, App(f#, a#)) <=>
          nx# = Pair(O, x0) |
          ?(nx0 : mem(N * X)).
            IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))):
   thm
val Nindf_monotone =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(N * X)))  (s2 : mem(Pow(N * X))).
        SS(s1#, s2#) ==> SS(App(Nindf(f0, x0), s1#), App(Nindf(f0, x0), s2#)):
   thm
val Ninds_SS =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), a#), a#) ==> SS(Ninds(f0, x0), a#): thm
val Ninds_cond =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (!(ss : mem(Pow(N * X))).
            SS(App(Nindf(f0, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Ninds(f0, x0)): thm
val Ninds_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- Ninds(f0, x0) = BIGINTER(Nind's(f0, x0)): thm
val x1 = "Nind0": string
val Nind_cases =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_rules =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nind_uex =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        ?!(x : mem(X#)). IN(Pair(n#, x#), Ninds(f0#, x0#)): thm
val Nrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (a : mem(N)).
        IN(Pair(a#, App(Nrec(x0#, f0#), a#)), Ninds(f0#, x0#)): thm
val Nrec_O =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        App(Nrec(x0#, f0#), O) = x0#: thm
val App_Nrec_Ninds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N))
      (x : mem(X#)).
        App(Nrec(x0#, f0#), n#) = x# <=> IN(Pair(n#, x#), Ninds(f0#, x0#)):
   thm
val Nrec_Suc =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        App(Nrec(x0#, f0#), Suc(n#)) = App(f0#, App(Nrec(x0#, f0#), n#)): thm
val Nrec_unique =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Nrec_Suc_eqn =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        Nrec(x0#, f0#) o SUC = f0# o Nrec(x0#, f0#): thm
val El_def = {},  |- !(A : set)  (a : mem(A#)). App(El(a#), dot) = a#: thm
val El_eq_eq =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). El(a#) = El(b#) <=> a# = b#:
   thm
val App_o_El =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(f#, a#) = App(f# o El(a#), dot): thm
val Nrec_El =
   {}, 
   |- !(X : set)  (a : mem(X#))  (f : fun(X#, X#)).
        Nrec(a#, f#) o El(O) = El(a#) &
        Nrec(a#, f#) o SUC = f# o Nrec(a#, f#) &
        !(u : fun(N, X#)).
          u# o El(O) = El(a#) & u# o SUC = f# o u# ==> u# = Nrec(a#, f#): thm
val App_El_mem =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(f#, a#) = b# <=> f# o El(a#) = El(b#): thm
val Nrec_O_SUC = {},  |- Nrec(O, SUC) = Id(N): thm
val comm_with_SUC_id0 =
   {}, 
   |- !(f : fun(N, N)). App(f#, O) = O & f# o SUC = SUC o f# ==> f# = Id(N):
   thm
val comm_with_SUC_id =
   {}, 
   |- !(f : fun(N, N)).
        f# o El(O) = El(O) & f# o SUC = SUC o f# ==> f# = Id(N): thm
val Thm1_case1_comm_condition =
   {}, 
   |- !(B : set)  (f0 : fun(N, B#))  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        f0# o El(O) = g# & f0# o SUC = h# o Pa(Id(N), f0#) <=>
        Pa(Id(N), f0#) o El(O) = Pa(El(O), g#) &
        Pa((SUC o p1(N, B#)), h#) o Pa(Id(N), f0#) = Pa(Id(N), f0#) o SUC:
   thm
val Dot_def = {},  |- !(A : set)  (f : fun(1, A#)). Dot(f#) = App(f#, dot):
   thm
val Dot_of_El = {},  |- !(A : set)  (a : mem(A#)). Dot(El(a#)) = a#: thm
val El_of_Dot = {},  |- !(X : set)  (f : fun(1, X#)). El(Dot(f#)) = f#: thm
val to_P_component =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#)).
        Pa(p1(A#, B#) o f#, p2(A#, B#) o f#) = f#: thm
val Thm1_case_1 =
   {}, 
   |- !(B : set)  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        ?!(f : fun(N, B#)). f# o El(O) = g# & f# o SUC = h# o Pa(Id(N), f#):
   thm
val is_Nrec =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Tp1_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(tpf : fun(1, Exp(A#, B#))). Tp(f# o p1(A#, 1)) = tpf#: thm
val Ev_of_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#)).
        Ev(A#, B#) o Pa(p1(A#, X#), Tp(f#) o p2(A#, X#)) = f#: thm
val Tp1_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Tp(f# o p1(A#, 1)) = Tp1(f#):
   thm
val Tp_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (g : fun(A# * X#, B#)). Tp(f#) = Tp(g#) <=> f# = g#: thm
val Ev_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, Exp(A#, B#)))
      (g : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), f# o p2(A#, X#)) = Ev(A#, B#) o
          Pa(p1(A#, X#), g# o p2(A#, X#)) ==> f# = g#: thm
val to_P_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#))
      (g : fun(X#, A# * B#)).
        p1(A#, B#) o f# = p1(A#, B#) o g# & p2(A#, B#) o f# = p2(A#, B#) o g# ==>
        f# = g#: thm
val Pa_o_split =
   {}, 
   |- !(B : set)  (X : set)  (f : fun(B#, X#))  (Y : set)  (g : fun(X#, Y#))
      (A : set).
        Pa(p1(A#, B#), g# o f# o p2(A#, B#)) =
          Pa(p1(A#, X#), (g# o p2(A#, X#))) o Pa(p1(A#, B#), f# o p2(A#, B#)):
   thm
val Thm1_comm_eq_left =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))  (g : fun(A#, B#)).
        Tp(f#) o El(O) = Tp1(g#) <=>
        f# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1): thm
val Pa_p1_p2 =
   {},  |- !(A : set)  (B : set). Pa(p1(A#, B#), p2(A#, B#)) = Id(A# * B#):
   thm
val Thm1_comm_eq_right =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))
      (h : fun((A# * N) * B#, B#))
      (l : fun(A# * N * Exp(A#, B#), (A# * N) * B#)).
        Pa(Pa(p1(A#, N * Exp(A#, B#)), p1(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#))), Ev(A#, B#) o
           Pa(p1(A#, N * Exp(A#, B#)), p2(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#)))) = l# ==>
        (h# o Pa(Id(A# * N), f#) = f# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
          Tp((h# o l#)) o Pa(Id(N), Tp(f#)) = Tp(f#) o SUC): thm
val Ev_of_Tp_el =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))  (P : set)
      (a : fun(P#, A#))  (x : fun(P#, X#)).
        Ev(A#, B#) o Pa(a#, Tp(f#) o x#) = f# o Pa(a#, x#): thm
val Ev_of_Tp_el' =
   {}, 
   |- !(A : set)  (B : set)  (P : set)  (f : fun(A# * P#, B#))
      (a : fun(P#, A#)). Ev(A#, B#) o Pa(a#, Tp(f#)) = f# o Pa(a#, Id(P#)):
   thm
val Tp_of_Ev =
   {(A : set), (B : set), (X : set), (f : fun(X, Exp(A, B)))}, 
   |- Tp(Ev(A, B) o Pa(p1(A, X), f o p2(A, X))) = f: thm
val Thm1 =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val Thm1_uex =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?!(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val PRE_def = {},  |- PRE o El(O) = El(O) & PRE o SUC = Id(N): thm
val Pre_def = {},  |- !(n : mem(N)). Pre(n#) = App(PRE, n#): thm
val Pre_eqn = {},  |- Pre(O) = O & !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val ADD_def =
   {}, 
   |- ADD o Pa(p1(N, 1), El(O) o To1(N * 1)) = p1(N, 1) &
      SUC o ADD = ADD o Pa(p1(N, N), SUC o p2(N, N)): thm
val Add_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Add(n1#, n2#) = App(ADD, Pair(n1#, n2#)):
   thm
val Add_O = {},  |- !(n : mem(N)). Add(n#, O) = n#: thm
val App_input_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a1 : mem(A#))
      (a2 : mem(A#)). a1# = a2# ==> App(f#, a1#) = App(f#, a2#): thm
val Add_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, Suc(n#)) = Suc(Add(m#, n#)):
   thm
val Pre_O = {},  |- Pre(O) = O: thm
val Pre_Suc = {},  |- !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val SUB_def =
   {}, 
   |- SUB o Pa(p1(N, 1), El(O) o p2(N, 1)) = p1(N, 1) &
      PRE o SUB = SUB o Pa(p1(N, N), SUC o p2(N, N)): thm
val o_eq_r =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        f1# = f2# ==> !(C : set)  (g : fun(B#, C#)). g# o f1# = g# o f2#: thm
val Sub_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Sub(n1#, n2#) = App(SUB, Pair(n1#, n2#)):
   thm
val Sub_O = {},  |- !(n : mem(N)). Sub(n#, O) = n#: thm
val Sub_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, Suc(n#)) = Pre(Sub(m#, n#)):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Le_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Pre_eq_O = {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O):
   thm
val Lt_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val Le_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val Lt_Le = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> Le(m#, n#):
   thm
val Lt_NE = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> ~m# = n#: thm
val Le_NE_Lt =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) & ~m# = n# ==> Lt(m#, n#):
   thm
val Lt_Le_NE =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val Sub_mono_eq =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(Suc(m#), Suc(n#)) = Sub(m#, n#):
   thm
val Add_Sub = {},  |- !(c : mem(N))  (a : mem(N)). Sub(Add(a#, c#), c#) = a#:
   thm
val Add_O2 = {},  |- !(n : mem(N)). Add(O, n#) = n#: thm
val Sub_EQ_O = {},  |- !(n : mem(N)). Sub(n#, n#) = O: thm
val Le_refl = {},  |- !(n : mem(N)). Le(n#, n#): thm
val Le_O_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val o_eq_l =
   {}, 
   |- !(B : set)  (C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
        g1# = g2# ==> !(A : set)  (f : fun(A#, B#)). g1# o f# = g2# o f#: thm
val Le_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) ==> Lt(m#, n#) | m# = n#:
   thm
val Le_Sub =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val cancel_Sub =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Le(a#, c#) ==> (Sub(b#, a#) = Sub(c#, a#) <=> b# = c#):
   thm
val th =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Sub_of_O = {},  |- !(n : mem(N)). Sub(O, n#) = O: thm
val O_LESS_EQ = {},  |- !(x : mem(N)). Le(O, x#): thm
val LESS_EQ_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val LESS_O = {},  |- !(n : mem(N)). Lt(O, Suc(n#)): thm
val LESS_MONO_EQ =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val LE_O_iff = {},  |- !(n : mem(N)). Le(n#, O) <=> n# = O: thm
val LESS_cases =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | Le(b#, a#): thm
val LESS_EQ_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) | Le(n#, m#): thm
val Add_Suc1 =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(Suc(a#), b#) = Suc(Add(a#, b#)):
   thm
val Add_comm =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(a#, b#) = Add(b#, a#): thm
val Suc_Sub = {},  |- !(n : mem(N)). Sub(Suc(n#), n#) = Suc(O): thm
val Sub_DIFF_1 =
   {},  |- !(a : mem(N))  (b : mem(N)). Sub(a#, b#) = Suc(O) <=> a# = Suc(b#):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Sub_Suc_O_cases =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, Suc(b#)) = O ==> a# = Suc(b#) | Sub(a#, b#) = O: thm
val Le_cases_iff =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) <=> Lt(a#, b#) | a# = b#:
   thm
val Lt_Suc_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Suc(b#)) <=> Le(a#, b#): thm
val Sub_EQ_O1 =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, n#) = O <=> Le(m#, n#): thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val strong_ind =
   {}, 
   |- (!(a : mem(N)). (!(a0 : mem(N)). Lt(a0#, a#) ==> P(a0#)) ==> P(a#)) ==>
      !(a : mem(N)). P(a#): thm
val WOP =
   {}, 
   |- !(a : mem(N)).
        P(a#) ==>
        ?(a0 : mem(N)). P(a0#) & !(a1 : mem(N)). P(a1#) ==> Le(a0#, a1#): thm
val MUL_def0 =
   {}, 
   |- MUL o Pa(p1(N, 1), El(O) o To1(N * 1)) = El(O) o To1(N * 1) &
      ADD o Pa(MUL, p1(N, N)) = MUL o Pa(p1(N, N), SUC o p2(N, N)): thm
val Mul_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Mul(n1#, n2#) = App(MUL, Pair(n1#, n2#)):
   thm
val App_Pa2 =
   {}, 
   |- !(A : set)  (B : set)  (D : set)  (g : fun(B#, D#))
      (ab : mem(A# * B#)).
        App(Pa(p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_p1_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p1(A#, B#), Pair(a#, b#)) = a#: thm
val App_p2_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p2(A#, B#), Pair(a#, b#)) = b#: thm
val Mul_O = {},  |- !(n : mem(N)). Mul(n#, O) = O: thm
val Mul_Suc =
   {}, 
   |- !(n : mem(N))  (n0 : mem(N)). Mul(n#, Suc(n0#)) = Add(Mul(n#, n0#), n#):
   thm
val Mul_LEFT_O = {},  |- !(m : mem(N)). Mul(O, m#) = O: thm
val Mul_LEFT_1 = {},  |- !(m : mem(N)). Mul(Suc(O), m#) = m#: thm
val Mul_RIGHT_1 = {},  |- !(m : mem(N)). Mul(m#, Suc(O)) = m#: thm
val Add_comm' =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(b#, a#) = Add(a#, b#): thm
val Add_assoc =
   {}, 
   |- !(m : mem(N))  (n0 : mem(N))  (p : mem(N)).
        Add(m#, Add(n0#, p#)) = Add(Add(m#, n0#), p#): thm
val Add_eq_eq =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (a : mem(N)).
        Add(m#, a#) = Add(n#, a#) ==> m# = n#: thm
val Mul_Suc1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Mul(Suc(n#), m#) = Add(m#, Mul(n#, m#)):
   thm
val Mul_clauses =
   {}, 
   |- (!(m : mem(N)).
          Mul(O, m#) = O &
          Mul(m#, O) = O & Mul(Suc(O), m#) = m# & Mul(m#, Suc(O)) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Mul(Suc(m#), n#) = Add(Mul(m#, n#), n#) &
        Mul(m#, Suc(n#)) = Add(m#, Mul(m#, n#)): thm
val Mul_comm =
   {},  |- !(m : mem(N))  (n : mem(N)). Mul(m#, n#) = Mul(n#, m#): thm
val Add_clauses =
   {}, 
   |- (!(m : mem(N)). Add(O, m#) = m# & Add(m#, O) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Add(Suc(m#), n#) = Suc(Add(m#, n#)) &
        Add(m#, Suc(n#)) = Suc(Add(m#, n#)): thm
val Nind_tac = fn: tactic
val RIGHT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Add(m#, n#), p#) = Add(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Add(m#, n#)) = Add(Mul(p#, m#), Mul(p#, n#)): thm
val Mul_assoc =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(m#, Mul(n#, p#)) = Mul(Mul(m#, n#), p#): thm
val Sub_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Sub(a#, Add(b#, c#)) = Sub(Sub(a#, b#), c#): thm
val Le_O_iff = {},  |- !(a : mem(N)). Le(a#, O) <=> a# = O: thm
val Le_Suc =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, Suc(b#)) ==> Le(a#, b#) | a# = Suc(b#): thm
val Le_Add_ex =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(n#, m#) ==> ?(p : mem(N)). Add(p#, n#) = m#: thm
val LE_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Sub(a#, b#) = O:
   thm
val LT_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Holds(LT, a#, b#) <=> Holds(LE, a#, b#) & ~a# = b#: thm
val LE_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Le(a#, b#): thm
val LT_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LT, a#, b#) <=> Lt(a#, b#): thm
val LE_Trans = {},  |- Trans(LE): thm
val LESS_MONO_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(m#, n#) <=> Lt(Add(m#, p#), Add(n#, p#)): thm
val EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val LESS_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(Add(m#, p#), Add(n#, p#)) <=> Lt(m#, n#): thm
val LESS_OR_EQ =
   {(m : mem(N)), (n : mem(N))},  |- Le(m, n) <=> Lt(m, n) | m = n: thm
val LESS_EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(Add(m#, p#), Add(n#, p#)) <=> Le(m#, n#): thm
val Le_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, c#) & Le(b#, d#) ==> Le(Add(a#, b#), Add(c#, d#)): thm
val Le_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Le(a1#, a2#) & Le(a2#, a3#) ==> Le(a1#, a3#): thm
val Asym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Asym(R#) <=>
        !(a : mem(A#))  (b : mem(A#)).
          Holds(R#, a#, b#) & Holds(R#, b#, a#) ==> a# = b#: thm
val Lt_Suc = {},  |- !(a : mem(N)). Lt(a#, Suc(a#)): thm
val Suc_NEQ = {},  |- !(a : mem(N)). ~a# = Suc(a#): thm
val Add_Suc_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Add(a#, Suc(b#))): thm
val LT_Trans = {},  |- Trans(LT): thm
val Lt_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Lt(a1#, a2#) & Lt(a2#, a3#) ==> Lt(a1#, a3#): thm
val LE_Asym = {},  |- Asym(LE): thm
val Le_Asym =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) ==> a# = b#:
   thm
val LESS_EQ_LESS_EQ_MONO =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N))  (q : mem(N)).
        Le(m#, p#) & Le(n#, q#) ==> Le(Add(m#, n#), Add(p#, q#)): thm
val Le_MONO_Mul =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(m#, n#) ==> Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul' =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(m#, n#) ==> !(p : mem(N)). Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Le(m#, i#) & Le(n#, j#) ==> Le(Mul(m#, n#), Mul(i#, j#)): thm
val Le_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val Le_O' = {},  |- !(x : mem(N)). Le(O, x#): thm
val Sub_Suc1 =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(b#, a#) ==> Sub(Suc(a#), b#) = Suc(Sub(a#, b#)): thm
val SUB_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Le(n#, m#) ==> Add(Sub(m#, n#), n#) = m#:
   thm
val ADD_EQ_SUB =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(n#, p#) ==> (Add(m#, n#) = p# <=> m# = Sub(p#, n#)): thm
val NOT_SUC_LESS_EQ_O = {},  |- !(n : mem(N)). ~Le(Suc(n#), O): thm
val NOT_SUC_LT_O = {},  |- !(n : mem(N)). ~Lt(Suc(n#), O): thm
val Lt_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val Lt_trichotomy =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | a# = b# | Lt(b#, a#):
   thm
val NEQ_O_Lt = {},  |- !(a : mem(N)). ~a# = O <=> Lt(O, a#): thm
val Add_eq_O =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, n#) = O <=> m# = O & n# = O:
   thm
val Mul_eq_O =
   {}, 
   |- !(a : mem(N)). ~a# = O ==> !(b : mem(N)). Mul(a#, b#) = O <=> b# = O:
   thm
val Sub_Sub_O_eq =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, b#) = O & Sub(b#, a#) = O ==> a# = b#: thm
val NOT_LESS =
   {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#): thm
val RIGHT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Sub(m#, n#), p#) = Sub(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Sub(m#, n#)) = Sub(Mul(p#, m#), Mul(p#, n#)): thm
val MULT_MONO_EQ =
   {}, 
   |- !(n : mem(N))  (m : mem(N))  (i : mem(N)).
        Mul(Suc(n#), m#) = Mul(Suc(n#), i#) <=> m# = i#: thm
val Mul_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        ~p# = O ==> (Mul(m#, p#) = Mul(n#, p#) <=> m# = n#): thm
val Lt_MONO_Mul =
   {}, 
   |- !(p : mem(N)).
        Lt(O, p#) ==>
        !(m : mem(N))  (n : mem(N)).
          Lt(m#, n#) ==> Lt(Mul(m#, p#), Mul(n#, p#)): thm
val Le_Lt_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Lt(a#, c#): thm
val Lt_O_Lt = {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) ==> Lt(O, b#):
   thm
val Lt_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Lt(m#, i#) & Lt(n#, j#) ==> Lt(Mul(m#, n#), Mul(i#, j#)): thm
val LESS_ADD_NONZERO =
   {},  |- !(m : mem(N))  (n : mem(N)). ~n# = O ==> Lt(m#, Add(m#, n#)): thm
val SUB_LESS =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Lt(O, n#) & Le(n#, m#) ==> Lt(Sub(m#, n#), m#): thm
val Add_leq =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (b : mem(N)).
        a1# = a2# ==> Add(a1#, b#) = Add(a2#, b#): thm
val Add_req =
   {}, 
   |- !(a : mem(N))  (b1 : mem(N))  (b2 : mem(N)).
        b1# = b2# ==> Add(a#, b1#) = Add(a#, b2#): thm
val Add_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, b#), Add(c#, d#)): thm
val Add_split_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(a#, Add(Add(b#, c#), d#)): thm
val Add_last_middle_split =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, d#), Add(b#, c#)): thm
val Add_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val Add_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (m : mem(N))  (n : mem(N)).
        Add(a#, m#) = Add(a#, n#) <=> m# = n#: thm
val Lt_Sub_O =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) <=> Lt(O, Sub(b#, a#)):
   thm
val Lt_Le_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(a#, b#) & Le(b#, c#) ==> Lt(a#, c#): thm
val LESS_EQ_SUC = {},  |- !(n : mem(N)). Le(n#, Suc(n#)): thm
val Le_Lt_Le =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Le(a#, c#): thm
val Add_Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(Add(a#, b#), Add(c#, d#)) = Add(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_Lt_Lt_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Lt(c#, d#) ==> Lt(Add(a#, c#), Add(b#, d#)): thm
val Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Add(a#, Add(b#, c#)) = Add(b#, Add(a#, c#)): thm
val NOT_LESS_EQ =
   {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
val SUC_NOT_LESS_EQ = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
val Lt_Le_Suc =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(b#, a#) <=> Le(Suc(b#), a#): thm
val Le_Le_iff_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) <=> a# = b#:
   thm
val Le_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Le(a#, b#) ==> Le(Sub(a#, c#), Sub(b#, c#)): thm
val Lt_imp_Sub_O =
   {(a : mem(N)), (b : mem(N))},  |- Lt(a, b) ==> Sub(a, b) = O: thm
val Lt_Sub_imp_Le =
   {(a : mem(N)), (b : mem(N)), (c : mem(N))}, 
   |- Lt(a, Sub(b, c)) ==> Le(c, b): thm
val Lt_MONO_Sub_hard_direction =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(Sub(a#, c#), Sub(b#, c#)) & Le(c#, a#) ==> Lt(a#, b#): thm
val Lt_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Lt(a#, b#) <=> Lt(Sub(a#, c#), Sub(b#, c#)): thm
val Add_Le = {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, Add(a#, b#)): thm
val Add_pos_Lt =
   {}, 
   |- !(a : mem(N)).
        Lt(O, a#) ==>
        !(b : mem(N))  (c : mem(N)). Add(a#, b#) = c# ==> Lt(b#, c#): thm
val Le_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Le(c#, d#) ==>
          Le(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val Lt_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Lt(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Lt(c#, d#) ==>
          Lt(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val num1_def = {},  |- num1 = Suc(O): thm
val num2_def = {},  |- num2 = Suc(num1): thm
val num3_def = {},  |- num3 = Suc(num2): thm
val num4_def = {},  |- num4 = Suc(num3): thm
val WOP' =
   {}, 
   |- !(s : mem(Pow(N))).
        ~s# = Empty(N) ==>
        ?(a0 : mem(N)).
          IN(a0#, s#) & !(a1 : mem(N)). IN(a1#, s#) ==> Le(a0#, a1#): thm
val division_theorem_N_ex0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Lt(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val division_theorem_N_ex =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Le(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val NOT_Lt_O_O = {},  |- ~Lt(O, O): thm
val it = (): unit
******

Loading SEAR file SEARZarith.sml

******
val ZR_def =
   {}, 
   |- !(x : mem(N))  (y : mem(N))  (u : mem(N))  (v : mem(N)).
        Holds(ZR, Pair(x#, y#), Pair(u#, v#)) <=> Add(x#, v#) = Add(u#, y#):
   thm
val ZR_Refl = {},  |- Refl(ZR): thm
val ZR_Trans = {},  |- Trans(ZR): thm
val ZR_Sym = {},  |- Sym(ZR): thm
val ZR_ER = {},  |- ER(ZR): thm
val Ri_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (s : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Ri(r#), s#)) <=>
        ?(a : mem(A#)). IN(a#, s#) & Holds(r#, a#, b#): thm
val Rsi_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#)). Rsi(r#) = Ri(r#) o Sg(A#):
   thm
val rsi_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (r : rel(A#, B#)).
        rsi(r#, a#) = App(Rsi(r#), a#): thm
val IN_rsi =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
val ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          (!(x : mem(A#)). Holds(r#, a1#, x#) <=> Holds(r#, a2#, x#)) <=>
          Holds(r#, a1#, a2#): thm
val rsi_eq_ER =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          rsi(r#, a1#) = rsi(r#, a2#) <=> Holds(r#, a1#, a2#): thm
val Z_def =
   {}, 
   |- Inj(iZ) &
      !(a : mem(Pow(N * N))).
        (?(n : mem(N * N)). a# = rsi(ZR, n#)) <=>
        ?(b : mem(Z)). a# = App(iZ, b#): thm
val iZ_Inj = {},  |- Inj(iZ): thm
val iZ_eq_eq =
   {}, 
   |- !(x1 : mem(Z))  (x2 : mem(Z)).
        App(iZ, x1#) = App(iZ, x2#) ==> x1# = x2#: thm
val iZ_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(m : mem(N))  (n : mem(N)). App(iZ, z#) = rsi(ZR, Pair(m#, n#)): thm
val rsi_iZ =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        ?(b : mem(Z)). rsi(ZR, Pair(m#, n#)) = App(iZ, b#): thm
val resp_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#)).
        resp(f#, r1#, r2#) <=>
        !(y : mem(A#))  (z : mem(A#)).
          Holds(r1#, y#, z#) ==> Holds(r2#, App(f#, y#), App(f#, z#)): thm
val rext_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a0 : mem(Pow(A#)))  (b0 : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a0#, b0#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a0# = rsi(r1#, a#) & b0# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val rext_def0 =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a : mem(Pow(A#)))  (b : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a#, b#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a# = rsi(r1#, a#) & b# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val prrel_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#))
      (a1 : mem(A#))  (b1 : mem(B#))  (a2 : mem(A#))  (b2 : mem(B#)).
        Holds(prrel(r1#, r2#), Pair(a1#, b1#), Pair(a2#, b2#)) <=>
        Holds(r1#, a1#, a2#) & Holds(r2#, b1#, b2#): thm
val main =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val ipow2_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (b : mem(B#))  (Q1 : set)
      (aq : mem(Q1#))  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (bq : mem(Q2#))
      (i2 : fun(Q2#, Pow(B#))).
        IN(Pair(a#, b#), App(ipow2(i1#, i2#), Pair(aq#, bq#))) <=>
        IN(a#, App(i1#, aq#)) & IN(b#, App(i2#, bq#)): thm
val addf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(addf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(a#, a'#), Add(b#, b''#)): thm
val prrel_ER_ER =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#)).
        ER(r1#) & ER(r2#) ==> ER(prrel(r1#, r2#)): thm
val Pow_conj_eq0 =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3#: thm
val Pow_conj_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3# & s2# = s4#: thm
val ipow2_Inj_Inj =
   {}, 
   |- !(Q1 : set)  (A : set)  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (B : set)
      (i2 : fun(Q2#, Pow(B#))).
        (!(q1 : mem(Q1#)). ?(a : mem(A#)). IN(a#, App(i1#, q1#))) &
        (!(q2 : mem(Q2#)). ?(b : mem(B#)). IN(b#, App(i2#, q2#))) &
        Inj(i1#) & Inj(i2#) ==> Inj(ipow2(i1#, i2#)): thm
val Quo_def =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quo(r#, i#) <=>
        !(s : mem(Pow(A#))).
          (?!(q : mem(Q#)). s# = App(i#, q#)) <=>
          ?(a : mem(A#)). s# = rsi(r#, a#): thm
val Inj_Quo =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Inj(i) &
      (!(s : mem(Pow(A))).
          (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#)) <=>
      Inj(i) & Quo(r, i): thm
val ER_rsi_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a : mem(A#)).
        ER(r#) ==> IN(a#, rsi(r#, a#)): thm
val Quo_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) & Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        Quo(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val Quo_fun =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val main_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val Inj_Quo_Z = {},  |- Inj(iZ) & Quo(ZR, iZ): thm
val Quo_fun_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val iZ_nonempty =
   {},  |- !(z : mem(Z)). ?(ab : mem(N * N)). IN(ab#, App(iZ, z#)): thm
val addf0_resp = {},  |- resp(addf0, prrel(ZR, ZR), ZR): thm
val addz_conds =
   {}, 
   |- ER(prrel(ZR, ZR)) &
      ER(ZR) &
      resp(addf0, prrel(ZR, ZR), ZR) &
      Inj(ipow2(iZ, iZ)) &
      Inj(iZ) & Quo(prrel(ZR, ZR), ipow2(iZ, iZ)) & Quo(ZR, iZ): thm
val main_addz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(addz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(addf0, a#) = b#: thm
val main_addz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(addz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val Inj_Quo_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Inj(i#) & Quo(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). App(i#, q#) = rsi(r#, a#): thm
val Z_has_rep =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). App(iZ, z#) = rsi(ZR, Pair(a'#, b#)):
   thm
val Addz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Addz(z1#, z2#) = App(addz, Pair(z1#, z2#)): thm
val Repz_def = {},  |- !(z : mem(Z)). Repz(z#) = App(iZ, z#): thm
val Repz_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = rsi(ZR, Pair(a'#, b#)): thm
val ZC_def = {},  |- !(ab : mem(N * N)). ZC(ab#) = rsi(ZR, ab#): thm
val Repz_ZC =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = ZC(Pair(a'#, b#)): thm
val Addz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Addz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val ZC_ZR =
   {}, 
   |- !(ab : mem(N * N))  (cd : mem(N * N)).
        ZC(ab#) = ZC(cd#) <=> Holds(ZR, ab#, cd#): thm
val Addz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Addz(z1#, z2#)) = ZC(Pair(Add(a1#, a3#), Add(a2#, a4#))): thm
val Repz_eq_eq =
   {},  |- !(x1 : mem(Z))  (x2 : mem(Z)). Repz(x1#) = Repz(x2#) ==> x1# = x2#:
   thm
val Repz_eq_ZR =
   {}, 
   |- !(a1 : mem(N * N))  (a2 : mem(N * N)).
        ZC(a1#) = ZC(a2#) <=> Holds(ZR, a1#, a2#): thm
val eq_ZR =
   {},  |- !(a : mem(N * N))  (b : mem(N * N)). a# = b# ==> Holds(ZR, a#, b#):
   thm
val Addz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Addz(z1#, z2#) = Addz(z2#, z1#):
   thm
val negf0_def =
   {},  |- !(a : mem(N * N)). App(negf0, a#) = Pair(Snd(a#), Fst(a#)): thm
val negf0_def1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). App(negf0, Pair(m#, n#)) = Pair(n#, m#):
   thm
val negf0_resp = {},  |- resp(negf0, ZR, ZR): thm
val Negz_def = {},  |- !(z : mem(Z)). Negz(z#) = App(negz, z#): thm
val main_negz =
   {(z : mem(Z))}, 
   |- ?(a : mem(N * N))  (b : mem(N * N)).
        Repz(z) = ZC(a#) & Repz(App(negz, z)) = ZC(b#) & App(negf0, a#) = b#:
   thm
val Negz_char =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = ZC(Pair(a#, b#)) ==> Repz(Negz(z#)) = ZC(Pair(b#, a#)):
   thm
val main_negz1 =
   {(z : mem(Z))}, 
   |- ?(a1' : mem(N))  (a2' : mem(N)).
        Repz(z) = ZC(Pair(a1'#, a2'#)) & Repz(Negz(z)) = ZC(Pair(a2'#, a1'#)):
   thm
val mulf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(mulf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(Mul(a#, a'#), Mul(b#, b''#)),
           Add(Mul(a#, b''#), Mul(b#, a'#))): thm
val mulf0_resp = {},  |- resp(mulf0, prrel(ZR, ZR), ZR): thm
val main_mulz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(mulz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(mulf0, a#) = b#: thm
val main_mulz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(mulz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
           Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Mulz(z1#, z2#) = App(mulz, Pair(z1#, z2#)): thm
val Mulz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Mulz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Mulz(z1#, z2#)) =
            ZC(Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
              Add(Mul(a1#, a4#), Mul(a2#, a3#)))): thm
val ZC_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        ?!(z : mem(Z)). Repz(z#) = ZC(Pair(a#, b#)): thm
val ZC_Repz' =
   {},  |- !(ab : mem(N * N)). ?!(z : mem(Z)). Repz(z#) = ZC(ab#): thm
val absz_def =
   {}, 
   |- !(a' : mem(N))  (b : mem(N))  (b : mem(Z)).
        App(absz, Pair(a'#, b#)) = b# <=> Repz(b#) = ZC(Pair(a'#, b#)): thm
val Absz_def = {},  |- !(ab : mem(N * N)). Absz(ab#) = App(absz, ab#): thm
val Asz_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Asz(a#, b#) = Absz(Pair(a#, b#)): thm
val Zc_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Zc(a#, b#) = ZC(Pair(a#, b#)): thm
val Absz_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Repz(Absz(Pair(a#, b#))) = ZC(Pair(a#, b#)): thm
val Asz_Repz =
   {},  |- !(a : mem(N))  (b : mem(N)). Repz(Asz(a#, b#)) = Zc(a#, b#): thm
val Oz_def = {},  |- Oz = Asz(O, O): thm
val En_def = {},  |- En = Suc(O): thm
val Ez_def = {},  |- Ez = Asz(En, O): thm
val Addz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Addz(z1#, z2#)) = Zc(Add(a1#, a3#), Add(a2#, a4#)): thm
val Addz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Addz(Asz(a#, b#), Asz(c#, d#)) = Asz(Add(a#, c#), Add(b#, d#)): thm
val Mulz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Mulz(z1#, z2#)) =
            Zc(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))): thm
val Mulz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Mulz(Asz(a#, b#), Asz(c#, d#)) =
          Asz(Add(Mul(a#, c#), Mul(b#, d#)), Add(Mul(a#, d#), Mul(b#, c#))):
   thm
val Negz_th0 =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) ==> Repz(Negz(z#)) = Zc(b#, a#): thm
val Negz_Asz =
   {},  |- !(a : mem(N))  (b : mem(N)). Negz(Asz(a#, b#)) = Asz(b#, a#): thm
val cases_z =
   {},  |- !(z : mem(Z)). ?(a : mem(N))  (b : mem(N)). z# = Asz(a#, b#): thm
val Addz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Addz(Addz(z1#, z2#), z3#) = Addz(z1#, Addz(z2#, z3#)): thm
val casesz =
   {}, 
   |- (!(a : mem(N))  (b : mem(N)). P(Asz(a#, b#))) <=> !(z : mem(Z)). P(z#):
   thm
SEARZarith.sml:1213: warning: Matches are not exhaustive. Found near fn [th0] => dimp_mp_l2r th0 th
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val casez_tac = fn: cont * form list * form -> goal list * validation
val Asz_eq_ZR =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Asz(a#, b#) = Asz(c#, d#) <=> Holds(ZR, Pair(a#, b#), Pair(c#, d#)):
   thm
val Addz_Negz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Negz(z#)) = Oz: thm
val Mulz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Mulz(z1#, z2#), z3#) = Mulz(z1#, Mulz(z2#, z3#)): thm
val LDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(z1#, Addz(z2#, z3#)) = Addz(Mulz(z1#, z2#), Mulz(z1#, z3#)): thm
val Mulz_Ez = {},  |- !(z : mem(Z)). Mulz(z#, Ez) = z#: thm
val Mulz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Mulz(z1#, z2#) = Mulz(z2#, z1#):
   thm
val RDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Addz(z2#, z3#), z1#) = Addz(Mulz(z2#, z1#), Mulz(z3#, z1#)): thm
val le0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b' : mem(N)).
        le0(Pair(a#, b#), Pair(a'#, b'#)) <=> Le(Add(a#, b'#), Add(b#, a'#)):
   thm
val Lez_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) <=>
        !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
          Repz(z1#) = Zc(a#, b#) & Repz(z2#) = Zc(c#, d#) ==>
          Le(Add(a#, d#), Add(b#, c#)): thm
val LEz_def =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Holds(LEz, a#, b#) <=> Lez(a#, b#):
   thm
val LEz_Refl = {},  |- Refl(LEz): thm
val Repz_Zc =
   {}, 
   |- !(z : mem(Z)). ?(a' : mem(N))  (b : mem(N)). Repz(z#) = Zc(a'#, b#):
   thm
val LEz_Trans = {},  |- Trans(LEz): thm
val LEz_Asym = {},  |- Asym(LEz): thm
val Total_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Total(R#) <=>
        !(a : mem(A#))  (b : mem(A#)). Holds(R#, a#, b#) | Holds(R#, b#, a#):
   thm
val Lez_resp0 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N))  (e : mem(N))
      (f : mem(N))  (g : mem(N))  (h : mem(N)).
        Holds(ZR, Pair(a#, b#), Pair(c#, d#)) &
        Holds(ZR, Pair(e#, f#), Pair(g#, h#)) ==>
        (Le(Add(a#, f#), Add(b#, e#)) <=> Le(Add(c#, h#), Add(d#, g#))): thm
val LEz_Total = {},  |- Total(LEz): thm
val Lez_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Lez(Asz(a#, b#), Asz(c#, d#)) <=> Le(Add(a#, d#), Add(b#, c#)): thm
val Lez_Addz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) ==> !(z3 : mem(Z)). Lez(Addz(z1#, z3#), Addz(z2#, z3#)):
   thm
val Lez_Mulz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Lez(z1#, z2#) & Lez(Oz, z3#) ==> Lez(Mulz(z1#, z3#), Mulz(z2#, z3#)):
   thm
val EVEN_def =
   {}, 
   |- (!(a : mem(1)). App(EVEN, O) = true) &
      !(a : mem(N)). App(EVEN, Suc(a#)) = App(NOT, App(EVEN, a#)): thm
val Even_def = {(n : mem(N))},  |- Even(n) <=> App(EVEN, n) = true: thm
val O_Even = {},  |- Even(O): thm
val Suc_Even = {},  |- !(n : mem(N)). Even(Suc(n#)) <=> ~Even(n#): thm
val Even_not_Odd = {},  |- !(n : mem(N)). Even(n#) <=> ~Odd(n#): thm
val Odd_def = {(n : mem(N))},  |- Odd(n) <=> ~Even(n): thm
val Odd_not_Even = {},  |- !(n : mem(N)). Odd(n#) <=> ~Even(n#): thm
val id_ER = {},  |- !(A : set). ER(id(A#)): thm
val Sg_Inj = {},  |- !(A : set). Inj(Sg(A#)): thm
val Quo_id_Sg = {},  |- !(A : set). Quo(id(A#), Sg(A#)): thm
val Pow_conj_eq' =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (s1 : mem(Pow(A#)))  (B : set)
      (b0 : mem(B#))  (s2 : mem(Pow(B#))).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        !(s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#))).
          (!(a : mem(A#))  (b : mem(B#)).
              IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) <=>
          s1# = s3# & s2# = s4#: thm
val Repz_iff_Asz =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) <=> Asz(a#, b#) = z#: thm
val ipow2_prrel_ZR =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N)), (z1 : mem(Z)),
    (z2 : mem(Z))}, 
   |- App(ipow2(iZ, iZ), Pair(z1, z2)) =
        rsi(prrel(ZR, ZR), Pair(Pair(a, b), Pair(c, d))) <=>
      Asz(a, b) = z1 & Asz(c, d) = z2: thm
val Asz_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, b#) = Asz(a#, c#) <=> b# = c#: thm
val Ltz_def =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Lez(a#, b#) & ~a# = b#:
   thm
val N2Z_def = {},  |- !(a : mem(N)). App(N2Z, a#) = Asz(a#, O): thm
val n2z_def = {},  |- !(n : mem(N)). n2z(n#) = App(N2Z, n#): thm
val Asz_eq_eq_l =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, c#) = Asz(b#, c#) <=> a# = b#: thm
val N2Z_Inj = {},  |- Inj(N2Z): thm
val Repz_eq_eq_iff =
   {(x1 : mem(Z)), (x2 : mem(Z))},  |- Repz(x1) = Repz(x2) <=> x1 = x2: thm
val prove_dimp_th = fn: thm -> thm
val Abv_positive_ex0 =
   {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> ?(n : mem(N)). Asz(n#, O) = z#: thm
val Lez_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Lez(Negz(z#), Negz(b#)) <=> Lez(b#, z#):
   thm
val Negz_eq_eq =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Negz(z#) = Negz(b#) <=> z# = b#: thm
val Negz_Oz = {},  |- Negz(Oz) = Oz: thm
val Abv_negative_ex0 =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> ?(n : mem(N)). Asz(O, n#) = z#: thm
val Lez_dichotomy =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Lez(z#, b#) | Lez(b#, z#): thm
val Ltz_Asz =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N))}, 
   |- Ltz(Asz(a, b), Asz(c, d)) <=> Lt(Add(a, d), Add(b, c)): thm
val NOT_Lez_Ltz =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Lez(z#, b#) <=> Ltz(b#, z#): thm
val Abv_def =
   {}, 
   |- !(z : mem(Z)).
        Lez(Oz, z#) & Asz(Abv(z#), O) = z# |
        Ltz(z#, Oz) & Asz(O, Abv(z#)) = z#: thm
val Abv_nonneg = {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> Asz(Abv(z#), O) = z#:
   thm
val Abv_uex =
   {}, 
   |- !(z : mem(Z)).
        ?!(n : mem(N)).
          Lez(Oz, z#) & Asz(n#, O) = z# | Ltz(z#, Oz) & Asz(O, n#) = z#: thm
val n2z_Abv = {},  |- !(a : mem(Z)). Lez(Oz, a#) ==> n2z(Abv(a#)) = a#: thm
val Oz_Mulz = {},  |- !(z : mem(Z)). Mulz(Oz, z#) = Oz: thm
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val Oz_Ltz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, Oz) & Ltz(b#, Oz) ==> Ltz(Oz, Mulz(z#, b#)): thm
val int1_NONZERO = {},  |- ~int1 = Oz: thm
val int1_def = {},  |- int1 = n2z(Suc(O)): thm
val Negz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Negz(Mulz(z#, b#)):
   thm
val Ltz_Addz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, b#) <=> Ltz(Addz(z#, Negz(b#)), Oz): thm
val Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(z#, Negz(b#)) = Negz(Mulz(z#, b#)):
   thm
val Mulz_int1 = {},  |- !(z : mem(Z)). Mulz(z#, int1) = z#: thm
val Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) ==> Lez(z#, b#): thm
val n2z_Oz_Lez = {},  |- !(a : mem(N)). Lez(Oz, n2z(a#)): thm
val Negz_Addz_Oz = {},  |- !(z : mem(Z)). Addz(Negz(z#), z#) = Oz: thm
val Lez_Addz_ex =
   {}, 
   |- !(z : mem(Z))  (m : mem(Z)).
        Lez(z#, m#) ==> ?(p : mem(Z)). Lez(Oz, p#) & Addz(p#, z#) = m#: thm
val Lez_Addz_2 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Lez(z#, c#) & Lez(b#, d#) ==> Lez(Addz(z#, b#), Addz(c#, d#)): thm
val Oz_Lez_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(Oz, z#) & Lez(Oz, b#) ==>
        Lez(z#, Addz(z#, b#)) & Lez(b#, Addz(z#, b#)): thm
val Oz_Ltz_Addz =
   {}, 
   |- !(z : mem(Z)). Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(b#, Addz(z#, b#)):
   thm
val int1_Asz = {},  |- int1 = Asz(Suc(O), O): thm
val Ltz_int1_Lez_Oz = {},  |- !(z : mem(Z)). Ltz(int1, z#) ==> Lez(Oz, z#):
   thm
val Lez_Oz_Addz_Lez =
   {}, 
   |- !(z : mem(Z)). Lez(z#, Oz) ==> !(a : mem(Z)). Lez(Addz(a#, z#), a#):
   thm
val Lez_Ltz_TRANS_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(z#, c#): thm
val Ltz_trans =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(a#, c#): thm
val NOT_Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Ltz(z#, b#) <=> Lez(b#, z#): thm
val Addz_Rarr =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = c# <=> z# = Addz(c#, Negz(b#)): thm
val Addz_eq_eq =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = Addz(z#, c#) <=> b# = c#: thm
val Negz_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Negz(Addz(z#, b#)) = Addz(Negz(z#), Negz(b#)): thm
val Lez_cases =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) <=> Ltz(a#, b#) | a# = b#:
   thm
val Lez_refl = {},  |- !(a : mem(Z)). Lez(a#, a#): thm
val Lez_REFL = {},  |- !(z : mem(Z)). Lez(z#, z#): thm
val Oz_Lez_int1 = {},  |- Lez(Oz, int1): thm
val Oz_Ltz_int1 = {},  |- Ltz(Oz, int1): thm
val Ltz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(Negz(z#), Negz(b#)) <=> Ltz(b#, z#):
   thm
val NEQ_Ltz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). ~a# = b# <=> Ltz(a#, b#) | Ltz(b#, a#):
   thm
val Ltz_iff_Lez_int1 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) <=> Lez(Addz(z#, int1), b#):
   thm
val Negz_Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Mulz(z#, Negz(b#)):
   thm
val Oz_Addz = {},  |- !(z : mem(Z)). Addz(Oz, z#) = z#: thm
val Addz_eq_eq' =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(a#, c#) = Addz(b#, c#) <=> a# = b#: thm
val between_int1_Oz =
   {},  |- !(z : mem(Z)). Ltz(Negz(int1), z#) & Ltz(z#, int1) <=> z# = Oz:
   thm
val Addz_Negz_Oz_eq =
   {}, 
   |- !(z : mem(Z))  (z2 : mem(Z)). Addz(z#, Negz(z2#)) = Oz <=> z# = z2#:
   thm
val Negz_Negz = {},  |- !(z : mem(Z)). Negz(Negz(z#)) = z#: thm
val Ltz_iff_O_Ltz_Sub =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) <=> Ltz(Oz, Addz(b#, Negz(a#))): thm
val Ltz_Ltz_Mulz_Ltz =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, Mulz(z#, b#)) ==> Ltz(Oz, b#):
   thm
val Ltz_Ltz_Mulz_pos =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, b#) ==> Ltz(Oz, Mulz(z#, b#)):
   thm
val Mulz_Ltz_Ltz =
   {}, 
   |- !(a : mem(Z)).
        Ltz(Oz, a#) ==>
        !(b : mem(Z))  (c : mem(Z)).
          Ltz(Mulz(a#, b#), Mulz(a#, c#)) <=> Ltz(b#, c#): thm
val Ltz_Oz_Lez_int1 = {},  |- !(z : mem(Z)). Ltz(Oz, z#) <=> Lez(int1, z#):
   thm
val Addz_Rarr_both_sides =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Addz(z#, b#) = Addz(c#, d#) <=>
        Addz(d#, Negz(b#)) = Addz(z#, Negz(c#)): thm
val Lez_Ltz_Addz_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==>
        !(c : mem(Z))  (d : mem(Z)).
          Ltz(c#, d#) ==> Ltz(Addz(z#, c#), Addz(b#, d#)): thm
val Mulz_Negz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), Negz(b#)) = Mulz(z#, b#):
   thm
val Lez_asym =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) & Lez(b#, a#) ==> a# = b#:
   thm
val Ltz_NOT_Ltz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) ==> ~Ltz(b#, a#): thm
val Abv_Negz = {},  |- !(z : mem(Z)). Abv(Negz(z#)) = Abv(z#): thm
val Abv_Oz = {},  |- Abv(Oz) = O: thm
val n2z_Abv_Negz =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> n2z(Abv(z#)) = Negz(z#): thm
val n2z_is_Abv =
   {},  |- !(n : mem(N))  (z : mem(Z)). n2z(n#) = z# ==> n# = Abv(z#): thm
val Le_Abv_Abv =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Lez(Oz, a#) & Lez(Oz, b#) ==> (Le(Abv(a#), Abv(b#)) <=> Lez(a#, b#)):
   thm
val division_theorem_ex0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_ex1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val Lez_trans =
   {}, 
   |- !(a1 : mem(Z))  (a2 : mem(Z))  (a3 : mem(Z)).
        Lez(a1#, a2#) & Lez(a2#, a3#) ==> Lez(a1#, a3#): thm
val division_theorem_ex =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?(q : mem(Z))  (r : mem(Z)).
            a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_unique0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem_unique1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        ?!(qr : mem(Z * Z)).
          a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
          Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val DIVRz_def =
   {}, 
   |- !(a : mem(Z * Z)).
        Snd(a#) = Oz & App(DIVRz, a#) = Pair(Oz, Oz) |
        ~Snd(a#) = Oz &
        Fst(a#) =
          Addz(Mulz(Fst(App(DIVRz, a#)), Snd(a#)), Snd(App(DIVRz, a#))) &
        Lez(Oz, Snd(App(DIVRz, a#))) &
        Ltz(Snd(App(DIVRz, a#)), n2z(Abv(Snd(a#)))): thm
val Divrz_Oz =
   {}, 
   |- !(d : mem(Z)). d# = Oz ==> !(a : mem(Z)). Divrz(a#, d#) = Pair(Oz, Oz):
   thm
val Divrz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divrz(a, d) = App(DIVRz, Pair(a, d)):
   thm
val Divrz_property0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        d# = Oz & Divrz(a#, d#) = Pair(Oz, Oz) |
        ~d# = Oz &
        a# = Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) &
        Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divrz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) = a# &
          Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divz_Remz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Divz(a#, d#), d#), Remz(a#, d#)) = a# &
          Lez(Oz, Remz(a#, d#)) & Ltz(Remz(a#, d#), n2z(Abv(d#))): thm
val Divz_Remz_Oz =
   {},  |- !(a : mem(Z)). Divz(a#, Oz) = Oz & Remz(a#, Oz) = Oz: thm
val Divz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divz(a, d) = Fst(Divrz(a, d)): thm
val Remz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Remz(a, d) = Snd(Divrz(a, d)): thm
val Subz_Addz =
   {},  |- !(m : mem(Z))  (n : mem(Z)). Addz(Subz(m#, n#), n#) = m#: thm
val Subz_def =
   {(a : mem(Z)), (b : mem(Z))},  |- Subz(a, b) = Addz(a, Negz(b)): thm
val Mulz_Oz = {},  |- !(z : mem(Z)). Mulz(z#, Oz) = Oz: thm
val Oz_Ltz_Negz = {},  |- !(a : mem(Z)). Ltz(Oz, a#) <=> Ltz(Negz(a#), Oz):
   thm
val Ltz_Oz_Negz = {},  |- !(a : mem(Z)). Ltz(a#, Oz) <=> Ltz(Oz, Negz(a#)):
   thm
val Mulz_Ltz_Ltz_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(Mulz(a#, b#), Oz) <=>
        Ltz(Oz, a#) & Ltz(b#, Oz) | Ltz(Oz, b#) & Ltz(a#, Oz): thm
val Mulz_Oz_iff_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Mulz(a#, b#) = Oz <=> a# = Oz | b# = Oz:
   thm
val Divz_Remz_unique =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z))  (q : mem(Z))  (r : mem(Z)).
          Addz(Mulz(q#, d#), r#) = a# & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))) ==>
          q# = Divz(a#, d#) & r# = Remz(a#, d#): thm
val division_theorem' =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?!(qr : mem(Z * Z)).
            a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
            Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val Ltz_Subz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Ltz(Oz, Subz(b#, a#)):
   thm
val Subz_Ltz =
   {}, 
   |- !(a : mem(Z)). Ltz(Oz, a#) ==> !(b : mem(Z)). Ltz(Subz(b#, a#), b#):
   thm
val int1_Mulz = {},  |- !(z : mem(Z)). Mulz(int1, z#) = z#: thm
val Addz_Subz_Rarr =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(Addz(a#, b#), Subz(c#, b#)) = Addz(a#, c#): thm
val Divz_pos_Remz =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(Oz, a#) & Ltz(Oz, d#) ==> Ltz(Remz(a#, d#), d#): thm
val n2z_eq_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). n2z(a#) = n2z(b#) <=> a# = b#: thm
val n2z_Asz = {},  |- !(n : mem(N)). n2z(n#) = Asz(n#, O): thm
val n2z_Oz = {},  |- n2z(O) = Oz: thm
val Lez_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Lez(n2z(a#), n2z(b#)) <=> Le(a#, b#):
   thm
val Ltz_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Ltz(n2z(a#), n2z(b#)) <=> Lt(a#, b#):
   thm
val Oz_Lez_n2z = {},  |- !(n : mem(N)). Lez(Oz, n2z(n#)): thm
val Mulz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Mulz(n2z(a#), n2z(b#)) = n2z(Mul(a#, b#)):
   thm
val Addz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Addz(n2z(a#), n2z(b#)) = n2z(Add(a#, b#)):
   thm
val n2z_Oz_O = {},  |- !(n : mem(N)). n2z(n#) = Oz <=> n# = O: thm
val Le_num1_Lt_O = {},  |- !(a : mem(N)). Le(num1, a#) <=> Lt(O, a#): thm
val division_theorem_N_uex =
   {}, 
   |- !(d : mem(N)).
        Le(num1, d#) ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val qfun_compr = fn: term frag list -> term frag list -> thm
******

Loading SEAR file quo.sml

******
val resp1_def =
   {(A : set), (B : set), (R : rel(A, A)), (f : fun(A, B))}, 
   |- resp1(f, R) <=> resp(f, R, id(B)): thm
val resp1_property =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (R : rel(A#, A#)).
        resp1(f#, R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> App(f#, a1#) = App(f#, a2#): thm
val Inj_INV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          ?!(ivf : fun(B#, A#)).
            ivf# o f# = Id(A#) &
            !(b : mem(B#)).
              (!(a : mem(A#)). ~App(f#, a#) = b#) ==> App(ivf#, b#) = a0#:
   thm
val Abs_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- Abs(r, i, q0) = LINV(i, q0) o Rsi(r): thm
val Inj_LINV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(a : mem(A#)). LINV(f#, a#) o f# = Id(A#): thm
val LINV_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          LINV(f#, a0#) o f# = Id(A#) &
          !(b : mem(B#)).
            (!(a : mem(A#)). ~App(f#, a#) = b#) ==>
            App(LINV(f#, a0#), b#) = a0#: thm
val Quot_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Quot(r, i) <=>
      Inj(i) &
      !(s : mem(Pow(A))).
        (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#):
   thm
val abs_def =
   {(A : set), (Q : set), (a : mem(A)), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- abs(r, i, q0, a) = App(Abs(r, i, q0), a): thm
val eth = {(A : set), (B : set), (a0 : mem(A))},  |- ?(f : fun(B, A)). T: thm
val fname = "LINV": string
val fun_mem_ex =
   {},  |- !(A : set)  (a0 : mem(A#))  (B : set). ?(f : fun(B#, A#)). T: thm
val qvl =
   [[QUOTE " (*#loc 80 35*)f:A->B"], [QUOTE " (*#loc 80 48*)a0:mem(A)"]]:
   term frag list list
val uexth0 =
   {(A : set), (B : set), (a0 : mem(A)), (f : fun(A, B))}, Inj(f)
   |- ?!(ivf : fun(B, A)).
        ivf# o f = Id(A) &
        !(b : mem(B)).
          (!(a : mem(A)). ~App(f, a#) = b#) ==> App(ivf#, b#) = a0: thm
val Abs_Surj =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==> !(q0 : mem(Q#)). Surj(Abs(r#, i#, q0#)): thm
val Quot_ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            App(i#, q1#) = rsi(r#, a1#) & App(i#, q2#) = rsi(r#, a2#) ==>
            (Holds(r#, a1#, a2#) <=> q1# = q2#): thm
val Quot_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            abs(r#, i#, q0#, a1#) = abs(r#, i#, q0#, a2#) <=>
            Holds(r#, a1#, a2#): thm
val Quot_UMP =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        !(B : set)  (f : fun(A#, B#)).
          resp1(f#, R#) ==>
          !(Q : set)  (i : fun(Q#, Pow(A#))).
            Quot(R#, i#) ==>
            !(q0 : mem(Q#)).
              ?!(fb : fun(Q#, B#)).
                !(a : mem(A#)). App(fb#, abs(R#, i#, q0#, a#)) = App(f#, a#):
   thm
val Quot_Quo =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) <=> Inj(i#) & Quo(r#, i#): thm
val ER_Quot_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). IN(a#, App(i#, q#)): thm
val Quot_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        Quot(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val abs_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        !(q1 : mem(Q1#))  (q2 : mem(Q2#))  (a : mem(A#))  (b : mem(B#)).
          abs(prrel(r1#, r2#), ipow2(i1#, i2#), Pair(q1#, q2#), Pair(a#, b#)) =
            Pair(abs(r1#, i1#, q1#, a#), abs(r2#, i2#, q2#, b#)): thm
val Rep_of_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(q0 : mem(Q#))  (a : mem(A#)).
          App(i#, abs(r#, i#, q0#, a#)) = rsi(r#, a#): thm
val Quot_rsi_uex =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). App(i#, q#) = rsi(r#, a#): thm
val ER_Quot_rsi_char =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q : mem(Q#))  (a : mem(A#)).
            IN(a#, App(i#, q#)) <=> App(i#, q#) = rsi(r#, a#): thm
val Quot_IN_BIGUNION_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            ?(a : mem(Q#)). IN(a#, s#) & abs(r#, i#, q0#, ra#) = a#: thm
val Quot_IN_BIGUNION_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            IN(abs(r#, i#, q0#, ra#), s#): thm
val Quot_el_same =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#)).
            q1# = q2# <=>
            ?(a1 : mem(A#))  (a2 : mem(A#)).
              IN(a1#, App(i#, q1#)) &
              IN(a2#, App(i#, q2#)) & Holds(r#, a1#, a2#): thm
val ER_Quot_has_mem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val ER_Quot_has_umem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val it = (): unit
val NONZERO_O_Lt = {},  |- !(n : mem(N)). ~n# = O <=> Lt(O, n#): thm
val DIVR_def =
   {}, 
   |- !(a : mem(N * N)).
        Snd(a#) = O & App(DIVR, a#) = Pair(O, O) |
        ~Snd(a#) = O &
        Fst(a#) = Add(Mul(Fst(App(DIVR, a#)), Snd(a#)), Snd(App(DIVR, a#))) &
        Lt(Snd(App(DIVR, a#)), Snd(a#)): thm
val Divr_O =
   {},  |- !(d : mem(N)). d# = O ==> !(a : mem(N)). Divr(a#, d#) = Pair(O, O):
   thm
val Divr_def =
   {(a : mem(N)), (d : mem(N))},  |- Divr(a, d) = App(DIVR, Pair(a, d)): thm
val Divr_property0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        d# = O & Divr(a#, d#) = Pair(O, O) |
        ~d# = O &
        a# = Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) &
        Lt(Snd(Divr(a#, d#)), d#): thm
val Z2N_def = {},  |- Z2N = LINV(N2Z, O): thm
val Divr_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) = a# &
          Lt(Snd(Divr(a#, d#)), d#): thm
val Div2_def = {(n : mem(N))},  |- Div2(n) = Div(n, num2): thm
val Div_Rem_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Div(a#, d#), d#), Rem(a#, d#)) = a# & Lt(Rem(a#, d#), d#):
   thm
val Div_def = {(a : mem(N)), (d : mem(N))},  |- Div(a, d) = Fst(Divr(a, d)):
   thm
val Rem_def = {(a : mem(N)), (d : mem(N))},  |- Rem(a, d) = Snd(Divr(a, d)):
   thm
val num2_NONZERO = {},  |- ~num2 = O: thm
val Mul_num2 = {},  |- !(a : mem(N)). Mul(num2, a#) = Add(a#, a#): thm
val Div_Rem_num2 =
   {}, 
   |- !(a : mem(N)).
        Add(Mul(Div2(a#), num2), Rem(a#, num2)) = a# &
        Lt(Rem(a#, num2), num2): thm
val Div_Rem_unique =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N))  (q : mem(N))  (r : mem(N)).
          Add(Mul(q#, d#), r#) = a# & Lt(r#, d#) ==>
          q# = Div(a#, d#) & r# = Rem(a#, d#): thm
val division_theorem_N_uex' =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val Div_Rem_Mul =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)). Div(Mul(d#, a#), d#) = a# & Rem(Mul(d#, a#), d#) = O:
   thm
val Div2_Mul = {},  |- !(n : mem(N)). Div2(Mul(num2, n#)) = n#: thm
val num1_Lt_num2 = {},  |- Lt(num1, num2): thm
val Div2_Suc_Mul_num2 =
   {}, 
   |- !(n : mem(N)).
        Div2(Suc(Mul(num2, n#))) = n# & Rem(Suc(Mul(num2, n#)), num2) = num1:
   thm
val Even_Suc = {},  |- !(a : mem(N)). Even(Suc(a#)) <=> ~Even(a#): thm
val num2_Mul_Even = {},  |- !(a : mem(N)). Even(Mul(num2, a#)): thm
val Suc_num2_Mul_Odd = {},  |- !(a : mem(N)). Odd(Suc(Mul(num2, a#))): thm
val O_Even = {},  |- Even(O): thm
val O_NEQ_num1 = {},  |- ~O = num1: thm
val O_NEQ_num2 = {},  |- ~O = num2: thm
val O_NEQ_num3 = {},  |- ~O = num3: thm
val O_NEQ_num4 = {},  |- ~O = num4: thm
val num1_NEQ_num4 = {},  |- ~num1 = num4: thm
val num1_NEQ_num3 = {},  |- ~num1 = num3: thm
val num1_NEQ_num2 = {},  |- ~num1 = num2: thm
val num2_NEQ_num3 = {},  |- ~num2 = num3: thm
val num2_NEQ_num4 = {},  |- ~num2 = num4: thm
val num4_NEQ_num3 = {},  |- ~num4 = num3: thm
val Div_of_O = {},  |- !(n : mem(N)). Div(O, n#) = O & Rem(O, n#) = O: thm
val Even_Sub_num2 = {},  |- !(a : mem(N)). Even(a#) ==> Even(Sub(a#, num2)):
   thm
val Odd_num1 = {},  |- Odd(num1): thm
val Lt_num2 = {},  |- !(a : mem(N)). Lt(a#, num2) <=> a# = O | a# = num1: thm
val Even_Div2 =
   {}, 
   |- !(a : mem(N)).
        Even(a#) <=> Mul(Div2(a#), num2) = a# & Rem(a#, num2) = O: thm
val Odd_Div2 =
   {}, 
   |- !(a : mem(N)).
        Odd(a#) <=> Suc(Mul(Div2(a#), num2)) = a# & Rem(a#, num2) = num1: thm
val it = (): unit
******

Loading SEAR file SEARFiniteness.sml

******
val FI's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). IN(a#, FI's(X)) <=> SS(App(FIf(X), a#), a#):
   thm
val FI_cases0 = {(X : set)},  |- App(FIf(X), FIs(X)) = FIs(X): thm
val FI_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_incond =
   !(xs : mem(Pow(X))).
     IN(xs#, FIs1) <=>
     xs# = Empty(X) |
     ?(xs0 : mem(Pow(X)))  (x : mem(X)). IN(xs0#, FIs0) & xs# = Ins(x#, xs0#):
   form
val FI_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> SS(FIs(X), ss#):
   thm
val FI_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        (!(a : mem(Pow(X))).
            a# = Empty(X) |
            (?(xs0 : mem(Pow(X)))  (x : mem(X)).
                IN(xs0#, ss#) & a# = Ins(x#, xs0#)) ==> IN(a#, ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_rules0 = {(X : set)},  |- SS(App(FIf(X), FIs(X)), FIs(X)): thm
val FI_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        a# = Empty(X) |
        (?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#)) ==> IN(a#, FIs(X)): thm
val FI_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (a# = Empty(X) ==> IN(a#, FIs(X))) &
        !(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#) ==> IN(a#, FIs(X)): thm
val FI_rules3 =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val FIf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
        IN(xs#, App(FIf(X), a#)) <=>
        xs# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X)), Pow(Pow(X)))).
        !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
          IN(xs#, App(f#, a#)) <=>
          xs# = Empty(X) |
          ?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X))))  (s2 : mem(Pow(Pow(X)))).
        SS(s1#, s2#) ==> SS(App(FIf(X), s1#), App(FIf(X), s2#)): thm
val FIs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). SS(App(FIf(X), a#), a#) ==> SS(FIs(X), a#):
   thm
val FIs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (!(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, FIs(X)): thm
val FIs_def = {(X : set)},  |- FIs(X) = BIGINTER(FI's(X)): thm
val x1 = "FIs0": string
val FI_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_rules =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val Fin_def =
   {},  |- !(X : set)  (A : mem(Pow(X#))). Fin(A#) <=> IN(A#, FIs(X#)): thm
val Cd's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))).
        IN(a#, Cd's(X)) <=> SS(App(Cdf(X), a#), a#): thm
val Cd_cases0 = {(X : set)},  |- App(Cdf(X), Cds(X)) = Cds(X): thm
val Cd_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_incond =
   !(xsn : mem(Pow(X) * N)).
     IN(xsn#, Cds1) <=>
     xsn# = Pair(Empty(X), O) |
     ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
       IN(xsn0#, Cds0) &
       ~IN(x#, Fst(xsn0#)) &
       xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): form
val Cd_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        SS(App(Cdf(X), ss#), ss#) ==> SS(Cds(X), ss#): thm
val Cd_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        (!(a : mem(Pow(X) * N)).
            a# = Pair(Empty(X), O) |
            (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
                IN(xsn0#, ss#) &
                ~IN(x#, Fst(xsn0#)) &
                a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_rules0 = {(X : set)},  |- SS(App(Cdf(X), Cds(X)), Cds(X)): thm
val Cd_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        a# = Pair(Empty(X), O) |
        (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, Cds(X)) &
            ~IN(x#, Fst(xsn0#)) &
            a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
        IN(a#, Cds(X)): thm
val Cd_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (a# = Pair(Empty(X), O) ==> IN(a#, Cds(X))) &
        !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))) ==> IN(a#, Cds(X)):
   thm
val Cd_rules3 =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cdf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
        IN(xsn#, App(Cdf(X), a#)) <=>
        xsn# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, a#) &
          ~IN(x#, Fst(xsn0#)) &
          xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X) * N), Pow(Pow(X) * N))).
        !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
          IN(xsn#, App(f#, a#)) <=>
          xsn# = Pair(Empty(X), O) |
          ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, a#) &
            ~IN(x#, Fst(xsn0#)) &
            xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X) * N)))  (s2 : mem(Pow(Pow(X) * N))).
        SS(s1#, s2#) ==> SS(App(Cdf(X), s1#), App(Cdf(X), s2#)): thm
val Cds_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))). SS(App(Cdf(X), a#), a#) ==> SS(Cds(X), a#):
   thm
val Cds_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (!(ss : mem(Pow(Pow(X) * N))).
            SS(App(Cdf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, Cds(X)):
   thm
val Cds_def = {(X : set)},  |- Cds(X) = BIGINTER(Cd's(X)): thm
val x1 = "Cds0": string
val Cd_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_rules =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cds_ind =
   {}, 
   |- !(X : set)  (ss : mem(Pow(Pow(X#) * N))).
        IN(Pair(Empty(X#), O), ss#) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            IN(Pair(xs0#, n0#), ss#) & ~IN(x#, xs0#) ==>
            IN(Pair(Ins(x#, xs0#), Suc(n0#)), ss#)) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> IN(Pair(xs#, n#), ss#): thm
val Cd_induct0 =
   {}, 
   |- !(X : set).
        P(Pair(Empty(X#), O)) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(Pair(xs0#, n0#)) & ~IN(x#, xs0#) ==>
            P(Pair(Ins(x#, xs0#), Suc(n0#)))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(Pair(xs#, n#)): thm
val Cd_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(xs#, n#): thm
val Fin_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#)) &
        (!(xs0 : mem(Pow(X#)))  (x : mem(X#)). P(xs0#) ==> P(Ins(x#, xs0#))) ==>
        !(xs : mem(Pow(X#))). Fin(xs#) ==> P(xs#): thm
val Cdr_def =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) <=> IN(Pair(xs#, n#), Cds(X#)): thm
val Cdr_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)). Cdr(xs#, n#) ==> P(xs#, n#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs0#, n#) ==>
        !(x : mem(X#)). ~IN(x#, xs0#) ==> Cdr(Ins(x#, xs0#), Suc(n#)): thm
val Ins_NONEMPTY =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs : mem(Pow(X#))).
        ~Ins(x0#, xs#) = Empty(X#): thm
val IN_Ins_SND =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (x : mem(X#)).
        IN(x#, Ins(x0#, xs0#)) & ~x# = x0# ==> IN(x#, xs0#): thm
val Cdr_Empty_unique =
   {},  |- !(X : set)  (n : mem(N)). Cdr(Empty(X#), n#) ==> n# = O: thm
val Del_Ins_SWAP =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        ~x0# = x# ==>
        !(xs : mem(Pow(X#))). Del(Ins(x0#, xs#), x#) = Ins(x0#, Del(xs#, x#)):
   thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(Ins(x0#, xs0#), n#) <=>
        ?(a : mem(Pow(X#)))  (b : mem(N))  (x : mem(X#)).
          Cdr(a#, b#) &
          ~IN(x#, a#) & Ins(x0#, xs0#) = Ins(x#, a#) & n# = Suc(b#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) ==>
        Cdr(xs#, n#) &
        !(x : mem(X#)). IN(x#, xs#) ==> Cdr(Del(xs#, x#), Pre(n#)): thm
val Fin_Card =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> ?!(n : mem(N)). Cdr(xs#, n#): thm
val CARD_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        Holds(CARD(X#), a#, b#) <=> Fin(a#) & Cdr(a#, b#) | ~Fin(a#) & b# = O:
   thm
val CARD_unique =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        ?!(n : mem(N)). Holds(CARD(X#), xs#, n#): thm
val Cd0_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        App(Cd0(X#), a#) = b# <=> Holds(CARD(X#), a#, b#): thm
val Card_def =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Card(xs#) = App(Cd0(X#), xs#):
   thm
val Del_Empty =
   {},  |- !(X : set)  (x : mem(X#)). Del(Empty(X#), x#) = Empty(X#): thm
val Ins_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (s1 : mem(Pow(A#)))  (a2 : mem(A#))
      (s2 : mem(Pow(A#))).
        ~IN(a1#, s1#) &
        ~IN(a2#, s2#) &
        ~IN(a1#, s2#) & ~IN(a2#, s1#) & Ins(a1#, s1#) = Ins(a2#, s2#) ==>
        a1# = a2# & s1# = s2#: thm
val Fin_Empty = {},  |- !(X : set). Fin(Empty(X#)): thm
val Fin_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#))).
        Fin(xs0#) ==> !(x : mem(X#)). Fin(Ins(x#, xs0#)): thm
val Fin_Ins_Ins =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Fin(Ins(a1#, Ins(a2#, Empty(A#)))): thm
val Fin_Del0 =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> Fin(xs#) & !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Fin_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Card_Fin =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(n : mem(N)). Card(xs#) = n# <=> Cdr(xs#, n#): thm
val Card_Empty = {},  |- !(X : set). Card(Empty(X#)) = O: thm
val Cdr_Card =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Fin(xs#) ==> Cdr(xs#, Card(xs#)):
   thm
val Card_Ins =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). ~IN(x#, xs#) ==> Card(Ins(x#, xs#)) = Suc(Card(xs#)):
   thm
val Card_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). IN(x#, xs#) ==> Card(Del(xs#, x#)) = Pre(Card(xs#)):
   thm
val IN_App_IMAGE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        IN(a#, s#) ==>
        !(B : set)  (f : fun(A#, B#)). IN(App(f#, a#), IMAGE(f#, s#)): thm
val Fin_SS =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Fin(s#) ==> !(t : mem(Pow(A#))). SS(t#, s#) ==> Fin(t#): thm
val Fin_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(Union(s1#, s2#)) <=> Fin(s1#) & Fin(s2#): thm
val Ins_Ins_Fin =
   {(A : set), (s1 : mem(A)), (s2 : mem(A))}, 
   |- Fin(Ins(s1, Ins(s2, Empty(A)))): thm
val Fin_Sing = {},  |- !(A : set)  (a : mem(A#)). Fin(Sing(a#)): thm
val it = (): unit
******

Loading SEAR file SEARList.sml

******
val isL's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        IN(a#, isL's(X)) <=> SS(App(isLf(X), a#), a#): thm
val isL_cases0 = {(X : set)},  |- App(isLf(X), isLs(X)) = isLs(X): thm
val isL_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_incond =
   !(ls : mem(Pow(N * X))).
     IN(ls#, isLs1) <=>
     ls# = Empty(N * X) |
     ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
       IN(ls0#, isLs0) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): form
val isL_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), ss#), ss#) ==> SS(isLs(X), ss#): thm
val isL_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        (!(a : mem(Pow(N * X))).
            a# = Empty(N * X) |
            (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
                IN(ls0#, ss#) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_rules0 = {(X : set)},  |- SS(App(isLf(X), isLs(X)), isLs(X)): thm
val isL_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        a# = Empty(N * X) |
        (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
        IN(a#, isLs(X)): thm
val isL_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (a# = Empty(N * X) ==> IN(a#, isLs(X))) &
        !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#) ==>
          IN(a#, isLs(X)): thm
val isL_rules3 =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val isLf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
        IN(ls#, App(isLf(X), a#)) <=>
        ls# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(N * X)), Pow(Pow(N * X)))).
        !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
          IN(ls#, App(f#, a#)) <=>
          ls# = Empty(N * X) |
          ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(N * X))))  (s2 : mem(Pow(Pow(N * X)))).
        SS(s1#, s2#) ==> SS(App(isLf(X), s1#), App(isLf(X), s2#)): thm
val isLs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), a#), a#) ==> SS(isLs(X), a#): thm
val isLs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (!(ss : mem(Pow(Pow(N * X)))).
            SS(App(isLf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isLs(X)):
   thm
val isLs_def = {(X : set)},  |- isLs(X) = BIGINTER(isL's(X)): thm
val x1 = "isLs0": string
val isL_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_rules =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val List_def =
   {}, 
   |- !(X : set).
        Inj(iL(X#)) &
        !(a : mem(Pow(N * X#))).
          IN(a#, isLs(X#)) <=> ?(b : mem(List(X#))). a# = App(iL(X#), b#):
   thm
val iL_Inj = {},  |- !(X : set). Inj(iL(X#)): thm
val isL_def =
   {},  |- !(X : set)  (l : mem(Pow(N * X#))). isL(l#) <=> IN(l#, isLs(X#)):
   thm
val isL_induct =
   {}, 
   |- !(X : set).
        P(Empty(N * X#)) &
        (!(ls0 : mem(Pow(N * X#)))  (x : mem(X#)).
            P(ls0#) ==> P(Ins(Pair(Card(ls0#), x#), ls0#))) ==>
        !(l : mem(Pow(N * X#))). isL(l#) ==> P(l#): thm
val isL_Empty = {},  |- !(X : set). isL(Empty(N * X#)): thm
val isL_Ins =
   {}, 
   |- !(X : set)  (ls0 : mem(Pow(N * X#))).
        isL(ls0#) ==> !(x : mem(X#)). isL(Ins(Pair(Card(ls0#), x#), ls0#)):
   thm
val Repl_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Repl(l#) = App(iL(X#), l#): thm
val Nil_def = {},  |- !(X : set). Repl(Nil(X#)) = Empty(N * X#): thm
val cons0_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- cons0(x, l) = Ins(Pair(Card(l), x), l): thm
val cons1_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- App(cons1(X), Pair(x, l)) = Ins(Pair(Card(l), x), l): thm
val iL_isL = {},  |- !(X : set)  (l : mem(List(X#))). isL(App(iL(X#), l#)):
   thm
val isL_Repl =
   {}, 
   |- !(X : set)  (a : mem(Pow(N * X#))).
        isL(a#) <=> ?(b : mem(List(X#))). a# = Repl(b#): thm
val CONS_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Ins(Pair(Card(Repl(l#)), x#), Repl(l#)) =
          Repl(App(CONS(X#), Pair(x#, l#))): thm
val lift_cond2 =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val lift_cond2' =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?!(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val Cons_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Cons(x#, l#) = App(CONS(X#), Pair(x#, l#)): thm
val Repl_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Repl(Cons(x#, l#)) = Ins(Pair(Card(Repl(l#)), x#), Repl(l#)): thm
val Repl_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(List(X#)))  (l2 : mem(List(X#))).
        Repl(l1#) = Repl(l2#) <=> l1# = l2#: thm
val Cons_NONNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(List(X#))). ~Cons(x#, l#) = Nil(X#):
   thm
val Repl_Empty_uex =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        Repl(l#) = Empty(N * X#) <=> l# = Nil(X#): thm
val List_induct =
   {}, 
   |- !(X : set).
        P(Nil(X#)) &
        (!(l : mem(List(X#))). P(l#) ==> !(x : mem(X#)). P(Cons(x#, l#))) ==>
        !(l : mem(List(X#))). P(l#): thm
val Fin_Repl = {},  |- !(X : set)  (l : mem(List(X#))). Fin(Repl(l#)): thm
val isL_Card_NOTIN0 =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (n : mem(N))  (x : mem(X#)).
        IN(Pair(n#, x#), Repl(l#)) ==> Lt(n#, Card(Repl(l#))): thm
val CONS_Inj = {},  |- !(X : set). Inj(CONS(X#)): thm
val Cons_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (l1 : mem(List(X#)))  (x2 : mem(X#))
      (l2 : mem(List(X#))).
        Cons(x1#, l1#) = Cons(x2#, l2#) <=> x1# = x2# & l1# = l2#: thm
val Cons_or_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        l# = Nil(X#) |
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Cons_xor_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        ~l# = Nil(X#) <=>
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Lind's_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        IN(a#, Lind's(a0, f0)) <=> SS(App(Lindf(a0, f0), a#), a#): thm
val Lind_cases0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- App(Lindf(a0, f0), Linds(a0, f0)) = Linds(a0, f0): thm
val Lind_cases1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_incond =
   !(p : mem(List(X) * A)).
     IN(p#, Lind1) <=>
     p# = Pair(Nil(X), a0) |
     ?(p0 : mem(List(X) * A))  (x : mem(X)).
       IN(p0#, Lind0) &
       p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): form
val Lind_ind =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), ss#), ss#) ==> SS(Linds(a0, f0), ss#): thm
val Lind_ind1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        (!(a : mem(List(X) * A)).
            a# = Pair(Nil(X), a0) |
            (?(p0 : mem(List(X) * A))  (x : mem(X)).
                IN(p0#, ss#) &
                a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_rules0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- SS(App(Lindf(a0, f0), Linds(a0, f0)), Linds(a0, f0)): thm
val Lind_rules1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        a# = Pair(Nil(X), a0) |
        (?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, Linds(a0, f0)) &
            a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
        IN(a#, Linds(a0, f0)): thm
val Lind_rules2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (a# = Pair(Nil(X), a0) ==> IN(a#, Linds(a0, f0))) &
        !(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))) ==>
          IN(a#, Linds(a0, f0)): thm
val Lind_rules3 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lindf_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
        IN(p#, App(Lindf(a0, f0), a#)) <=>
        p# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, a#) &
          p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_ex =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- ?!(f : fun(Pow(List(X) * A), Pow(List(X) * A))).
        !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Nil(X), a0) |
          ?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, a#) &
            p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_monotone =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(s1 : mem(Pow(List(X) * A)))  (s2 : mem(Pow(List(X) * A))).
        SS(s1#, s2#) ==> SS(App(Lindf(a0, f0), s1#), App(Lindf(a0, f0), s2#)):
   thm
val Linds_SS =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), a#), a#) ==> SS(Linds(a0, f0), a#): thm
val Linds_cond =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (!(ss : mem(Pow(List(X) * A))).
            SS(App(Lindf(a0, f0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Linds(a0, f0)): thm
val Linds_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- Linds(a0, f0) = BIGINTER(Lind's(a0, f0)): thm
val x1 = "Lind0": string
val Lind_cases =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_rules =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lind_uex =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#))). ?!(a : mem(A#)). IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_def =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (a : mem(List(X#))).
        IN(Pair(a#, App(Lrec(a0#, f0#), a#)), Linds(a0#, f0#)): thm
val Lrec_Nil =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        App(Lrec(a0#, f0#), Nil(X#)) = a0#: thm
val App_Lrec_Linds =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (a : mem(A#)).
        App(Lrec(a0#, f0#), l#) = a# <=> IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_Cons =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (x : mem(X#)).
        App(Lrec(a0#, f0#), Cons(x#, l#)) =
          App(f0#, Pair(x#, App(Lrec(a0#, f0#), l#))): thm
val Lrec_unique =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f : fun(X# * A#, A#))
      (r : fun(List(X#), A#)).
        App(r#, Nil(X#)) = a0# & r# o CONS(X#) = f# o Prla(Id(X#), r#) ==>
        r# = Lrec(a0#, f#): thm
val Lrec_Cons_eqn =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        Lrec(a0#, f0#) o CONS(X#) = f0# o Prla(Id(X#), Lrec(a0#, f0#)): thm
val LENGTH_def = {},  |- !(X : set). LENGTH(X#) = Lrec(O, SUC o p2(X#, N)):
   thm
val Length_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Length(l#) = App(LENGTH(X#), l#):
   thm
val Length_Nil = {},  |- !(X : set). Length(Nil(X#)) = O: thm
val Length_Cons =
   {}, 
   |- !(A : set)  (a : mem(A#))  (l : mem(List(A#))).
        Length(Cons(a#, l#)) = Suc(Length(l#)): thm
val HD_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        App(HD(X#), Cons(x#, l#)) = SOME(x#): thm
val HD_Nil = {(X : set)},  |- App(HD(X), Nil(X)) = NONE(X): thm
val HD_def =
   {},  |- !(X : set). HD(X#) = Lrec(NONE(X#), i1(X#, 1) o p1(X#, X# + 1)):
   thm
val Hd_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Hd(Cons(x#, l#)) = SOME(x#): thm
val Hd_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Hd(l#) = App(HD(X#), l#): thm
val TL_Nil = {(X : set)},  |- App(TL(X), Nil(X)) = Nil(X): thm
val TL_def =
   {}, 
   |- !(X : set)  (a : mem(List(X#))).
        a# = Nil(X#) & App(TL(X#), a#) = Nil(X#) |
        ~a# = Nil(X#) & ?(x : mem(X#)). a# = Cons(x#, App(TL(X#), a#)): thm
val TL_ex =
   {(X : set)}, 
   |- !(l : mem(List(X))).
        ?!(tl : mem(List(X))).
          l# = Nil(X) & tl# = Nil(X) |
          ~l# = Nil(X) & ?(x : mem(X)). l# = Cons(x#, tl#): thm
val TL_Cons =
   {(X : set)}, 
   |- !(x : mem(X))  (tl : mem(List(X))). App(TL(X), Cons(x#, tl#)) = tl#:
   thm
val ELn_Nil = {(X : set)},  |- App(ELn(X), O) = Tpm(HD(X)): thm
val ELn_def =
   {(X : set)}, 
   |- ELn(X) = Nrec(Tpm(HD(X)), Ap1(MO(List(X), List(X), X + 1), Tpm(TL(X)))):
   thm
val Eln_Map =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(n : mem(N))  (l : mem(List(X))).
        Lt(n#, Length(l#)) ==> Eln(n#, Map(f, l#)) = App(OM(f), Eln(n#, l#)):
   thm
val Eln_O = {(X : set)},  |- !(a : mem(List(X))). Eln(O, a#) = Hd(a#): thm
val Eln_Suc =
   {(X : set)}, 
   |- !(n : mem(N))  (a : mem(List(X))). Eln(Suc(n#), a#) = Eln(n#, Tl(a#)):
   thm
val Eln_def =
   {(X : set), (l : mem(List(X))), (n : mem(N))}, 
   |- Eln(n, l) = App(tof(App(ELn(X), n)), l): thm
val MAP_Cons =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(l : mem(List(X)))  (x : mem(X)).
        App(MAP(f), Cons(x#, l#)) = Cons(App(f, x#), App(MAP(f), l#)): thm
val MAP_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        App(MAP(f#), Nil(X#)) = Nil(Y#): thm
val MAP_def =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        MAP(f#) = Lrec(Nil(Y#), CONS(Y#) o Prla(f#, Id(List(Y#)))): thm
val MO_def =
   {(A : set), (B : set), (C : set), (fm : mem(Exp(A, B))),
    (gm : mem(Exp(B, C)))},  |- App(MO(A, B, C), Pair(gm, fm)) = mo(gm, fm):
   thm
val Map_Cons =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#))  (l : mem(List(X#)))
      (x : mem(X#)). Map(f#, Cons(x#, l#)) = Cons(App(f#, x#), Map(f#, l#)):
   thm
val Map_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)). Map(f#, Nil(X#)) = Nil(Y#):
   thm
val Map_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (Y : set)  (f : fun(X#, Y#)).
        Map(f#, l#) = App(MAP(f#), l#): thm
val Tl_Cons =
   {}, 
   |- !(X : set)  (x : mem(X#))  (tl : mem(List(X#))).
        Tl(Cons(x#, tl#)) = tl#: thm
val Tl_Nil = {},  |- !(X : set). Tl(Nil(X#)) = Nil(X#): thm
val Tl_def = {(X : set), (l : mem(List(X)))},  |- Tl(l) = App(TL(X), l): thm
val mo_def =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (C : set)
      (g : mem(Exp(B#, C#))). mo(g#, f#) = Tpm(tof(g#) o tof(f#)): thm
val it = (): unit
******

Loading SEAR file SEARfm.sml

******
val InjA_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjA(A#), a#)) <=> a# = SOME(a#): thm
val InjN_def =
   {}, 
   |- !(A : set)  (a : mem(N))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjN(A#), a#)) <=> n# = a#: thm
val InjUU0_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * A)))  (b : mem(Pow(N * A)))  (n : mem(N))
      (a : mem(A)).
        IN(Pair(n#, a#), App(InjUU0(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val injUU0_char =
   {}, 
   |- (!(n : mem(N)).
          Even(n#) ==>
          !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
          (a : mem(A#)).
            IN(Pair(n#, a#), injUU0(u1#, u2#)) <=>
            IN(Pair(Div2(n#), a#), u1#)) &
      !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val injUU0_def =
   {(A : set), (u1 : mem(Pow(N * A))), (u2 : mem(Pow(N * A)))}, 
   |- injUU0(u1, u2) = App(InjUU0(A), Pair(u1, u2)): thm
val InjUU0_Inj = {},  |- !(A : set). Inj(InjUU0(A#)): thm
val injUU0_Even =
   {}, 
   |- !(n : mem(N)).
        Even(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u1#):
   thm
val injUU0_Odd =
   {}, 
   |- !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val F0_def = {(A : set)},  |- F0(A) = injN(A, O): thm
val InjA_Inj = {},  |- !(A : set). Inj(InjA(A#)): thm
val InjUU_Inj = {},  |- !(A : set). Inj(InjUU(A#)): thm
val InjUU_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * (A + 1))))  (b : mem(Pow(N * (A + 1))))
      (n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), App(InjUU(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val InjUU_def0 = {},  |- !(A : set). InjUU(A#) = InjUU0(A# + 1): thm
val injA_def = {(A : set), (a : mem(A))},  |- injA(a) = App(InjA(A), a): thm
val injN_def = {(A : set), (n : mem(N))},  |- injN(A, n) = App(InjN(A), n):
   thm
val VAR0_Inj = {},  |- !(A : set). Inj(VAR0(A#)): thm
val VAR0_def =
   {(A : set)}, 
   |- VAR0(A) = InjUU(A) o Pa(El(injN(A, num1)) o To1(A), InjA(A)): thm
val NEG0_Inj = {},  |- !(A : set). Inj(NEG0(A#)): thm
val NEG0_def =
   {(A : set)}, 
   |- NEG0(A) = InjUU(A) o
        Pa(El(injN(A, num2)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Var0_def = {(A : set), (a : mem(A))},  |- Var0(a) = App(VAR0(A), a): thm
val DISJ0_Inj = {},  |- !(A : set). Inj(DISJ0(A#)): thm
val DISJ0_def =
   {(A : set)}, 
   |- DISJ0(A) = InjUU(A) o
        Pa(El(injN(A, num3)) o To1(Pow((N * (A + 1))) * Pow(N * (A + 1))),
         InjUU(A)): thm
val Neg0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- Neg0(f0) = App(NEG0(A), f0):
   thm
val DIAM0_Inj = {},  |- !(A : set). Inj(DIAM0(A#)): thm
val DIAM0_def =
   {(A : set)}, 
   |- DIAM0(A) = InjUU(A) o
        Pa(El(injN(A, num4)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Disj0_def =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- Disj0(f1, f2) = App(DISJ0(A), Pair(f1, f2)): thm
val Diam0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- Diam0(f0) = App(DIAM0(A), f0): thm
val f =
   (nas = F0 ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_cl =
   (nas = F0(A) ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_incond =
   !(nas : mem(Pow(N * (A + 1)))).
     IN(nas#, isfms1) <=>
     nas# = F0(A) |
     (?(p : mem(A)). nas# = Var0(p#)) |
     (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Neg0(f0#)) |
     (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
         IN(f1#, isfms0) & IN(f2#, isfms0) & nas# = Disj0(f1#, f2#)) |
     ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Diam0(f0#): form
val x1 = "isfms0": string
val isfmf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(Pow(N * (A + 1))), Pow(Pow(N * (A + 1))))).
        !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
          IN(nas#, App(f#, a#)) <=>
          nas# = F0(A) |
          (?(p : mem(A)). nas# = Var0(p#)) |
          (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
          (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
              IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
          ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
        IN(nas#, App(isfmf(A), a#)) <=>
        nas# = F0(A) |
        (?(p : mem(A)). nas# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(Pow(N * (A + 1)))))  (s2 : mem(Pow(Pow(N * (A + 1))))).
        SS(s1#, s2#) ==> SS(App(isfmf(A), s1#), App(isfmf(A), s2#)): thm
val isfm's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        IN(a#, isfm's(A)) <=> SS(App(isfmf(A), a#), a#): thm
val isfms_def = {(A : set)},  |- isfms(A) = BIGINTER(isfm's(A)): thm
val isfms_cond =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (!(ss : mem(Pow(Pow(N * (A + 1))))).
            SS(App(isfmf(A), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isfms(A)):
   thm
val isfms_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), a#), a#) ==> SS(isfms(A), a#): thm
val isfm_rules0 = {(A : set)},  |- SS(App(isfmf(A), isfms(A)), isfms(A)): thm
val isfm_cases0 = {(A : set)},  |- App(isfmf(A), isfms(A)) = isfms(A): thm
val isfm_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), ss#), ss#) ==> SS(isfms(A), ss#): thm
val isfm_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (!(a : mem(Pow(N * (A + 1)))).
            a# = F0(A) |
            (?(p : mem(A)). a# = Var0(p#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Neg0(f0#)) |
            (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj0(f1#, f2#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Diam0(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases1 =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules1 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        a# = F0(A) |
        (?(p : mem(A)). a# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Diam0(f0#)) ==>
        IN(a#, isfms(A)): thm
val isfm_rules2 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (a# = F0(A) ==> IN(a#, isfms(A))) &
        (!(p : mem(A)). a# = Var0(p#) ==> IN(a#, isfms(A))) &
        (!(f0 : mem(Pow(N * (A + 1)))).
            IN(f0#, isfms(A)) & a# = Neg0(f0#) ==> IN(a#, isfms(A))) &
        (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#) ==>
            IN(a#, isfms(A))) &
        !(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) & a# = Diam0(f0#) ==> IN(a#, isfms(A)): thm
val isfm_rules3 =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_def =
   {}, 
   |- !(A : set)  (f : mem(Pow(N * (A# + 1)))).
        isfm(f#) <=> IN(f#, isfms(A#)): thm
val isfm_induct =
   {}, 
   |- !(A : set).
        P(F0(A#)) &
        (!(p : mem(A#)). P(Var0(p#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Neg0(f0#))) &
        (!(f1 : mem(Pow(N * (A# + 1))))  (f2 : mem(Pow(N * (A# + 1)))).
            P(f1#) & P(f2#) ==> P(Disj0(f1#, f2#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Diam0(f0#))) ==>
        !(f0 : mem(Pow(N * (A# + 1)))). isfm(f0#) ==> P(f0#): thm
val isfm_F0 = {},  |- !(A : set). isfm(F0(A#)): thm
val isfm_Diam0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val isfm_Neg0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#)): thm
val isfm_Var0 = {},  |- !(A : set)  (p : mem(A#)). isfm(Var0(p#)): thm
val isfm_clauses =
   {(A : set)}, 
   |- isfm(F0(A)) &
      (!(p : mem(A)). isfm(Var0(p#))) &
      (!(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#))) &
      !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val form_def =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). a# = App(repf(A), b#): thm
val isfm_Disj0 =
   {(A : set)}, 
   |- !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
        isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#)): thm
val repf_Inj = {(A : set)},  |- Inj(repf(A)): thm
val Bot_def = {(A : set)},  |- Repf(Bot(A)) = F0(A): thm
val Repf_def =
   {},  |- !(A : set)  (f : mem(form(A#))). Repf(f#) = App(repf(A#), f#): thm
val VAR_def =
   {(A : set)},  |- !(a : mem(A)). App(repf(A) o VAR(A), a#) = Var0(a#): thm
val flip_fconv = fn: form -> thm
val form_def' =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). App(repf(A), b#) = a#: thm
val repf_isfm = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Repf(f0#)): thm
val VAR_VAR0 = {},  |- !(A : set). repf(A#) o VAR(A#) = VAR0(A#): thm
val VAR_Inj = {},  |- !(A : set). Inj(VAR(A#)): thm
val NEG_NEG0 = {},  |- !(A : set). repf(A#) o NEG(A#) = NEG0(A#) o repf(A#):
   thm
val NEG_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(NEG(A), a#)) = Neg0(Repf(a#)): thm
val Neg0_Repf = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Neg0(Repf(f0#))):
   thm
val NEG_Inj = {},  |- !(A : set). Inj(NEG(A#)): thm
val DIAM_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(DIAM(A), a#)) = Diam0(Repf(a#)): thm
val Diam0_Repf =
   {(A : set)},  |- !(f0 : mem(form(A))). isfm(Diam0(Repf(f0#))): thm
val form_def_uex =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (?!(b : mem(form(A))). a# = Repf(b#)) <=> isfm(a#): thm
val DISJ_DISJ0 =
   {}, 
   |- !(A : set). repf(A#) o DISJ(A#) = DISJ0(A#) o Prla(repf(A#), repf(A#)):
   thm
val DISJ_def =
   {(A : set)}, 
   |- !(a' : mem(form(A)))  (b : mem(form(A))).
        Repf(App(DISJ(A), Pair(a'#, b#))) = Disj0(Repf(a'#), Repf(b#)): thm
val DISJ_Inj = {},  |- !(A : set). Inj(DISJ(A#)): thm
val DIAM_DIAM0 =
   {},  |- !(A : set). repf(A#) o DIAM(A#) = DIAM0(A#) o repf(A#): thm
val DIAM_Inj = {},  |- !(A : set). Inj(DIAM(A#)): thm
val Diam_def =
   {(A : set), (f : mem(form(A)))},  |- Diam(f) = App(DIAM(A), f): thm
val Disj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Disj(f1, f2) = App(DISJ(A), Pair(f1, f2)): thm
val Neg_def = {(A : set), (f : mem(form(A)))},  |- Neg(f) = App(NEG(A), f):
   thm
val Var_def = {(A : set), (a : mem(A))},  |- Var(a) = App(VAR(A), a): thm
val Var_eq_eq =
   {(A : set)}, 
   |- !(p1 : mem(A))  (p2 : mem(A)). Var(p1#) = Var(p2#) <=> p1# = p2#: thm
val Neg_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Neg(f1#) = Neg(f2#) <=> f1# = f2#: thm
val Diam_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Diam(f1#) = Diam(f2#) <=> f1# = f2#: thm
val Disj_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A)))  (g1 : mem(form(A)))
      (g2 : mem(form(A))).
        Disj(f1#, f2#) = Disj(g1#, g2#) <=> f1# = g1# & f2# = g2#: thm
val Repf_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Repf(f1#) = Repf(f2#) <=> f1# = f2#: thm
val form_induct =
   {}, 
   |- !(A : set).
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Neg(f0#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Diam(f0#))) ==>
        !(f0 : mem(form(A#))). P(f0#): thm
val fmind's_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        IN(a#, fmind's(djf, dmf, nf, vf, x0)) <=>
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#): thm
val fmind_cases0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)) =
        fminds(djf, dmf, nf, vf, x0): thm
val fmind_cases1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_incond =
   !(p : mem(form(A) * X)).
     IN(p#, fmind1) <=>
     p# = Pair(Bot(A), x0) |
     (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
     ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
       IN(p1#, fmind0) &
       IN(p2#, fmind0) &
       p# =
         Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))):
   form
val fmind_ind =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), ss#): thm
val fmind_ind1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (!(a : mem(form(A) * X)).
            a# = Pair(Bot(A), x0) |
            (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
            (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
                IN(p1#, ss#) &
                IN(p2#, ss#) &
                a# =
                  Pair(Disj(Fst(p1#), Fst(p2#)),
                   App(djf, Pair(Snd(p1#), Snd(p2#))))) ==> IN(a#, ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_rules0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- SS(App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)),
       fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        a# = Pair(Bot(A), x0) |
        (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
            IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
            a# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#))))) ==>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (a# = Pair(Bot(A), x0) ==> IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(a' : mem(A)).
            a# = Pair(Var(a'#), App(vf, a'#)) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          a# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))) ==>
          IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules3 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val fmindf_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
        IN(p#, App(fmindf(djf, dmf, nf, vf, x0), a#)) <=>
        p# = Pair(Bot(A), x0) |
        (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, a#) &
          IN(p2#, a#) &
          p# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_ex =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(form(A) * X), Pow(form(A) * X))).
        !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Bot(A), x0) |
          (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
          ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, a#) &
            IN(p2#, a#) &
            p# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_monotone =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(form(A) * X)))  (s2 : mem(Pow(form(A) * X))).
        SS(s1#, s2#) ==>
        SS(App(fmindf(djf, dmf, nf, vf, x0), s1#),
         App(fmindf(djf, dmf, nf, vf, x0), s2#)): thm
val fminds_SS =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), a#): thm
val fminds_cond =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (!(ss : mem(Pow(form(A) * X))).
            SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fminds_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- fminds(djf, dmf, nf, vf, x0) = BIGINTER(fmind's(djf, dmf, nf, vf, x0)):
   thm
val x1 = "fmind0": string
val fmind_cases =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_rules =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val IN_F0 =
   {(A : set)}, 
   |- !(n : mem(N))  (a : mem(A + 1)). IN(Pair(n#, a#), F0(A)) <=> n# = O:
   thm
val IN_Var0 =
   {(A : set), (a0 : mem(A))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Var0(a0)) <=>
        Even(n#) & Div2(n#) = num1 | Odd(n#) & a# = SOME(a0): thm
val IN_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Neg0(f0)) <=>
        Even(n#) & Div2(n#) = num2 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Diam0(f0)) <=>
        Even(n#) & Div2(n#) = num4 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Disj0(f1, f2)) <=>
        Even(n#) & Div2(n#) = num3 |
        Odd(n#) &
        (Even(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f1) |
          Odd(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f2)): thm
val F0_NOT_Var0 = {(A : set), (p : mem(A))},  |- ~F0(A) = Var0(p): thm
val Bot_NOT_Var = {(A : set), (p : mem(A))},  |- ~Bot(A) = Var(p): thm
val F0_NOT_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- ~F0(A) = Disj0(f1, f2): thm
val Bot_NOT_Disj =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Bot(A) = Disj(f1, f2): thm
val F0_NOT_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Neg0(f0): thm
val Bot_NOT_Neg = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Neg(f): thm
val F0_NOT_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Diam0(f0): thm
val Bot_NOT_Diam = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Diam(f):
   thm
val Bot_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Bot(A#) = Var(p#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Neg(f#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Diam(f#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Bot(A#) = Disj(f1#, f2#): thm
val InjN_Inj = {},  |- !(A : set). Inj(InjN(A#)): thm
val Var0_NOT_Diam0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Diam0(f0): thm
val VAR_def' =
   {(A : set)},  |- !(a : mem(A)). Repf(App(VAR(A), a#)) = Var0(a#): thm
val Var_NOT_Diam =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Diam(f): thm
val Var0_NOT_Disj0 =
   {(A : set), (a : mem(A)), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Var0(a) = Disj0(f1, f2): thm
val Var_NOT_Disj =
   {(A : set), (a : mem(A)), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Var(a) = Disj(f1, f2): thm
val Var0_NOT_Neg0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Neg0(f0): thm
val Var_NOT_Neg =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Neg(f): thm
val Var_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Var(p#) = Bot(A#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Neg(f#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Diam(f#)) &
        !(p : mem(A#))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Var(p#) = Disj(f1#, f2#): thm
val Neg0_NOT_Diam0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Neg0(f) = Diam0(f0): thm
val Neg_NOT_Diam =
   {(A : set), (f : mem(form(A))), (f0 : mem(form(A)))}, 
   |- ~Neg(f) = Diam(f0): thm
val Neg0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Neg0(f) = Disj0(f1, f2): thm
val Neg_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Neg(f) = Disj(f1, f2): thm
val Neg_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Neg(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Neg(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Neg(f#) = Diam(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Neg(f#) = Disj(f1#, f2#): thm
val Diam0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Diam0(f) = Disj0(f1, f2): thm
val Diam_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Diam(f) = Disj(f1, f2): thm
val Diam_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Diam(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Diam(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Diam(f#) = Neg(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Diam(f#) = Disj(f1#, f2#): thm
val Disj_NOT =
   {}, 
   |- !(A : set).
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            ~Disj(f1#, f2#) = Bot(A#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (p : mem(A#)).
            ~Disj(f1#, f2#) = Var(p#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f0 : mem(form(A#))).
            ~Disj(f1#, f2#) = Diam(f0#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f : mem(form(A#))).
          ~Disj(f1#, f2#) = Neg(f#): thm
val fmind_Neg =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Neg(f), App(nf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_Disj =
   {}, 
   |- !(A : set)  (f1 : mem(form(A#)))  (X : set)  (djf : fun(X# * X#, X#))
      (dmf : fun(X#, X#))  (nf : fun(X#, X#))  (vf : fun(A#, X#))
      (x0 : mem(X#))  (x1 : mem(X#)).
        IN(Pair(f1#, x1#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
        !(f2 : mem(form(A#)))  (x2 : mem(X#)).
          IN(Pair(f2#, x2#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
          IN(Pair(Disj(f1#, f2#), App(djf#, Pair(x1#, x2#))),
           fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmind_Diam =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Diam(f), App(dmf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_uex =
   {(X : set)}, 
   |- !(A : set)  (x0 : mem(X))  (vf : fun(A#, X))  (nf : fun(X, X))
      (djf : fun(X * X, X))  (dmf : fun(X, X))  (f : mem(form(A#))).
        ?!(x : mem(X)). IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)):
   thm
val fmrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (a : mem(form(A#))).
        IN(Pair(a#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), a#)),
       fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val App_fmrec_fminds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (f : mem(form(A#)))  (x : mem(X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#) = x# <=>
        IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmrec_clauses =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), Bot(A#)) = x0# &
        (!(p : mem(A#)).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Var(p#)) = App(vf#, p#)) &
        (!(f : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Neg(f#)) =
              App(nf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Disj(f1#, f2#)) =
              App(djf#,
               Pair(App(fmrec(x0#, vf#, nf#, djf#, dmf#), f1#),
                App(fmrec(x0#, vf#, nf#, djf#, dmf#), f2#)))) &
        !(f : mem(form(A#))).
          App(fmrec(x0#, vf#, nf#, djf#, dmf#), Diam(f#)) =
            App(dmf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#)): thm
val it = (): unit
******

Loading SEAR file SEARUF.sml

******
val Inter_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val Inter_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val filter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- filter(L) <=>
      ~EMPTY(J) &
      IN(Whole(J), L) &
      (!(X : mem(Pow(J)))  (Y : mem(Pow(J))).
          IN(X#, L) & IN(Y#, L) ==> IN(Inter(X#, Y#), L)) &
      !(X : mem(Pow(J))).
        IN(X#, L) ==> !(Y : mem(Pow(J))). SS(X#, Y#) ==> IN(Y#, L): thm
val ufilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). ~IN(Compl(X#), L) <=> IN(X#, L): thm
val ufilter_filter =
   {},  |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> filter(L#):
   thm
val SS_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val SS_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val Whole_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). filter(L#) ==> IN(Whole(J#), L#):
   thm
val Whole_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> IN(Whole(J#), L#):
   thm
val Empty_NOTIN_UF =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> ~IN(Empty(J#), L#):
   thm
val IN_UF_NONEMPTY =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==> !(X : mem(Pow(J#))). IN(X#, L#) ==> ~X# = Empty(J#):
   thm
val Repu_def = {(J : set), (u : mem(UFs(J)))},  |- Repu(u) = App(iUF(J), u):
   thm
val Repu_ufilter = {},  |- !(A : set)  (u : mem(UFs(A#))). ufilter(Repu(u#)):
   thm
val UFs_def =
   {(J : set)}, 
   |- Inj(iUF(J)) &
      !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = App(iUF(J), b#): thm
val from_UFs =
   {(J : set)}, 
   |- !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = Repu(b#): thm
val Empty_NOTIN_UFs =
   {},  |- !(J : set)  (u : mem(UFs(J#))). ~IN(Empty(J#), Repu(u#)): thm
val ufilter_alt =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). IN(Compl(X#), L) <=> ~IN(X#, L): thm
val Compl_Repu =
   {(J : set), (X : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Compl(X), Repu(u)) <=> ~IN(X, Repu(u)): thm
val Union_Repu =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Union(s1, s2), Repu(u)) <=> IN(s1, Repu(u)) | IN(s2, Repu(u)): thm
val CUI_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- CUI(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        IN(BIGINTER(ss0#), ss): thm
val CUI_iff_binary =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#)))).
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) <=>
        !(s : mem(Pow(Pow(W#)))).
          SS(s#, A#) & Fin(s#) & ~s# = Empty(Pow(W#)) ==>
          IN(BIGINTER(s#), A#): thm
val FIP_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- FIP(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        ~BIGINTER(ss0#) = Empty(A): thm
val FIP_CUI_lemma =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        ~IN(Empty(W#), A#) & ~IN(Empty(W#), B#): thm
val FIP_closed_under_Inter =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) &
        (!(b1 : mem(Pow(W#))).
            IN(b1#, B#) ==>
            !(b2 : mem(Pow(W#))). IN(b2#, B#) ==> IN(Inter(b1#, b2#), B#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        FIP(Union(A#, B#)): thm
val IN_gfilter =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(x : mem(Pow(A))).
        IN(x#, gfilter(s)) <=>
        !(ss : mem(Pow(Pow(A)))). SS(s, ss#) & filter(ss#) ==> IN(x#, ss#):
   thm
val gfilter_def =
   {(A : set), (s : mem(Pow(Pow(A))))},  |- gfilter(s) = BIGINTER(gfss(s)):
   thm
val gfilter_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter(s#)): thm
val gfilter_ind =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(A#)))).
        SS(s#, ss#) & filter(ss#) ==>
        !(x : mem(Pow(A#))). IN(x#, gfilter(s#)) ==> IN(x#, ss#): thm
val gfss_def =
   {(A : set), (s0 : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(Pow(A)))). IN(a#, gfss(s0)) <=> SS(s0, a#) & filter(a#):
   thm
val SS_gfilter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter(s#)): thm
val pfilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- pfilter(L) <=> filter(L) & ~L = Whole(Pow(J)): thm
val gfilter1_def =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, gfilter1(s)) <=>
        a# = Whole(A) |
        ?(ss : mem(Pow(Pow(A)))).
          SS(ss#, s) &
          Fin(ss#) & ~ss# = Empty(Pow(A)) & SS(BIGINTER(ss#), a#): thm
val gfilter1_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter1(s#)): thm
val SS_gfilter1 =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter1(s#)): thm
val CUI_filter =
   {},  |- !(A : set)  (L : mem(Pow(Pow(A#)))). filter(L#) ==> CUI(L#): thm
val gfilter_gfilter1 =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) ==> gfilter(s#) = gfilter1(s#): thm
val Empty_NOTIN_pfilter =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) <=> filter(s#) & ~IN(Empty(A#), s#): thm
val FIP_Empty_NOTIN_gfilter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))). FIP(s#) ==> ~IN(Empty(A#), gfilter(s#)):
   thm
val FIP_PSUBSET_proper_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))).
          FIP(s#) ==> ?(v : mem(Pow(Pow(A#)))). pfilter(v#) & SS(s#, v#): thm
val filter_Whole = {},  |- !(J : set). ~EMPTY(J#) ==> filter(Whole(Pow(J#))):
   thm
val filter_Empty_Whole =
   {}, 
   |- !(J : set).
        ~EMPTY(J#) ==>
        !(L : mem(Pow(Pow(J#)))).
          filter(L#) & IN(Empty(J#), L#) <=> L# = Whole(Pow(J#)): thm
val ufilter_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        ufilter(u#) ==>
        !(s : mem(Pow(Pow(J#)))).
          filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#)): thm
val CUI_Empty_NOTIN_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        CUI(s#) & ~IN(Empty(W#), s#) ==> FIP(s#): thm
val pfilter_FIP =
   {},  |- !(W : set)  (s : mem(Pow(Pow(W#)))). pfilter(s#) ==> FIP(s#): thm
val pfilter_filter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). pfilter(s#) ==> filter(s#):
   thm
val pfilter_INSERT_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        pfilter(s#) ==>
        !(b : mem(Pow(W#))).
          ~IN(b#, s#) & ~IN(Compl(b#), s#) ==> FIP(Ins(b#, s#)): thm
val maximal_ufilter =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        (!(s : mem(Pow(Pow(J#)))).
            filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) ==> ufilter(u#):
   thm
val chain_def =
   {(A : set), (R : rel(A, A)), (t : mem(Pow(A)))}, 
   |- chain(t, R) <=>
      !(a1 : mem(A))  (a2 : mem(A)).
        IN(a1#, t) & IN(a2#, t) ==> Holds(R, a1#, a2#) | Holds(R, a2#, a1#):
   thm
val ismax_def =
   {(A : set), (R : rel(A, A)), (m : mem(A))}, 
   |- ismax(R, m) <=> !(x : mem(A)). Holds(R, m, x#) ==> x# = m: thm
val ptorder_def =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> Trans(R) & Refl(R) & Asym(R): thm
val ubound_def =
   {(A : set), (R : rel(A, A)), (s : mem(Pow(A))), (x : mem(A))}, 
   |- ubound(s, R, x) <=> !(y : mem(A)). IN(y#, s) ==> Holds(R, y#, x): thm
******

Loading SEAR file zorns.sml

******
val AC =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). Holds(R#, a#, App(f#, a#)): thm
val antisym_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        antisym(r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, x#), r#) ==> x# = y#: thm
val chain0_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        chain0(s#, r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==>
          IN(Pair(x#, y#), r#) | IN(Pair(y#, x#), r#): thm
val domain_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, domain(r#)) <=> ?(y : mem(A#)). IN(Pair(a#, y#), r#): thm
val ischoice_def =
   {(A : set), (f : fun(Pow(A), A)), (s : mem(Pow(Pow(A))))}, 
   |- ischoice(f, s) <=>
      ~IN(Empty(A), s) &
      !(s0 : mem(Pow(A))). IN(s0#, s) ==> IN(App(f, s0#), s0#): thm
val ischoice_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) & ~IN(Empty(A#), s#) ==>
        ?(f : fun(Pow(A#), A#)). ischoice(f#, s#): thm
val maximal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, maximal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(a#, x'#), r#) ==> a# = x'#:
   thm
val minimal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, minimal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(x'#, a#), r#) ==> a# = x'#:
   thm
val partial_order_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        partial_order(r#, s#) <=>
        SS(domain(r#), s#) &
        SS(range(r#), s#) & transitive(r#) & reflexive(r#, s#) & antisym(r#):
   thm
val range_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, range(r#)) <=> ?(x : mem(A#)). IN(Pair(x#, a#), r#): thm
val reflexive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        reflexive(r#, s#) <=>
        !(x : mem(A#)). IN(x#, s#) ==> IN(Pair(x#, x#), r#): thm
val transitive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        transitive(r#) <=>
        !(x : mem(A#))  (y : mem(A#))  (z : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, z#), r#) ==>
          IN(Pair(x#, z#), r#): thm
val upper_bounds_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, upper_bounds(s#, r#)) <=>
        IN(a#, range(r#)) &
        !(y : mem(A#)). IN(y#, s#) ==> IN(Pair(y#, a#), r#): thm
val fchains_def =
   {(A : set), (f : fun(Pow(A), A)), (r : mem(Pow(A * A)))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, fchains(r, f)) <=>
        chain0(a#, r) &
        ~a# = Empty(A) &
        !(C : mem(Pow(A))).
          chain0(C#, r) &
          SS(C#, a#) & ~Inter(Diff(upper_bounds(C#, r), C#), a#) = Empty(A) ==>
          IN(App(f, Diff(upper_bounds(C#, r), C#)),
           minimal_elements(Inter(Diff(upper_bounds(C#, r), C#), a#), r)):
   thm
val hatclass_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(Pow(A#))).
        IN(a#, hatclass(r#)) <=>
        ~a# = Empty(A#) &
        ?(C : mem(Pow(A#))). a# = Diff(upper_bounds(C#, r#), C#): thm
val lemma1 =
   {(A : set)}, 
   |- !(x : mem(A))  (s : mem(Pow(A)))  (r : mem(Pow(A * A))).
        chain0(s#, r#) & IN(x#, s#) ==>
        IN(x#, domain(r#)) & IN(x#, range(r#)): thm
val lemma2 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A)))  (x : mem(A))  (x' : mem(A)).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        IN(k1#, fchains(r#, f#)) &
        IN(k2#, fchains(r#, f#)) & IN(x#, k1#) & IN(x'#, k2#) & ~IN(x'#, k1#) ==>
        IN(Pair(x#, x'#), r#): thm
val lemma3 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) & IN(k1#, fchains(r#, f#)) & IN(k2#, fchains(r#, f#)) ==>
        SS(k1#, k2#) | SS(k2#, k1#): thm
val lemma4 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A)).
        ischoice(f#, hatclass(r#)) & antisym(r#) & transitive(r#) ==>
        chain0(BIGUNION(fchains(r#, f#)), r#) &
        !(x : mem(A))  (x' : mem(A))  (k : mem(Pow(A))).
          IN(Pair(x'#, x#), r#) &
          IN(x'#, BIGUNION(fchains(r#, f#))) &
          IN(x#, BIGUNION(fchains(r#, f#))) &
          IN(k#, fchains(r#, f#)) & IN(x#, k#) ==> IN(x'#, k#): thm
val lemma5 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) & ~range(r#) = Empty(A) & reflexive(r#, s#) ==>
        IN(Sing(App(f#, range(r#))), fchains(r#, f#)): thm
val lemma6 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (k : mem(Pow(A)))
      (x : mem(A))  (C : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) &
        IN(k#, fchains(r#, f#)) &
        IN(x#, k#) &
        chain0(C#, r#) &
        IN(x#, Diff(upper_bounds(C#, r#), C#)) &
        SS(C#, BIGUNION(fchains(r#, f#))) ==>
        IN(App(f#, Diff(upper_bounds(C#, r#), C#)), k#) &
        IN(Pair(App(f#, Diff(upper_bounds(C#, r#), C#)), x#), r#): thm
val lemma7 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        IN(BIGUNION(fchains(r#, f#)), fchains(r#, f#)): thm
val lemma8 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A)))
      (k : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        reflexive(r#, s#) &
        antisym(r#) &
        transitive(r#) &
        IN(k#, fchains(r#, f#)) & ~Diff(upper_bounds(k#, r#), k#) = Empty(A) ==>
        IN(Ins(App(f#, Diff(upper_bounds(k#, r#), k#)), k#), fchains(r#, f#)):
   thm
val upper_bounds_lem =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A)))  (x1 : mem(A))
      (x2 : mem(A)).
        transitive(r#) &
        IN(x1#, upper_bounds(s#, r#)) & IN(Pair(x1#, x2#), r#) ==>
        IN(x2#, upper_bounds(s#, r#)): thm
val lemma9 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        SS(upper_bounds(BIGUNION(fchains(r#, f#)), r#),
         maximal_elements(s#, r#)): thm
val zorns_lemma0 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A))).
        ~s# = Empty(A) &
        partial_order(r#, s#) &
        (!(t : mem(Pow(A))).
            chain0(t#, r#) ==> ~upper_bounds(t#, r#) = Empty(A)) ==>
        ?(x : mem(A)). IN(x#, maximal_elements(s#, r#)): thm
val Trans_transitive =
   {},  |- !(A : set)  (R : rel(A#, A#)). Trans(R#) <=> transitive(r2m(R#)):
   thm
val Refl_reflexive =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> reflexive(r2m(R#), Whole(A#)): thm
val Asym_antisym =
   {},  |- !(A : set)  (R : rel(A#, A#)). Asym(R#) <=> antisym(r2m(R#)): thm
val ptorder_partial_order =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> partial_order(r2m(R), Whole(A)): thm
val zorns_lemma =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ~EMPTY(A#) & ptorder(R#) ==>
        (!(c : mem(Pow(A#))).
            chain(c#, R#) & ~c# = Empty(A#) ==>
            ?(ub : mem(A#)). ubound(c#, R#, ub#)) ==>
        ?(m : mem(A#)). ismax(R#, m#): thm
val it = (): unit
val ufilter_iff_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        ((!(s : mem(Pow(Pow(J#)))).
              filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) <=>
          ufilter(u#)): thm
val UNION_chain_filter_filter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> filter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          filter(BIGUNION(ss#)): thm
val UNION_chain_pfilter_pfilter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> pfilter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          pfilter(BIGUNION(ss#)): thm
val ufilter_thm =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) ==> ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(s#, u#):
   thm
val ufilter_thm_coro =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==>
        ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(ss#, u#): thm
val Prop_5_3 =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==> ?(u : mem(UFs(A#))). SS(ss#, Repu(u#)): thm
val FIP_Sing =
   {},  |- !(W : set)  (a : mem(Pow(W#))). ~a# = Empty(W#) ==> FIP(Sing(a#)):
   thm
val it = (): unit
******

Loading SEAR file SEARmmmt.sml

******
val Rm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w1 : mem(W)), (w2 : mem(W))}, 
   |- Rm(M, w1, w2) <=> IN(Pair(w1, w2), Rof(M)): thm
val Rof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Rof(M#) = Fst(M#): thm
val Vof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Vof(M#) = tof(Snd(M#)): thm
val HAT_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(A))  (w : mem(W)).
        IN(w#, App(HAT(M), a#)) <=> IN(a#, App(Vof(M), w#)): thm
val satis_def0 =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A))), (w : mem(W))}, 
   |- satis(M, w, f) <=> IN(w, App(satisf(M), f)): thm
val satis_dmf =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(Pow(W)))  (w : mem(W)).
        IN(w#, App(sdmf(M), a#)) <=>
        ?(w0 : mem(W)). IN(w0#, a#) & Rm(M, w#, w0#): thm
val satisf_clause =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- App(satisf(M), Bot(A)) = Empty(W) &
      (!(p : mem(A)). App(satisf(M), Var(p#)) = App(HAT(M), p#)) &
      (!(f : mem(form(A))).
          App(satisf(M), Neg(f#)) = App(COMPL(W), App(satisf(M), f#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          App(satisf(M), Disj(f1#, f2#)) =
            App(UNION(W), Pair(App(satisf(M), f1#), App(satisf(M), f2#)))) &
      !(f : mem(form(A))).
        App(satisf(M), Diam(f#)) = App(sdmf(M), App(satisf(M), f#)): thm
val satisf_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- satisf(M) = fmrec(Empty(W), HAT(M), COMPL(W), UNION(W), sdmf(M)): thm
val satis_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))}, 
   |- ~satis(M, w, Bot(A)) &
      (!(a : mem(A)). satis(M, w, Var(a#)) <=> IN(a#, App(Vof(M), w))) &
      (!(f : mem(form(A))). satis(M, w, Neg(f#)) <=> ~satis(M, w, f#)) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          satis(M, w, Disj(f1#, f2#)) <=> satis(M, w, f1#) | satis(M, w, f2#)) &
      !(f : mem(form(A))).
        satis(M, w, Diam(f#)) <=>
        ?(v : mem(W)). Rm(M, w, v#) & satis(M, v#, f#): thm
val SATIS_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (fs : mem(Pow(form(A)))), (w : mem(W))}, 
   |- SATIS(M, w, fs) <=> !(f : mem(form(A))). IN(f#, fs) ==> satis(M, w, f#):
   thm
val Top_def = {(A : set)},  |- Top(A) = Neg(Bot(A)): thm
val Conj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Conj(f1, f2) = Neg(Disj(Neg(f1), Neg(f2))): thm
val satis_Conj =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f1 : mem(form(A)))  (f2 : mem(form(A))).
        satis(M#, w#, Conj(f1#, f2#)) <=>
        satis(M#, w#, f1#) & satis(M#, w#, f2#): thm
val PE's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). IN(a#, PE's(A)) <=> SS(App(PEf(A), a#), a#):
   thm
val PE_cases0 = {(A : set)},  |- App(PEf(A), PEs(A)) = PEs(A): thm
val PE_cases1 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_incond =
   !(f : mem(form(A))).
     IN(f#, PEs1) <=>
     f# = Top(A) |
     f# = Bot(A) |
     (?(p : mem(A)). f# = Var(p#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Conj(f1#, f2#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Disj(f1#, f2#)) |
     ?(f0 : mem(form(A))). IN(f0#, PEs0) & f# = Diam(f0#): form
val PE_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        (!(a : mem(form(A))).
            a# = Top(A) |
            a# = Bot(A) |
            (?(p : mem(A)). a# = Var(p#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Conj(f1#, f2#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj(f1#, f2#)) |
            (?(f0 : mem(form(A))). IN(f0#, ss#) & a# = Diam(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_rules0 = {(A : set)},  |- SS(App(PEf(A), PEs(A)), PEs(A)): thm
val PE_rules1 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        a# = Top(A) |
        a# = Bot(A) |
        (?(p : mem(A)). a# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#)) |
        (?(f0 : mem(form(A))). IN(f0#, PEs(A)) & a# = Diam(f0#)) ==>
        IN(a#, PEs(A)): thm
val PE_rules2 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (a# = Top(A) ==> IN(a#, PEs(A))) &
        (a# = Bot(A) ==> IN(a#, PEs(A))) &
        (!(p : mem(A)). a# = Var(p#) ==> IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        !(f0 : mem(form(A))).
          IN(f0#, PEs(A)) & a# = Diam(f0#) ==> IN(a#, PEs(A)): thm
val PE_rules3 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PEf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A))))  (f : mem(form(A))).
        IN(f#, App(PEf(A), a#)) <=>
        f# = Top(A) |
        f# = Bot(A) |
        (?(p : mem(A)). f# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(form(A)), Pow(form(A)))).
        !(a : mem(Pow(form(A))))  (f : mem(form(A))).
          IN(f#, App(f#, a#)) <=>
          f# = Top(A) |
          f# = Bot(A) |
          (?(p : mem(A)). f# = Var(p#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
          ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==> SS(App(PEf(A), s1#), App(PEf(A), s2#)): thm
val PEs_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). SS(App(PEf(A), a#), a#) ==> SS(PEs(A), a#):
   thm
val PEs_cond =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (!(ss : mem(Pow(form(A)))). SS(App(PEf(A), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, PEs(A)): thm
val PEs_def = {(A : set)},  |- PEs(A) = BIGINTER(PE's(A)): thm
val x1 = "PEs0": string
val PE_cases0 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_rules0 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PE_def0 = {(A : set), (f : mem(form(A)))},  |- PE(f) <=> IN(f, PEs(A)):
   thm
val PE_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). PE(a#) ==> IN(a#, ss#): thm
val PE_cases =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        PE(x#) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). PE(f0#) & x# = Diam(f0#): thm
val PE_rules =
   {(A : set)}, 
   |- PE(Top(A)) &
      PE(Bot(A)) &
      (!(p : mem(A)). PE(Var(p#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#))) &
      !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val PE_induct =
   {}, 
   |- !(A : set).
        P(Top(A#)) &
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Conj(f1#, f2#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f : mem(form(A#))). P(f#) ==> P(Diam(f#))) ==>
        !(f : mem(form(A#))). PE(f#) ==> P(f#): thm
val satis_Bot =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
      (w : mem(W#)). ~satis(M#, w#, Bot(A#)): thm
val satis_Top =
   {(W : set)}, 
   |- !(A : set)  (M : mem(Pow((W * W)) * Exp(W, Pow(A#))))  (w : mem(W)).
        satis(M#, w#, Top(A#)): thm
val PUS_Var = {},  |- !(A : set)  (p : mem(A#)). PUS(Var(p#)): thm
val PUS_def =
   {(A : set), (f : mem(form(A)))}, 
   |- PUS(f) <=>
      !(W1 : set)  (W2 : set)  (R : rel(W1#, W2#))
      (M1 : mem(Pow((W1# * W1#)) * Exp(W1#, Pow(A))))
      (M2 : mem(Pow((W2# * W2#)) * Exp(W2#, Pow(A)))).
        Sim(R#, M1#, M2#) ==>
        !(w1 : mem(W1#))  (w2 : mem(W2#)).
          Holds(R#, w1#, w2#) ==> satis(M1#, w1#, f) ==> satis(M2#, w2#, f):
   thm
val Sim_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (R : rel(W1, W2)),
    (W1 : set), (W2 : set)}, 
   |- Sim(R, M1, M2) <=>
      !(w1 : mem(W1))  (w2 : mem(W2)).
        Holds(R, w1#, w2#) ==>
        (!(p : mem(A)).
            IN(p#, App(Vof(M1), w1#)) ==> IN(p#, App(Vof(M2), w2#))) &
        !(v : mem(W1)).
          Rm(M1, w1#, v#) ==>
          ?(v' : mem(W2)). Holds(R, v#, v'#) & Rm(M2, w2#, v'#): thm
val PUS_Top = {},  |- !(A : set). PUS(Top(A#)): thm
val PUS_Bot = {},  |- !(A : set). PUS(Bot(A#)): thm
val Thm_6_25_r2l0 =
   {},  |- !(A : set)  (f : mem(form(A#))). PE(f#) ==> PUS(f#): thm
val EQV_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- EQV(f1, f2) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, f1) <=> satis(M#, w#, f2): thm
val Thm_6_25_r2l =
   {}, 
   |- !(A : set)  (f : mem(form(A#)))  (f0 : mem(form(A#))).
        PE(f0#) & EQV(f#, f0#) ==> PUS(f#): thm
val Fsab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Fsab(fs, X, M) <=>
      !(ss : mem(Pow(form(A)))). Fin(ss#) & SS(ss#, fs) ==> Sab(ss#, X, M):
   thm
val Msat_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- Msat(M) <=>
      !(w : mem(W))  (fs : mem(Pow(form(A)))).
        Fsab(fs#, Sucm(M, w#), M) ==> Sab(fs#, Sucm(M, w#), M): thm
val Sab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Sab(fs, X, M) <=> ?(x : mem(W)). IN(x#, X) & SATIS(M, x#, fs): thm
val Sucm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))},  |- !(a : mem(W)). IN(a#, Sucm(M, w)) <=> Rm(M, w, a#):
   thm
val Tat_def =
   {(A : set), (W : set), (a : mem(A)), (f0 : fun(W, Pow(A)))}, 
   |- !(a' : mem(W)). IN(a'#, Tat(f0, a)) <=> IN(a, App(f0, a'#)): thm
val fun_mem_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(f : fun(A#, B#)). P(f#)) <=> ?(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val mem_fun_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(m : mem(Exp(A#, B#))). P(m#)) <=> ?(f : fun(A#, B#)). P(Tpm(f#)):
   thm
val fun_mem_uex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?!(f : fun(A#, B#)). P(f#)) <=> ?!(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val UE_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- UE(M) = Pair(ueR(M), ueV(M)): thm
val csee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, csee(M, X)) <=> ?(v : mem(W)). Rm(M, a#, v#) & IN(v#, X): thm
val osee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, osee(M, X)) <=> !(v : mem(W)). Rm(M, a#, v#) ==> IN(v#, X):
   thm
val ueR_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a' : mem(UFs(W)))  (b : mem(UFs(W))).
        IN(Pair(a'#, b#), ueR(M)) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(b#)) ==> IN(csee(M, X#), Repu(a'#)):
   thm
val ueV_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(u : mem(UFs(W)))  (a : mem(A)).
        IN(a#, App(tof(ueV(M)), u#)) <=> IN(Tat(Vof(M), a#), Repu(u#)): thm
val ufilter_Compl =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))). ~IN(Compl(X#), L#) <=> IN(X#, L#): thm
val exists_forall_dual =
   {},  |- !(A : set). (?(a : mem(A#)). P(a#)) <=> ~!(a : mem(A#)). ~P(a#):
   thm
val Prop_5_4_1 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        csee(M#, X#) = Compl(osee(M#, Compl(X#))): thm
val Prop_5_4_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        osee(M#, X#) = Compl(csee(M#, Compl(X#))): thm
val Prop_5_6 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val MEQ_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (W1 : set), (W2 : set),
    (w1 : mem(W1)), (w2 : mem(W2))}, 
   |- MEQ(M1, w1, M2, w2) <=>
      !(f : mem(form(A))). satis(M1, w1, f#) <=> satis(M2, w2, f#): thm
val pufilter_def =
   {(A : set), (a : mem(A))}, 
   |- !(a' : mem(Pow(A))). IN(a'#, pufilter(a)) <=> IN(a, a'#): thm
val pufilter_filter =
   {},  |- !(A : set)  (a : mem(A#)). filter(pufilter(a#)): thm
val ueR_alt =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val pufilter_ufilter =
   {},  |- !(A : set)  (a : mem(A#)). ufilter(pufilter(a#)): thm
val Repu_eq_eq =
   {}, 
   |- !(W : set)  (u1 : mem(UFs(W#)))  (u2 : mem(UFs(W#))).
        Repu(u1#) = Repu(u2#) ==> u1# = u2#: thm
val Pft_def =
   {(W : set), (w0 : mem(W))}, 
   |- !(ws : mem(Pow(W))). IN(ws#, Repu(Pft(w0))) <=> IN(w0, ws#): thm
val Prop_5_5_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W)))
      (Y : mem(Pow(W))).
        osee(M#, Inter(X#, Y#)) = Inter(osee(M#, X#), osee(M#, Y#)): thm
val SW_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(form(A)))  (w : mem(W)).
        IN(w#, App(SW(M), a#)) <=> satis(M, w#, a#): thm
val Sw_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A)))},  |- Sw(M, f) = App(SW(M), f): thm
val Sw_Bot =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Sw(M#, Bot(A)) = Empty(W):
   thm
val Sw_Var =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        Sw(M#, Var(p#)) = App(HAT(M#), p#): thm
val Vof_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Vof(UE(M#)) = tof(ueV(M#)):
   thm
val HAT_Tat =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        App(HAT(M#), p#) = Tat(Vof(M#), p#): thm
val Sw_Neg =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        Sw(M#, Neg(f#)) = Compl(Sw(M#, f#)): thm
val Sw_Disj =
   {(A : set), (W : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        Sw(M#, Disj(f1, f2)) = Union(Sw(M#, f1), Sw(M#, f2)): thm
val Rm_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (u' : mem(UFs(W))).
        Rm(UE(M#), u#, u'#) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(u'#)) ==> IN(csee(M#, X#), Repu(u#)):
   thm
val csee_Sw_DIAM =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        csee(M#, Sw(M#, f#)) = Sw(M#, Diam(f#)): thm
val Prop_5_8 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
      (phi : mem(form(A)))  (u : mem(UFs(W#))).
        IN(Sw(M#, phi#), Repu(u#)) <=> satis(UE(M#), u#, phi#): thm
val Prop_5_7 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        MEQ(M#, w#, UE(M#), Pft(w#)): thm
val SATIS_Sing =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f : mem(form(A))). SATIS(M#, w#, Sing(f#)) <=> satis(M#, w#, f#): thm
val Fin_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(s1#) | Fin(s2#) ==> Fin(Inter(s1#, s2#)): thm
val SATIS_Union =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SATIS(M#, w#, Union(s1#, s2#)) <=>
        SATIS(M#, w#, s1#) & SATIS(M#, w#, s2#): thm
val only_see_whole_world =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        osee(M#, Whole(W)) = Whole(W): thm
val SATIS_Empty =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        SATIS(M#, w#, Empty(form(A))): thm
val BIGCONJ_EXISTS =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        ?(ff : mem(form(A))).
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val SS_Union_of =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s1#, s#) & SS(s2#, s#) ==> SS(Union(s1#, s2#), s#): thm
val Prop_5_9 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Msat(UE(M#)): thm
val PE_BIGCONJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val PE_Conj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#)): thm
val PE_BIGDISJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)).
            satis(M#, w#, ff#) <=>
            ?(f : mem(form(A))). IN(f#, s#) & satis(M#, w#, f#): thm
val PE_Disj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#)): thm
val PE_Diam =
   {(A : set)},  |- !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val Thm_6_22 =
   {(A : set), (W1 : set), (W2 : set)}, 
   |- !(M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A))))
      (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))).
        Msat(M1#) & Msat(M2#) ==>
        !(w1 : mem(W1))  (w2 : mem(W2)).
          (!(f : mem(form(A))).
              PE(f#) ==> satis(M1#, w1#, f#) ==> satis(M2#, w2#, f#)) ==>
          ?(R : rel(W1, W2)). Sim(R#, M1#, M2#) & Holds(R#, w1#, w2#): thm
val ENT_def =
   {(A : set), (phis : mem(Pow(form(A)))), (psi : mem(form(A)))}, 
   |- ENT(phis, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        SATIS(M#, w#, phis) ==> satis(M#, w#, psi): thm
val MCOMPACT_def =
   {}, 
   |- MCOMPACT <=>
      !(A : set)  (fs : mem(Pow(form(A#)))).
        (!(ffs : mem(Pow(form(A#)))).
            SS(ffs#, fs#) & Fin(ffs#) ==>
            ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
            (w : mem(W#)). SATIS(M#, w#, ffs#)) ==>
        ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
        (w : mem(W#)). SATIS(M#, w#, fs#): thm
val satis_Neg =
   {(A : set), (W : set), (f : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        satis(M#, w#, Neg(f)) <=> ~satis(M#, w#, f): thm
val Ent_def =
   {(A : set), (phi : mem(form(A))), (psi : mem(form(A)))}, 
   |- Ent(phi, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, phi) ==> satis(M#, w#, psi): thm
val SATIS_SS =
   {(A : set), (W : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==>
        !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
          SATIS(M#, w#, s2#) ==> SATIS(M#, w#, s1#): thm
val Thm_6_24 =
   {(A : set)}, 
   |- MCOMPACT ==>
      !(fs : mem(Pow(form(A))))  (phi : mem(form(A))).
        ENT(fs#, phi#) ==>
        ?(ffs : mem(Pow(form(A)))).
          SS(ffs#, fs#) & Fin(ffs#) & ENT(ffs#, phi#): thm
val Fin_ENT_PE =
   {(A : set)}, 
   |- !(fs : mem(Pow(form(A)))).
        Fin(fs#) & (!(f : mem(form(A))). IN(f#, fs#) ==> PE(f#)) ==>
        ?(phi : mem(form(A))).
          PE(phi#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). SATIS(M#, w#, fs#) <=> satis(M#, w#, phi#): thm
val PEC_def =
   {(A : set), (f : mem(form(A)))}, 
   |- !(a : mem(form(A))). IN(a#, PEC(f)) <=> PE(a#) & Ent(f, a#): thm
val SATIS_PEC =
   {(A : set), (W : set)}, 
   |- !(f : mem(form(A)))  (M : mem(Pow((W * W)) * Exp(W, Pow(A))))
      (w : mem(W)). satis(M#, w#, f#) ==> SATIS(M#, w#, PEC(f#)): thm
val Del_Fin =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        Fin(Del(s#, a#)) ==> Fin(s#): thm
val Fin_Inj0 =
   {}, 
   |- !(B : set)  (s : mem(Pow(B#))).
        Fin(s#) ==>
        !(A : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
          s# = IMAGE(f#, ss#) ==> Inj(f#) ==> Fin(ss#): thm
val Fin_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(ss : mem(Pow(A#))). Fin(IMAGE(f#, ss#)) ==> Fin(ss#):
   thm
val Thm_6_25_iff =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) <=> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val Thm_6_25_l2r =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) ==> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val it = (): unit
******

Loading SEAR file SEARllist.sml

******
val IN_gfp =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (a : mem(A)).
        IN(a#, gfp(f#)) <=>
        ?(sa : mem(Pow(A))). SS(sa#, App(f#, sa#)) & IN(a#, sa#): thm
val gfp_def =
   {}, 
   |- !(A : set)  (f : fun(Pow(A#), Pow(A#))). gfp(f#) = BIGUNION(prims(f#)):
   thm
val prims_def =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- !(a : mem(Pow(A))). IN(a#, prims(f)) <=> SS(a#, App(f, a#)): thm
val weak_coind =
   {}, 
   |- !(A : set)  (sa : mem(Pow(A#)))  (a : mem(A#))
      (f : fun(Pow(A#), Pow(A#))).
        IN(a#, sa#) & SS(sa#, App(f#, sa#)) ==> IN(a#, gfp(f#)): thm
val SS_gfp_fgfp =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(gfp(f), App(f, gfp(f))): thm
val monotone_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(Pow(A#), Pow(B#))).
        monotone(f#) <=>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          SS(s1#, s2#) ==> SS(App(f#, s1#), App(f#, s2#)): thm
val rules0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(App(f, gfp(f)), gfp(f)): thm
val cases0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> gfp(f) = App(f, gfp(f)): thm
val coind0 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (sa : mem(Pow(A))).
        SS(sa#, App(f#, sa#)) ==> SS(sa#, gfp(f#)): thm
val lcons0_def =
   {}, 
   |- !(X : set)  (f0 : fun(N, X# + 1))  (x : mem(X#)).
        App(lcons0(x#, f0#), O) = SOME(x#) &
        !(n : mem(N)). App(lcons0(x#, f0#), Suc(n#)) = App(f0#, n#): thm
val llf_uex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Exp(N, X + 1)), Pow(Exp(N, X + 1)))).
        !(gs : mem(Pow(Exp(N, X + 1))))  (g : mem(Exp(N, X + 1))).
          IN(g#, App(f#, gs#)) <=>
          g# = Tpm(Null(X)) |
          ?(h : mem(X))  (t : fun(N, X + 1)).
            g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_def =
   {}, 
   |- !(X : set)  (gs : mem(Pow(Exp(N, X# + 1))))  (g : mem(Exp(N, X# + 1))).
        IN(g#, App(llf(X#), gs#)) <=>
        g# = Tpm(Null(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_monotone = {},  |- !(X : set). monotone(llf(X#)): thm
val islls_def = {(X : set)},  |- islls(X) = gfp(llf(X)): thm
val llist_def1 =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          IN(a#, islls(X#)) <=>
          ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_Inj = {},  |- !(X : set). Inj(repll(X#)): thm
val isll_def =
   {}, 
   |- !(X : set)  (l : mem(Exp(N, X# + 1))). isll(l#) <=> IN(l#, islls(X#)):
   thm
val ll_cases = {},  |- !(X : set). islls(X#) = App(llf(X#), islls(X#)): thm
val ll_coind =
   {}, 
   |- !(X : set)  (sa : mem(Pow(Exp(N, X# + 1)))).
        (!(a : mem(Exp(N, X# + 1))).
            IN(a#, sa#) ==>
            a# = Tpm(Null(X#)) |
            ?(h : mem(X#))  (t : fun(N, X# + 1)).
              a# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), sa#)) ==>
        !(a : mem(Exp(N, X# + 1))). IN(a#, sa#) ==> IN(a#, islls(X#)): thm
val ll_rules =
   {}, 
   |- !(X : set).
        IN(Tpm(Null(X#)), islls(X#)) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          IN(Tpm(t#), islls(X#)) ==> IN(Tpm(lcons0(h#, t#)), islls(X#)): thm
val isll_lnil = {},  |- !(X : set). isll(Tpm(Null(X#))): thm
val isll_shift =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val Repll_def =
   {},  |- !(X : set)  (l : mem(llist(X#))). Repll(l#) = App(repll(X#), l#):
   thm
val LNil_def = {},  |- !(X : set). Repll(LNil(X#)) = Tpm(Null(X#)): thm
val llist_def =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          isll(a#) <=> ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_isll =
   {},  |- !(X : set)  (ll : mem(llist(X#))). isll(App(repll(X#), ll#)): thm
val isll_Repll =
   {}, 
   |- !(X : set)  (a : mem(Exp(N, X# + 1))).
        isll(a#) <=> ?(b : mem(llist(X#))). a# = Repll(b#): thm
val Repll_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(llist(X#)))  (l2 : mem(llist(X#))).
        Repll(l1#) = Repll(l2#) <=> l1# = l2#: thm
val Repll_isll = {},  |- !(X : set)  (ll : mem(llist(X#))). isll(Repll(ll#)):
   thm
val isll_lcons0 =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val isll_rules =
   {}, 
   |- !(X : set).
        isll(Tpm(Null(X#))) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          isll(Tpm(t#)) ==> isll(Tpm(lcons0(h#, t#))): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LCons_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#)))  (x : mem(X#)).
        Repll(LCons(x#, ll#)) = Tpm(lcons0(x#, tof(Repll(ll#)))): thm
val Repll_lnil_uex =
   {}, 
   |- !(X : set)  (l : mem(llist(X#))).
        Repll(l#) = Tpm(Null(X#)) <=> l# = LNil(X#): thm
val FPB_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- App(FPB(f), NONE(B * A)) = NONE(B * A) &
      !(b : mem(B))  (a : mem(A)).
        App(FPB(f), SOME(Pair(b#, a#))) = App(f, b#): thm
val FP_def =
   {(X : set), (f : fun(X, X))}, 
   |- !(x : mem(X)).
        App(FP(f), Pair(O, x#)) = x# &
        !(n : mem(N)).
          App(FP(f), Pair(Suc(n#), x#)) = App(FP(f), Pair(n#, App(f, x#))):
   thm
val OB_def =
   {(A : set), (B : set)}, 
   |- !(f : fun(A, B + 1)).
        App(OB(A, B), Pair(NONE(A), Tpm(f#))) = NONE(B) &
        !(a : mem(A)). App(OB(A, B), Pair(SOME(a#), Tpm(f#))) = App(f#, a#):
   thm
val lnil_def = {(X : set)},  |- lnil(X) = Tpm(Null(X)): thm
val toabs_char0 =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)).
        (App(f#, z#) = NONE(B * A) ==> toabs(f#, z#) = Null(A)) &
        !(b : mem(B))  (a : mem(A)).
          App(f#, z#) = SOME(Pair(b#, a#)) ==>
          toabs(f#, z#) = lcons0(a#, toabs(f#, b#)): thm
val toabs_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1)), (z : mem(B))}, 
   |- !(n : mem(N)).
        App(toabs(f, z), n#) =
          App(OM(p2(B, A)), App(FP(FPB(f)), Pair(n#, App(f, z)))): thm
val toabs_isll =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)). isll(Tpm(toabs(f#, z#))): thm
val toabs_unique =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (g : fun(B, Exp(N, A + 1))).
        (!(z : mem(B)).
            (App(f#, z#) = NONE(B * A) ==> App(g#, z#) = Tpm(Null(A))) &
            !(b : mem(B))  (a : mem(A)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(g#, z#) = Tpm(lcons0(a#, tof(App(g#, b#))))) ==>
        !(z : mem(B)). App(g#, z#) = Tpm(toabs(f#, z#)): thm
val llcr0_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- !(z : mem(B)). App(llcr0(f), z#) = Tpm(toabs(f, z#)): thm
val llrec0_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, Exp(N, A# + 1))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = Tpm(Null(A#))) &
            (!(b : mem(B#))  (a : mem(A#)).
                App(f#, z#) = SOME(Pair(b#, a#)) ==>
                App(cr#, z#) = Tpm(lcons0(a#, tof(App(cr#, b#))))) &
            isll(App(cr#, z#)): thm
val llcr_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, llist(A#))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = LNil(A#)) &
            !(b : mem(B#))  (a : mem(A#)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(cr#, z#) = LCons(a#, App(cr#, b#)): thm
val CB_def =
   {(X : set)}, 
   |- !(R : mem(Pow(llist(X) * llist(X))))  (ll1 : mem(llist(X)))
      (ll2 : mem(llist(X))).
        IN(Pair(ll1#, ll2#), App(CB(X), R#)) <=>
        ll1# = LNil(X) & ll2# = LNil(X) |
        ?(l01 : mem(llist(X)))  (l02 : mem(llist(X)))  (x : mem(X)).
          IN(Pair(l01#, l02#), R#) &
          ll1# = LCons(x#, l01#) & ll2# = LCons(x#, l02#): thm
val CB_monotone = {(X : set)},  |- monotone(CB(X)): thm
val CB_cases = {},  |- !(X : set). gfp(CB(X#)) = App(CB(X#), gfp(CB(X#))):
   thm
val CB_rules0 =
   {}, 
   |- !(X : set).
        IN(Pair(LNil(X#), LNil(X#)), gfp(CB(X#))) &
        !(l01 : mem(llist(X#)))  (l02 : mem(llist(X#))).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          !(x : mem(X#)).
            IN(Pair(LCons(x#, l01#), LCons(x#, l02#)), gfp(CB(X#))): thm
val CB_rules00 =
   {}, 
   |- !(X : set).
        (!(b : mem(llist(X#)))  (a' : mem(llist(X#))).
            a'# = LNil(X#) ==>
            b# = LNil(X#) ==> IN(Pair(a'#, b#), gfp(CB(X#)))) &
        !(a' : mem(llist(X#)))  (b : mem(llist(X#)))  (l01 : mem(llist(X#)))
        (l02 : mem(llist(X#)))  (x : mem(X#)).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          a'# = LCons(x#, l01#) ==>
          b# = LCons(x#, l02#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val CB_coind0 =
   {}, 
   |- !(X : set)  (sa : mem(Pow(llist(X#) * llist(X#)))).
        (!(a' : mem(llist(X#)))  (b : mem(llist(X#))).
            IN(Pair(a'#, b#), sa#) ==>
            a'# = LNil(X#) & b# = LNil(X#) |
            ?(l01 : mem(llist(X#)))  (l02 : mem(llist(X#)))  (x : mem(X#)).
              IN(Pair(l01#, l02#), sa#) &
              a'# = LCons(x#, l01#) & b# = LCons(x#, l02#)) ==>
        !(a' : mem(llist(X#)))  (b : mem(llist(X#))).
          IN(Pair(a'#, b#), sa#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val LHD_THM =
   {(X : set)}, 
   |- LHD(LNil(X)) = NONE(X) &
      !(h : mem(X))  (t : mem(llist(X))). LHD(LCons(h#, t#)) = SOME(h#): thm
val LHD_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))). LHD(ll#) = App(tof(Repll(ll#)), O):
   thm
val LNTH_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). LNTH(n#, ll1#) = LNTH(n#, ll2#)) <=> ll1# = ll2#: thm
val LNTH_def =
   {}, 
   |- !(A : set)  (ll : mem(llist(A#)))  (n : mem(N)).
        LNTH(n#, ll#) = App(tof(Repll(ll#)), n#): thm
val Repll_n_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). App(tof(Repll(ll1#)), n#) = App(tof(Repll(ll2#)), n#)) <=>
        ll1# = ll2#: thm
val isll_cases0 =
   {}, 
   |- !(X : set)  (x : mem(Exp(N, X# + 1))).
        isll(x#) <=>
        x# = Repll(LNil(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          x# = Tpm(lcons0(h#, t#)) & isll(Tpm(t#)): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LTL_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        (LHD(ll#) = NONE(X#) ==> LTL(ll#) = NONE(llist(X#))) &
        !(hd : mem(X#)).
          LHD(ll#) = SOME(hd#) ==>
          ?(ltl0 : mem(llist(X#))).
            LTL(ll#) = SOME(ltl0#) &
            !(n : mem(N)).
              App(tof(Repll(ltl0#)), n#) = App(tof(Repll(ll#)), Suc(n#)): thm
val LCons_xor_LNil =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        ~ll# = LNil(X#) <=>
        ?(h : mem(X#))  (t : mem(llist(X#))). ll# = LCons(h#, t#): thm
val LTL_THM =
   {(X : set)}, 
   |- LTL(LNil(X)) = NONE(llist(X)) &
      !(h : mem(X))  (t : mem(llist(X))). LTL(LCons(h#, t#)) = SOME(t#): thm
val LNTH_THM =
   {}, 
   |- !(X : set).
        (!(n : mem(N)). LNTH(n#, LNil(X#)) = NONE(X#)) &
        (!(h : mem(X#))  (t : mem(llist(X#))).
            LNTH(O, LCons(h#, t#)) = SOME(h#)) &
        !(n : mem(N))  (h : mem(X#))  (t : mem(llist(X#))).
          LNTH(Suc(n#), LCons(h#, t#)) = LNTH(n#, t#): thm
val gfp_CB =
   {}, 
   |- !(X : set)  (g1 : mem(llist(X#)))  (g2 : mem(llist(X#))).
        IN(Pair(g1#, g2#), gfp(CB(X#))) <=> g1# = g2#: thm
val LLIST_BISIMULATION0 =
   {(X : set)}, 
   |- !(ll1 : mem(llist(X)))  (ll2 : mem(llist(X))).
        ll1# = ll2# <=>
        ?(R : mem(Pow(llist(X) * llist(X)))).
          IN(Pair(ll1#, ll2#), R#) &
          !(ll3 : mem(llist(X)))  (ll4 : mem(llist(X))).
            IN(Pair(ll3#, ll4#), R#) ==>
            ll3# = LNil(X) & ll4# = LNil(X) |
            ?(h : mem(X))  (t1 : mem(llist(X)))  (t2 : mem(llist(X))).
              IN(Pair(t1#, t2#), R#) &
              ll3# = LCons(h#, t1#) & ll4# = LCons(h#, t2#): thm
val lcons0_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : fun(N, X + 1))
      (t2 : fun(N, X + 1)).
        lcons0(h1#, t1#) = lcons0(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LCons_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : mem(llist(X)))
      (t2 : mem(llist(X))).
        LCons(h1#, t1#) = LCons(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LMAP_def =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(z : mem(llist(X))).
        (App(lmapf(f), z#) = NONE(llist(X) * Y) ==>
          App(LMAP(f), z#) = LNil(Y)) &
        !(b : mem(llist(X)))  (a : mem(Y)).
          App(lmapf(f), z#) = SOME(Pair(b#, a#)) ==>
          App(LMAP(f), z#) = LCons(a#, App(LMAP(f), b#)): thm
val LMap_def =
   {(X : set), (Y : set), (f : fun(X, Y)), (l : mem(llist(X)))}, 
   |- LMap(f, l) = App(LMAP(f), l): thm
val f_ex0 =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(l : mem(llist(X))).
        ?!(opv : mem(llist(X) * A + 1)).
          l# = LNil(X) & opv# = NONE(llist(X) * A) |
          ?(lh : mem(X))  (lt : mem(llist(X))).
            l# = LCons(lh#, lt#) & opv# = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LNil =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A)). App(lmapf(f#), LNil(X)) = NONE(llist(X) * A): thm
val lmapf_def =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(a : mem(llist(X))).
        a# = LNil(X) & App(lmapf(f), a#) = NONE(llist(X) * A) |
        ?(lh : mem(X))  (lt : mem(llist(X))).
          a# = LCons(lh#, lt#) &
          App(lmapf(f), a#) = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LCons =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A))  (lh : mem(X))  (lt : mem(llist(X))).
        App(lmapf(f#), LCons(lh#, lt#)) = SOME(Pair(lt#, App(f#, lh#))): thm
val LMAP_LNil =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y)). App(LMAP(f#), LNil(X)) = LNil(Y): thm
val LMAP_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        App(LMAP(f#), LCons(lh#, lt#)) =
          LCons(App(f#, lh#), App(LMAP(f#), lt#)): thm
val LMap_LNil =
   {(X : set), (Y : set)},  |- !(f : fun(X, Y)). LMap(f#, LNil(X)) = LNil(Y):
   thm
val LMap_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        LMap(f#, LCons(lh#, lt#)) = LCons(App(f#, lh#), LMap(f#, lt#)): thm
val LMap_functorial =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (g : fun(Z, X))  (ll : mem(llist(Z))).
        LMap(f#, LMap(g#, ll#)) = LMap(f# o g#, ll#): thm
val it = (): unit
******

Loading SEAR file SEARGrp.sml

******
val Grp_def =
   {}, 
   |- !(G : set).
        Inj(iG(G#)) &
        !(a : mem(Exp((G# * G#), G#) * Exp(G#, G#) * G#)).
          isgrp(a#) <=> ?(b : mem(Grp(G#))). a# = App(iG(G#), b#): thm
val RepG_def = {(G : set), (g : mem(Grp(G)))},  |- RepG(g) = App(iG(G), g):
   thm
val RepG_isgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isgrp(RepG(g#)): thm
val asc_def =
   {(A : set), (m : fun(A * A, A))}, 
   |- asc(m) <=>
      !(a1 : mem(A))  (a2 : mem(A))  (a3 : mem(A)).
        mul(m, mul(m, a1#, a2#), a3#) = mul(m, a1#, mul(m, a2#, a3#)): thm
val isgrp_def =
   {(G : set), (g : mem(Exp((G * G), G) * Exp(G, G) * G))}, 
   |- isgrp(g) <=>
      asc(tof(c31(g))) &
      isunit(tof(c31(g)), c33(g)) & isinv(tof(c31(g)), tof(c32(g)), c33(g)):
   thm
val isinv_def =
   {(A : set), (e : mem(A)), (i : fun(A, A)), (m : fun(A * A, A))}, 
   |- isinv(m, i, e) <=>
      !(a : mem(A)). mul(m, App(i, a#), a#) = e & mul(m, a#, App(i, a#)) = e:
   thm
val isunit_def =
   {(A : set), (e : mem(A)), (m : fun(A * A, A))}, 
   |- isunit(m, e) <=> !(a : mem(A)). mul(m, e, a#) = a# & mul(m, a#, e) = a#:
   thm
val mul_def =
   {(G : set), (g1 : mem(G)), (g2 : mem(G)), (m : fun(G * G, G))}, 
   |- mul(m, g1, g2) = App(m, Pair(g1, g2)): thm
val Rnsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rnsg(g#)): thm
val eof_def = {(G : set), (g : mem(Grp(G)))},  |- eof(g) = c33(RepG(g)): thm
val ginv_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G))}, 
   |- ginv(g, x) = App(iof(g), x): thm
val gmul_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G)), (y : mem(G))}, 
   |- gmul(g, x, y) = mul(mof(g), x, y): thm
val iof_def = {(G : set), (g : mem(Grp(G)))},  |- iof(g) = tof(c32(RepG(g))):
   thm
val isghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (f : fun(G1#, G2#))
      (g2 : mem(Grp(G2#))).
        isghom(f#, g1#, g2#) <=>
        !(a : mem(G1#))  (b : mem(G1#)).
          App(f#, gmul(g1#, a#, b#)) = gmul(g2#, App(f#, a#), App(f#, b#)):
   thm
val isnml_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(sgrp(g)))}, 
   |- isnml(h) <=> !(a : mem(G)). rcs(h, a#) = lcs(a#, h): thm
val issgrp_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(Pow(G)))}, 
   |- issgrp(h, g) <=>
      IN(eof(g), h) &
      (!(a : mem(G))  (b : mem(G)).
          IN(a#, h) & IN(b#, h) ==> IN(gmul(g, a#, b#), h)) &
      !(a : mem(G)). IN(a#, h) ==> IN(ginv(g, a#), h): thm
val lcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, lcs(a, H)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, a, h#): thm
val lsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (x : mem(G#))
      (a : mem(G#)).
        IN(a#, lsmul(g#, x#, s#)) <=>
        ?(y : mem(G#)). IN(y#, s#) & a# = gmul(g#, x#, y#): thm
val mof_def = {(G : set), (g : mem(Grp(G)))},  |- mof(g) = tof(c31(RepG(g))):
   thm
val nsg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(sgrp(g))).
        (?(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#) <=>
        ?!(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#: thm
val nsg_uex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(sgrp(g#))).
        isnml(a#) ==> ?!(a : mem(nsgrp(g#))). App(Rnsg(g#), a#) = a#: thm
val nsgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))).
        Inj(Rnsg(g#)) &
        !(a : mem(sgrp(g#))).
          isnml(a#) <=> ?(b : mem(nsgrp(g#))). a# = App(Rnsg(g#), b#): thm
val rcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, rcs(H, a)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, h#, a): thm
val rcs_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        rcs(H#, a#) = rsmul(g#, rsg(H#), a#): thm
val rsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        rsg(H#) = App(Rsg(g#), H#): thm
val rsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (y : mem(G#))
      (a : mem(G#)).
        IN(a#, rsmul(g#, s#, y#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = gmul(g#, x#, y#): thm
val sgrp_def =
   {(G : set), (g : mem(Grp(G)))}, 
   |- Inj(Rsg(g)) &
      !(a : mem(Pow(G))).
        issgrp(a#, g) <=> ?(b : mem(sgrp(g))). a# = App(Rsg(g), b#): thm
val lcs_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        lcs(a#, H#) = lsmul(g#, a#, rsg(H#)): thm
val Rsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rsg(g#)): thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val sg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(Pow(G))).
        (?(a : mem(sgrp(g))). App(Rsg(g), a#) = b#) <=>
        ?!(a : mem(sgrp(g))). App(Rsg(g), a#) = b#: thm
val sg_uex =
   {}, 
   |- !(G : set)  (a : mem(Pow(G#)))  (g : mem(Grp(G#))).
        issgrp(a#, g#) ==> ?!(a : mem(sgrp(g#))). App(Rsg(g#), a#) = a#: thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val gmul_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, ginv(g#, a#), a#) = eof(g#) &
        gmul(g#, a#, ginv(g#, a#)) = eof(g#): thm
val asc_mof = {},  |- !(G : set)  (g : mem(Grp(G#))). asc(mof(g#)): thm
val gmul_assoc =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (c : mem(G#)).
        gmul(g#, gmul(g#, a#, b#), c#) = gmul(g#, a#, gmul(g#, b#, c#)): thm
val gmul_lcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, x#, y#) = gmul(g#, x#, z#) <=> y# = z#: thm
val gmul_rcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, y#, x#) = gmul(g#, z#, x#) <=> y# = z#: thm
val is_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        a1# = ginv(g#, a#) <=>
        gmul(g#, a#, a1#) = eof(g#) | gmul(g#, a1#, a#) = eof(g#): thm
val ginv_e =
   {},  |- !(G : set)  (g : mem(Grp(G#))). ginv(g#, eof(g#)) = eof(g#): thm
val e_sgrp =
   {},  |- !(G : set)  (g : mem(Grp(G#))). issgrp(Sing(eof(g#)), g#): thm
val esg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))). App(Rsg(g#), esg(g#)) = Sing(eof(g#)):
   thm
val rsg_esg =
   {},  |- !(G : set)  (g : mem(Grp(G#))). rsg(esg(g#)) = Sing(eof(g#)): thm
val e_nsgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isnml(esg(g#)): thm
val ensg_def =
   {},  |- !(G : set)  (g : mem(Grp(G#))). App(Rnsg(g#), ensg(g#)) = esg(g#):
   thm
val nsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(sgrp(g#))).
        nsg(h#) = App(LINV(Rnsg(g#), ensg(g#)), h#): thm
val qgR_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        Holds(qgR(H#), a#, b#) <=> lcs(a#, rnsg(H#)) = lcs(b#, rnsg(H#)): thm
val rnsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rnsg(H#) = App(Rnsg(g#), H#): thm
val qgR_Refl =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Refl(qgR(H#)):
   thm
val qgR_Sym =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Sym(qgR(H#)):
   thm
val qgR_Trans =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Trans(qgR(H#)):
   thm
val qgR_ER =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). ER(qgR(H#)):
   thm
val css_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Inj(Rcss(H#)) &
        !(a : mem(Pow(G#))).
          (?(a : mem(G#)). a# = rsi(qgR(H#), a#)) <=>
          ?(b : mem(css(H#))). a# = App(Rcss(H#), b#): thm
val Rcss_Inj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Inj(Rcss(H#)):
   thm
val rcss_def =
   {(G : set), (H : mem(nsgrp(g))), (cs : mem(css(H))), (g : mem(Grp(G)))}, 
   |- rcss(cs) = App(Rcss(H), cs): thm
val rcss_eq_eq =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (a : mem(css(H#)))  (b : mem(css(H#))). rcss(a#) = rcss(b#) <=> a# = b#:
   thm
val mem_css_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ?!(a : mem(css(H#))). rcss(a#) = rsi(qgR(H#), eof(g#)): thm
val Quot_qgR_Rcss =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(qgR(H#), Rcss(H#)): thm
val cs_def =
   {}, 
   |- !(G : set)  (a : mem(G#))  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        cs(a#, H#) = abs(qgR(H#), Rcss(H#), ecs(H#), a#): thm
val ecs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rcss(ecs(H#)) = rsi(qgR(H#), eof(g#)): thm
val rcss_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcss(cs(a#, H#)) = rsi(qgR(H#), a#): thm
val nsgrp_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val nsgrp_swap_l2r =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, a#, h#) = gmul(g#, h#, a#): thm
val smul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, smul(g#, s1#, s2#)) <=>
        ?(x : mem(G#))  (y : mem(G#)).
          IN(x#, s1#) & IN(y#, s2#) & a# = gmul(g#, x#, y#): thm
val nsgrp_swap_r2l =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, h#, a#) = gmul(g#, a#, h#): thm
val rsg_issgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        issgrp(rsg(H#), g#): thm
val e_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        IN(eof(g#), rsg(H#)): thm
val gmul_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h1 : mem(G#)).
        IN(h1#, rsg(H#)) ==>
        !(h2 : mem(G#)). IN(h2#, rsg(H#)) ==> IN(gmul(g#, h1#, h2#), rsg(H#)):
   thm
val ginv_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(H#)) ==> IN(ginv(g#, h#), rsg(H#)): thm
val gmul_lcs_smul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        lcs(gmul(g#, a#, b#), rnsg(H#)) =
          smul(g#, lcs(a#, rnsg(H#)), lcs(b#, rnsg(H#))): thm
val mof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o mof(g#),
       prrel(qgR(H#), qgR(H#))): thm
val prrel_qgR_ER =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ER(prrel(qgR(H#), qgR(H#))): thm
val qgR_Rcss_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#))): thm
val qgR_Rcss_abs_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        abs(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#)),
           Pair(ecs(H#), ecs(H#)), Pair(a#, b#)) =
          Pair(abs(qgR(H#), Rcss(H#), ecs(H#), a#),
           abs(qgR(H#), Rcss(H#), ecs(H#), b#)): thm
val ginv_oneside =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        gmul(g#, a#, a1#) = eof(g#) <=> gmul(g#, a1#, a#) = eof(g#): thm
val mulcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        mul(mulcs(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val sinv_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, sinv(g#, s#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = ginv(g#, x#): thm
val is_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        a# = eof(g#) <=>
        (?(x : mem(G#)). gmul(g#, a#, x#) = x#) |
        ?(x : mem(G#)). gmul(g#, x#, a#) = x#: thm
val ginv_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#)).
        ginv(g#, gmul(g#, a#, b#)) = gmul(g#, ginv(g#, b#), ginv(g#, a#)):
   thm
val ginv_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        ginv(g#, ginv(g#, a#)) = a#: thm
val ginv_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        lcs(ginv(g#, a#), rnsg(H#)) = sinv(g#, lcs(a#, rnsg(H#))): thm
val iof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o iof(g#), qgR(H#)): thm
val invcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(invcs(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_Surj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Surj(qmap(H#)):
   thm
val qmap_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qmap(H#) = Abs(qgR(H#), Rcss(H#), ecs(H#)): thm
val css_rep_ex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (b : mem(css(H#))). ?(a : mem(G#)). b# = cs(a#, H#): thm
val ecs_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ecs(H#) = cs(eof(g#), H#): thm
val mulcs_invcs_ecs_isgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isgrp(Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#)))): thm
val mof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        mof(qgrp(H#)) = mulcs(H#): thm
val qgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        RepG(qgrp(H#)) = Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#))):
   thm
val iof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        iof(qgrp(H#)) = invcs(H#): thm
val eof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        eof(qgrp(H#)) = ecs(H#): thm
val gmul_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        gmul(qgrp(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val ginv_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : set). ginv(qgrp(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(qmap(H#), a#) = cs(a#, H#): thm
val qmap_isghom =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isghom(qmap(H#), g#, qgrp(H#)): thm
val constf_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        isghom(constf(G1#, eof(g2#)), g1#, g2#): thm
val ghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)) &
        !(a : mem(Exp(G1#, G2#))).
          isghom(tof(a#), g1#, g2#) <=>
          ?(b : mem(ghom(g1#, g2#))). a# = App(ih(g1#, g2#), b#): thm
val ghom_ex_uex =
   {(G1 : set), (G2 : set), (g1 : mem(Grp(G1))), (g2 : mem(Grp(G2)))}, 
   |- !(b : mem(Exp(G1, G2))).
        (?(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#) <=>
        ?!(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#: thm
val ghom_uex =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (a : mem(Exp(G1#, G2#))).
        isghom(tof(a#), g1#, g2#) ==>
        ?!(a : mem(ghom(g1#, g2#))). App(ih(g1#, g2#), a#) = a#: thm
val ih_Inj =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)): thm
val eghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        App(ih(g1#, g2#), eghm(g1#, g2#)) = Tpm(constf(G1#, eof(g2#))): thm
val ghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : fun(G1#, G2#)).
        ghm(h#, g1#, g2#) = App(LINV(ih(g1#, g2#), eghm(g1#, g2#)), Tpm(h#)):
   thm
val homfun_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : mem(ghom(g1#, g2#))). homfun(h#) = tof(App(ih(g1#, g2#), h#)): thm
val isghom_homfun_ghm =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : fun(G1#, G2#)).
        isghom(f#, g1#, g2#) <=> homfun(ghm(f#, g1#, g2#)) = f#: thm
val IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#)).
        IN(x#, kers(f#)) <=> App(homfun(f#), x#) = eof(g2#): thm
val ker_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). ker(f#) = nsg(sg(kers(f#), g1#)): thm
val kers_def =
   {(G1 : set), (G2 : set), (f : mem(ghom(g1, g2))), (g1 : mem(Grp(G1))),
    (g2 : mem(Grp(G2)))},  |- kers(f) = PREIM(homfun(f), Sing(eof(g2))): thm
val sg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(Pow(G#))).
        sg(h#, g#) = App(LINV(Rsg(g#), esg(g#)), h#): thm
val homfun_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isghom(homfun(f#), g1#, g2#): thm
val homfun_gmul =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#))  (y : mem(G1#)).
        App(homfun(f#), gmul(g1#, x#, y#)) =
          gmul(g2#, App(homfun(f#), x#), App(homfun(f#), y#)): thm
val homfun_e =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). App(homfun(f#), eof(g1#)) = eof(g2#): thm
val homfun_ginv =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a : mem(G1#)).
        App(homfun(f#), ginv(g1#, a#)) = ginv(g2#, App(homfun(f#), a#)): thm
val e_IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). IN(eof(g1#), kers(f#)): thm
val kers_issgrp =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). issgrp(kers(f#), g1#): thm
val cjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (h : mem(G))}, 
   |- cjg(g, a, h) = gmul(g, a, gmul(g, h, ginv(g, a))): thm
val lsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (s : mem(Pow(G#))).
        lsmul(g#, a#, lsmul(g#, b#, s#)) = lsmul(g#, gmul(g#, a#, b#), s#):
   thm
val qhom_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qhom(H#) = ghm(qmap(H#), g#, qgrp(H#)): thm
val rsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        rsmul(g#, rsmul(g#, s#, a#), b#) = rsmul(g#, s#, gmul(g#, a#, b#)):
   thm
val lsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        lsmul(g#, eof(g#), s#) = s#: thm
val rsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        rsmul(g#, s#, eof(g#)) = s#: thm
val lsmul_rsmul_comm =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#)))
      (b : mem(G#)).
        rsmul(g#, lsmul(g#, a#, s#), b#) = lsmul(g#, a#, rsmul(g#, s#, b#)):
   thm
val isnml_alt =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). scjg(g#, a#, rsg(H#)) = rsg(H#): thm
val scjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (s : mem(Pow(G)))}, 
   |- scjg(g, a, s) = lsmul(g, a, rsmul(g, s, ginv(g, a))): thm
val scjg_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (H : mem(Pow(G#)))
      (x : mem(G#)).
        IN(x#, scjg(g#, a#, H#)) <=>
        ?(h : mem(G#)). IN(h#, H#) & x# = cjg(g#, a#, h#): thm
val SS_scjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#))).
        SS(scjg(g#, a#, s#), s#) <=>
        !(x : mem(G#)). IN(x#, s#) ==> IN(cjg(g#, a#, x#), s#): thm
val SS_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(rsmul(g#, s1#, a#), rsmul(g#, s2#, a#)): thm
val SS_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val isnml_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). SS(scjg(g#, a#, rsg(H#)), rsg(H#)): thm
val IN_gmul_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, H#) <=>
        !(b : mem(G#)). IN(gmul(g#, a#, b#), rsmul(g#, H#, b#)): thm
val IN_gmul_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (b : mem(G#)).
        IN(b#, H#) <=>
        !(a : mem(G#)). IN(gmul(g#, a#, b#), lsmul(g#, a#, H#)): thm
val gmul_IN_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val gmul_IN_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val rnsg_isnml =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). isnml(rnsg(H#)):
   thm
val rnsg_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val SS_ex_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        ?(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val same_cs_cond =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        cs(a#, H#) = cs(b#, H#) <=>
        IN(gmul(g#, a#, ginv(g#, b#)), rsg(rnsg(H#))): thm
val sg_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        sg(rsg(H#), g#) = H#: thm
val nsg_rnsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        nsg(rnsg(H#)) = H#: thm
val issgrp_rsg_sg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#))).
        issgrp(H#, g#) <=> rsg(sg(H#, g#)) = H#: thm
val isnml_rnsg_nsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> rnsg(nsg(H#)) = H#: thm
val sg_kers_isnml =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isnml(sg(kers(f#), g1#)): thm
val rsg_rnsg_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rsg(rnsg(ker(f#))) = kers(f#): thm
val rgh_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rgh(f#) = App(ih(g1#, g2#), f#): thm
val rgh_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        rgh(f1#) = rgh(f2#) <=> f1# = f2#: thm
val homfun_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        homfun(f1#) = homfun(f2#) <=> f1# = f2#: thm
val homfun_eq_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a1 : mem(G1#))  (a2 : mem(G1#)).
        App(homfun(f#), a1#) = App(homfun(f#), a2#) <=>
        App(homfun(f#), gmul(g1#, ginv(g1#, a1#), a2#)) = eof(g2#): thm
val homfun_resp1_qgR_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). resp1(homfun(f#), qgR(ker(f#))): thm
val first_iso_thm =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))).
        ?!(fb : mem(ghom(qgrp(ker(f#)), g2#))).
          Inj(homfun(fb#)) & homfun(fb#) o qmap(ker(f#)) = homfun(f#): thm
val it = (): unit
******

Loading SEAR file SEARexamplecol.sml

******
val AX5 =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
val cardeq_REFL = {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, s#): thm
val cardeq_def =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=>
      ?(R : rel(A, B)).
        (!(a : mem(A)).
            IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R#, a#, b#)) &
        !(b : mem(B)).
          IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R#, a#, b#): thm
val isset_def =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
val cardeq_SYM =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(s2#, s1#): thm
val cardeq_TRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#))).
          cardeq(s2#, s3#) ==> cardeq(s1#, s3#): thm
val restrict_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (R : rel(A#, B#))
      (s2 : mem(Pow(B#)))  (a : mem(A#))  (b : mem(B#)).
        Holds(restrict(R#, s1#, s2#), a#, b#) <=>
        IN(a#, s1#) & IN(b#, s2#) & Holds(R#, a#, b#): thm
val cardeq_Whole_Inj_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set).
        cardeq(s#, Whole(B#)) ==>
        ?(i : fun(B#, A#)). Inj(i#) & IMAGE(i#, Whole(B#)) = s#: thm
val cardeq_Inj_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> cardeq(Whole(A#), IMAGE(f#, Whole(A#))): thm
val Inj_Image =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Inj(f#) ==> Inj(Image(f#)):
   thm
val IMAGE_INJ_cardeq =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#)))
      (f : fun(A#, B#)).
        INJ(f#, s1#, s2#) ==>
        !(s01 : mem(Pow(A#))).
          SS(s01#, s1#) ==> cardeq(s01#, IMAGE(f#, s01#)): thm
val INJ_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (t : mem(Pow(B#))).
        INJ(f#, s#, t#) <=>
        (!(x : mem(A#)). IN(x#, s#) ==> IN(App(f#, x#), t#)) &
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==> App(f#, x#) = App(f#, y#) ==> x# = y#:
   thm
val Inj_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). INJ(f#, s#, IMAGE(f#, s#)): thm
val INJ_SS_dom =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(A#))). SS(s#, s1#) ==> INJ(f#, s#, s2#): thm
val INJ_SS_cod =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(B#))). SS(s2#, s#) ==> INJ(f#, s1#, s#): thm
val o_INJ_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(C : set)  (g : fun(B#, C#))  (s3 : mem(Pow(C#))).
          INJ(g#, s2#, s3#) ==> INJ(g# o f#, s1#, s3#): thm
val cardeq_Inj_IMAGE_gen =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). cardeq(s#, IMAGE(f#, s#)): thm
val INJ_INS_NONE =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X# + 1)))).
        (!(s0 : mem(Pow(X# + 1))). IN(s0#, s#) ==> ~IN(NONE(X#), s0#)) ==>
        INJ(INS(NONE(X#)), s#, IMAGE(INS(NONE(X#)), s#)): thm
val INS_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (a : mem(Pow(X#))).
        App(INS(x0#), a#) = Ins(x0#, a#): thm
val POW_Whole_Pow = {},  |- !(A : set). POW(Whole(A#)) = Whole(Pow(A#)): thm
val POW_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (a : mem(Pow(A#))).
        IN(a#, POW(s0#)) <=> SS(a#, s0#): thm
val cardeq_POW_Whole_Pow =
   {},  |- !(A : set). cardeq(POW(Whole(A#)), Whole(Pow(A#))): thm
val FIB_constf =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#)).
        FIB(constf(A#, b#), b#) = Whole(A#): thm
val nPow_def =
   {}, 
   |- !(A : set)  (B : set)  (n : mem(N)).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)).
          cardeq(FIB(f#, O), Whole(A#)) &
          cardeq(FIB(f#, n#), Whole(B#)) &
          !(n0 : mem(N)).
            Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPow_O = {},  |- !(A : set). nPow(O, A#, A#): thm
val OE_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- OE(f, b0) = coPa(f, El(b0)): thm
val Sg_Sing = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Sgf_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- (!(a : mem(A)). App(Sgf(f, b0), Sing(a#)) = App(f, a#)) &
      !(s : mem(Pow(A))).
        (!(a : mem(A)). ~s# = Sing(a#)) ==> App(Sgf(f, b0), s#) = b0: thm
val content_Sing =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        App(content(x0#), Sing(x#)) = x#: thm
val content_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#)).
        (!(s : mem(Pow(X#)))  (x : mem(X#)).
            s# = Sing(x#) ==> App(content(x0#), s#) = x#) &
        !(s : mem(Pow(X#))).
          (!(x : mem(X#)). ~s# = Sing(x#)) ==> App(content(x0#), s#) = x0#:
   thm
val ctt_def =
   {}, 
   |- !(X : set)  (s : mem(Pow(X#)))  (x0 : mem(X#)).
        ctt(s#, x0#) = App(content(x0#), s#): thm
val PREIM_i1_Sing_SOME =
   {(X : set), (x0 : mem(X))},  |- PREIM(i1(X, 1), Sing(SOME(x0))) = Sing(x0):
   thm
val IMAGE_Sing =
   {(A : set), (B : set), (a : mem(A)), (f : fun(A, B))}, 
   |- IMAGE(f, Sing(a)) = Sing(App(f, a)): thm
val ctt_Sing =
   {},  |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)). ctt(Sing(a#), a0#) = a#:
   thm
val Sing_SOME_NEQ_Ins_NONE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A# + 1))).
        ~Sing(SOME(a#)) = Ins(NONE(A#), s#): thm
val SS_Ri_restrict =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (a : mem(Pow(A#)))  (B : set)
      (R : rel(A#, B#))  (s2 : mem(Pow(B#))).
        SS(App(Ri(restrict(R#, s1#, s2#)), a#), s2#): thm
val biunique_def =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) <=>
      (!(a : mem(A)).
          IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R, a#, b#)) &
      !(b : mem(B)).
        IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R, a#, b#): thm
val nPow_Suc_ex_lemma =
   {}, 
   |- !(C : set)  (X : set)  (i : fun(C#, Pow(X#))).
        Inj(i#) ==>
        !(B : set)  (f : fun(X#, B#))  (bs : mem(Pow(B#)))  (b0 : mem(B#)).
          (!(x : mem(X#)). ~App(f#, x#) = b0#) ==>
          ~IN(b0#, bs#) ==>
          !(b1 : mem(B#)).
            ~b1# = b0# & ~IN(b1#, bs#) ==>
            ?(f1 : fun(Pow(X# + 1), B#)).
              (!(b : mem(B#)).
                  IN(b#, bs#) ==>
                  FIB(f1#, b#) = IMAGE(Sg(X# + 1) o i1(X#, 1), FIB(f#, b#))) &
              FIB(f1#, b0#) =
                IMAGE(INS(NONE(X#)) o Image(i1(X#, 1)) o i#, Whole(C#)): thm
val biunique_op =
   {(A : set), (B : set)}, 
   |- !(R : rel(A, B))  (s1 : mem(Pow(A)))  (s2 : mem(Pow(B))).
        biunique(R#, s1#, s2#) ==> biunique(op(R#), s2#, s1#): thm
val biunique_Ri_restrict =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) ==>
      !(s : mem(Pow(A))).
        SS(s#, s1) ==>
        App(Ri(restrict(op(R), s2, s1)), App(Ri(restrict(R, s1, s2)), s#)) =
          s#: thm
val cardeq_POW =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(POW(s1#), POW(s2#)): thm
val cardeq_biunique =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=> ?(R : rel(A, B)). biunique(R#, s1, s2): thm
val cardeq_BITRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#)))  (D : set)  (s4 : mem(Pow(D#))).
          cardeq(s3#, s4#) ==> (cardeq(s1#, s3#) <=> cardeq(s2#, s4#)): thm
val NONE_NOTIN_IMAGE_i1 =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X#))))  (s0 : mem(Pow(X# + 1))).
        IN(s0#, IMAGE(Image(i1(X#, 1)), s#)) ==> ~IN(NONE(X#), s0#): thm
val shrink_IMAGE =
   {}, 
   |- !(X : set)  (B : set)  (f0 : fun(X#, B#))  (s : mem(Pow(B#)))
      (b0 : mem(B#)).
        ~IN(b0#, s#) ==>
        (!(b : mem(B#)).
            IN(b#, s#) ==> FIB(shrink(f0#, s#, b0#), b#) = FIB(f0#, b#)) &
        !(x : mem(X#)).
          ~IN(App(f0#, x#), s#) ==> App(shrink(f0#, s#, b0#), x#) = b0#: thm
val shrink_def =
   {(B : set), (X : set), (b0 : mem(B)), (f0 : fun(X, B)), (s : mem(Pow(B)))},
   
   |- !(a : mem(X)).
        (IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = App(f0, a#)) &
        (~IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = b0): thm
val nPow_shrink_IMAGE_ex =
   {(A : set), (An : set), (n : mem(N))}, 
   |- nPow(n, A, An) ==>
      ?(X : set)  (f : fun(X#, N)).
        cardeq(FIB(f#, O), Whole(A)) &
        cardeq(FIB(f#, n), Whole(An)) &
        (!(n0 : mem(N)).
            Lt(n0#, n) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#)))) &
        !(x : mem(X#)). ~App(f#, x#) = Suc(n): thm
val nPow_Suc =
   {(n : mem(N))}, 
   |- !(A : set)  (An : set). nPow(n, A#, An#) ==> nPow(Suc(n), A#, Pow(An#)):
   thm
val nPow_ex =
   {},  |- !(A : set)  (n : mem(N)). ?(An : set). nPow(n#, A#, An#): thm
val cardeq_m2s =
   {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, Whole(m2s(s#))): thm
val m2s_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Inj(minc(s#)) &
        !(a : mem(A#)).
          IN(a#, s#) <=> ?(b : mem(m2s(s#))). a# = App(minc(s#), b#): thm
val nPowf_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, N))  (n : mem(N)).
        nPowf(n#, A#, B#, f#) <=>
        cardeq(FIB(f#, O), Whole(A#)) &
        cardeq(FIB(f#, n#), Whole(B#)) &
        !(n0 : mem(N)).
          Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPowf_Preds =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> ?(B0 : set). nPowf(n0#, A#, B0#, f#):
   thm
val nPowf_Preds_FIB =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> nPowf(n0#, A#, m2s(FIB(f#, n0#)), f#):
   thm
val nPow_nPowf =
   {}, 
   |- !(A : set)  (n : mem(N))  (B : set).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)). nPowf(n#, A#, B#, f#): thm
val nPow_unique =
   {}, 
   |- !(A : set)  (n : mem(N))  (An1 : set)  (An2 : set).
        nPow(n#, A#, An1#) & nPow(n#, A#, An2#) ==>
        cardeq(Whole(An1#), Whole(An2#)): thm
val nPow_uex =
   {}, 
   |- !(A : set)  (n : mem(N)).
        ?(An : set).
          nPow(n#, A#, An#) &
          !(An1 : set).
            nPow(n#, A#, An1#) ==> cardeq(Whole(An#), Whole(An1#)): thm
val Pn_def = {},  |- !(A : set)  (n : mem(N)). nPow(n#, A#, Pn(A#, n#)): thm
val cardeq_Whole_REFL = {},  |- !(An : set). cardeq(Whole(An#), Whole(An#)):
   thm
val cardeq_Whole_SYM =
   {}, 
   |- !(An : set)  (An' : set).
        cardeq(Whole(An#), Whole(An'#)) ==> cardeq(Whole(An'#), Whole(An#)):
   thm
val cardeq_Whole_TRANS =
   {}, 
   |- !(An : set)  (An' : set)  (An'' : set).
        cardeq(Whole(An#), Whole(An'#)) & cardeq(Whole(An'#), Whole(An''#)) ==>
        cardeq(Whole(An#), Whole(An''#)): thm
val isset_minc = {},  |- !(A : set)  (s : mem(Pow(A#))). isset(minc(s#), s#):
   thm
val large_ex =
   {}, 
   |- !(A : set).
        ?(P : set). !(n : mem(N)). ?(i : fun(Pn(A#, n#), P#)). Inj(i#): thm
val nPow_ts_ex = {},  |- !(A : set)  (n : mem(N)). ?(An : set). T: thm
val it = (): unit
val it = (): unit
> # # # # # # Exception- Empty raised
> # # # # # # Exception- Empty raised
> # # # # # # # # # # # # Exception- ERR ("not a function symbol: Apr", [], [], []) raised
> 
*** Emacs/HOL command completed ***

> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol4IZKsFScript.sml

******
val Inj_same_IMAGE =
   {}, 
   |- !(X : set)  (A1 : set)  (i1 : fun(A1#, X#))  (A2 : set)
      (i2 : fun(A2#, X#)).
        Inj(i1#) & Inj(i2#) & IMAGE(i1#, Whole(A1#)) = IMAGE(i2#, Whole(A2#)) ==>
        ?(f : fun(A1#, A2#))  (g : fun(A2#, A1#)).
          f# o g# = Id(A2#) &
          g# o f# = Id(A1#) & i2# o f# = i1# & i1# o g# = i2#: thm
val Inj_same_IMAGE_unique =
   {}, 
   |- !(X : set)  (A1 : set)  (i1 : fun(A1#, X#))  (A2 : set)
      (i2 : fun(A2#, X#)).
        Inj(i1#) & Inj(i2#) & IMAGE(i1#, Whole(A1#)) = IMAGE(i2#, Whole(A2#)) ==>
        ?!(f : fun(A1#, A2#)). i2# o f# = i1#: thm
val Bij_Inj =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Bij(f#) ==> Inj(f#): thm
val ex_mem_eq =
   {}, 
   |- (!(A : set)  (a : mem(A#)). ?(a0 : mem(A#)). a# = a0#) &
      (!(A : set)  (a : mem(A#)). ?(a0 : mem(A#)). a0# = a#) &
      (!(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
          ?(a0 : mem(A#)). App(f#, a0#) = App(f#, a#)) &
      !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        ?(a0 : mem(A#)). App(f#, a#) = App(f#, a0#): thm
val Inj_Pow_EXT =
   {}, 
   |- !(X : set)  (A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
      (R : rel(X#, X#)).
        Inj(i#) &
        Inj(pi#) &
        (!(ax : mem(X#))  (sx : mem(X#)).
            (?(a : mem(A#)). ax# = App(i#, a#)) &
            (?(s : mem(Pow(A#))). sx# = App(pi#, s#)) ==>
            (Holds(R#, ax#, sx#) <=>
              ?(a : mem(A#))  (s : mem(Pow(A#))).
                IN(a#, s#) & App(i#, a#) = ax# & App(pi#, s#) = sx#)) ==>
        !(sx1 : mem(X#))  (sx2 : mem(X#)).
          IN(sx1#, IMAGE(pi#, Whole(Pow(A#)))) &
          IN(sx2#, IMAGE(pi#, Whole(Pow(A#)))) ==>
          (sx1# = sx2# <=>
            !(ax : mem(X#)).
              IN(ax#, IMAGE(i#, Whole(A#))) ==>
              (Holds(R#, ax#, sx1#) <=> Holds(R#, ax#, sx2#))): thm
val Les_O_Sing = {},  |- Les(O) = Sing(O): thm
val Les_def =
   {},  |- !(n : mem(N))  (a : mem(N)). IN(a#, Les(n#)) <=> Le(a#, n#): thm
val Upows_def =
   {(R : rel(X, X)), (X : set), (n : mem(N)), (p : fun(X, N)),
    (z : fun(N, X))}, 
   |- Upows(n, p, R, z) <=>
      IMAGE(p, Whole(X)) = Les(n) &
      Inj(z) &
      IMAGE(z, Whole(N)) = FIB(p, O) &
      (!(n0 : mem(N)).
          Lt(n0#, n) ==>
          ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
      !(x : mem(X))  (s : mem(X)).
        Holds(R, x#, s#) <=>
        Lt(App(p, x#), n) &
        Suc(App(p, x#)) = App(p, s#) &
        ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))  (a : mem(A#))
        (sa : mem(Pow(A#))).
          Inj(i#) &
          Inj(pi#) &
          IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
          IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
          (!(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
          IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
val constf_iff_Sing =
   {}, 
   |- !(A : set).
        (?(a : mem(A#)). T) ==>
        !(B : set)  (f : fun(A#, B#))  (b : mem(B#)).
          IMAGE(f#, Whole(A#)) = Sing(b#) <=> f# = constf(A#, b#): thm
val IMAGE_constf =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        ~s# = Empty(A#) ==>
        !(X : set)  (x : mem(X#)). IMAGE(constf(A#, x#), s#) = Sing(x#): thm
val Upows_O =
   {(R : rel(X, X)), (X : set), (p : fun(X, N)), (z : fun(N, X))}, 
   |- Upows(O, p, R, z) <=>
      IMAGE(z, Whole(N)) = FIB(p, O) &
      p = constf(X, O) &
      (!(x1 : mem(X))  (x2 : mem(X)). ~Holds(R, x1#, x2#)) & Bij(z): thm
val IMAGE_Id =
   {},  |- !(A : set)  (s : mem(Pow(A#))). IMAGE(Id(A#), s#) = s#: thm
val REmpty_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). ~Holds(REmpty(A#), a#, b#):
   thm
val Id_Surj = {},  |- !(A : set). Surj(Id(A#)): thm
val Bij_Id = {},  |- !(A : set). Bij(Id(A#)): thm
val Upows_O_ex = {},  |- Upows(O, constf(N, O), REmpty(N), Id(N)): thm
val Apr_def =
   {}, 
   |- !(A : set)  (X : set)  (R0 : rel(X#, X#))  (f : fun(X#, A#))
      (a : mem(A#))  (b : mem(A#)).
        Holds(Apr(f#, R0#), a#, b#) <=>
        ?(x1 : mem(X#))  (x2 : mem(X#)).
          App(f#, x1#) = a# & App(f#, x2#) = b# & Holds(R0#, x1#, x2#): thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holzOw60kScript.sml

******
Exception- Empty raised
> 
*** Emacs/HOL command completed ***

> # # # # # # # # # # # # # val f =
   ?(X : set)  (p : fun(X#, N))  (R : rel(X#, X#))  (z : fun(N, X#)).
     P(X#, p#, R#, z#) &
     !(X' : set)  (p' : fun(X'#, N))  (R' : rel(X'#, X'#))
     (z' : fun(N, X'#)).
       P(X'#, p'#, R'#, z'#) ==>
       ?!(f : fun(X#, X'#)).
         p# = p'# o f# & R'# = Apr(f#, R#) & z'# = f# o z#: form
val repl_Upows0 =
   {}, 
   |- !(U : set)  (u : mem(U#)).
        ?(X : set)  (p : fun(X#, U#))  (R : rel(X#, X#))  (z : fun(N, X#)).
          P(X#, p#, R#, z#) &
          !(X' : set)  (p' : fun(X'#, U#))  (R' : rel(X'#, X'#))
          (z' : fun(N, X'#)).
            P(X'#, p'#, R'#, z'#) ==>
            ?!(f : fun(X#, X'#)).
              p# = p'# o f# & R'# = Apr(f#, R#) & z'# = f# o z#: thm
> 
*** Emacs/HOL command completed ***

> # val repl_Upows1 =
   {(n : mem(N))}, 
   |- ?(X : set)  (p : fun(X#, N))  (R : rel(X#, X#))  (z : fun(N, X#)).
        P(X#, p#, R#, z#) &
        !(X' : set)  (p' : fun(X'#, N))  (R' : rel(X'#, X'#))
        (z' : fun(N, X'#)).
          P(X'#, p'#, R'#, z'#) ==>
          ?!(f : fun(X#, X'#)).
            p# = p'# o f# & R'# = Apr(f#, R#) & z'# = f# o z#: thm
> # # # val it =
   {(n : mem(N))}, 
   |- ?(X : set)  (p : fun(X#, N))  (R : rel(X#, X#))  (z : fun(N, X#)).
        Upows(n, p#, R#, z#) &
        !(X' : set)  (p' : fun(X'#, N))  (R' : rel(X'#, X'#))
        (z' : fun(N, X'#)).
          Upows(n, p'#, R'#, z'#) ==>
          ?!(f : fun(X#, X'#)).
            p# = p'# o f# & R'# = Apr(f#, R#) & z'# = f# o z#: thm
> isset_def;
val it =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # Exception- UNIFY ("terms cannot be unified", []) raised
> Exception- NO_PROOFS raised
> # # # # # # Exception- ERR ("", [], [], []) raised
> Exception- NO_PROOFS raised
> # # # # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : set).
                 ?(X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
                 (z : fun(N, X#)).
                   P(n#, p#, R#, z#) ==>
                   ?(V : set)  (e : fun(V#, N)).
                     epi(e#) &
                     ?(X' : set)  (f : fun(X'#, N))  (p' : fun(X'#, N * N))
                     (R' : rel(X'#, X'#))  (z' : fun(N * N, X'#)).
                       !(v : mem(V#))  (Xev : set)  (i : fun(Xev#, N))
                       (pev : fun(Xev#, N))  (Rev : rel(Xev#, Xev#))
                       (zev : set). T]: proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> val it = PRFS []: proofmanager.proofs
> # # # # # # Exception- UNIFY ("terms cannot be unified", []) raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # Exception- UNIFY ("terms cannot be unified", []) raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # Exception- UNIFY ("terms cannot be unified", []) raised
> Exception- NO_PROOFS raised
> # Exception- UNIFY ("different variable name", []) raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # Exception- UNIFY ("different variable name", []) raised
> Exception- NO_PROOFS raised
> # Exception- UNIFY ("different variable name", []) raised
> # val it = FIB(e, App(e, v)): term
> val it = PRFS []: proofmanager.proofs
> val it = PRFS []: proofmanager.proofs
> # # # # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : set).
                 ?(X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
                 (z : fun(N, X#)).
                   P(n#, p#, R#, z#) ==>
                   ?(V : set)  (e : fun(V#, N)).
                     epi(e#) &
                     ?(X' : set)  (f : fun(X'#, N))  (p' : fun(X'#, N * N))
                     (R' : rel(X'#, X'#))  (z' : fun(N * N, X'#)).
                       !(v : mem(V#))  (Xev : set)  (i : fun(Xev#, X'#))
                       (pev : fun(Xev#, N))  (Rev : rel(Xev#, Xev#))
                       (zev : set). isset(i#, FIB(f#, App(e#, v#)))]:
   proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : set).
                 ?(X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
                 (z : fun(N, X#)).
                   P(n#, p#, R#, z#) ==>
                   ?(V : set)  (e : fun(V#, N)).
                     epi(e#) &
                     ?(X' : set)  (f : fun(X'#, N))  (p' : fun(X'#, N * N))
                     (R' : rel(X'#, X'#))  (z' : fun(N * N, X'#)).
                       !(v : mem(V#))  (Xev : set)  (i : fun(Xev#, X'#))
                       (pev : fun(Xev#, N))  (Rev : rel(Xev#, Xev#))
                       (zev : fun(N, Xev#)).
                         isset(i#, FIB(f#, App(e#, v#))) &
                         p'# o i# = Pa(Id(N), Id(N)) o pev# &
                         (!(x1 : mem(Xev#))  (x2 : mem(Xev#)).
                             Holds(Rev#, x1#, x2#) <=>
                             Holds(R'#, App(i#, x1#), App(i#, x2#))) &
                         i# o zev# = z'# o Pa(Id(N), Id(N)) ==>
                         P(App(e#, v#), pev#, Rev#, zev#)]:
   proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # Exception- ERROR "Extra characters in formula" raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # Exception- ERROR "Extra characters in formula" raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (fa : fun(A#, U))  (B : set)  (fb : fun(B#, U)).
                 (!(u : mem(U))  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#)).
                     isset(ia#, FIB(fa#, u#)) & isset(ib#, FIB(fb#, u#)) ==>
                     ?(f : fun(uA#, uB#)). P(u#, f#)) ==>
                 ?(V : set)  (e : fun(V#, U)).
                   epi(e#) &
                   !(pA : set)  (pa1 : fun(pA#, A#))  (pa2 : fun(pA#, V#))
                   (pB : set)  (pb1 : fun(pA#, A#))  (pb2 : fun(pA#, V#)).
                     isPb(e#, fa#, pa1#, pa2#) & isPb(e#, fb#, pb1#, pb2#) ==>
                     ?(p : fun(pA#, pB#)). T]: proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # # # # # # Exception- UNIFY ("different variable name", []) raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (fa : fun(A#, U))  (B : set)  (fb : fun(B#, U)).
                 (!(u : mem(U))  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#)).
                     isset(ia#, FIB(fa#, u#)) & isset(ib#, FIB(fb#, u#)) ==>
                     ?(f : fun(uA#, uB#)). P(u#, f#)) ==>
                 ?(V : set)  (e : fun(V#, U)).
                   epi(e#) &
                   !(eA : set)  (ea1 : fun(eA#, A#))  (ea2 : fun(eA#, V#))
                   (eB : set)  (eb1 : fun(eA#, A#))  (eb2 : fun(eA#, V#)).
                     isPb(e#, fa#, ea1#, ea2#) & isPb(e#, fb#, eb1#, eb2#)]:
   proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # Exception- UNIFY ("different variable name", []) raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # Exception- UNIFY ("different variable name", []) raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (fa : fun(A#, U))  (B : set)  (fb : fun(B#, U)).
                 (!(u : mem(U))  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#)).
                     isset(ia#, FIB(fa#, u#)) & isset(ib#, FIB(fb#, u#)) ==>
                     ?(f : fun(uA#, uB#)). P(u#, f#)) ==>
                 ?(V : set)  (e : fun(V#, U)).
                   epi(e#) &
                   !(eA : set)  (ea2 : fun(eA#, A#))  (ea1 : fun(eA#, V#))
                   (eB : set)  (eb2 : fun(eA#, A#))  (eb1 : fun(eA#, V#)).
                     isPb(e#, fa#, ea1#, ea2#) & isPb(e#, fb#, eb1#, eb2#)]:
   proofmanager.proofs
> val it = (): unit
> isPb_def;
poly: : error: Value or constructor (isPb_def) has not been declared Found near isPb_def
Static Errors
> isPb_def;
poly: : error: Value or constructor (isPb_def) has not been declared Found near isPb_def
Static Errors
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (fa : fun(A#, U))  (B : set)  (fb : fun(B#, U)).
                 (!(u : mem(U))  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#)).
                     isset(ia#, FIB(fa#, u#)) & isset(ib#, FIB(fb#, u#)) ==>
                     ?(f : fun(uA#, uB#)). P(u#, f#)) ==>
                 ?(V : set)  (e : fun(V#, U)).
                   epi(e#) &
                   !(eA : set)  (ea2 : fun(eA#, A#))  (ea1 : fun(eA#, V#))
                   (eB : set)  (eb2 : fun(eA#, A#))  (eb1 : fun(eA#, V#)).
                     isPb(e#, fa#, ea1#, ea2#) & isPb(e#, fb#, eb1#, eb2#) ==>
                     ?(g : fun(eA#, eB#)).
                       !(v : mem(V#))  (vA : set)  (vea : fun(vA#, eA#))
                       (vB : set)  (veb : fun(vB#, eB#))
                       (vg : fun(vA#, vB#)). isset(vea#, FIB(ea1#, v#))]:
   proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # # # # # # Exception- UNIFY ("different variable name", []) raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (fa : fun(A#, U))  (B : set)  (fb : fun(B#, U)).
                 (!(u : mem(U))  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#)).
                     isset(ia#, FIB(fa#, u#)) & isset(ib#, FIB(fb#, u#)) ==>
                     ?(f : fun(uA#, uB#)). P(u#, f#)) ==>
                 ?(V : set)  (e : fun(V#, U)).
                   epi(e#) &
                   !(eA : set)  (ea2 : fun(eA#, A#))  (ea1 : fun(eA#, V#))
                   (eB : set)  (eb2 : fun(eA#, A#))  (eb1 : fun(eA#, V#)).
                     isPb(e#, fa#, ea1#, ea2#) & isPb(e#, fb#, eb1#, eb2#) ==>
                     ?(g : fun(eA#, eB#)).
                       !(v : mem(V#))  (vA : set)  (vea : fun(vA#, eA#))
                       (vB : set)  (veb : fun(vB#, eB#))
                       (vg : fun(vA#, vB#)). isset(vea#, FIB(ea1#, v#))]:
   proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # Exception- UNIFY ("different variable name", []) raised
> Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (fa : fun(A#, U))  (B : set)  (fb : fun(B#, U)).
                 (!(u : mem(U))  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#)).
                     isset(ia#, FIB(fa#, u#)) & isset(ib#, FIB(fb#, u#)) ==>
                     ?(f : fun(uA#, uB#)). P(u#, f#)) ==>
                 ?(V : set)  (e : fun(V#, U)).
                   epi(e#) &
                   !(eA : set)  (ea2 : fun(eA#, A#))  (ea1 : fun(eA#, V#))
                   (eB : set)  (eb2 : fun(eB#, A#))  (eb1 : fun(eB#, V#)).
                     isPb(e#, fa#, ea1#, ea2#) & isPb(e#, fb#, eb1#, eb2#) ==>
                     ?(g : fun(eA#, eB#)).
                       !(v : mem(V#))  (vA : set)  (vea : fun(vA#, eA#))
                       (vB : set)  (veb : fun(vB#, eB#))
                       (vg : fun(vA#, vB#)).
                         isset(vea#, FIB(ea1#, v#)) &
                         isset(veb#, FIB(eb1#, v#)) & g# o vea# = veb# o vg# ==>
                         P(App(e#, v#), g#)]: proofmanager.proofs
> val it = (): unit
> AX5;
val it =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
> # # # # # # # # # # poly: : error: Type error in function application.
   Function: e0 : tactic -> gstk -> gstk
   Argument: () : unit
   Reason:
      Can't unify goal -> goal list * validation to {} (Incompatible types)
Found near prove_store ("col_of_set", e0 () (form_goal (... ...)))
Static Errors
> val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
               ?(V : set)  (p : fun(V#, U)).
                 epi(p#) &
                 ?(A : set)  (fa : fun(A#, V#)).
                   !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                     isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   U
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   ----------------------------------------------------------------------
   ?(V : set)  (p : fun(V#, U)).
               epi(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("extra variable involved", [set], [A], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   U
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.?(B : set)  (p : fun(B#, U))  (Y : set)  (M : rel(B#, Y#)).
               (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
                   isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
               !(a : mem(U))  (X : set).
                 P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#
   ----------------------------------------------------------------------
   ?(V : set)  (p : fun(V#, U)).
               epi(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   ----------------------------------------------------------------------
   ?(V : set)  (p : fun(V#, U)).
               epi(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)
   : proofmanager.proof
> rsi_def;
val it =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (r : rel(A#, B#)).
        rsi(r#, a#) = App(Rsi(r#), a#): thm
> Rsi_def;
val it =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#)). Rsi(r#) = Ri(r#) o Sg(A#):
   thm
> Ri_def;
val it =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (s : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Ri(r#), s#)) <=>
        ?(a : mem(A#)). IN(a#, s#) & Holds(r#, a#, b#): thm
> # val it =
   {(B : set), (Y : set)}, 
   |- ?(B' : set)  (i : fun(B'#, B * Pow(Y))).
        Inj(i#) &
        !(a : mem(B * Pow(Y))). P(a#) <=> ?(b : mem(B'#)). a# = App(i#, b#):
   thm
> # # # Exception- ERROR "Symbol:) expected" raised
> # # # val it =
   {(B : set), (M : rel(B, Y)), (Y : set)}, 
   |- ?(B' : set)  (i : fun(B'#, B * Pow(Y))).
        Inj(i#) &
        !(a : mem(B * Pow(Y))).
          Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(B'#)). a# = App(i#, b#):
   thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   ?(V : set)  (p : fun(V#, U)).
               epi(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   epi(p o p1(B, Pow(Y)) o inc) &
             ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Pow(Y)) o inc, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 2 subgoals:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   6.epi(p o p1(B, Pow(Y)) o inc)
   ----------------------------------------------------------------------
   epi(p o p1(B, Pow(Y)) o inc) &
             ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Pow(Y)) o inc, v#), vA#)
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   epi(p o p1(B, Pow(Y)) o inc)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # poly: : error: Value or constructor (epi_def) has not been declared Found near [epi_def]
Static Errors
> val it = PRFS []: proofmanager.proofs
> val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
               ?(V : set)  (p : fun(V#, U)).
                 Surj(p#) &
                 ?(A : set)  (fa : fun(A#, V#)).
                   !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                     isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holSsbOuKScript.sml

******
2 subgoals:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   6.Surj(p o p1(B, Pow(Y)) o inc)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Pow(Y)) o inc) &
             ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Pow(Y)) o inc, v#), vA#)
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Pow(Y)) o inc)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   !(b : mem(U)). ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # Exception- ERR ("drule.find", [], [], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # Exception- UNIFY ("different variable name", []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.Inj(inc)
   4.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   5.!(X : set). P(b, X#) ==> ?(b' : mem(B)). App(p, b'#) = b
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> val it =
   YVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Inj(inc)
   4.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   5.?(X : set). P(b, X#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holJ12x6ZScript.sml

******
2 subgoals:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   6.Surj(p o p1(B, Pow(Y)) o inc)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Pow(Y)) o inc) &
             ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Pow(Y)) o inc, v#), vA#)
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Pow(Y)) o inc)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Inj(inc)
   4.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   5.?(X : set). P(b, X#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Inj(inc)
   4.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   5.P(b, X)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   4.P(b, X)
   5.?(b' : mem(B)). App(p, b'#) = b
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   4.P(b, X)
   5.App(p, b') = b
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # Exception- TER ("match_sort.incorrect length of list", [], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.P(b, X)
   4.App(p, b') = b
   5.Snd(Pair(b', rsi(M, b'))) = rsi(M, Fst(Pair(b', rsi(M, b')))) <=>
             ?(b : mem(V)). Pair(b', rsi(M, b')) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.P(b, X)
   4.App(p, b') = b
   5.Snd(Pair(b', rsi(M, b'))) = rsi(M, Fst(Pair(b', rsi(M, b')))) <=>
             ?(b : mem(V)). Pair(b', rsi(M, b')) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)). Pair(Fst(r#), Snd(r#)) = r#:
   thm
> # val it =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#: thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b'' : mem(V))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.P(b, X)
   4.App(p, b') = b
   5.Pair(b', rsi(M, b')) = App(inc, b'')
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Pow(Y)) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b'' : mem(V))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.P(b, X)
   4.App(p, b') = b
   5.Pair(b', rsi(M, b')) = App(inc, b'')
   ----------------------------------------------------------------------
   App(p o p1(B, Pow(Y)) o inc, b'') = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b'' : mem(V))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.P(b, X)
   4.App(p, b') = b
   5.App(inc, b'') = Pair(b', rsi(M, b'))
   ----------------------------------------------------------------------
   App(p o p1(B, Pow(Y)) o inc, b'') = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b'' : mem(V))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.P(b, X)
   4.App(p, b') = b
   5.App(inc, b'') = Pair(b', rsi(M, b'))
   ----------------------------------------------------------------------
   App(p, App(p1(B, Pow(Y)), Pair(b', rsi(M, b')))) = b
   : proofmanager.proof
> find "Pair";
poly: : error: Value or constructor (find) has not been declared Found near find "Pair"
Static Errors
> find_th "Pair";
val it =
   [("App_Pa_Pair",
     {}, 
     |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)
        (g : fun(X#, B#))  (x : mem(X#)).
          App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#))),
    ("App_p1_Pair",
     {}, 
     |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
          App(p1(A#, B#), Pair(a#, b#)) = a#),
    ("App_p2_Pair",
     {}, 
     |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
          App(p2(A#, B#), Pair(a#, b#)) = b#),
    ("Pair_App_eq",
     {}, 
     |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
          App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
          App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#),
    ("Pair_Fst_Snd",
     {}, 
     |- !(A : set)  (B : set)  (r : mem(A# * B#)).
          Pair(Fst(r#), Snd(r#)) = r#),
    ("Pair_component",
     {}, 
     |- !(A : set)  (B : set)  (r : mem(A# * B#)).
          Pair(App(p1(A#, B#), r#), App(p2(A#, B#), r#)) = r#),
    ("Pair_def'",
     {}, 
     |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
          Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#),
    ("Pair_eq_eq",
     {}, 
     |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
        (b2 : mem(B#)).
          Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#),
    ("Pair_has_comp",
     {}, 
     |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
          ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#)),
    ("Pair_p12",
     {}, 
     |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
          Pair(App(p1(A#, B#), ab#), App(p2(A#, B#), ab#)) = ab#),
    ("Pair_uex",
     {}, 
     |- !(A : set)  (B : set)  (x : mem(A#))  (y : mem(B#)).
          ?!(r : mem(A# * B#)).
            App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#),
    ("isPair_uex",
     {}, 
     |- !(A : set)  (B : set)  (AB : set)  (p1 : fun(AB#, A#))
        (p2 : fun(AB#, B#))  (AB' : set)  (p1' : fun(AB'#, A#))
        (p2' : fun(AB'#, B#)).
          isPair(p1#, p2#) & isPair(p1'#, p2'#) ==>
          ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            p1'# o i# = p1# &
            p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#),
    ("p12_of_Pair",
     {}, 
     |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
          App(p1(A#, B#), Pair(x#, y#)) = x# &
          App(p2(A#, B#), Pair(x#, y#)) = y#)]: (string * thm) list
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b'' : mem(V))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Pow(Y)))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.P(b, X)
   4.App(p, b') = b
   5.App(inc, b'') = Pair(b', rsi(M, b'))
   ----------------------------------------------------------------------
   App(p, b') = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   6.Surj(p o p1(B, Pow(Y)) o inc)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Pow(Y)) o inc) &
             ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Pow(Y)) o inc, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Pow(Y)))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Pow(Y))).
               Snd(a#) = rsi(M, Fst(a#)) <=> ?(b : mem(V)). a# = App(inc, b#)
   6.Surj(p o p1(B, Pow(Y)) o inc)
   ----------------------------------------------------------------------
   ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Pow(Y)) o inc, v#), vA#)
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   ----------------------------------------------------------------------
   ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # # # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception-
   ERR
     ("exists_tac.inconsist sorts", [fun(V, B), fun(V, U)],
      [p1(B, Y) o inc, p], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Y) o inc) &
             ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Y) o inc, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # Exception- UNIFY ("terms cannot be unified", []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 2 subgoals:
val it =
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   6.Surj(p o p1(B, Y) o inc)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Y) o inc) &
             ?(A : set)  (fa : fun(A#, V)).
               !(v : mem(V))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==>
                 P(App(p o p1(B, Y) o inc, v#), vA#)
   YVUB(M : rel(B, Y))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   Surj(p o p1(B, Y) o inc)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Y) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Inj(inc)
   4.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   5.?(X : set). P(b, X#)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Y) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Inj(inc)
   4.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   5.P(b, X)
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Y) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))(inc : fun(V, B * Y))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   4.P(b, X)
   5.?(b' : mem(B)). App(p, b'#) = b
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Y) o inc, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YXVUB(M : rel(B, Y))(b' : mem(B))(b : mem(U))(p : fun(B, U))(inc :
      fun(V, B * Y))
   1.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   2.Inj(inc)
   3.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(V)). a# = App(inc, b#)
   4.P(b, X)
   5.App(p, b') = b
   ----------------------------------------------------------------------
   ?(a : mem(V)). App(p o p1(B, Y) o inc, a#) = b
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
> val it = PRFS []: proofmanager.proofs
> # Exception- ERR ("", [], [], []) raised
> Exception- NO_PROOFS raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # Exception- NO_PROOFS raised
> val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
               ?(V : set)  (p : fun(V#, U)).
                 Surj(p#) &
                 ?(A : set)  (fa : fun(A#, V#)).
                   !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                     isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   ----------------------------------------------------------------------
   ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   ----------------------------------------------------------------------
   Surj(p) &
             ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   ----------------------------------------------------------------------
   Surj(p) &
             ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   ----------------------------------------------------------------------
   Surj(p)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   ----------------------------------------------------------------------
   !(b : mem(U)). ?(a : mem(B)). App(p, a#) = b#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   ----------------------------------------------------------------------
   ?(a : mem(B)). App(p, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(b : mem(U))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   ----------------------------------------------------------------------
   ?(X : set). P(b, X#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   ----------------------------------------------------------------------
   Surj(p) &
             ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   ----------------------------------------------------------------------
   ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # Exception- ERR ("extra variable involved", [set], [B], []) raised
> # # # val it =
   {(B : set), (M : rel(B, Y)), (Y : set)}, 
   |- ?(B' : set)  (i : fun(B'#, B * Y)).
        Inj(i#) &
        !(a : mem(B * Y)).
          Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(B'#)). a# = App(i#, b#):
   thm
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # # # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   ----------------------------------------------------------------------
   ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # 1 subgoal:
val it =
   YUBA(M : rel(B, Y))(p : fun(B, U))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(fa)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   ----------------------------------------------------------------------
   ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception-
   ERR
     ("exists_tac.inconsist sorts", [fun(A, U), fun(A, B)],
      [p o p1(B, Y) o fa, fa], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YUBA(M : rel(B, Y))(p : fun(B, U))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(fa)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   ----------------------------------------------------------------------
   !(v : mem(B))  (vA : set)  (i : fun(vA#, A)).
               isset(i#, FIB(p1(B, Y) o fa, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(fa)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   7.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   P(App(p, v), vA)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). isset(i#, rsi(M, v))
   : proofmanager.proof
> find_th "isset";
val it = []: (string * thm) list
> isset_def;
val it =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
> val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(fa)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   7.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   P(App(p, v), vA)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). isset(i#, rsi(M, v))
   : proofmanager.proof
> # val it =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   isset(p2(B, Y) o fa o i, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o fa o i) & IMAGE(p2(B, Y) o fa o i, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.Inj(p2(B, Y) o fa o i)
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o fa o i) & IMAGE(p2(B, Y) o fa o i, Whole(vA)) = rsi(M, v)
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o fa o i)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   !(x1 : mem(vA))  (x2 : mem(vA)).
               App(p2(B, Y) o fa o i, x1#) = App(p2(B, Y) o fa o i, x2#) ==>
               x1# = x2#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y) o fa o i, x1) = App(p2(B, Y) o fa o i, x2)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holfJwyt7Script.sml

******
1 subgoal:
val it =
   YUBA(M : rel(B, Y))(p : fun(B, U))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(fa)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   ----------------------------------------------------------------------
   !(v : mem(B))  (vA : set)  (i : fun(vA#, A)).
               isset(i#, FIB(p1(B, Y) o fa, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # 2 subgoals:
val it =
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.Inj(p2(B, Y) o fa o i)
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o fa o i) & IMAGE(p2(B, Y) o fa o i, Whole(vA)) = rsi(M, v)
   vAYUBA(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(i : fun(vA, A))(fa :
      fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o fa o i)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   8.Inj(i) & IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o fa, v)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   8.Inj(i)
   9.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o fa, v)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   8.Inj(i)
   9.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o fa, v)
   10.!(x1 : mem(vA))  (x2 : mem(vA)).
               App(i, x1#) = App(i, x2#) <=> x1# = x2#
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   8.Inj(i)
   9.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o fa, v)
   ----------------------------------------------------------------------
   App(i, x1) = App(i, x2)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   8.Inj(i)
   9.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o fa, v)
   10.!(x1 : mem(A))  (x2 : mem(A)).
               App(fa, x1#) = App(fa, x2#) <=> x1# = x2#
   ----------------------------------------------------------------------
   App(i, x1) = App(i, x2)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYUBA(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(i : fun(vA, A))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(fa)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   6.isset(i, FIB(p1(B, Y) o fa, v))
   7.App(p2(B, Y), App(fa, App(i, x1))) = App(p2(B, Y), App(fa, App(i, x2)))
   8.Inj(i)
   9.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o fa, v)
   ----------------------------------------------------------------------
   App(fa, App(i, x1)) = App(fa, App(i, x2))
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # # # 1 subgoal:
val it =
   YUB(M : rel(B, Y))(p : fun(B, U))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   ----------------------------------------------------------------------
   ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception-
   ERR
     ("exists_tac.inconsist sorts", [fun( 9, B), fun(A, B)],
      [p1(B, Y) o fa, fa], []) raised
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holcb84V1Script.sml

******
1 subgoal:
val it =
   YUBA(M : rel(B, Y))(p : fun(B, U))(fa : fun(A, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(fa)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(A)). a# = App(fa, b#)
   ----------------------------------------------------------------------
   !(v : mem(B))  (vA : set)  (i : fun(vA#, A)).
               isset(i#, FIB(p1(B, Y) o fa, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
val it = (): unit
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol4EH7xDScript.sml

******
1 subgoal:
val it =
   YUM0B(M : rel(B, Y))(p : fun(B, U))(i : fun(M0, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(i)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=> ?(b : mem(M0)). a# = App(i, b#)
   ----------------------------------------------------------------------
   ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception-
   ERR
     ("exists_tac.inconsist sorts", [fun( 9, B), fun(A, B)],
      [p1(B, Y) o fa, fa], []) raised
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holvzz6SHScript.sml

******
1 subgoal:
val it =
   YURB(M : rel(B, Y))(p : fun(B, U))(inc : fun(R, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(inc)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   !(v : mem(B))  (vA : set)  (i : fun(vA#, R)).
               isset(i#, FIB(p1(B, Y) o inc, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(inc)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   7.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   P(App(p, v), vA)
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holMksrHGScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). isset(i#, rsi(M, v))
   : proofmanager.proof
val it = (): unit
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holbgawabScript.sml

******
1 subgoal:
val it =
   YURB(M : rel(B, Y))(p : fun(B, U))(inc : fun(R, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(inc)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   ?(A : set)  (fa : fun(A#, B)).
               !(v : mem(B))  (vA : set)  (i : fun(vA#, A#)).
                 isset(i#, FIB(fa#, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   YURB(M : rel(B, Y))(p : fun(B, U))(inc : fun(R, B * Y))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(inc)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   ----------------------------------------------------------------------
   !(v : mem(B))  (vA : set)  (i : fun(vA#, R)).
               isset(i#, FIB(p1(B, Y) o inc, v#)) ==> P(App(p, v#), vA#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(S : set)  (i : fun(S#, Y))  (b : mem(B)).
               isset(i#, rsi(M, b#)) ==> P(App(p, b#), S#)
   3.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   4.Surj(p)
   5.Inj(inc)
   6.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   7.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   P(App(p, v), vA)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). isset(i#, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   isset(p2(B, Y) o fa o i, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("extra variable involved", [fun(R, B * Y)], [fa], []) raised
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holC3x7vRScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). isset(i#, rsi(M, v))
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   isset(p2(B, Y) o inc o i, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i) & IMAGE(p2(B, Y) o inc o i, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i) & IMAGE(p2(B, Y) o inc o i, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("extra variable involved", [fun(B * Y, B)], [p1], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.p1(B, Y) o inc o i = constf(vA, v)
   ----------------------------------------------------------------------
   x1 = x2
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   p1(B, Y) o inc o i = constf(vA, v)
   : proofmanager.proof
> # # # # # # # val isset_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (A0 : set)
      (i : fun(A0#, A#))  (b : mem(B#)).
        isset(i#, FIB(f#, b#)) ==> f# o i# = constf(A0#, b#): thm
> > Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.(p1(B, Y) o inc) o i = constf(vA, v)
   ----------------------------------------------------------------------
   p1(B, Y) o inc o i = constf(vA, v)
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol3TEGerScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.p1(B, Y) o inc o i = constf(vA, v)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   ----------------------------------------------------------------------
   App(inc, App(i, x1)) = App(inc, App(i, x2))
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
      (b2 : mem(B#)).
        Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#: thm
> # poly: : error: Value or constructor (pair_has_comp) has not been declared
Found near pair_has_comp
Static Errors
> find_th "has_com";
val it =
   [("Pair_has_comp",
     {}, 
     |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
          ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#))]:
   (string * thm) list
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.!(A : set)  (B : set)  (ab : mem(A# * B#)).
               ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#)
   ----------------------------------------------------------------------
   App(inc, App(i, x1)) = App(inc, App(i, x2))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   ----------------------------------------------------------------------
   App(inc, App(i, x1)) = App(inc, App(i, x2))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b : mem(Y))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   ----------------------------------------------------------------------
   App(inc, App(i, x1)) = App(inc, App(i, x2))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), App(inc, App(i, x1))) =
               App(p2(B, Y), App(inc, App(i, x2)))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   App(inc, App(i, x1)) = App(inc, App(i, x2))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Pair(a, b) = Pair(a', b')
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a' & b = b'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = a
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = Fst(Pair(a, b)) ==> a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = Fst(Pair(a, b)) ==> a = a'
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = a ==> a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = Fst(App(inc, App(i, x1))) ==> a' = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   a' = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> #   C-c C-c
Process HOL killed: 9
> Loading empty hol-mode.sml
> > > use "SEARmaster.ML";
val use = fn: string -> unit
******

Loading SEAR file SEARsorts.sml

******
val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = set: sort
val it = (): unit
******

Loading SEAR file SEARnewspec.sml

******
val define_fsym = fn: string * (string * sort) list -> term -> thm
val define_fsym_lemma_fun =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : fun(A#, B#)).
        ?!(newfsym : fun(A#, B#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_mem =
   {}, 
   |- !(A : set)  (newfsym0 : mem(A#)).
        ?!(newfsym : mem(A#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_rel =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : rel(A#, B#)).
        ?!(newfsym : rel(A#, B#)). newfsym# = newfsym0#: thm
val funeqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : fun(A#, B#)). i# = i#) &
        (!(i : fun(A#, B#))  (i' : fun(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : fun(A#, B#))  (i' : fun(A#, B#))  (i'' : fun(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val memeqeqvth =
   {}, 
   |- !(A : set).
        (!(i : mem(A#)). i# = i#) &
        (!(i : mem(A#))  (i' : mem(A#)). i# = i'# ==> i'# = i#) &
        !(i : mem(A#))  (i' : mem(A#))  (i'' : mem(A#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val qdefine_fsym = fn: string * term frag list list -> term frag list -> thm
val qsimple_uex_spec = fn: string -> term frag list list -> thm -> thm
val quex_spec = fn: string -> term frag list list -> thm -> thm -> thm
val releqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : rel(A#, B#)). i# = i#) &
        (!(i : rel(A#, B#))  (i' : rel(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : rel(A#, B#))  (i' : rel(A#, B#))  (i'' : rel(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val simple_uex_spec = fn: string -> (string * sort) list -> thm -> thm
val uex_spec = fn: string -> (string * sort) list -> thm -> thm -> thm
val it = (): unit
******

Loading SEAR file SEARrel.sml

******
val AX1 =
   {}, 
   |- !(A : set)  (B : set).
        ?!(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val Fun_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=> !(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#): thm
val R_EXT =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        (!(a : mem(A#))  (b : mem(B#)).
            Holds(R1#, a#, b#) <=> Holds(R2#, a#, b#)) <=> R1# = R2#: thm
val AX1_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val ao_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, c#)) <=>
        Holds(psi# @ phi#, a#, c#): thm
val ao_def0 =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (b : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, b#)) <=>
        Holds(psi# @ phi#, a#, b#): thm
val ao_uex =
   {(A : set), (B : set), (C : set), (phi : rel(A, B)), (psi : rel(B, C))}, 
   |- ?!(R : rel(A, C)).
        !(a : mem(A))  (b : mem(C)).
          Holds(R#, a#, b#) <=>
          ?(b : mem(B)). Holds(phi, a#, b#) & Holds(psi, b#, b#): thm
val Fun_expand =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=>
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) &
        !(a : mem(A#))  (b1 : mem(B#))  (b2 : mem(B#)).
          Holds(R#, a#, b1#) & Holds(R#, a#, b2#) ==> b1# = b2#: thm
val id_Fun = {},  |- !(A : set). isFun(id(A#)): thm
val id_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)).
        Holds(id(A#), a#, b#) <=> a# = b#: thm
val id_uex =
   {(A : set)}, 
   |- ?!(R : rel(A, A)).
        !(a : mem(A))  (b : mem(A)). Holds(R#, a#, b#) <=> a# = b#: thm
val idL = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). id(B#) @ f# = f#:
   thm
val idR = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). f# @ id(A#) = f#:
   thm
val Thm_2_7_ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val Thm_2_7_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val Thm_2_7_id =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#)).
        phi# @ id(A#) = phi# & id(B#) @ phi# = phi#: thm
val op_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(B#))  (b : mem(A#)).
        Holds(op(R#), a#, b#) <=> Holds(R#, b#, a#): thm
val op_uex =
   {(A : set), (B : set), (R : rel(A, B))}, 
   |- ?!(R' : rel(B, A)).
        !(a : mem(B))  (b : mem(A)). Holds(R'#, a#, b#) <=> Holds(R, b#, a#):
   thm
val ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val ao_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val op_DISTR =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#)). op(psi# @ phi#) = op(phi#) @ op(psi#): thm
val Refl_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> !(a : mem(A#)). Holds(R#, a#, a#): thm
val Sym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> Holds(R#, a2#, a1#): thm
val Trans_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Trans(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#))  (a3 : mem(A#)).
          Holds(R#, a1#, a2#) & Holds(R#, a2#, a3#) ==> Holds(R#, a1#, a3#):
   thm
val ER_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) <=> Refl(R#) & Sym(R#) & Trans(R#): thm
val Sym_Trans_Rright =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) & Trans(R#) ==>
        !(x : mem(A#))  (y : mem(A#)).
          Holds(R#, x#, y#) ==>
          !(z : mem(A#)). Holds(R#, x#, z#) <=> Holds(R#, y#, z#): thm
val op_op =
   {},  |- !(A : set)  (B : set)  (R : rel(A#, B#)). op(op(R#)) = R#: thm
val it = (): unit
******

Loading SEAR file SEARfun.sml

******
val rel2fun =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val rel2fun_ex =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val rel2fun_ex' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val asR_Fun =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). isFun(asR(f#)): thm
val asR_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- !(a : mem(A))  (b : mem(B)). Holds(asR(f), a#, b#) <=> App(f, a#) = b#:
   thm
val asR_uex =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- ?!(R : rel(A, B)).
        !(a : mem(A))  (b : mem(B)). Holds(R#, a#, b#) <=> App(f, a#) = b#:
   thm
val FUN_EXT =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        (!(a : mem(A#)). App(f1#, a#) = App(f2#, a#)) <=> f1# = f2#: thm
val P2fun_uex =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val fun_tm_compr = fn: string * sort -> term -> thm
val fun_tm_compr_uex = fn: string * sort -> term -> thm
val qfun_compr = fn: term frag list -> term frag list -> thm
val unique_lemma =
   {},  |- !(A : set)  (a : mem(A#)). ?!(a' : mem(A#)). a'# = a#: thm
val App_Id = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_def = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_uex =
   {(A : set)}, 
   |- ?!(f : fun(A, A)).
        !(a : mem(A))  (b : mem(A)).
          App(f#, a#) = b# <=> Holds(id(A), a#, b#): thm
val o_ex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val o_uex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?!(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val Inj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) <=>
        !(x1 : mem(A#))  (x2 : mem(A#)).
          App(f#, x1#) = App(f#, x2#) ==> x1# = x2#: thm
val o_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        App(psi# o phi#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#):
   thm
val Surj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) <=> !(b : mem(B#)). ?(a : mem(A#)). App(f#, a#) = b#: thm
val Bij_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> Inj(f#) & Surj(f#): thm
val Bij_op =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> ?(f' : fun(B#, A#)). asR(f'#) = op(asR(f#)): thm
val App_App_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val App_o_l =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val asR_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        asR(g# o f#) = asR(g#) @ asR(f#): thm
val asR_Id = {},  |- !(A : set). asR(Id(A#)) = id(A#): thm
val asR_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        asR(f1#) = asR(f2#) <=> f1# = f2#: thm
val Thm_2_7_bij =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#)).
        Bij(phi#) <=>
        ?(psi : fun(B#, A#)). psi# o phi# = Id(A#) & phi# o psi# = Id(B#):
   thm
val Inj_lcancel =
   {}, 
   |- !(A : set)  (B : set)  (m : fun(A#, B#)).
        Inj(m#) ==>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, A#)).
          m# o f# = m# o g# ==> f# = g#: thm
val IdL = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Id(B#) o f# = f#:
   thm
val IdR = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). f# o Id(A#) = f#:
   thm
val Inj_lift_R_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(R : rel(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?!(a2 : mem(A#)). Holds(R#, App(i#, a1#), App(i#, a2#))) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). Holds(R#, App(i#, a#), App(i# o f#, a#)): thm
val Inj_lift_fun_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val asR_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        Holds(asR(f#), a#, b#) <=> App(f#, a#) = b#: thm
val Inj_lift_fun_lemma' =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?!(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val Inj_eq_eq =
   {}, 
   |- !(X : set)  (Y : set)  (i : fun(X#, Y#)).
        Inj(i#) ==>
        !(x1 : mem(X#))  (x2 : mem(X#)).
          App(i#, x1#) = App(i#, x2#) <=> x1# = x2#: thm
val Inj_lift_fun =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?(f : fun(X#, A#)). !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#):
   thm
val Inj_lift_fun_uex =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?!(f : fun(X#, A#)).
            !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#): thm
val o_assoc =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (D : set)  (h : fun(C#, D#)). (h# o g#) o f# = h# o g# o f#: thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val P2fun_uex0 =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val it = (): unit
******

Loading SEAR file SEARsetting.sml

******
val AX0 = {},  |- ?(A : set)  (a : mem(A#)). T: thm
val Tab_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) <=>
        (!(x : mem(A#))  (y : mem(B#)).
            Holds(R#, x#, y#) <=>
            ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val AX2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        ?(TR : set)  (p : fun(TR#, A#))  (q : fun(TR#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              Holds(R#, x#, y#) <=>
              ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
          !(r : mem(TR#))  (s : mem(TR#)).
            App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Empty_unique =
   {}, 
   |- !(E1 : set)  (E2 : set).
        (!(a : mem(E1#)). F) & (!(a : mem(E2#)). F) ==>
        ?(i : fun(E1#, E2#))  (j : fun(E2#, E1#)).
          i# o j# = Id(E2#) & j# o i# = Id(E1#): thm
val Thm_2_2 = {},  |- ?(Empty : set). !(a : mem(Empty#)). F: thm
val Thm_2_3 =
   {},  |- ?(ONE : set)  (x : mem(ONE#)). !(x' : mem(ONE#)). x'# = x#: thm
val unique_fun_to_ONE =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#)).
        (!(a : mem(ONE#)). a# = x#) ==> !(A : set). ?!(f : fun(A#, ONE#)). T:
   thm
val ONE_unique =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#))  (ONE' : set)  (x' : mem(ONE'#)).
        (!(a : mem(ONE#)). a# = x#) & (!(a : mem(ONE'#)). a# = x'#) ==>
        ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
          i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso0_REFL =
   {}, 
   |- !(A : set).
        ?(i : fun(A#, A#))  (j : fun(A#, A#)).
          i# o j# = Id(A#) & j# o i# = Id(A#): thm
val iso0_SYM =
   {}, 
   |- !(A : set)  (A' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
        ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
          i# o j# = Id(A#) & j# o i# = Id(A'#): thm
val iso0_TRANS =
   {}, 
   |- !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_uex =
   {}, 
   |- ?(ONE : set).
        (?(x : mem(ONE#)). !(a : mem(ONE#)). a# = x#) &
        !(ONE' : set).
          (?(x : mem(ONE'#)). !(a : mem(ONE'#)). a# = x#) ==>
          ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
            i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso_Reqv =
   {}, 
   |- (!(A : set).
          ?(i : fun(A#, A#))  (j : fun(A#, A#)).
            i# o j# = Id(A#) & j# o i# = Id(A#)) &
      (!(A : set)  (A' : set).
          (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
              i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
          ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
            i# o j# = Id(A#) & j# o i# = Id(A'#)) &
      !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_def = {},  |- ?(x : mem(1)). !(a : mem(1)). a# = x#: thm
val dot_uex = {},  |- ?!(x : mem(1)). x# = x#: thm
val dot_def = {},  |- !(a : mem(1)). a# = dot: thm
val dot_def0 = {},  |- dot = dot: thm
val ONE = 1: term
val Thm_2_3_5 = {},  |- !(A : set). ?!(f : rel(A#, 1)). isFun(f#): thm
val To1_ex = {},  |- !(A : set). ?!(f : fun(A#, 1)). T: thm
val dot = dot: term
val To1_uex = {},  |- !(A : set). ?!(f : fun(A#, 1)). f# = f#: thm
val To1_def = {},  |- !(A : set)  (f' : fun(A#, 1)). f'# = To1(A#): thm
val To1_def0 = {(A : set)},  |- To1(A) = To1(A): thm
val Thm_2_4_R_ver =
   {}, 
   |- !(A : set)  (R : rel(1, A#)).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)).
            Holds(R#, dot, a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Rel_Pred1 =
   {}, 
   |- !(A : set).
        ?!(R : rel(1, A#)). !(a : mem(A#)). Holds(R#, dot, a#) <=> P(a#): thm
val Tab_App_Rel =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (x : mem(A#))  (y : mem(B#)).
          App(p#, r#) = x# & App(q#, r#) = y# ==> Holds(R#, x#, y#): thm
val Thm_2_4 =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Tab_mem_R =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#)). Holds(R#, App(p#, r#), App(q#, r#)): thm
val Tab_prop1 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(x : mem(A#))  (y : mem(B#)).
          Holds(R#, x#, y#) <=>
          ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#: thm
val T_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(T0 : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(T0#, a#, b#): thm
val T_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          (!(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#)) &
          !(R' : rel(A#, B#)).
            (!(a : mem(A#))  (b : mem(B#)). Holds(R'#, a#, b#)) ==> R'# = R#:
   thm
val Tab_prop2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Thm_2_5 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (T1 : set)
      (p1 : fun(T1#, A#))  (q1 : fun(T1#, B#))  (T2 : set)
      (p2 : fun(T2#, A#))  (q2 : fun(T2#, B#)).
        isTab(R#, p1#, q1#) & isTab(R#, p2#, q2#) ==>
        ?(b : fun(T1#, T2#)). Bij(b#): thm
val isPair_def =
   {(A : set), (AxB : set), (B : set), (p1 : fun(AxB, A)), (p2 : fun(AxB, B))},
   
   |- isPair(p1, p2) <=>
      !(x : mem(A))  (y : mem(B)).
        ?!(r : mem(AxB)). App(p1, r#) = x# & App(p2, r#) = y#: thm
val isPair_uex =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (p1 : fun(AB#, A#))
      (p2 : fun(AB#, B#))  (AB' : set)  (p1' : fun(AB'#, A#))
      (p2' : fun(AB'#, B#)).
        isPair(p1#, p2#) & isPair(p1'#, p2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          p1'# o i# = p1# &
          p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AxB : set)  (p1 : fun(AxB#, A#))  (p2 : fun(AxB#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              ?(r : mem(AxB#)). App(p1#, r#) = x# & App(p2#, r#) = y#) &
          !(r : mem(AxB#))  (s : mem(AxB#)).
            App(p1#, r#) = App(p1#, s#) & App(p2#, r#) = App(p2#, s#) ==>
            r# = s#: thm
val Pr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)).
          isPair(p1#, p2#) &
          !(AB' : set)  (p1' : fun(AB'#, A#))  (p2' : fun(AB'#, B#)).
            isPair(p1'#, p2'#) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_p12_def =
   {},  |- !(A : set)  (B : set). isPair(p1(A#, B#), p2(A#, B#)): thm
val Pr_ts_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)). T: thm
val isPair_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            p1# o i# = p1# & p2# o i# = p2# & p1# o j# = p1# & p2# o j# = p2#) &
      (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
        (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            p1# o i# = p1'# &
            p2# o i# = p2'# & p1'# o j# = p1# & p2'# o j# = p2#) &
      !(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
      (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B))  (AB'' : set)
      (p1'' : fun(AB''#, A))  (p2'' : fun(AB''#, B)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            p1'# o i# = p1# &
            p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            p1''# o i# = p1'# &
            p2''# o i# = p2'# & p1'# o j# = p1''# & p2'# o j# = p2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          p1''# o i# = p1# &
          p2''# o i# = p2# & p1# o j# = p1''# & p2# o j# = p2''#: thm
val p2_def =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#))  (y : mem(B#)).
            ?(r : mem(A# * B#)).
              App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#) &
        !(r : mem(A# * B#))  (s : mem(A# * B#)).
          App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
          App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val SetPr_def =
   {}, 
   |- !(A : set)  (AB : set)  (p1 : fun(AB#, A#))  (B : set)
      (p2 : fun(AB#, B#)).
        SetPr(p1#, p2#) <=>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
          ?!(fg : fun(X#, AB#)). p1# o fg# = f# & p2# o fg# = g#: thm
val Cross = fn: term -> term -> term
val Pa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        (p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#) &
        !(fg' : fun(X#, A# * B#)).
          p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==>
          fg'# = Pa(f#, g#): thm
val Pa_def0 =
   {(A : set), (B : set), (X : set), (f : fun(X, A)), (g : fun(X, B))}, 
   |- p1(A, B) o Pa(f, g) = f & p2(A, B) o Pa(f, g) = g: thm
val Thm_2_8_SetPr =
   {},  |- !(A : set)  (B : set). SetPr(p1(A#, B#), p2(A#, B#)): thm
val p12_of_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#: thm
val p1_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f#: thm
val p2_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p2(A#, B#) o Pa(f#, g#) = g#: thm
val is_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (fg' : fun(X#, A# * B#)).
        p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==> fg'# = Pa(f#, g#):
   thm
val AX3 =
   {}, 
   |- !(A : set).
        ?(PA : set)  (e : rel(A#, PA#)).
          !(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#): thm
val Pow_uex =
   {(A : set)}, 
   |- ?(PA : set)  (e : rel(A, PA#)).
        (!(S0 : rel(1, A)).
            ?!(s : mem(PA#)).
              !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        !(PA' : set)  (e' : rel(A, PA'#)).
          (!(S0 : rel(1, A)).
              ?!(s : mem(PA'#)).
                !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
          ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val Pow_unique =
   {}, 
   |- !(A : set)  (PA : set)  (e : rel(A#, PA#))  (PA' : set)
      (e' : rel(A#, PA'#)).
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA'#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
        ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
          i# o j# = Id(PA'#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val SetEz_def =
   {(A : set), (B : set), (E : set), (e : fun(E, A)), (f : fun(A, B)),
    (g : fun(A, B))}, 
   |- SetEz(f, g, e) <=>
      !(X : set)  (x : fun(X#, A)).
        f o x# = g o x# ==> ?!(x0 : fun(X#, E)). x# = e o x0#: thm
val Thm_2_10 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(M : set)  (e : fun(A#, M#))  (m : fun(M#, B#)).
          f# = m# o e# & Surj(e#) & Inj(m#): thm
val Thm_2_9_Eqlz =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
        ?(E : set)  (e : fun(E#, A#)). SetEz(f#, g#, e#): thm
val BC0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))).
        Holds(BC0(f#), a#, b#) <=>
        !(z : mem(Z#)).
          Holds(In(Z#), z#, b#) <=> Holds(In(Y#), App(f#, z#), a#): thm
val Pow = fn: term -> term
val Pow_REFL =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#)).
        ?(i : fun(PA#, PA#))  (j : fun(PA#, PA#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e# & asR(j#) @ e# = e#: thm
val Pow_SYM =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) ==>
        ?(i : fun(PA'#, PA#))  (j : fun(PA#, PA'#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA'#) & asR(i#) @ e'# = e# & asR(j#) @ e# = e'#: thm
val Pow_TRANS =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#))
      (PA'' : set)  (e'' : rel(A, PA''#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) &
        (?(i : fun(PA'#, PA''#))  (j : fun(PA''#, PA'#)).
            i# o j# = Id(PA''#) &
            j# o i# = Id(PA'#) & asR(i#) @ e'# = e''# & asR(j#) @ e''# = e'#) ==>
        ?(i : fun(PA#, PA''#))  (j : fun(PA''#, PA#)).
          i# o j# = Id(PA''#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e''# & asR(j#) @ e''# = e#: thm
val Pow_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val All0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(All0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, a#): thm
val All0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(All0(f#)): thm
val BC0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(BC0(f#)): thm
val Ex0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(Ex0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          ?(z : mem(Z#)). Holds(In(Z#), z#, a#) & App(f#, z#) = y#: thm
val Ex0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(Ex0(f#)): thm
val In_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). Holds(In(A#), x#, s1#) <=> Holds(In(A#), x#, s2#)) ==>
        s1# = s2#: thm
val In_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val In_def_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (s0 : fun(A0#, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)).
            (?(a0 : mem(A0#)). x# = App(s0#, a0#)) <=> Holds(In(A#), x#, s#):
   thm
val In_def_P =
   {}, 
   |- !(A : set).
        ?!(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> Holds(In(A#), a#, s#):
   thm
val PO_def =
   {}, 
   |- !(A : set)  (S1 : mem(Pow(A#)))  (S2 : mem(Pow(A#))).
        PO(S1#, S2#) <=>
        !(a : mem(A#)). Holds(In(A#), a#, S1#) ==> Holds(In(A#), a#, S2#):
   thm
val BC_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))). App(BC(f#), a#) = b# <=> Holds(BC0(f#), a#, b#):
   thm
val In_App_BC =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (z : mem(Z#))
      (ys : mem(Pow(Y#))).
        Holds(In(Z#), z#, App(BC(f#), ys#)) <=>
        Holds(In(Y#), App(f#, z#), ys#): thm
val Ex_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(Ex(f#), a#) = b# <=> Holds(Ex0(f#), a#, b#):
   thm
val In_App_Ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(Ex(f#), zs#)) <=>
        ?(z : mem(Z#)). Holds(In(Z#), z#, zs#) & App(f#, z#) = y#: thm
val All_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(All(f#), a#) = b# <=> Holds(All0(f#), a#, b#):
   thm
val In_App_All =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(All(f#), zs#)) <=>
        !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, zs#): thm
val Thm_2_11_SEx_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (zs : mem(Pow(Z#)))
      (ys : mem(Pow(Y#))).
        PO(App(Ex(f#), zs#), ys#) <=> PO(zs#, App(BC(f#), ys#)): thm
val Thm_2_11_SAll_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (ys : mem(Pow(Y#)))
      (zs : mem(Pow(Z#))).
        PO(App(BC(f#), ys#), zs#) <=> PO(ys#, App(All(f#), zs#)): thm
val Sub_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, R2#) <=>
        !(a : mem(A#))  (b : mem(B#)).
          Holds(R1#, a#, b#) ==> Holds(R2#, a#, b#): thm
val Meet_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Meet(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) & Holds(R2#, a#, b#): thm
val Sub_Meet =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(Meet(R1#, R2#), R1#) &
        Sub(Meet(R1#, R2#), R2#) &
        !(R0 : rel(A#, B#)).
          Sub(R0#, R1#) & Sub(R0#, R2#) ==> Sub(R0#, Meet(R1#, R2#)): thm
val Join_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Join(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) | Holds(R2#, a#, b#): thm
val Sub_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, Join(R1#, R2#)) &
        Sub(R2#, Join(R1#, R2#)) &
        !(R0 : rel(A#, B#)).
          Sub(R1#, R0#) & Sub(R2#, R0#) ==> Sub(Join(R1#, R2#), R0#): thm
val MODULAR_LAW =
   {}, 
   |- !(x : set)  (y : set)  (phi : rel(x#, y#))  (z : set)
      (psi : rel(y#, z#))  (chi : rel(x#, z#)).
        Sub(Meet(psi# @ phi#, chi#), psi# @ Meet(phi#, op(psi#) @ chi#)): thm
val left_o_pres_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (C : set)  (R : rel(B#, C#)).
        R# @ Join(R1#, R2#) = Join(R# @ R1#, R# @ R2#): thm
val right_o_pres_Join =
   {(C : set)}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (R : rel(C, A#)). Join(R1#, R2#) @ R# = Join(R1# @ R#, R2# @ R#): thm
val Div_ex =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (C : set)  (s : rel(A#, C#)).
        ?(sdr : rel(B#, C#)).
          !(t : rel(B#, C#)). Sub(t#, sdr#) <=> Sub(t# @ r#, s#): thm
val MF_def = {},  |- !(A : set)  (a : mem(A#)). App(MF(a#), dot) = a#: thm
val Pair_uex =
   {}, 
   |- !(A : set)  (B : set)  (x : mem(A#))  (y : mem(B#)).
        ?!(r : mem(A# * B#)).
          App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#: thm
val Thm_2_12 =
   {}, 
   |- !(B : set)  (A : set)  (R : rel(B#, A#)).
        ?!(fR : fun(B#, Pow(A#))).
          !(y : mem(B#))  (x : mem(A#)).
            Holds(R#, y#, x#) <=> Holds(In(A#), x#, App(fR#, y#)): thm
val Thm_2_3_5_el =
   {},  |- !(A : set)  (a : mem(A#)). ?!(R : fun(1, A#)). App(R#, dot) = a#:
   thm
val Pair_App_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val Pair_def =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val Pair_component =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)).
        Pair(App(p1(A#, B#), r#), App(p2(A#, B#), r#)) = r#: thm
val Pair_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
      (b2 : mem(B#)).
        Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#: thm
val Pair_p12 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        Pair(App(p1(A#, B#), ab#), App(p2(A#, B#), ab#)) = ab#: thm
val Ap1_def =
   {}, 
   |- !(A : set)  (X : set)  (x : mem(X#))  (B : set)  (f : fun(A# * X#, B#))
      (a : mem(A#)). App(Ap1(f#, x#), a#) = App(f#, Pair(a#, x#)): thm
val Ap1_uex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#))
      (x : mem(X#)).
        ?!(fx : fun(A#, B#)).
          !(a : mem(A#)). App(fx#, a#) = App(f#, Pair(a#, x#)): thm
val Cross_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val App_Pa =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (D : set)
      (g : fun(B#, D#))  (ab : mem(A# * B#)).
        App(Pa(f# o p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(f# o p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_o_p2 =
   {}, 
   |- !(B : set)  (C : set)  (f : fun(B#, C#))  (A : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p2(A#, B#), Pair(a#, b#)) = App(f#, b#): thm
val App_o_p1 =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p1(A#, B#), Pair(a#, b#)) = App(f#, a#): thm
val Fst_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p1(A, B), x) = Fst(x):
   thm
val Pair_def' =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#: thm
val Snd_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p2(A, B), x) = Snd(x):
   thm
val Pair_Fst_Snd =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)). Pair(Fst(r#), Snd(r#)) = r#:
   thm
val Pair_has_comp =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#): thm
val p12_of_Pair =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val dest_cross = fn: term -> term * term
val basic_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_fconv = fn: form -> thm
val mk_Pair = fn: term -> term -> term
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val Prla_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (D : set)
      (g : fun(C#, D#)). Prla(f#, g#) = Pa(f# o p1(A#, C#), g# o p2(A#, C#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Exp_ev_unique =
   {}, 
   |- !(A : set)  (B : set)  (A2B : set)  (ev : fun(A# * A2B#, B#))
      (A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B'#)).
              !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
        ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
          i# o j# = Id(A2B'#) &
          j# o i# = Id(A2B#) &
          ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#: thm
val Exp_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#): thm
val Exp_ex_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          (!(f : fun(A#, B#)).
              ?!(sf : mem(A2B#)).
                !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
          !(A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
            (!(f : fun(A#, B#)).
                ?!(sf : mem(A2B'#)).
                  !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
            ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
              i# o j# = Id(A2B'#) &
              j# o i# = Id(A2B#) &
              ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#:
   thm
val Thm_2_13 =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A2B# * A#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(sf#, a#)) = App(f#, a#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Ev_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_uex_refl =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B)).
        ?(i : fun(A2B#, A2B#))  (j : fun(A2B#, A2B#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B#) &
          ev# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_sym =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) ==>
        ?(i : fun(A2B'#, A2B#))  (j : fun(A2B#, A2B'#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B'#) &
          ev# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_trans =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B))  (A2B'' : set)  (ev'' : fun(A * A2B''#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) &
        (?(i : fun(A2B'#, A2B''#))  (j : fun(A2B''#, A2B'#)).
            i# o j# = Id(A2B''#) &
            j# o i# = Id(A2B'#) &
            ev''# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev''#) ==>
        ?(i : fun(A2B#, A2B''#))  (j : fun(A2B''#, A2B#)).
          i# o j# = Id(A2B''#) &
          j# o i# = Id(A2B#) &
          ev''# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev''#: thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val Tpm_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
        !(sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#): thm
val Tpm_def0 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#): thm
val is_Tpm =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sf' : mem(Exp(A#, B#))).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
        sf'# = Tpm(f#): thm
val Tp_def0 =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f: thm
val Tp_ex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#)).
        ?!(h : fun(X#, Exp(A#, B#))).
          Ev(A#, B#) o Pa(p1(A#, X#), h# o p2(A#, X#)) = f#: thm
val Tp_def =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f &
      !(h' : fun(X, Exp(A, B))).
        Ev(A, B) o Pa(p1(A, X), h'# o p2(A, X)) = f ==> h'# = Tp(f): thm
val is_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (h' : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), h'# o p2(A#, X#)) = f# ==> h'# = Tp(f#):
   thm
val Thm_2_14 =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        ?(B : set)  (q : fun(A#, B#)).
          Surj(q#) &
          !(x : mem(A#))  (y : mem(A#)).
            Holds(R#, x#, y#) <=> App(q#, x#) = App(q#, y#): thm
val IN_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#))).
        IN(a#, ss#) <=> Holds(In(A#), a#, ss#): thm
val IN_def_P_expand =
   {}, 
   |- !(A : set).
        ?(s : mem(Pow(A#))).
          (!(a : mem(A#)). P(a#) <=> IN(a#, s#)) &
          !(s' : mem(Pow(A#))).
            (!(a : mem(A#)). P(a#) <=> IN(a#, s'#)) ==> s'# = s#: thm
val IN_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) ==> s1# = s2#: thm
val SS_def =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) <=> !(a : mem(A#)). IN(a#, P1#) ==> IN(a#, P2#): thm
val SS_Trans =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) ==> !(P3 : mem(Pow(A#))). SS(P2#, P3#) ==> SS(P1#, P3#):
   thm
val SS_SS_eq =
   {}, 
   |- !(A : set)  (p1 : mem(Pow(A#)))  (p2 : mem(Pow(A#))).
        SS(p1#, p2#) & SS(p2#, p1#) ==> p1# = p2#: thm
val IN_def_P_ex =
   {}, 
   |- !(A : set). ?(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> IN(a#, s#):
   thm
val IN_def_P =
   {}, 
   |- !(A : set). ?!(s : mem(Pow(A#))). !(a : mem(A#)). IN(a#, s#) <=> P(a#):
   thm
val AX4 =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set).
        ?!(BI : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BI#, sss#)) <=>
            !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val BI_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BI(A#), sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val N0 = N0: term
val N0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val O0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val S0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_def =
   {(A : set), (sss : mem(Pow(Pow(A))))},  |- App(BI(A), sss) = BIGINTER(sss):
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        ?(isss : mem(Pow(A#))). App(BI(A#), sss#) = isss#: thm
val IN_BIGINTER =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGINTER(sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
******

Loading SEAR file SEARreln.sml

******
val mk_App = fn: term -> term -> term
SEARreln.sml:75: warning: Matches are not exhaustive.
Found near
  case (view_form ante, view_form conseq) of
     (vConn ("&", ...), vConn (...)) =>
     let val ip1 = ... ...; val ... = ... in conj_monotone ip1 ip2 end |
     (vConn (...), ... ...) => let val ... = ...; val ... in ... ... ip2 end
     |
     (... ..., ...) => let val ... in ... ... end |
     (...) => let ... in ... end
SEARreln.sml:247: warning: Pattern is not exhaustive.
Found near
  val [fnterm, LFP] = fLFP |> #3 o dest_fun handle _ => raise ... ...
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
val conj_monotone = fn: thm -> thm -> thm
val disj_monotone = fn: thm -> thm -> thm
val exists_monotone = fn: thm -> thm
val forall_monotone = fn: thm -> thm
val imp_induce = fn: thm -> form -> thm
val mk_LFP = fn: term -> thm
val mk_Pow = fn: term -> term
val mk_SS = fn: thm -> thm -> thm
val mk_cases = fn: thm -> thm -> thm -> thm
val mk_cond = fn: thm -> thm -> thm
val mk_fdef = fn: string -> thm -> thm
val mk_fex = fn: form -> string -> thm
val mk_ind = fn: thm -> thm
val mk_ind1 = fn: thm -> thm -> thm
val mk_monotone = fn: thm -> thm
val mk_prim = fn: thm -> thm
val mk_rules = fn: thm -> thm -> thm -> thm
val trivial_imp = fn: form -> thm
val PULL_CONJ = fn: (form -> bool) -> form -> thm option
val conj_assoc_fconv = fn: form -> thm
val conj_cossa_fconv = fn: form -> thm
val conj_swap_fconv = fn: form -> thm
val disj_imp_distr_fconv = fn: form -> thm
val exists_eq_fconv = fn: form -> thm
val forall_conj_split_fconv = fn: form -> thm
val forall_eq_fconv = fn: form -> thm
val mk_case1 = fn: thm -> thm -> thm
val mk_rules1 = fn: thm -> thm -> thm
val mk_rules2 = fn: thm -> thm
val pull_conj_fconv = fn: (form -> bool) -> form -> thm
val pull_exists_fconv1 = fn: form -> thm
SEARreln.sml:599: warning: Pattern is not exhaustive.
Found near val [qv, newtm] = conc |> dest_pred |> #2
val conj_imp_fconv = fn: form -> thm
val disj_imp_undistr_fconv = fn: form -> thm
val forall_in_eq_fconv = fn: form -> thm
val mk_incond = fn: form -> form * string
val mk_ind2 = fn: thm -> thm
val mk_rules3 = fn: thm -> thm
val remove_list_item = fn: ''a -> ''a list -> ''a list
val unpull_exists_fconv1 = fn: form -> thm
val it = (): unit
val inN's_def =
   {},  |- !(a : mem(Pow(N0))). IN(a#, inN's) <=> SS(App(inNf, a#), a#): thm
val inN_cases0 = {},  |- App(inNf, inNs) = inNs: thm
val inN_cases1 =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_incond =
   !(n : mem(N0)).
     IN(n#, inN1) <=>
     n# = O0 | ?(n0 : mem(N0)). IN(n0#, inN0) & n# = App(S0, n0#): form
val inN_ind =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_ind0 =
   {},  |- !(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> SS(inNs, ss#):
   thm
val inN_ind1 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        (!(a : mem(N0)).
            a# = O0 | (?(n0 : mem(N0)). IN(n0#, ss#) & a# = App(S0, n0#)) ==>
            IN(a#, ss#)) ==> !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#):
   thm
val inN_ind2 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_rules0 = {},  |- SS(App(inNf, inNs), inNs): thm
val inN_rules1 =
   {}, 
   |- !(a : mem(N0)).
        a# = O0 | (?(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#)) ==>
        IN(a#, inNs): thm
val inN_rules2 =
   {}, 
   |- !(a : mem(N0)).
        (a# = O0 ==> IN(a#, inNs)) &
        !(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#) ==> IN(a#, inNs):
   thm
val inN_rules3 =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val inNf_def =
   {}, 
   |- !(a : mem(Pow(N0)))  (n : mem(N0)).
        IN(n#, App(inNf, a#)) <=>
        n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_ex =
   {}, 
   |- ?!(f : fun(Pow(N0), Pow(N0))).
        !(a : mem(Pow(N0)))  (n : mem(N0)).
          IN(n#, App(f#, a#)) <=>
          n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_monotone =
   {}, 
   |- !(s1 : mem(Pow(N0)))  (s2 : mem(Pow(N0))).
        SS(s1#, s2#) ==> SS(App(inNf, s1#), App(inNf, s2#)): thm
val inNs_SS =
   {},  |- !(a : mem(Pow(N0))). SS(App(inNf, a#), a#) ==> SS(inNs, a#): thm
val inNs_cond =
   {}, 
   |- !(a : mem(N0)).
        (!(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, inNs): thm
val inNs_def = {},  |- inNs = BIGINTER(inN's): thm
val x1 = "inN0": string
val inN_cases =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_rules =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val N_def =
   {}, 
   |- Inj(iN) &
      !(a : mem(N0)). IN(a#, inNs) <=> ?(b : mem(N)). a# = App(iN, b#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val iN_Inj = {},  |- Inj(iN): thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val iN_inNs = {},  |- !(n : mem(N)). IN(App(iN, n#), inNs): thm
val SUC_ex_lemma =
   {},  |- !(n1 : mem(N)). ?(b : mem(N)). App(S0 o iN, n1#) = App(iN, b#):
   thm
val SUC_def = {},  |- !(a : mem(N)). App(iN o SUC, a#) = App(S0 o iN, a#):
   thm
val iN_eq_eq =
   {}, 
   |- !(x1 : mem(N))  (x2 : mem(N)).
        App(iN, x1#) = App(iN, x2#) ==> x1# = x2#: thm
val O_def = {},  |- O0 = App(iN, O): thm
val iN_ex_uex =
   {}, 
   |- !(b : mem(N0)).
        (?(a : mem(N)). App(iN, a#) = b#) <=>
        ?!(a : mem(N)). App(iN, a#) = b#: thm
val S0_eq_eq =
   {}, 
   |- !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) ==> n# = m#:
   thm
val SUC_Inj = {},  |- Inj(SUC): thm
val iN_O = {},  |- !(n : mem(N)). App(iN, n#) = O0 <=> n# = O: thm
val SUC_NONZERO = {},  |- !(n : mem(N)). ~App(SUC, n#) = O: thm
val Image_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(im : fun(Pow(A#), Pow(B#))).
          !(sa : mem(Pow(A#)))  (b : mem(B#)).
            IN(b#, App(im#, sa#)) <=>
            ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val Image_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sa : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Image(f#), sa#)) <=>
        ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val IMAGE_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (b : mem(B#)).
        IN(b#, IMAGE(f#, s0#)) <=>
        ?(a : mem(A#)). IN(a#, s0#) & b# = App(f#, a#): thm
val IMAGE_def0 =
   {(A : set), (B : set), (f : fun(A, B)), (s0 : mem(Pow(A)))}, 
   |- IMAGE(f, s0) = App(Image(f), s0): thm
val Whole_def = {},  |- !(A : set)  (a : mem(A#)). IN(a#, Whole(A#)): thm
val IN_IMAGE_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(s : mem(Pow(A#)))  (a : mem(A#)).
          IN(a#, s#) <=> IN(App(i#, a#), IMAGE(i#, s#)): thm
val N_ind_P =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(App(SUC, n#))) ==>
      !(n : mem(N)). P(n#): thm
val O_xor_SUC =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = App(SUC, pn#): thm
val SUC_eq_eq =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)).
        App(SUC, n1#) = App(SUC, n2#) <=> n1# = n2#: thm
val Suc_def = {},  |- !(n : mem(N)). Suc(n#) = App(SUC, n#): thm
val O_xor_Suc =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = Suc(pn#): thm
val Suc_eq_eq =
   {},  |- !(n1 : mem(N))  (n2 : mem(N)). Suc(n1#) = Suc(n2#) <=> n1# = n2#:
   thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val N_induct =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Eqv_def =
   {},  |- !(A : set)  (B : set). Eqv(A#, B#) <=> ?(f : fun(A#, B#)). Bij(f#):
   thm
val Asset_def =
   {}, 
   |- !(B : set)  (bs : mem(Pow(B#)))  (B0 : set).
        Asset(bs#, B0#) <=>
        !(B1 : set)  (i : fun(B1#, B#)).
          Inj(i#) &
          (!(b : mem(B#)).
              (?(b0 : mem(B1#)). App(i#, b0#) = b#) <=> IN(b#, bs#)) ==>
          Eqv(B0#, B1#): thm
val Sg_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (a0 : mem(A#)).
        IN(a0#, App(Sg(A#), a#)) <=> a0# = a#: thm
val Sing_def = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Empty_def = {},  |- !(X : set)  (a : mem(X#)). ~IN(a#, Empty(X#)): thm
val Sing_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Sing(a1#) = Sing(a2#) <=> a1# = a2#: thm
val Sing_NONEMPTY = {},  |- !(A : set)  (a : mem(A#)). ~Sing(a#) = Empty(A#):
   thm
val iscoPr_def =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (i1 : fun(A#, AB#))
      (i2 : fun(B#, AB#)).
        iscoPr(i1#, i2#) <=>
        !(X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
          ?!(fg : fun(AB#, X#)). fg# o i1# = f# & fg# o i2# = g#: thm
val tof_def =
   {(A : set), (B : set), (f0 : mem(Exp(A, B)))}, 
   |- !(a : mem(A)). App(Ev(A, B), Pair(a#, f0)) = App(tof(f0), a#): thm
val coPr_unique =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        iscoPr(i1#, i2#) & iscoPr(i1'#, i2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          j# o i1'# = i1# &
          j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val iscoPr_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          iscoPr(i1#, i2#) &
          Inj(i1#) &
          Inj(i2#) &
          (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
          !(ab : mem(AB#)).
            (?(a : mem(A#)). ab# = App(i1#, a#)) |
            ?(b : mem(B#)). ab# = App(i2#, b#): thm
val coPr_REFL =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
        ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB#) &
          j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#:
   thm
val coPr_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#) &
      (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
        (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            j# o i1# = i1'# &
            j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#) &
      !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_SYM =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
        ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB'#) &
          j# o i1# = i1'# &
          j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#: thm
val coPr_TRANS =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          (iscoPr(i1#, i2#) &
            Inj(i1#) &
            Inj(i2#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
            !(ab : mem(AB#)).
              (?(a : mem(A#)). ab# = App(i1#, a#)) |
              ?(b : mem(B#)). ab# = App(i2#, b#)) &
          !(AB' : set)  (i1' : fun(A#, AB'#))  (i2' : fun(B#, AB'#)).
            iscoPr(i1'#, i2'#) &
            Inj(i1'#) &
            Inj(i2'#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1'#, a#) = App(i2'#, b#)) &
            (!(ab : mem(AB'#)).
                (?(a : mem(A#)). ab# = App(i1'#, a#)) |
                ?(b : mem(B#)). ab# = App(i2'#, b#)) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val coPo_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i2_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val coPa_def0 =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#: thm
val coPa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        (coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#) &
        !(fg' : fun(A# + B#, X#)).
          fg'# o i1(A#, B#) = f# & fg'# o i2(A#, B#) = g# ==>
          fg'# = coPa(f#, g#): thm
val i1_Inj = {},  |- !(A : set)  (B : set). Inj(i1(A#, B#)): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val i1_or_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
        ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_xor_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) <=>
        ?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#): thm
val i2_xor_i1 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#)) <=>
        ?(a : mem(A#)). ab# = App(i1(A#, B#), a#): thm
val it = (): unit
******

Loading SEAR file SEARpred_set.sml

******
val tof_Tpm_inv =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). tof(Tpm(f#)) = f#: thm
val Tpm_tof_inv =
   {},  |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#))). Tpm(tof(f#)) = f#:
   thm
val Tpm_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        Tpm(f1#) = Tpm(f2#) <=> f1# = f2#: thm
val tof_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (g : mem(Exp(A#, B#))).
        tof(f#) = tof(g#) <=> f# = g#: thm
val IN_Sing =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)).
        IN(a#, Sing(a0#)) <=> a# = a0#: thm
val BU_ex =
   {}, 
   |- !(A : set).
        ?!(BU : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BU#, sss#)) <=>
            ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val EMPTY_def = {(A : set)},  |- EMPTY(A) <=> !(x : mem(A)). F: thm
val BU_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BU(A#), sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val BIGUNION_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        BIGUNION(sss#) = App(BU(A#), sss#): thm
val IN_BIGUNION =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGUNION(sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val IMAGE_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (s : mem(Pow(A#))). IMAGE(g# o f#, s#) = IMAGE(g#, IMAGE(f#, s#)): thm
val ex_eq_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#))).
        (!(b : mem(B#)). IN(b#, s#) ==> ?(a : mem(A#)). b# = App(f#, a#)) ==>
        ?(s0 : mem(Pow(A#))). s# = IMAGE(f#, s0#): thm
val App_IN_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))
      (a : mem(A#)). IN(a#, s#) ==> IN(App(f#, a#), IMAGE(f#, s#)): thm
val IMAGE_BIGUNION =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(Pow(A#)))).
        IMAGE(f#, BIGUNION(ss#)) = BIGUNION(IMAGE(Image(f#), ss#)): thm
val Prla_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(C : set)  (D : set)  (g : fun(C#, D#)).
          Inj(g#) ==> Inj(Prla(f#, g#)): thm
val Id_Inj = {},  |- !(X : set). Inj(Id(X#)): thm
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Pa_distr =
   {}, 
   |- !(A : set)  (X : set)  (a1 : fun(X#, A#))  (B : set)
      (a2 : fun(X#, B#))  (X0 : set)  (x : fun(X0#, X#)).
        Pa(a1#, a2#) o x# = Pa(a1# o x#, a2# o x#): thm
val Pa_eq_eq =
   {}, 
   |- !(A : set)  (X : set)  (f1 : fun(X#, A#))  (f2 : fun(X#, A#))
      (B : set)  (g1 : fun(X#, B#))  (g2 : fun(X#, B#)).
        Pa(f1#, g1#) = Pa(f2#, g2#) <=> f1# = f2# & g1# = g2#: thm
val p2_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(B#, C#)).
        f# o p2(A#, B#) = p2(A#, C#) o Prla(Id(A#), f#): thm
val p1_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(A#, C#)).
        f# o p1(A#, B#) = p1(C#, B#) o Prla(f#, Id(B#)): thm
val p1_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#)). p1(X#, Y#) o Prla(f#, g#) = f# o p1(A#, B#): thm
val IMAGE_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#))  (x : mem(X#))  (y : mem(Y#))
      (s : mem(Pow(A# * B#))).
        IN(Pair(x#, y#), IMAGE(Prla(f#, g#), s#)) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          IN(Pair(a#, b#), s#) & x# = App(f#, a#) & y# = App(g#, b#): thm
val exists_cross_fconv = fn: form -> thm
val Image_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        App(Image(f#), s#) = IMAGE(f#, s#): thm
val IMAGE_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        IMAGE(f#, Empty(A#)) = Empty(B#): thm
val IN_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        (?(a : mem(A#)). IN(a#, s#)) <=> ~s# = Empty(A#): thm
val IMAGE_Empty_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val BIGUNION_Empty_Empty =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        BIGUNION(ss#) = Empty(A#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val BIGUNION_NONEMPTY =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        ~BIGUNION(ss#) = Empty(A#) <=>
        ?(s : mem(Pow(A#))). IN(s#, ss#) & ~s# = Empty(A#): thm
val BIGUNION_Empty_Empty' =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        Empty(A#) = BIGUNION(ss#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val INTER_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(INTER(A), Pair(a'#, b#))) <=> IN(a#, a'#) & IN(a#, b#):
   thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Inter_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Inter(s1, s2) = App(INTER(A), Pair(s1, s2)): thm
val UNION_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(UNION(A), Pair(a'#, b#))) <=> IN(a#, a'#) | IN(a#, b#):
   thm
val COMPL_def =
   {(A : set)}, 
   |- !(a : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(COMPL(A), a#)) <=> ~IN(a#, a#): thm
val Compl_def =
   {(A : set), (s : mem(Pow(A)))},  |- Compl(s) = App(COMPL(A), s): thm
val IN_Compl =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Compl(s#)) <=> ~IN(a#, s#): thm
val IN_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Union(s1#, s2#)) <=> IN(a#, s1#) | IN(a#, s2#): thm
val Union_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Union(s1, s2) = App(UNION(A), Pair(s1, s2)): thm
val m2r_def =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (od : mem(Pow(A# * A#))).
        Holds(m2r(od#), a1#, a2#) <=> IN(Pair(a1#, a2#), od#): thm
val r2m_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(Pair(a1#, a2#), r2m(R#)) <=> Holds(R#, a1#, a2#): thm
val Union_Empty_Empty =
   {},  |- !(A : set). Union(Empty(A#), Empty(A#)) = Empty(A#): thm
val SS_Refl = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(s#, s#): thm
val NONE_def = {(X : set)},  |- NONE(X) = App(i2(X, 1), dot): thm
val Null_def =
   {},  |- !(X : set)  (n : mem(N)). App(Null(X#), n#) = App(i2(X#, 1), dot):
   thm
val PREIM_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#)))
      (a : mem(A#)).
        IN(a#, PREIM(f#, s#)) <=>
        ?(b : mem(B#)). IN(b#, s#) & App(f#, a#) = b#: thm
val SOME_def =
   {},  |- !(A : set)  (a : mem(A#)). SOME(a#) = App(i1(A#, 1), a#): thm
val Surj_Epi =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) ==>
        !(C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
          g1# o f# = g2# o f# ==> g1# = g2#: thm
val false_def = {},  |- false = App(i1(1, 1), dot): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val true_def = {},  |- true = App(i2(1, 1), dot): thm
val true_ne_false = {},  |- ~true = false: thm
val true_or_false = {},  |- !(tv : mem(1 + 1)). tv# = true | tv# = false: thm
val true_xor_false = {},  |- !(tv : mem(1 + 1)). ~tv# = true <=> tv# = false:
   thm
val false_xor_true = {},  |- !(tv : mem(1 + 1)). ~tv# = false <=> tv# = true:
   thm
val tv_eq_true =
   {}, 
   |- !(tv1 : mem(1 + 1))  (tv2 : mem(1 + 1)).
        tv1# = tv2# <=> tv1# = true <=> tv2# = true: thm
val tf_eq_true =
   {}, 
   |- !(A : set)  (tf1 : fun(A#, 1 + 1))  (tf2 : fun(A#, 1 + 1)).
        tf1# = tf2# <=>
        !(a : mem(A#)). App(tf1#, a#) = true <=> App(tf2#, a#) = true: thm
val basic_fconv_tac = fn: conv -> fconv -> tactic
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
******

Loading SEAR file lambda.sml

******
val TAUT = {},  |- A | ~A: thm
val cond_unique_lemma =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b# = b'#: thm
val cond_unique_lemma' =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b'# = b#: thm
val conj1 = fn: form -> form
val conj2 = fn: form -> form
val conjIs = fn: thm list -> thm
val disj1 = fn: form -> form
val disj2 = fn: form -> form
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val disj_neg_absorb = {},  |- A | ~A & B <=> A | B: thm
val disj_of_negconj = {},  |- ~A & ~B <=> ~(A | B): thm
val djE = fn: form * thm -> form * thm -> form * thm
val djEs = fn: (form * thm) list -> form * thm
val drop_last_cj = fn: form -> form * form
val iant = fn: form -> form
val iconc = fn: form -> form
val imp_dimp_distr = {},  |- A ==> (B <=> C) <=> A ==> B <=> A ==> C: thm
val strip_conj = fn: form -> form list
val strip_disj = fn: form -> form list
val cond_rw_fconv = fn: form -> thm
val conj_assoc_fm = fn: form -> form
val define_lambda = fn: form -> thm
val define_lambda_fun = fn: form -> thm
val nlist = fn: int -> int list
val normalise_lambda_input = fn: form -> form
val it = (): unit
val NOT_def = {},  |- App(NOT, true) = false & App(NOT, false) = true: thm
val OR_def =
   {}, 
   |- App(OR, Pair(true, true)) = true &
      App(OR, Pair(true, false)) = true &
      App(OR, Pair(false, true)) = true & App(OR, Pair(false, false)) = false:
   thm
val constf_def =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#))  (a : mem(A#)).
        App(constf(A#, b#), a#) = b#: thm
val f2r_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * B#, 1 + 1))  (a : mem(A#))
      (b : mem(B#)). Holds(f2r(f#), a#, b#) <=> App(f#, Pair(a#, b#)) = true:
   thm
val r2f_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = App(i2(1, 1), dot) <=> Holds(R#, a#, b#):
   thm
val r2f_def' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = true <=> Holds(R#, a#, b#): thm
val ss2f =
   {(A : set), (s : mem(Pow(A)))}, 
   |- !(a : mem(A)). App(ss2f(s), a#) = true <=> IN(a#, s): thm
val FIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : fun(A, B))}, 
   |- FIB(f, b) = PREIM(f, Sing(b)): thm
val Inj_Image_Inj =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(A#, B#)). Inj(i#) ==> Inj(Image(i#)):
   thm
val mApp_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (f : mem(Exp(A#, B#))).
        mApp(f#, a#) = App(tof(f#), a#): thm
val mFIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : mem(Exp(A, B)))}, 
   |- mFIB(f, b) = PREIM(tof(f), Sing(b)): thm
val Compl_Whole = {},  |- !(A : set). Compl(Whole(A#)) = Empty(A#): thm
val Compl_Empty = {},  |- !(A : set). Compl(Empty(A#)) = Whole(A#): thm
val Inter_Compl_Compl =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J)))}, 
   |- Inter(Compl(s1), Compl(s2)) = Compl(Union(s1, s2)): thm
val neg_or_distr = {},  |- ~(A | B) <=> ~A & ~B: thm
val SS_Union =
   {}, 
   |- (!(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
          SS(a#, Union(a#, b#))) &
      !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val SS_Union1 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(a#, b#)): thm
val SS_Union2 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val Ins_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (s0 : mem(Pow(X#)))  (a : mem(X#)).
        IN(a#, Ins(x0#, s0#)) <=> a# = x0# | IN(a#, s0#): thm
val Union_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Union(Sing(a#), s#) = Ins(a#, s#): thm
val SS_Ins =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(s#, Ins(a#, s#)):
   thm
val BIGINTER_Sing =
   {},  |- !(A : set)  (s : mem(Pow(A#))). BIGINTER(Sing(s#)) = s#: thm
val Whole_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Whole(A#), s#) = s#: thm
val Inter_Whole =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Whole(A#)) = s#: thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Empty_SS = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(Empty(A#), s#): thm
val BIGINTER_Empty = {(A : set)},  |- BIGINTER(Empty(Pow(A))) = Whole(A): thm
val BIGINTER_Ins_Empty =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#))). BIGINTER(Ins(x#, Empty(Pow(A#)))) = x#:
   thm
val Inter_same = {},  |- !(A : set)  (x : mem(Pow(A#))). Inter(x#, x#) = x#:
   thm
val BIGINTER_Ins =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#)))  (xs0 : mem(Pow(Pow(A#)))).
        BIGINTER(Ins(x#, xs0#)) = Inter(x#, BIGINTER(xs0#)): thm
val imp_or_distr = {},  |- A | B ==> C <=> (A ==> C) & (B ==> C): thm
val BIGINTER_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(Pow(A#))))  (s2 : mem(Pow(Pow(A#)))).
        BIGINTER(Union(s1#, s2#)) = Inter(BIGINTER(s1#), BIGINTER(s2#)): thm
val Empty_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Empty(A#), s#) = Empty(A#):
   thm
val Union_EMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val neg_and_distr = {},  |- ~(A & B) <=> ~A | ~B: thm
val SS_Union_split =
   {}, 
   |- !(W : set)  (A : mem(Pow(W#)))  (B : mem(Pow(W#)))  (s : mem(Pow(W#))).
        SS(s#, Union(A#, B#)) <=>
        ?(s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
          SS(s1#, A#) & SS(s2#, B#) & s# = Union(s1#, s2#): thm
val Inter_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Empty(A#)) = Empty(A#):
   thm
val SS_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        SS(s#, Sing(a#)) <=> s# = Sing(a#) | s# = Empty(A#): thm
val Empty_Union =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(Empty(A#), s#) = s#: thm
val SS_Empty =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))). SS(s#, Empty(A#)) <=> s# = Empty(A#):
   thm
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val Union_assoc =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Union(Union(s1#, s2#), s3#) = Union(s1#, Union(s2#, s3#)): thm
val Inter_Whole_Whole =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Whole(A#) <=> s1# = Whole(A#) & s2# = Whole(A#):
   thm
val Union_SS1 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(Union(s1#, s2#), s#) <=> SS(s1#, s#) & SS(s2#, s#): thm
val SS_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s#, Inter(s1#, s2#)) <=> SS(s#, s1#) & SS(s#, s2#): thm
val Union_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        SS(Inter(s1#, s2#), s1#) & SS(Inter(s1#, s2#), s2#): thm
val Whole_SS =
   {}, 
   |- !(A : set)  (X : mem(Pow(A#))). SS(Whole(A#), X#) ==> X# = Whole(A#):
   thm
val SS_Whole = {},  |- !(A : set)  (X : mem(Pow(A#))). SS(X#, Whole(A#)): thm
val Sing_Ins_Empty =
   {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = Ins(a#, Empty(A#)): thm
val EMPTY_Empty_Whole =
   {},  |- !(A : set). EMPTY(A#) <=> Empty(A#) = Whole(A#): thm
val NOT_EMPTY = {},  |- !(A : set). ~EMPTY(A#) <=> ?(a : mem(A#)). T: thm
val NEQ_IN =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val PSS_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- PSS(s1, s2) <=> SS(s1, s2) & ~s1 = s2: thm
val PSS_alt =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) <=>
        SS(s1#, s2#) & ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val Inter_Compl =
   {},  |- !(A : set)  (a : mem(Pow(A#))). Inter(a#, Compl(a#)) = Empty(A#):
   thm
val neg_iff = {},  |- ~(A <=> B) <=> A & ~B | B & ~A: thm
val Union_Empty2 =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(s#, Empty(A#)) = s#: thm
val Inter_eq_Empty =
   {}, 
   |- !(W : set)  (s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
        Inter(s1#, s2#) = Empty(W#) <=> SS(s2#, Compl(s1#)): thm
val PSS_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) ==> SS(s1#, s2#): thm
val SS_BIGUNION =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(Pow(A#)))))
      (s0 : mem(Pow(Pow(A#)))).
        IN(s0#, ss#) & SS(s#, s0#) ==> SS(s#, BIGUNION(ss#)): thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val Del_def =
   {}, 
   |- !(X : set)  (s0 : mem(Pow(X#)))  (x0 : mem(X#))  (a : mem(X#)).
        IN(a#, Del(s0#, x0#)) <=> IN(a#, s0#) & ~a# = x0#: thm
val c31_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c31(abc) = Fst(abc): thm
val c32_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c32(abc) = Fst(Snd(abc)): thm
val c33_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c33(abc) = Snd(Snd(abc)): thm
val Del_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        ~IN(x0#, xs0#) ==> Del(Ins(x0#, xs0#), x0#) = xs0#: thm
val Ins_absorb =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        IN(x0#, xs0#) ==> Ins(x0#, xs0#) = xs0#: thm
val Ins_Del =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, s#) ==> Ins(a#, Del(s#, a#)) = s#: thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
        IMAGE(f#, ss#) = Empty(B#) <=> ss# = Empty(A#): thm
val NOTIN_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        ~IN(a#, s#) ==> Del(s#, a#) = s#: thm
val Inj_IMAGE_Del =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#)))
      (a : mem(A#)).
        Inj(f#) ==>
        IMAGE(f#, Del(ss#, a#)) = Del(IMAGE(f#, ss#), App(f#, a#)): thm
val disj_not_imp = {},  |- A | ~B <=> B ==> A: thm
val exists_forall = fn: string * sort -> thm
val exists_forall_th =
   {(A : set)},  |- (?(a : mem(A)). f0(a#)) <=> ~!(a : mem(A)). ~f0(a#): thm
val not_disj_imp = {},  |- ~B | A <=> B ==> A: thm
val set_NEQ =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). ~IN(a#, s1#) & IN(a#, s2#): thm
val Pa_Inj =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#)).
        Inj(f#) ==> !(B : set)  (g : fun(X#, B#)). Inj(Pa(g#, f#)): thm
val o_Inj_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_restrict =
   {}, 
   |- !(D : set)  (D0 : set)  (i1 : fun(D#, D0#)).
        Inj(i1#) ==>
        !(C : set)  (C0 : set)  (i2 : fun(C#, C0#)).
          Inj(i2#) ==>
          !(f0 : fun(D0#, C0#)).
            (!(d : mem(D#)).
                ?!(c : mem(C#)). App(f0# o i1#, d#) = App(i2#, c#)) ==>
            ?!(f : fun(D#, C#)). i2# o f# = f0# o i1#: thm
val SS_Del =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(Del(s#, a#), s#):
   thm
val Inj_o_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        Inj(g# o f#) ==> Inj(f#): thm
val SS_Ins_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#)))  (G : mem(Pow(A#))).
        SS(ss#, Ins(a#, G#)) ==> SS(Del(ss#, a#), G#): thm
val SOME_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (x2 : mem(X#)).
        SOME(x1#) = SOME(x2#) <=> x1# = x2#: thm
val option_xor =
   {}, 
   |- !(A : set)  (a1 : mem(A# + 1)).
        ~a1# = NONE(A#) <=> ?!(a0 : mem(A#)). a1# = SOME(a0#): thm
val NOT_true_iff_false =
   {},  |- !(tv : mem(1 + 1)). App(NOT, tv#) = true <=> tv# = false: thm
val SOME_NOTNONE = {},  |- !(X : set)  (x : mem(X#)). ~SOME(x#) = NONE(X#):
   thm
val OM_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- App(OM(f), NONE(A)) = NONE(B) &
      !(a : mem(A)). App(OM(f), SOME(a#)) = SOME(App(f, a#)): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val Diff_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Diff(s1#, s2#)) <=> IN(a#, s1#) & ~IN(a#, s2#): thm
val Inter_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        ~Inter(s#, Sing(a#)) = Empty(A#) <=> IN(a#, s#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val Diff_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Diff(s#, Empty(A#)) = s#: thm
val Diff_Empty_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Diff(s1#, s2#) = Empty(A#) <=> SS(s1#, s2#): thm
val Ins_Union =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Ins(a#, s#) = Union(Sing(a#), s#): thm
val Union_Empty_both_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Inter(s1#, Union(s2#, s3#)) = Union(Inter(s1#, s2#), Inter(s1#, s3#)):
   thm
val Inter_Diff_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Sing(x#)) = Empty(A#) <=>
        IN(x#, Diff(s1#, s2#)): thm
val Diff_Ins_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Ins(x#, s3#)) = Empty(A#) <=>
        ~Inter(Diff(s1#, s2#), s3#) = Empty(A#) | IN(x#, Diff(s1#, s2#)): thm
val Inter_Empty2 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Empty(A#) ==>
        !(a : mem(A#)). IN(a#, s2#) ==> ~IN(a#, s1#): thm
val Inter_both_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~Inter(s1#, s2#) = Empty(A#) ==> ~s1# = Empty(A#) & ~s2# = Empty(A#):
   thm
val neg_imp_conj = {},  |- ~(A ==> B) <=> A & ~B: thm
val forall_exists_dual =
   {},  |- !(A : set). (!(a : mem(A#)). P(a#)) <=> ~?(a : mem(A#)). ~P(a#):
   thm
val neg_conj_imp = {},  |- ~(A & B) <=> A ==> ~B: thm
val it = (): unit
******

Loading SEAR file SEARNarith.sml

******
val Nind's_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        IN(a#, Nind's(f0, x0)) <=> SS(App(Nindf(f0, x0), a#), a#): thm
val Nind_cases0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- App(Nindf(f0, x0), Ninds(f0, x0)) = Ninds(f0, x0): thm
val Nind_cases1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_incond =
   !(nx : mem(N * X)).
     IN(nx#, Nind1) <=>
     nx# = Pair(O, x0) |
     ?(nx0 : mem(N * X)).
       IN(nx0#, Nind0) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): form
val Nind_ind =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), ss#), ss#) ==> SS(Ninds(f0, x0), ss#): thm
val Nind_ind1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        (!(a : mem(N * X)).
            a# = Pair(O, x0) |
            (?(nx0 : mem(N * X)).
                IN(nx0#, ss#) & a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_rules0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- SS(App(Nindf(f0, x0), Ninds(f0, x0)), Ninds(f0, x0)): thm
val Nind_rules1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        a# = Pair(O, x0) |
        (?(nx0 : mem(N * X)).
            IN(nx0#, Ninds(f0, x0)) &
            a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
        IN(a#, Ninds(f0, x0)): thm
val Nind_rules2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (a# = Pair(O, x0) ==> IN(a#, Ninds(f0, x0))) &
        !(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))) ==>
          IN(a#, Ninds(f0, x0)): thm
val Nind_rules3 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nindf_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
        IN(nx#, App(Nindf(f0, x0), a#)) <=>
        nx# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nindf_ex =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(N * X), Pow(N * X))).
        !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
          IN(nx#, App(f#, a#)) <=>
          nx# = Pair(O, x0) |
          ?(nx0 : mem(N * X)).
            IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))):
   thm
val Nindf_monotone =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(N * X)))  (s2 : mem(Pow(N * X))).
        SS(s1#, s2#) ==> SS(App(Nindf(f0, x0), s1#), App(Nindf(f0, x0), s2#)):
   thm
val Ninds_SS =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), a#), a#) ==> SS(Ninds(f0, x0), a#): thm
val Ninds_cond =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (!(ss : mem(Pow(N * X))).
            SS(App(Nindf(f0, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Ninds(f0, x0)): thm
val Ninds_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- Ninds(f0, x0) = BIGINTER(Nind's(f0, x0)): thm
val x1 = "Nind0": string
val Nind_cases =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_rules =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nind_uex =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        ?!(x : mem(X#)). IN(Pair(n#, x#), Ninds(f0#, x0#)): thm
val Nrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (a : mem(N)).
        IN(Pair(a#, App(Nrec(x0#, f0#), a#)), Ninds(f0#, x0#)): thm
val Nrec_O =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        App(Nrec(x0#, f0#), O) = x0#: thm
val App_Nrec_Ninds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N))
      (x : mem(X#)).
        App(Nrec(x0#, f0#), n#) = x# <=> IN(Pair(n#, x#), Ninds(f0#, x0#)):
   thm
val Nrec_Suc =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        App(Nrec(x0#, f0#), Suc(n#)) = App(f0#, App(Nrec(x0#, f0#), n#)): thm
val Nrec_unique =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Nrec_Suc_eqn =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        Nrec(x0#, f0#) o SUC = f0# o Nrec(x0#, f0#): thm
val El_def = {},  |- !(A : set)  (a : mem(A#)). App(El(a#), dot) = a#: thm
val El_eq_eq =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). El(a#) = El(b#) <=> a# = b#:
   thm
val App_o_El =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(f#, a#) = App(f# o El(a#), dot): thm
val Nrec_El =
   {}, 
   |- !(X : set)  (a : mem(X#))  (f : fun(X#, X#)).
        Nrec(a#, f#) o El(O) = El(a#) &
        Nrec(a#, f#) o SUC = f# o Nrec(a#, f#) &
        !(u : fun(N, X#)).
          u# o El(O) = El(a#) & u# o SUC = f# o u# ==> u# = Nrec(a#, f#): thm
val App_El_mem =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(f#, a#) = b# <=> f# o El(a#) = El(b#): thm
val Nrec_O_SUC = {},  |- Nrec(O, SUC) = Id(N): thm
val comm_with_SUC_id0 =
   {}, 
   |- !(f : fun(N, N)). App(f#, O) = O & f# o SUC = SUC o f# ==> f# = Id(N):
   thm
val comm_with_SUC_id =
   {}, 
   |- !(f : fun(N, N)).
        f# o El(O) = El(O) & f# o SUC = SUC o f# ==> f# = Id(N): thm
val Thm1_case1_comm_condition =
   {}, 
   |- !(B : set)  (f0 : fun(N, B#))  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        f0# o El(O) = g# & f0# o SUC = h# o Pa(Id(N), f0#) <=>
        Pa(Id(N), f0#) o El(O) = Pa(El(O), g#) &
        Pa((SUC o p1(N, B#)), h#) o Pa(Id(N), f0#) = Pa(Id(N), f0#) o SUC:
   thm
val Dot_def = {},  |- !(A : set)  (f : fun(1, A#)). Dot(f#) = App(f#, dot):
   thm
val Dot_of_El = {},  |- !(A : set)  (a : mem(A#)). Dot(El(a#)) = a#: thm
val El_of_Dot = {},  |- !(X : set)  (f : fun(1, X#)). El(Dot(f#)) = f#: thm
val to_P_component =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#)).
        Pa(p1(A#, B#) o f#, p2(A#, B#) o f#) = f#: thm
val Thm1_case_1 =
   {}, 
   |- !(B : set)  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        ?!(f : fun(N, B#)). f# o El(O) = g# & f# o SUC = h# o Pa(Id(N), f#):
   thm
val is_Nrec =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Tp1_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(tpf : fun(1, Exp(A#, B#))). Tp(f# o p1(A#, 1)) = tpf#: thm
val Ev_of_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#)).
        Ev(A#, B#) o Pa(p1(A#, X#), Tp(f#) o p2(A#, X#)) = f#: thm
val Tp1_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Tp(f# o p1(A#, 1)) = Tp1(f#):
   thm
val Tp_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (g : fun(A# * X#, B#)). Tp(f#) = Tp(g#) <=> f# = g#: thm
val Ev_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, Exp(A#, B#)))
      (g : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), f# o p2(A#, X#)) = Ev(A#, B#) o
          Pa(p1(A#, X#), g# o p2(A#, X#)) ==> f# = g#: thm
val to_P_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#))
      (g : fun(X#, A# * B#)).
        p1(A#, B#) o f# = p1(A#, B#) o g# & p2(A#, B#) o f# = p2(A#, B#) o g# ==>
        f# = g#: thm
val Pa_o_split =
   {}, 
   |- !(B : set)  (X : set)  (f : fun(B#, X#))  (Y : set)  (g : fun(X#, Y#))
      (A : set).
        Pa(p1(A#, B#), g# o f# o p2(A#, B#)) =
          Pa(p1(A#, X#), (g# o p2(A#, X#))) o Pa(p1(A#, B#), f# o p2(A#, B#)):
   thm
val Thm1_comm_eq_left =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))  (g : fun(A#, B#)).
        Tp(f#) o El(O) = Tp1(g#) <=>
        f# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1): thm
val Pa_p1_p2 =
   {},  |- !(A : set)  (B : set). Pa(p1(A#, B#), p2(A#, B#)) = Id(A# * B#):
   thm
val Thm1_comm_eq_right =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))
      (h : fun((A# * N) * B#, B#))
      (l : fun(A# * N * Exp(A#, B#), (A# * N) * B#)).
        Pa(Pa(p1(A#, N * Exp(A#, B#)), p1(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#))), Ev(A#, B#) o
           Pa(p1(A#, N * Exp(A#, B#)), p2(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#)))) = l# ==>
        (h# o Pa(Id(A# * N), f#) = f# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
          Tp((h# o l#)) o Pa(Id(N), Tp(f#)) = Tp(f#) o SUC): thm
val Ev_of_Tp_el =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))  (P : set)
      (a : fun(P#, A#))  (x : fun(P#, X#)).
        Ev(A#, B#) o Pa(a#, Tp(f#) o x#) = f# o Pa(a#, x#): thm
val Ev_of_Tp_el' =
   {}, 
   |- !(A : set)  (B : set)  (P : set)  (f : fun(A# * P#, B#))
      (a : fun(P#, A#)). Ev(A#, B#) o Pa(a#, Tp(f#)) = f# o Pa(a#, Id(P#)):
   thm
val Tp_of_Ev =
   {(A : set), (B : set), (X : set), (f : fun(X, Exp(A, B)))}, 
   |- Tp(Ev(A, B) o Pa(p1(A, X), f o p2(A, X))) = f: thm
val Thm1 =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val Thm1_uex =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?!(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val PRE_def = {},  |- PRE o El(O) = El(O) & PRE o SUC = Id(N): thm
val Pre_def = {},  |- !(n : mem(N)). Pre(n#) = App(PRE, n#): thm
val Pre_eqn = {},  |- Pre(O) = O & !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val ADD_def =
   {}, 
   |- ADD o Pa(p1(N, 1), El(O) o To1(N * 1)) = p1(N, 1) &
      SUC o ADD = ADD o Pa(p1(N, N), SUC o p2(N, N)): thm
val Add_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Add(n1#, n2#) = App(ADD, Pair(n1#, n2#)):
   thm
val Add_O = {},  |- !(n : mem(N)). Add(n#, O) = n#: thm
val App_input_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a1 : mem(A#))
      (a2 : mem(A#)). a1# = a2# ==> App(f#, a1#) = App(f#, a2#): thm
val Add_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, Suc(n#)) = Suc(Add(m#, n#)):
   thm
val Pre_O = {},  |- Pre(O) = O: thm
val Pre_Suc = {},  |- !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val SUB_def =
   {}, 
   |- SUB o Pa(p1(N, 1), El(O) o p2(N, 1)) = p1(N, 1) &
      PRE o SUB = SUB o Pa(p1(N, N), SUC o p2(N, N)): thm
val o_eq_r =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        f1# = f2# ==> !(C : set)  (g : fun(B#, C#)). g# o f1# = g# o f2#: thm
val Sub_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Sub(n1#, n2#) = App(SUB, Pair(n1#, n2#)):
   thm
val Sub_O = {},  |- !(n : mem(N)). Sub(n#, O) = n#: thm
val Sub_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, Suc(n#)) = Pre(Sub(m#, n#)):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Le_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Pre_eq_O = {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O):
   thm
val Lt_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val Le_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val Lt_Le = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> Le(m#, n#):
   thm
val Lt_NE = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> ~m# = n#: thm
val Le_NE_Lt =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) & ~m# = n# ==> Lt(m#, n#):
   thm
val Lt_Le_NE =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val Sub_mono_eq =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(Suc(m#), Suc(n#)) = Sub(m#, n#):
   thm
val Add_Sub = {},  |- !(c : mem(N))  (a : mem(N)). Sub(Add(a#, c#), c#) = a#:
   thm
val Add_O2 = {},  |- !(n : mem(N)). Add(O, n#) = n#: thm
val Sub_EQ_O = {},  |- !(n : mem(N)). Sub(n#, n#) = O: thm
val Le_refl = {},  |- !(n : mem(N)). Le(n#, n#): thm
val Le_O_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val o_eq_l =
   {}, 
   |- !(B : set)  (C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
        g1# = g2# ==> !(A : set)  (f : fun(A#, B#)). g1# o f# = g2# o f#: thm
val Le_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) ==> Lt(m#, n#) | m# = n#:
   thm
val Le_Sub =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val cancel_Sub =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Le(a#, c#) ==> (Sub(b#, a#) = Sub(c#, a#) <=> b# = c#):
   thm
val th =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Sub_of_O = {},  |- !(n : mem(N)). Sub(O, n#) = O: thm
val O_LESS_EQ = {},  |- !(x : mem(N)). Le(O, x#): thm
val LESS_EQ_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val LESS_O = {},  |- !(n : mem(N)). Lt(O, Suc(n#)): thm
val LESS_MONO_EQ =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val LE_O_iff = {},  |- !(n : mem(N)). Le(n#, O) <=> n# = O: thm
val LESS_cases =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | Le(b#, a#): thm
val LESS_EQ_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) | Le(n#, m#): thm
val Add_Suc1 =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(Suc(a#), b#) = Suc(Add(a#, b#)):
   thm
val Add_comm =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(a#, b#) = Add(b#, a#): thm
val Suc_Sub = {},  |- !(n : mem(N)). Sub(Suc(n#), n#) = Suc(O): thm
val Sub_DIFF_1 =
   {},  |- !(a : mem(N))  (b : mem(N)). Sub(a#, b#) = Suc(O) <=> a# = Suc(b#):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Sub_Suc_O_cases =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, Suc(b#)) = O ==> a# = Suc(b#) | Sub(a#, b#) = O: thm
val Le_cases_iff =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) <=> Lt(a#, b#) | a# = b#:
   thm
val Lt_Suc_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Suc(b#)) <=> Le(a#, b#): thm
val Sub_EQ_O1 =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, n#) = O <=> Le(m#, n#): thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val strong_ind =
   {}, 
   |- (!(a : mem(N)). (!(a0 : mem(N)). Lt(a0#, a#) ==> P(a0#)) ==> P(a#)) ==>
      !(a : mem(N)). P(a#): thm
val WOP =
   {}, 
   |- !(a : mem(N)).
        P(a#) ==>
        ?(a0 : mem(N)). P(a0#) & !(a1 : mem(N)). P(a1#) ==> Le(a0#, a1#): thm
val MUL_def0 =
   {}, 
   |- MUL o Pa(p1(N, 1), El(O) o To1(N * 1)) = El(O) o To1(N * 1) &
      ADD o Pa(MUL, p1(N, N)) = MUL o Pa(p1(N, N), SUC o p2(N, N)): thm
val Mul_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Mul(n1#, n2#) = App(MUL, Pair(n1#, n2#)):
   thm
val App_Pa2 =
   {}, 
   |- !(A : set)  (B : set)  (D : set)  (g : fun(B#, D#))
      (ab : mem(A# * B#)).
        App(Pa(p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_p1_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p1(A#, B#), Pair(a#, b#)) = a#: thm
val App_p2_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p2(A#, B#), Pair(a#, b#)) = b#: thm
val Mul_O = {},  |- !(n : mem(N)). Mul(n#, O) = O: thm
val Mul_Suc =
   {}, 
   |- !(n : mem(N))  (n0 : mem(N)). Mul(n#, Suc(n0#)) = Add(Mul(n#, n0#), n#):
   thm
val Mul_LEFT_O = {},  |- !(m : mem(N)). Mul(O, m#) = O: thm
val Mul_LEFT_1 = {},  |- !(m : mem(N)). Mul(Suc(O), m#) = m#: thm
val Mul_RIGHT_1 = {},  |- !(m : mem(N)). Mul(m#, Suc(O)) = m#: thm
val Add_comm' =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(b#, a#) = Add(a#, b#): thm
val Add_assoc =
   {}, 
   |- !(m : mem(N))  (n0 : mem(N))  (p : mem(N)).
        Add(m#, Add(n0#, p#)) = Add(Add(m#, n0#), p#): thm
val Add_eq_eq =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (a : mem(N)).
        Add(m#, a#) = Add(n#, a#) ==> m# = n#: thm
val Mul_Suc1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Mul(Suc(n#), m#) = Add(m#, Mul(n#, m#)):
   thm
val Mul_clauses =
   {}, 
   |- (!(m : mem(N)).
          Mul(O, m#) = O &
          Mul(m#, O) = O & Mul(Suc(O), m#) = m# & Mul(m#, Suc(O)) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Mul(Suc(m#), n#) = Add(Mul(m#, n#), n#) &
        Mul(m#, Suc(n#)) = Add(m#, Mul(m#, n#)): thm
val Mul_comm =
   {},  |- !(m : mem(N))  (n : mem(N)). Mul(m#, n#) = Mul(n#, m#): thm
val Add_clauses =
   {}, 
   |- (!(m : mem(N)). Add(O, m#) = m# & Add(m#, O) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Add(Suc(m#), n#) = Suc(Add(m#, n#)) &
        Add(m#, Suc(n#)) = Suc(Add(m#, n#)): thm
val Nind_tac = fn: tactic
val RIGHT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Add(m#, n#), p#) = Add(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Add(m#, n#)) = Add(Mul(p#, m#), Mul(p#, n#)): thm
val Mul_assoc =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(m#, Mul(n#, p#)) = Mul(Mul(m#, n#), p#): thm
val Sub_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Sub(a#, Add(b#, c#)) = Sub(Sub(a#, b#), c#): thm
val Le_O_iff = {},  |- !(a : mem(N)). Le(a#, O) <=> a# = O: thm
val Le_Suc =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, Suc(b#)) ==> Le(a#, b#) | a# = Suc(b#): thm
val Le_Add_ex =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(n#, m#) ==> ?(p : mem(N)). Add(p#, n#) = m#: thm
val LE_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Sub(a#, b#) = O:
   thm
val LT_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Holds(LT, a#, b#) <=> Holds(LE, a#, b#) & ~a# = b#: thm
val LE_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Le(a#, b#): thm
val LT_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LT, a#, b#) <=> Lt(a#, b#): thm
val LE_Trans = {},  |- Trans(LE): thm
val LESS_MONO_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(m#, n#) <=> Lt(Add(m#, p#), Add(n#, p#)): thm
val EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val LESS_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(Add(m#, p#), Add(n#, p#)) <=> Lt(m#, n#): thm
val LESS_OR_EQ =
   {(m : mem(N)), (n : mem(N))},  |- Le(m, n) <=> Lt(m, n) | m = n: thm
val LESS_EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(Add(m#, p#), Add(n#, p#)) <=> Le(m#, n#): thm
val Le_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, c#) & Le(b#, d#) ==> Le(Add(a#, b#), Add(c#, d#)): thm
val Le_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Le(a1#, a2#) & Le(a2#, a3#) ==> Le(a1#, a3#): thm
val Asym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Asym(R#) <=>
        !(a : mem(A#))  (b : mem(A#)).
          Holds(R#, a#, b#) & Holds(R#, b#, a#) ==> a# = b#: thm
val Lt_Suc = {},  |- !(a : mem(N)). Lt(a#, Suc(a#)): thm
val Suc_NEQ = {},  |- !(a : mem(N)). ~a# = Suc(a#): thm
val Add_Suc_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Add(a#, Suc(b#))): thm
val LT_Trans = {},  |- Trans(LT): thm
val Lt_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Lt(a1#, a2#) & Lt(a2#, a3#) ==> Lt(a1#, a3#): thm
val LE_Asym = {},  |- Asym(LE): thm
val Le_Asym =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) ==> a# = b#:
   thm
val LESS_EQ_LESS_EQ_MONO =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N))  (q : mem(N)).
        Le(m#, p#) & Le(n#, q#) ==> Le(Add(m#, n#), Add(p#, q#)): thm
val Le_MONO_Mul =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(m#, n#) ==> Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul' =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(m#, n#) ==> !(p : mem(N)). Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Le(m#, i#) & Le(n#, j#) ==> Le(Mul(m#, n#), Mul(i#, j#)): thm
val Le_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val Le_O' = {},  |- !(x : mem(N)). Le(O, x#): thm
val Sub_Suc1 =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(b#, a#) ==> Sub(Suc(a#), b#) = Suc(Sub(a#, b#)): thm
val SUB_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Le(n#, m#) ==> Add(Sub(m#, n#), n#) = m#:
   thm
val ADD_EQ_SUB =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(n#, p#) ==> (Add(m#, n#) = p# <=> m# = Sub(p#, n#)): thm
val NOT_SUC_LESS_EQ_O = {},  |- !(n : mem(N)). ~Le(Suc(n#), O): thm
val NOT_SUC_LT_O = {},  |- !(n : mem(N)). ~Lt(Suc(n#), O): thm
val Lt_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val Lt_trichotomy =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | a# = b# | Lt(b#, a#):
   thm
val NEQ_O_Lt = {},  |- !(a : mem(N)). ~a# = O <=> Lt(O, a#): thm
val Add_eq_O =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, n#) = O <=> m# = O & n# = O:
   thm
val Mul_eq_O =
   {}, 
   |- !(a : mem(N)). ~a# = O ==> !(b : mem(N)). Mul(a#, b#) = O <=> b# = O:
   thm
val Sub_Sub_O_eq =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, b#) = O & Sub(b#, a#) = O ==> a# = b#: thm
val NOT_LESS =
   {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#): thm
val RIGHT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Sub(m#, n#), p#) = Sub(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Sub(m#, n#)) = Sub(Mul(p#, m#), Mul(p#, n#)): thm
val MULT_MONO_EQ =
   {}, 
   |- !(n : mem(N))  (m : mem(N))  (i : mem(N)).
        Mul(Suc(n#), m#) = Mul(Suc(n#), i#) <=> m# = i#: thm
val Mul_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        ~p# = O ==> (Mul(m#, p#) = Mul(n#, p#) <=> m# = n#): thm
val Lt_MONO_Mul =
   {}, 
   |- !(p : mem(N)).
        Lt(O, p#) ==>
        !(m : mem(N))  (n : mem(N)).
          Lt(m#, n#) ==> Lt(Mul(m#, p#), Mul(n#, p#)): thm
val Le_Lt_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Lt(a#, c#): thm
val Lt_O_Lt = {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) ==> Lt(O, b#):
   thm
val Lt_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Lt(m#, i#) & Lt(n#, j#) ==> Lt(Mul(m#, n#), Mul(i#, j#)): thm
val LESS_ADD_NONZERO =
   {},  |- !(m : mem(N))  (n : mem(N)). ~n# = O ==> Lt(m#, Add(m#, n#)): thm
val SUB_LESS =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Lt(O, n#) & Le(n#, m#) ==> Lt(Sub(m#, n#), m#): thm
val Add_leq =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (b : mem(N)).
        a1# = a2# ==> Add(a1#, b#) = Add(a2#, b#): thm
val Add_req =
   {}, 
   |- !(a : mem(N))  (b1 : mem(N))  (b2 : mem(N)).
        b1# = b2# ==> Add(a#, b1#) = Add(a#, b2#): thm
val Add_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, b#), Add(c#, d#)): thm
val Add_split_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(a#, Add(Add(b#, c#), d#)): thm
val Add_last_middle_split =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, d#), Add(b#, c#)): thm
val Add_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val Add_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (m : mem(N))  (n : mem(N)).
        Add(a#, m#) = Add(a#, n#) <=> m# = n#: thm
val Lt_Sub_O =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) <=> Lt(O, Sub(b#, a#)):
   thm
val Lt_Le_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(a#, b#) & Le(b#, c#) ==> Lt(a#, c#): thm
val LESS_EQ_SUC = {},  |- !(n : mem(N)). Le(n#, Suc(n#)): thm
val Le_Lt_Le =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Le(a#, c#): thm
val Add_Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(Add(a#, b#), Add(c#, d#)) = Add(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_Lt_Lt_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Lt(c#, d#) ==> Lt(Add(a#, c#), Add(b#, d#)): thm
val Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Add(a#, Add(b#, c#)) = Add(b#, Add(a#, c#)): thm
val NOT_LESS_EQ =
   {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
val SUC_NOT_LESS_EQ = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
val Lt_Le_Suc =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(b#, a#) <=> Le(Suc(b#), a#): thm
val Le_Le_iff_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) <=> a# = b#:
   thm
val Le_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Le(a#, b#) ==> Le(Sub(a#, c#), Sub(b#, c#)): thm
val Lt_imp_Sub_O =
   {(a : mem(N)), (b : mem(N))},  |- Lt(a, b) ==> Sub(a, b) = O: thm
val Lt_Sub_imp_Le =
   {(a : mem(N)), (b : mem(N)), (c : mem(N))}, 
   |- Lt(a, Sub(b, c)) ==> Le(c, b): thm
val Lt_MONO_Sub_hard_direction =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(Sub(a#, c#), Sub(b#, c#)) & Le(c#, a#) ==> Lt(a#, b#): thm
val Lt_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Lt(a#, b#) <=> Lt(Sub(a#, c#), Sub(b#, c#)): thm
val Add_Le = {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, Add(a#, b#)): thm
val Add_pos_Lt =
   {}, 
   |- !(a : mem(N)).
        Lt(O, a#) ==>
        !(b : mem(N))  (c : mem(N)). Add(a#, b#) = c# ==> Lt(b#, c#): thm
val Le_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Le(c#, d#) ==>
          Le(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val Lt_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Lt(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Lt(c#, d#) ==>
          Lt(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val num1_def = {},  |- num1 = Suc(O): thm
val num2_def = {},  |- num2 = Suc(num1): thm
val num3_def = {},  |- num3 = Suc(num2): thm
val num4_def = {},  |- num4 = Suc(num3): thm
val WOP' =
   {}, 
   |- !(s : mem(Pow(N))).
        ~s# = Empty(N) ==>
        ?(a0 : mem(N)).
          IN(a0#, s#) & !(a1 : mem(N)). IN(a1#, s#) ==> Le(a0#, a1#): thm
val division_theorem_N_ex0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Lt(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val division_theorem_N_ex =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Le(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val NOT_Lt_O_O = {},  |- ~Lt(O, O): thm
val it = (): unit
******

Loading SEAR file SEARZarith.sml

******
val ZR_def =
   {}, 
   |- !(x : mem(N))  (y : mem(N))  (u : mem(N))  (v : mem(N)).
        Holds(ZR, Pair(x#, y#), Pair(u#, v#)) <=> Add(x#, v#) = Add(u#, y#):
   thm
val ZR_Refl = {},  |- Refl(ZR): thm
val ZR_Trans = {},  |- Trans(ZR): thm
val ZR_Sym = {},  |- Sym(ZR): thm
val ZR_ER = {},  |- ER(ZR): thm
val Ri_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (s : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Ri(r#), s#)) <=>
        ?(a : mem(A#)). IN(a#, s#) & Holds(r#, a#, b#): thm
val Rsi_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#)). Rsi(r#) = Ri(r#) o Sg(A#):
   thm
val rsi_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (r : rel(A#, B#)).
        rsi(r#, a#) = App(Rsi(r#), a#): thm
val IN_rsi =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
val ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          (!(x : mem(A#)). Holds(r#, a1#, x#) <=> Holds(r#, a2#, x#)) <=>
          Holds(r#, a1#, a2#): thm
val rsi_eq_ER =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          rsi(r#, a1#) = rsi(r#, a2#) <=> Holds(r#, a1#, a2#): thm
val Z_def =
   {}, 
   |- Inj(iZ) &
      !(a : mem(Pow(N * N))).
        (?(n : mem(N * N)). a# = rsi(ZR, n#)) <=>
        ?(b : mem(Z)). a# = App(iZ, b#): thm
val iZ_Inj = {},  |- Inj(iZ): thm
val iZ_eq_eq =
   {}, 
   |- !(x1 : mem(Z))  (x2 : mem(Z)).
        App(iZ, x1#) = App(iZ, x2#) ==> x1# = x2#: thm
val iZ_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(m : mem(N))  (n : mem(N)). App(iZ, z#) = rsi(ZR, Pair(m#, n#)): thm
val rsi_iZ =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        ?(b : mem(Z)). rsi(ZR, Pair(m#, n#)) = App(iZ, b#): thm
val resp_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#)).
        resp(f#, r1#, r2#) <=>
        !(y : mem(A#))  (z : mem(A#)).
          Holds(r1#, y#, z#) ==> Holds(r2#, App(f#, y#), App(f#, z#)): thm
val rext_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a0 : mem(Pow(A#)))  (b0 : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a0#, b0#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a0# = rsi(r1#, a#) & b0# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val rext_def0 =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a : mem(Pow(A#)))  (b : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a#, b#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a# = rsi(r1#, a#) & b# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val prrel_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#))
      (a1 : mem(A#))  (b1 : mem(B#))  (a2 : mem(A#))  (b2 : mem(B#)).
        Holds(prrel(r1#, r2#), Pair(a1#, b1#), Pair(a2#, b2#)) <=>
        Holds(r1#, a1#, a2#) & Holds(r2#, b1#, b2#): thm
val main =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val ipow2_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (b : mem(B#))  (Q1 : set)
      (aq : mem(Q1#))  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (bq : mem(Q2#))
      (i2 : fun(Q2#, Pow(B#))).
        IN(Pair(a#, b#), App(ipow2(i1#, i2#), Pair(aq#, bq#))) <=>
        IN(a#, App(i1#, aq#)) & IN(b#, App(i2#, bq#)): thm
val addf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(addf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(a#, a'#), Add(b#, b''#)): thm
val prrel_ER_ER =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#)).
        ER(r1#) & ER(r2#) ==> ER(prrel(r1#, r2#)): thm
val Pow_conj_eq0 =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3#: thm
val Pow_conj_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3# & s2# = s4#: thm
val ipow2_Inj_Inj =
   {}, 
   |- !(Q1 : set)  (A : set)  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (B : set)
      (i2 : fun(Q2#, Pow(B#))).
        (!(q1 : mem(Q1#)). ?(a : mem(A#)). IN(a#, App(i1#, q1#))) &
        (!(q2 : mem(Q2#)). ?(b : mem(B#)). IN(b#, App(i2#, q2#))) &
        Inj(i1#) & Inj(i2#) ==> Inj(ipow2(i1#, i2#)): thm
val Quo_def =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quo(r#, i#) <=>
        !(s : mem(Pow(A#))).
          (?!(q : mem(Q#)). s# = App(i#, q#)) <=>
          ?(a : mem(A#)). s# = rsi(r#, a#): thm
val Inj_Quo =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Inj(i) &
      (!(s : mem(Pow(A))).
          (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#)) <=>
      Inj(i) & Quo(r, i): thm
val ER_rsi_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a : mem(A#)).
        ER(r#) ==> IN(a#, rsi(r#, a#)): thm
val Quo_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) & Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        Quo(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val Quo_fun =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val main_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val Inj_Quo_Z = {},  |- Inj(iZ) & Quo(ZR, iZ): thm
val Quo_fun_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val iZ_nonempty =
   {},  |- !(z : mem(Z)). ?(ab : mem(N * N)). IN(ab#, App(iZ, z#)): thm
val addf0_resp = {},  |- resp(addf0, prrel(ZR, ZR), ZR): thm
val addz_conds =
   {}, 
   |- ER(prrel(ZR, ZR)) &
      ER(ZR) &
      resp(addf0, prrel(ZR, ZR), ZR) &
      Inj(ipow2(iZ, iZ)) &
      Inj(iZ) & Quo(prrel(ZR, ZR), ipow2(iZ, iZ)) & Quo(ZR, iZ): thm
val main_addz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(addz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(addf0, a#) = b#: thm
val main_addz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(addz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val Inj_Quo_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Inj(i#) & Quo(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). App(i#, q#) = rsi(r#, a#): thm
val Z_has_rep =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). App(iZ, z#) = rsi(ZR, Pair(a'#, b#)):
   thm
val Addz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Addz(z1#, z2#) = App(addz, Pair(z1#, z2#)): thm
val Repz_def = {},  |- !(z : mem(Z)). Repz(z#) = App(iZ, z#): thm
val Repz_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = rsi(ZR, Pair(a'#, b#)): thm
val ZC_def = {},  |- !(ab : mem(N * N)). ZC(ab#) = rsi(ZR, ab#): thm
val Repz_ZC =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = ZC(Pair(a'#, b#)): thm
val Addz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Addz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val ZC_ZR =
   {}, 
   |- !(ab : mem(N * N))  (cd : mem(N * N)).
        ZC(ab#) = ZC(cd#) <=> Holds(ZR, ab#, cd#): thm
val Addz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Addz(z1#, z2#)) = ZC(Pair(Add(a1#, a3#), Add(a2#, a4#))): thm
val Repz_eq_eq =
   {},  |- !(x1 : mem(Z))  (x2 : mem(Z)). Repz(x1#) = Repz(x2#) ==> x1# = x2#:
   thm
val Repz_eq_ZR =
   {}, 
   |- !(a1 : mem(N * N))  (a2 : mem(N * N)).
        ZC(a1#) = ZC(a2#) <=> Holds(ZR, a1#, a2#): thm
val eq_ZR =
   {},  |- !(a : mem(N * N))  (b : mem(N * N)). a# = b# ==> Holds(ZR, a#, b#):
   thm
val Addz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Addz(z1#, z2#) = Addz(z2#, z1#):
   thm
val negf0_def =
   {},  |- !(a : mem(N * N)). App(negf0, a#) = Pair(Snd(a#), Fst(a#)): thm
val negf0_def1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). App(negf0, Pair(m#, n#)) = Pair(n#, m#):
   thm
val negf0_resp = {},  |- resp(negf0, ZR, ZR): thm
val Negz_def = {},  |- !(z : mem(Z)). Negz(z#) = App(negz, z#): thm
val main_negz =
   {(z : mem(Z))}, 
   |- ?(a : mem(N * N))  (b : mem(N * N)).
        Repz(z) = ZC(a#) & Repz(App(negz, z)) = ZC(b#) & App(negf0, a#) = b#:
   thm
val Negz_char =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = ZC(Pair(a#, b#)) ==> Repz(Negz(z#)) = ZC(Pair(b#, a#)):
   thm
val main_negz1 =
   {(z : mem(Z))}, 
   |- ?(a1' : mem(N))  (a2' : mem(N)).
        Repz(z) = ZC(Pair(a1'#, a2'#)) & Repz(Negz(z)) = ZC(Pair(a2'#, a1'#)):
   thm
val mulf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(mulf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(Mul(a#, a'#), Mul(b#, b''#)),
           Add(Mul(a#, b''#), Mul(b#, a'#))): thm
val mulf0_resp = {},  |- resp(mulf0, prrel(ZR, ZR), ZR): thm
val main_mulz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(mulz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(mulf0, a#) = b#: thm
val main_mulz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(mulz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
           Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Mulz(z1#, z2#) = App(mulz, Pair(z1#, z2#)): thm
val Mulz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Mulz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Mulz(z1#, z2#)) =
            ZC(Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
              Add(Mul(a1#, a4#), Mul(a2#, a3#)))): thm
val ZC_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        ?!(z : mem(Z)). Repz(z#) = ZC(Pair(a#, b#)): thm
val ZC_Repz' =
   {},  |- !(ab : mem(N * N)). ?!(z : mem(Z)). Repz(z#) = ZC(ab#): thm
val absz_def =
   {}, 
   |- !(a' : mem(N))  (b : mem(N))  (b : mem(Z)).
        App(absz, Pair(a'#, b#)) = b# <=> Repz(b#) = ZC(Pair(a'#, b#)): thm
val Absz_def = {},  |- !(ab : mem(N * N)). Absz(ab#) = App(absz, ab#): thm
val Asz_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Asz(a#, b#) = Absz(Pair(a#, b#)): thm
val Zc_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Zc(a#, b#) = ZC(Pair(a#, b#)): thm
val Absz_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Repz(Absz(Pair(a#, b#))) = ZC(Pair(a#, b#)): thm
val Asz_Repz =
   {},  |- !(a : mem(N))  (b : mem(N)). Repz(Asz(a#, b#)) = Zc(a#, b#): thm
val Oz_def = {},  |- Oz = Asz(O, O): thm
val En_def = {},  |- En = Suc(O): thm
val Ez_def = {},  |- Ez = Asz(En, O): thm
val Addz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Addz(z1#, z2#)) = Zc(Add(a1#, a3#), Add(a2#, a4#)): thm
val Addz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Addz(Asz(a#, b#), Asz(c#, d#)) = Asz(Add(a#, c#), Add(b#, d#)): thm
val Mulz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Mulz(z1#, z2#)) =
            Zc(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))): thm
val Mulz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Mulz(Asz(a#, b#), Asz(c#, d#)) =
          Asz(Add(Mul(a#, c#), Mul(b#, d#)), Add(Mul(a#, d#), Mul(b#, c#))):
   thm
val Negz_th0 =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) ==> Repz(Negz(z#)) = Zc(b#, a#): thm
val Negz_Asz =
   {},  |- !(a : mem(N))  (b : mem(N)). Negz(Asz(a#, b#)) = Asz(b#, a#): thm
val cases_z =
   {},  |- !(z : mem(Z)). ?(a : mem(N))  (b : mem(N)). z# = Asz(a#, b#): thm
val Addz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Addz(Addz(z1#, z2#), z3#) = Addz(z1#, Addz(z2#, z3#)): thm
val casesz =
   {}, 
   |- (!(a : mem(N))  (b : mem(N)). P(Asz(a#, b#))) <=> !(z : mem(Z)). P(z#):
   thm
SEARZarith.sml:1213: warning: Matches are not exhaustive. Found near fn [th0] => dimp_mp_l2r th0 th
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val casez_tac = fn: cont * form list * form -> goal list * validation
val Asz_eq_ZR =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Asz(a#, b#) = Asz(c#, d#) <=> Holds(ZR, Pair(a#, b#), Pair(c#, d#)):
   thm
val Addz_Negz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Negz(z#)) = Oz: thm
val Mulz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Mulz(z1#, z2#), z3#) = Mulz(z1#, Mulz(z2#, z3#)): thm
val LDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(z1#, Addz(z2#, z3#)) = Addz(Mulz(z1#, z2#), Mulz(z1#, z3#)): thm
val Mulz_Ez = {},  |- !(z : mem(Z)). Mulz(z#, Ez) = z#: thm
val Mulz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Mulz(z1#, z2#) = Mulz(z2#, z1#):
   thm
val RDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Addz(z2#, z3#), z1#) = Addz(Mulz(z2#, z1#), Mulz(z3#, z1#)): thm
val le0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b' : mem(N)).
        le0(Pair(a#, b#), Pair(a'#, b'#)) <=> Le(Add(a#, b'#), Add(b#, a'#)):
   thm
val Lez_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) <=>
        !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
          Repz(z1#) = Zc(a#, b#) & Repz(z2#) = Zc(c#, d#) ==>
          Le(Add(a#, d#), Add(b#, c#)): thm
val LEz_def =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Holds(LEz, a#, b#) <=> Lez(a#, b#):
   thm
val LEz_Refl = {},  |- Refl(LEz): thm
val Repz_Zc =
   {}, 
   |- !(z : mem(Z)). ?(a' : mem(N))  (b : mem(N)). Repz(z#) = Zc(a'#, b#):
   thm
val LEz_Trans = {},  |- Trans(LEz): thm
val LEz_Asym = {},  |- Asym(LEz): thm
val Total_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Total(R#) <=>
        !(a : mem(A#))  (b : mem(A#)). Holds(R#, a#, b#) | Holds(R#, b#, a#):
   thm
val Lez_resp0 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N))  (e : mem(N))
      (f : mem(N))  (g : mem(N))  (h : mem(N)).
        Holds(ZR, Pair(a#, b#), Pair(c#, d#)) &
        Holds(ZR, Pair(e#, f#), Pair(g#, h#)) ==>
        (Le(Add(a#, f#), Add(b#, e#)) <=> Le(Add(c#, h#), Add(d#, g#))): thm
val LEz_Total = {},  |- Total(LEz): thm
val Lez_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Lez(Asz(a#, b#), Asz(c#, d#)) <=> Le(Add(a#, d#), Add(b#, c#)): thm
val Lez_Addz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) ==> !(z3 : mem(Z)). Lez(Addz(z1#, z3#), Addz(z2#, z3#)):
   thm
val Lez_Mulz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Lez(z1#, z2#) & Lez(Oz, z3#) ==> Lez(Mulz(z1#, z3#), Mulz(z2#, z3#)):
   thm
val EVEN_def =
   {}, 
   |- (!(a : mem(1)). App(EVEN, O) = true) &
      !(a : mem(N)). App(EVEN, Suc(a#)) = App(NOT, App(EVEN, a#)): thm
val Even_def = {(n : mem(N))},  |- Even(n) <=> App(EVEN, n) = true: thm
val O_Even = {},  |- Even(O): thm
val Suc_Even = {},  |- !(n : mem(N)). Even(Suc(n#)) <=> ~Even(n#): thm
val Even_not_Odd = {},  |- !(n : mem(N)). Even(n#) <=> ~Odd(n#): thm
val Odd_def = {(n : mem(N))},  |- Odd(n) <=> ~Even(n): thm
val Odd_not_Even = {},  |- !(n : mem(N)). Odd(n#) <=> ~Even(n#): thm
val id_ER = {},  |- !(A : set). ER(id(A#)): thm
val Sg_Inj = {},  |- !(A : set). Inj(Sg(A#)): thm
val Quo_id_Sg = {},  |- !(A : set). Quo(id(A#), Sg(A#)): thm
val Pow_conj_eq' =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (s1 : mem(Pow(A#)))  (B : set)
      (b0 : mem(B#))  (s2 : mem(Pow(B#))).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        !(s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#))).
          (!(a : mem(A#))  (b : mem(B#)).
              IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) <=>
          s1# = s3# & s2# = s4#: thm
val Repz_iff_Asz =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) <=> Asz(a#, b#) = z#: thm
val ipow2_prrel_ZR =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N)), (z1 : mem(Z)),
    (z2 : mem(Z))}, 
   |- App(ipow2(iZ, iZ), Pair(z1, z2)) =
        rsi(prrel(ZR, ZR), Pair(Pair(a, b), Pair(c, d))) <=>
      Asz(a, b) = z1 & Asz(c, d) = z2: thm
val Asz_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, b#) = Asz(a#, c#) <=> b# = c#: thm
val Ltz_def =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Lez(a#, b#) & ~a# = b#:
   thm
val N2Z_def = {},  |- !(a : mem(N)). App(N2Z, a#) = Asz(a#, O): thm
val n2z_def = {},  |- !(n : mem(N)). n2z(n#) = App(N2Z, n#): thm
val Asz_eq_eq_l =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, c#) = Asz(b#, c#) <=> a# = b#: thm
val N2Z_Inj = {},  |- Inj(N2Z): thm
val Repz_eq_eq_iff =
   {(x1 : mem(Z)), (x2 : mem(Z))},  |- Repz(x1) = Repz(x2) <=> x1 = x2: thm
val prove_dimp_th = fn: thm -> thm
val Abv_positive_ex0 =
   {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> ?(n : mem(N)). Asz(n#, O) = z#: thm
val Lez_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Lez(Negz(z#), Negz(b#)) <=> Lez(b#, z#):
   thm
val Negz_eq_eq =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Negz(z#) = Negz(b#) <=> z# = b#: thm
val Negz_Oz = {},  |- Negz(Oz) = Oz: thm
val Abv_negative_ex0 =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> ?(n : mem(N)). Asz(O, n#) = z#: thm
val Lez_dichotomy =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Lez(z#, b#) | Lez(b#, z#): thm
val Ltz_Asz =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N))}, 
   |- Ltz(Asz(a, b), Asz(c, d)) <=> Lt(Add(a, d), Add(b, c)): thm
val NOT_Lez_Ltz =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Lez(z#, b#) <=> Ltz(b#, z#): thm
val Abv_def =
   {}, 
   |- !(z : mem(Z)).
        Lez(Oz, z#) & Asz(Abv(z#), O) = z# |
        Ltz(z#, Oz) & Asz(O, Abv(z#)) = z#: thm
val Abv_nonneg = {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> Asz(Abv(z#), O) = z#:
   thm
val Abv_uex =
   {}, 
   |- !(z : mem(Z)).
        ?!(n : mem(N)).
          Lez(Oz, z#) & Asz(n#, O) = z# | Ltz(z#, Oz) & Asz(O, n#) = z#: thm
val n2z_Abv = {},  |- !(a : mem(Z)). Lez(Oz, a#) ==> n2z(Abv(a#)) = a#: thm
val Oz_Mulz = {},  |- !(z : mem(Z)). Mulz(Oz, z#) = Oz: thm
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val Oz_Ltz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, Oz) & Ltz(b#, Oz) ==> Ltz(Oz, Mulz(z#, b#)): thm
val int1_NONZERO = {},  |- ~int1 = Oz: thm
val int1_def = {},  |- int1 = n2z(Suc(O)): thm
val Negz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Negz(Mulz(z#, b#)):
   thm
val Ltz_Addz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, b#) <=> Ltz(Addz(z#, Negz(b#)), Oz): thm
val Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(z#, Negz(b#)) = Negz(Mulz(z#, b#)):
   thm
val Mulz_int1 = {},  |- !(z : mem(Z)). Mulz(z#, int1) = z#: thm
val Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) ==> Lez(z#, b#): thm
val n2z_Oz_Lez = {},  |- !(a : mem(N)). Lez(Oz, n2z(a#)): thm
val Negz_Addz_Oz = {},  |- !(z : mem(Z)). Addz(Negz(z#), z#) = Oz: thm
val Lez_Addz_ex =
   {}, 
   |- !(z : mem(Z))  (m : mem(Z)).
        Lez(z#, m#) ==> ?(p : mem(Z)). Lez(Oz, p#) & Addz(p#, z#) = m#: thm
val Lez_Addz_2 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Lez(z#, c#) & Lez(b#, d#) ==> Lez(Addz(z#, b#), Addz(c#, d#)): thm
val Oz_Lez_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(Oz, z#) & Lez(Oz, b#) ==>
        Lez(z#, Addz(z#, b#)) & Lez(b#, Addz(z#, b#)): thm
val Oz_Ltz_Addz =
   {}, 
   |- !(z : mem(Z)). Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(b#, Addz(z#, b#)):
   thm
val int1_Asz = {},  |- int1 = Asz(Suc(O), O): thm
val Ltz_int1_Lez_Oz = {},  |- !(z : mem(Z)). Ltz(int1, z#) ==> Lez(Oz, z#):
   thm
val Lez_Oz_Addz_Lez =
   {}, 
   |- !(z : mem(Z)). Lez(z#, Oz) ==> !(a : mem(Z)). Lez(Addz(a#, z#), a#):
   thm
val Lez_Ltz_TRANS_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(z#, c#): thm
val Ltz_trans =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(a#, c#): thm
val NOT_Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Ltz(z#, b#) <=> Lez(b#, z#): thm
val Addz_Rarr =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = c# <=> z# = Addz(c#, Negz(b#)): thm
val Addz_eq_eq =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = Addz(z#, c#) <=> b# = c#: thm
val Negz_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Negz(Addz(z#, b#)) = Addz(Negz(z#), Negz(b#)): thm
val Lez_cases =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) <=> Ltz(a#, b#) | a# = b#:
   thm
val Lez_refl = {},  |- !(a : mem(Z)). Lez(a#, a#): thm
val Lez_REFL = {},  |- !(z : mem(Z)). Lez(z#, z#): thm
val Oz_Lez_int1 = {},  |- Lez(Oz, int1): thm
val Oz_Ltz_int1 = {},  |- Ltz(Oz, int1): thm
val Ltz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(Negz(z#), Negz(b#)) <=> Ltz(b#, z#):
   thm
val NEQ_Ltz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). ~a# = b# <=> Ltz(a#, b#) | Ltz(b#, a#):
   thm
val Ltz_iff_Lez_int1 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) <=> Lez(Addz(z#, int1), b#):
   thm
val Negz_Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Mulz(z#, Negz(b#)):
   thm
val Oz_Addz = {},  |- !(z : mem(Z)). Addz(Oz, z#) = z#: thm
val Addz_eq_eq' =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(a#, c#) = Addz(b#, c#) <=> a# = b#: thm
val between_int1_Oz =
   {},  |- !(z : mem(Z)). Ltz(Negz(int1), z#) & Ltz(z#, int1) <=> z# = Oz:
   thm
val Addz_Negz_Oz_eq =
   {}, 
   |- !(z : mem(Z))  (z2 : mem(Z)). Addz(z#, Negz(z2#)) = Oz <=> z# = z2#:
   thm
val Negz_Negz = {},  |- !(z : mem(Z)). Negz(Negz(z#)) = z#: thm
val Ltz_iff_O_Ltz_Sub =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) <=> Ltz(Oz, Addz(b#, Negz(a#))): thm
val Ltz_Ltz_Mulz_Ltz =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, Mulz(z#, b#)) ==> Ltz(Oz, b#):
   thm
val Ltz_Ltz_Mulz_pos =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, b#) ==> Ltz(Oz, Mulz(z#, b#)):
   thm
val Mulz_Ltz_Ltz =
   {}, 
   |- !(a : mem(Z)).
        Ltz(Oz, a#) ==>
        !(b : mem(Z))  (c : mem(Z)).
          Ltz(Mulz(a#, b#), Mulz(a#, c#)) <=> Ltz(b#, c#): thm
val Ltz_Oz_Lez_int1 = {},  |- !(z : mem(Z)). Ltz(Oz, z#) <=> Lez(int1, z#):
   thm
val Addz_Rarr_both_sides =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Addz(z#, b#) = Addz(c#, d#) <=>
        Addz(d#, Negz(b#)) = Addz(z#, Negz(c#)): thm
val Lez_Ltz_Addz_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==>
        !(c : mem(Z))  (d : mem(Z)).
          Ltz(c#, d#) ==> Ltz(Addz(z#, c#), Addz(b#, d#)): thm
val Mulz_Negz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), Negz(b#)) = Mulz(z#, b#):
   thm
val Lez_asym =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) & Lez(b#, a#) ==> a# = b#:
   thm
val Ltz_NOT_Ltz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) ==> ~Ltz(b#, a#): thm
val Abv_Negz = {},  |- !(z : mem(Z)). Abv(Negz(z#)) = Abv(z#): thm
val Abv_Oz = {},  |- Abv(Oz) = O: thm
val n2z_Abv_Negz =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> n2z(Abv(z#)) = Negz(z#): thm
val n2z_is_Abv =
   {},  |- !(n : mem(N))  (z : mem(Z)). n2z(n#) = z# ==> n# = Abv(z#): thm
val Le_Abv_Abv =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Lez(Oz, a#) & Lez(Oz, b#) ==> (Le(Abv(a#), Abv(b#)) <=> Lez(a#, b#)):
   thm
val division_theorem_ex0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_ex1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val Lez_trans =
   {}, 
   |- !(a1 : mem(Z))  (a2 : mem(Z))  (a3 : mem(Z)).
        Lez(a1#, a2#) & Lez(a2#, a3#) ==> Lez(a1#, a3#): thm
val division_theorem_ex =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?(q : mem(Z))  (r : mem(Z)).
            a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_unique0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem_unique1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        ?!(qr : mem(Z * Z)).
          a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
          Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val DIVRz_def =
   {}, 
   |- !(a : mem(Z * Z)).
        Snd(a#) = Oz & App(DIVRz, a#) = Pair(Oz, Oz) |
        ~Snd(a#) = Oz &
        Fst(a#) =
          Addz(Mulz(Fst(App(DIVRz, a#)), Snd(a#)), Snd(App(DIVRz, a#))) &
        Lez(Oz, Snd(App(DIVRz, a#))) &
        Ltz(Snd(App(DIVRz, a#)), n2z(Abv(Snd(a#)))): thm
val Divrz_Oz =
   {}, 
   |- !(d : mem(Z)). d# = Oz ==> !(a : mem(Z)). Divrz(a#, d#) = Pair(Oz, Oz):
   thm
val Divrz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divrz(a, d) = App(DIVRz, Pair(a, d)):
   thm
val Divrz_property0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        d# = Oz & Divrz(a#, d#) = Pair(Oz, Oz) |
        ~d# = Oz &
        a# = Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) &
        Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divrz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) = a# &
          Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divz_Remz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Divz(a#, d#), d#), Remz(a#, d#)) = a# &
          Lez(Oz, Remz(a#, d#)) & Ltz(Remz(a#, d#), n2z(Abv(d#))): thm
val Divz_Remz_Oz =
   {},  |- !(a : mem(Z)). Divz(a#, Oz) = Oz & Remz(a#, Oz) = Oz: thm
val Divz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divz(a, d) = Fst(Divrz(a, d)): thm
val Remz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Remz(a, d) = Snd(Divrz(a, d)): thm
val Subz_Addz =
   {},  |- !(m : mem(Z))  (n : mem(Z)). Addz(Subz(m#, n#), n#) = m#: thm
val Subz_def =
   {(a : mem(Z)), (b : mem(Z))},  |- Subz(a, b) = Addz(a, Negz(b)): thm
val Mulz_Oz = {},  |- !(z : mem(Z)). Mulz(z#, Oz) = Oz: thm
val Oz_Ltz_Negz = {},  |- !(a : mem(Z)). Ltz(Oz, a#) <=> Ltz(Negz(a#), Oz):
   thm
val Ltz_Oz_Negz = {},  |- !(a : mem(Z)). Ltz(a#, Oz) <=> Ltz(Oz, Negz(a#)):
   thm
val Mulz_Ltz_Ltz_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(Mulz(a#, b#), Oz) <=>
        Ltz(Oz, a#) & Ltz(b#, Oz) | Ltz(Oz, b#) & Ltz(a#, Oz): thm
val Mulz_Oz_iff_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Mulz(a#, b#) = Oz <=> a# = Oz | b# = Oz:
   thm
val Divz_Remz_unique =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z))  (q : mem(Z))  (r : mem(Z)).
          Addz(Mulz(q#, d#), r#) = a# & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))) ==>
          q# = Divz(a#, d#) & r# = Remz(a#, d#): thm
val division_theorem' =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?!(qr : mem(Z * Z)).
            a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
            Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val Ltz_Subz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Ltz(Oz, Subz(b#, a#)):
   thm
val Subz_Ltz =
   {}, 
   |- !(a : mem(Z)). Ltz(Oz, a#) ==> !(b : mem(Z)). Ltz(Subz(b#, a#), b#):
   thm
val int1_Mulz = {},  |- !(z : mem(Z)). Mulz(int1, z#) = z#: thm
val Addz_Subz_Rarr =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(Addz(a#, b#), Subz(c#, b#)) = Addz(a#, c#): thm
val Divz_pos_Remz =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(Oz, a#) & Ltz(Oz, d#) ==> Ltz(Remz(a#, d#), d#): thm
val n2z_eq_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). n2z(a#) = n2z(b#) <=> a# = b#: thm
val n2z_Asz = {},  |- !(n : mem(N)). n2z(n#) = Asz(n#, O): thm
val n2z_Oz = {},  |- n2z(O) = Oz: thm
val Lez_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Lez(n2z(a#), n2z(b#)) <=> Le(a#, b#):
   thm
val Ltz_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Ltz(n2z(a#), n2z(b#)) <=> Lt(a#, b#):
   thm
val Oz_Lez_n2z = {},  |- !(n : mem(N)). Lez(Oz, n2z(n#)): thm
val Mulz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Mulz(n2z(a#), n2z(b#)) = n2z(Mul(a#, b#)):
   thm
val Addz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Addz(n2z(a#), n2z(b#)) = n2z(Add(a#, b#)):
   thm
val n2z_Oz_O = {},  |- !(n : mem(N)). n2z(n#) = Oz <=> n# = O: thm
val Le_num1_Lt_O = {},  |- !(a : mem(N)). Le(num1, a#) <=> Lt(O, a#): thm
val division_theorem_N_uex =
   {}, 
   |- !(d : mem(N)).
        Le(num1, d#) ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val qfun_compr = fn: term frag list -> term frag list -> thm
******

Loading SEAR file quo.sml

******
val resp1_def =
   {(A : set), (B : set), (R : rel(A, A)), (f : fun(A, B))}, 
   |- resp1(f, R) <=> resp(f, R, id(B)): thm
val resp1_property =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (R : rel(A#, A#)).
        resp1(f#, R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> App(f#, a1#) = App(f#, a2#): thm
val Inj_INV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          ?!(ivf : fun(B#, A#)).
            ivf# o f# = Id(A#) &
            !(b : mem(B#)).
              (!(a : mem(A#)). ~App(f#, a#) = b#) ==> App(ivf#, b#) = a0#:
   thm
val Abs_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- Abs(r, i, q0) = LINV(i, q0) o Rsi(r): thm
val Inj_LINV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(a : mem(A#)). LINV(f#, a#) o f# = Id(A#): thm
val LINV_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          LINV(f#, a0#) o f# = Id(A#) &
          !(b : mem(B#)).
            (!(a : mem(A#)). ~App(f#, a#) = b#) ==>
            App(LINV(f#, a0#), b#) = a0#: thm
val Quot_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Quot(r, i) <=>
      Inj(i) &
      !(s : mem(Pow(A))).
        (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#):
   thm
val abs_def =
   {(A : set), (Q : set), (a : mem(A)), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- abs(r, i, q0, a) = App(Abs(r, i, q0), a): thm
val eth = {(A : set), (B : set), (a0 : mem(A))},  |- ?(f : fun(B, A)). T: thm
val fname = "LINV": string
val fun_mem_ex =
   {},  |- !(A : set)  (a0 : mem(A#))  (B : set). ?(f : fun(B#, A#)). T: thm
val qvl =
   [[QUOTE " (*#loc 80 35*)f:A->B"], [QUOTE " (*#loc 80 48*)a0:mem(A)"]]:
   term frag list list
val uexth0 =
   {(A : set), (B : set), (a0 : mem(A)), (f : fun(A, B))}, Inj(f)
   |- ?!(ivf : fun(B, A)).
        ivf# o f = Id(A) &
        !(b : mem(B)).
          (!(a : mem(A)). ~App(f, a#) = b#) ==> App(ivf#, b#) = a0: thm
val Abs_Surj =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==> !(q0 : mem(Q#)). Surj(Abs(r#, i#, q0#)): thm
val Quot_ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            App(i#, q1#) = rsi(r#, a1#) & App(i#, q2#) = rsi(r#, a2#) ==>
            (Holds(r#, a1#, a2#) <=> q1# = q2#): thm
val Quot_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            abs(r#, i#, q0#, a1#) = abs(r#, i#, q0#, a2#) <=>
            Holds(r#, a1#, a2#): thm
val Quot_UMP =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        !(B : set)  (f : fun(A#, B#)).
          resp1(f#, R#) ==>
          !(Q : set)  (i : fun(Q#, Pow(A#))).
            Quot(R#, i#) ==>
            !(q0 : mem(Q#)).
              ?!(fb : fun(Q#, B#)).
                !(a : mem(A#)). App(fb#, abs(R#, i#, q0#, a#)) = App(f#, a#):
   thm
val Quot_Quo =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) <=> Inj(i#) & Quo(r#, i#): thm
val ER_Quot_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). IN(a#, App(i#, q#)): thm
val Quot_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        Quot(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val abs_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        !(q1 : mem(Q1#))  (q2 : mem(Q2#))  (a : mem(A#))  (b : mem(B#)).
          abs(prrel(r1#, r2#), ipow2(i1#, i2#), Pair(q1#, q2#), Pair(a#, b#)) =
            Pair(abs(r1#, i1#, q1#, a#), abs(r2#, i2#, q2#, b#)): thm
val Rep_of_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(q0 : mem(Q#))  (a : mem(A#)).
          App(i#, abs(r#, i#, q0#, a#)) = rsi(r#, a#): thm
val Quot_rsi_uex =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). App(i#, q#) = rsi(r#, a#): thm
val ER_Quot_rsi_char =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q : mem(Q#))  (a : mem(A#)).
            IN(a#, App(i#, q#)) <=> App(i#, q#) = rsi(r#, a#): thm
val Quot_IN_BIGUNION_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            ?(a : mem(Q#)). IN(a#, s#) & abs(r#, i#, q0#, ra#) = a#: thm
val Quot_IN_BIGUNION_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            IN(abs(r#, i#, q0#, ra#), s#): thm
val Quot_el_same =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#)).
            q1# = q2# <=>
            ?(a1 : mem(A#))  (a2 : mem(A#)).
              IN(a1#, App(i#, q1#)) &
              IN(a2#, App(i#, q2#)) & Holds(r#, a1#, a2#): thm
val ER_Quot_has_mem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val ER_Quot_has_umem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val it = (): unit
val NONZERO_O_Lt = {},  |- !(n : mem(N)). ~n# = O <=> Lt(O, n#): thm
val DIVR_def =
   {}, 
   |- !(a : mem(N * N)).
        Snd(a#) = O & App(DIVR, a#) = Pair(O, O) |
        ~Snd(a#) = O &
        Fst(a#) = Add(Mul(Fst(App(DIVR, a#)), Snd(a#)), Snd(App(DIVR, a#))) &
        Lt(Snd(App(DIVR, a#)), Snd(a#)): thm
val Divr_O =
   {},  |- !(d : mem(N)). d# = O ==> !(a : mem(N)). Divr(a#, d#) = Pair(O, O):
   thm
val Divr_def =
   {(a : mem(N)), (d : mem(N))},  |- Divr(a, d) = App(DIVR, Pair(a, d)): thm
val Divr_property0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        d# = O & Divr(a#, d#) = Pair(O, O) |
        ~d# = O &
        a# = Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) &
        Lt(Snd(Divr(a#, d#)), d#): thm
val Z2N_def = {},  |- Z2N = LINV(N2Z, O): thm
val Divr_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) = a# &
          Lt(Snd(Divr(a#, d#)), d#): thm
val Div2_def = {(n : mem(N))},  |- Div2(n) = Div(n, num2): thm
val Div_Rem_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Div(a#, d#), d#), Rem(a#, d#)) = a# & Lt(Rem(a#, d#), d#):
   thm
val Div_def = {(a : mem(N)), (d : mem(N))},  |- Div(a, d) = Fst(Divr(a, d)):
   thm
val Rem_def = {(a : mem(N)), (d : mem(N))},  |- Rem(a, d) = Snd(Divr(a, d)):
   thm
val num2_NONZERO = {},  |- ~num2 = O: thm
val Mul_num2 = {},  |- !(a : mem(N)). Mul(num2, a#) = Add(a#, a#): thm
val Div_Rem_num2 =
   {}, 
   |- !(a : mem(N)).
        Add(Mul(Div2(a#), num2), Rem(a#, num2)) = a# &
        Lt(Rem(a#, num2), num2): thm
val Div_Rem_unique =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N))  (q : mem(N))  (r : mem(N)).
          Add(Mul(q#, d#), r#) = a# & Lt(r#, d#) ==>
          q# = Div(a#, d#) & r# = Rem(a#, d#): thm
val division_theorem_N_uex' =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val Div_Rem_Mul =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)). Div(Mul(d#, a#), d#) = a# & Rem(Mul(d#, a#), d#) = O:
   thm
val Div2_Mul = {},  |- !(n : mem(N)). Div2(Mul(num2, n#)) = n#: thm
val num1_Lt_num2 = {},  |- Lt(num1, num2): thm
val Div2_Suc_Mul_num2 =
   {}, 
   |- !(n : mem(N)).
        Div2(Suc(Mul(num2, n#))) = n# & Rem(Suc(Mul(num2, n#)), num2) = num1:
   thm
val Even_Suc = {},  |- !(a : mem(N)). Even(Suc(a#)) <=> ~Even(a#): thm
val num2_Mul_Even = {},  |- !(a : mem(N)). Even(Mul(num2, a#)): thm
val Suc_num2_Mul_Odd = {},  |- !(a : mem(N)). Odd(Suc(Mul(num2, a#))): thm
val O_Even = {},  |- Even(O): thm
val O_NEQ_num1 = {},  |- ~O = num1: thm
val O_NEQ_num2 = {},  |- ~O = num2: thm
val O_NEQ_num3 = {},  |- ~O = num3: thm
val O_NEQ_num4 = {},  |- ~O = num4: thm
val num1_NEQ_num4 = {},  |- ~num1 = num4: thm
val num1_NEQ_num3 = {},  |- ~num1 = num3: thm
val num1_NEQ_num2 = {},  |- ~num1 = num2: thm
val num2_NEQ_num3 = {},  |- ~num2 = num3: thm
val num2_NEQ_num4 = {},  |- ~num2 = num4: thm
val num4_NEQ_num3 = {},  |- ~num4 = num3: thm
val Div_of_O = {},  |- !(n : mem(N)). Div(O, n#) = O & Rem(O, n#) = O: thm
val Even_Sub_num2 = {},  |- !(a : mem(N)). Even(a#) ==> Even(Sub(a#, num2)):
   thm
val Odd_num1 = {},  |- Odd(num1): thm
val Lt_num2 = {},  |- !(a : mem(N)). Lt(a#, num2) <=> a# = O | a# = num1: thm
val Even_Div2 =
   {}, 
   |- !(a : mem(N)).
        Even(a#) <=> Mul(Div2(a#), num2) = a# & Rem(a#, num2) = O: thm
val Odd_Div2 =
   {}, 
   |- !(a : mem(N)).
        Odd(a#) <=> Suc(Mul(Div2(a#), num2)) = a# & Rem(a#, num2) = num1: thm
val it = (): unit
******

Loading SEAR file SEARFiniteness.sml

******
val FI's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). IN(a#, FI's(X)) <=> SS(App(FIf(X), a#), a#):
   thm
val FI_cases0 = {(X : set)},  |- App(FIf(X), FIs(X)) = FIs(X): thm
val FI_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_incond =
   !(xs : mem(Pow(X))).
     IN(xs#, FIs1) <=>
     xs# = Empty(X) |
     ?(xs0 : mem(Pow(X)))  (x : mem(X)). IN(xs0#, FIs0) & xs# = Ins(x#, xs0#):
   form
val FI_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> SS(FIs(X), ss#):
   thm
val FI_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        (!(a : mem(Pow(X))).
            a# = Empty(X) |
            (?(xs0 : mem(Pow(X)))  (x : mem(X)).
                IN(xs0#, ss#) & a# = Ins(x#, xs0#)) ==> IN(a#, ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_rules0 = {(X : set)},  |- SS(App(FIf(X), FIs(X)), FIs(X)): thm
val FI_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        a# = Empty(X) |
        (?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#)) ==> IN(a#, FIs(X)): thm
val FI_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (a# = Empty(X) ==> IN(a#, FIs(X))) &
        !(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#) ==> IN(a#, FIs(X)): thm
val FI_rules3 =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val FIf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
        IN(xs#, App(FIf(X), a#)) <=>
        xs# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X)), Pow(Pow(X)))).
        !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
          IN(xs#, App(f#, a#)) <=>
          xs# = Empty(X) |
          ?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X))))  (s2 : mem(Pow(Pow(X)))).
        SS(s1#, s2#) ==> SS(App(FIf(X), s1#), App(FIf(X), s2#)): thm
val FIs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). SS(App(FIf(X), a#), a#) ==> SS(FIs(X), a#):
   thm
val FIs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (!(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, FIs(X)): thm
val FIs_def = {(X : set)},  |- FIs(X) = BIGINTER(FI's(X)): thm
val x1 = "FIs0": string
val FI_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_rules =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val Fin_def =
   {},  |- !(X : set)  (A : mem(Pow(X#))). Fin(A#) <=> IN(A#, FIs(X#)): thm
val Cd's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))).
        IN(a#, Cd's(X)) <=> SS(App(Cdf(X), a#), a#): thm
val Cd_cases0 = {(X : set)},  |- App(Cdf(X), Cds(X)) = Cds(X): thm
val Cd_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_incond =
   !(xsn : mem(Pow(X) * N)).
     IN(xsn#, Cds1) <=>
     xsn# = Pair(Empty(X), O) |
     ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
       IN(xsn0#, Cds0) &
       ~IN(x#, Fst(xsn0#)) &
       xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): form
val Cd_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        SS(App(Cdf(X), ss#), ss#) ==> SS(Cds(X), ss#): thm
val Cd_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        (!(a : mem(Pow(X) * N)).
            a# = Pair(Empty(X), O) |
            (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
                IN(xsn0#, ss#) &
                ~IN(x#, Fst(xsn0#)) &
                a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_rules0 = {(X : set)},  |- SS(App(Cdf(X), Cds(X)), Cds(X)): thm
val Cd_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        a# = Pair(Empty(X), O) |
        (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, Cds(X)) &
            ~IN(x#, Fst(xsn0#)) &
            a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
        IN(a#, Cds(X)): thm
val Cd_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (a# = Pair(Empty(X), O) ==> IN(a#, Cds(X))) &
        !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))) ==> IN(a#, Cds(X)):
   thm
val Cd_rules3 =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cdf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
        IN(xsn#, App(Cdf(X), a#)) <=>
        xsn# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, a#) &
          ~IN(x#, Fst(xsn0#)) &
          xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X) * N), Pow(Pow(X) * N))).
        !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
          IN(xsn#, App(f#, a#)) <=>
          xsn# = Pair(Empty(X), O) |
          ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, a#) &
            ~IN(x#, Fst(xsn0#)) &
            xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X) * N)))  (s2 : mem(Pow(Pow(X) * N))).
        SS(s1#, s2#) ==> SS(App(Cdf(X), s1#), App(Cdf(X), s2#)): thm
val Cds_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))). SS(App(Cdf(X), a#), a#) ==> SS(Cds(X), a#):
   thm
val Cds_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (!(ss : mem(Pow(Pow(X) * N))).
            SS(App(Cdf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, Cds(X)):
   thm
val Cds_def = {(X : set)},  |- Cds(X) = BIGINTER(Cd's(X)): thm
val x1 = "Cds0": string
val Cd_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_rules =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cds_ind =
   {}, 
   |- !(X : set)  (ss : mem(Pow(Pow(X#) * N))).
        IN(Pair(Empty(X#), O), ss#) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            IN(Pair(xs0#, n0#), ss#) & ~IN(x#, xs0#) ==>
            IN(Pair(Ins(x#, xs0#), Suc(n0#)), ss#)) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> IN(Pair(xs#, n#), ss#): thm
val Cd_induct0 =
   {}, 
   |- !(X : set).
        P(Pair(Empty(X#), O)) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(Pair(xs0#, n0#)) & ~IN(x#, xs0#) ==>
            P(Pair(Ins(x#, xs0#), Suc(n0#)))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(Pair(xs#, n#)): thm
val Cd_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(xs#, n#): thm
val Fin_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#)) &
        (!(xs0 : mem(Pow(X#)))  (x : mem(X#)). P(xs0#) ==> P(Ins(x#, xs0#))) ==>
        !(xs : mem(Pow(X#))). Fin(xs#) ==> P(xs#): thm
val Cdr_def =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) <=> IN(Pair(xs#, n#), Cds(X#)): thm
val Cdr_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)). Cdr(xs#, n#) ==> P(xs#, n#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs0#, n#) ==>
        !(x : mem(X#)). ~IN(x#, xs0#) ==> Cdr(Ins(x#, xs0#), Suc(n#)): thm
val Ins_NONEMPTY =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs : mem(Pow(X#))).
        ~Ins(x0#, xs#) = Empty(X#): thm
val IN_Ins_SND =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (x : mem(X#)).
        IN(x#, Ins(x0#, xs0#)) & ~x# = x0# ==> IN(x#, xs0#): thm
val Cdr_Empty_unique =
   {},  |- !(X : set)  (n : mem(N)). Cdr(Empty(X#), n#) ==> n# = O: thm
val Del_Ins_SWAP =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        ~x0# = x# ==>
        !(xs : mem(Pow(X#))). Del(Ins(x0#, xs#), x#) = Ins(x0#, Del(xs#, x#)):
   thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(Ins(x0#, xs0#), n#) <=>
        ?(a : mem(Pow(X#)))  (b : mem(N))  (x : mem(X#)).
          Cdr(a#, b#) &
          ~IN(x#, a#) & Ins(x0#, xs0#) = Ins(x#, a#) & n# = Suc(b#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) ==>
        Cdr(xs#, n#) &
        !(x : mem(X#)). IN(x#, xs#) ==> Cdr(Del(xs#, x#), Pre(n#)): thm
val Fin_Card =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> ?!(n : mem(N)). Cdr(xs#, n#): thm
val CARD_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        Holds(CARD(X#), a#, b#) <=> Fin(a#) & Cdr(a#, b#) | ~Fin(a#) & b# = O:
   thm
val CARD_unique =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        ?!(n : mem(N)). Holds(CARD(X#), xs#, n#): thm
val Cd0_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        App(Cd0(X#), a#) = b# <=> Holds(CARD(X#), a#, b#): thm
val Card_def =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Card(xs#) = App(Cd0(X#), xs#):
   thm
val Del_Empty =
   {},  |- !(X : set)  (x : mem(X#)). Del(Empty(X#), x#) = Empty(X#): thm
val Ins_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (s1 : mem(Pow(A#)))  (a2 : mem(A#))
      (s2 : mem(Pow(A#))).
        ~IN(a1#, s1#) &
        ~IN(a2#, s2#) &
        ~IN(a1#, s2#) & ~IN(a2#, s1#) & Ins(a1#, s1#) = Ins(a2#, s2#) ==>
        a1# = a2# & s1# = s2#: thm
val Fin_Empty = {},  |- !(X : set). Fin(Empty(X#)): thm
val Fin_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#))).
        Fin(xs0#) ==> !(x : mem(X#)). Fin(Ins(x#, xs0#)): thm
val Fin_Ins_Ins =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Fin(Ins(a1#, Ins(a2#, Empty(A#)))): thm
val Fin_Del0 =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> Fin(xs#) & !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Fin_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Card_Fin =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(n : mem(N)). Card(xs#) = n# <=> Cdr(xs#, n#): thm
val Card_Empty = {},  |- !(X : set). Card(Empty(X#)) = O: thm
val Cdr_Card =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Fin(xs#) ==> Cdr(xs#, Card(xs#)):
   thm
val Card_Ins =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). ~IN(x#, xs#) ==> Card(Ins(x#, xs#)) = Suc(Card(xs#)):
   thm
val Card_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). IN(x#, xs#) ==> Card(Del(xs#, x#)) = Pre(Card(xs#)):
   thm
val IN_App_IMAGE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        IN(a#, s#) ==>
        !(B : set)  (f : fun(A#, B#)). IN(App(f#, a#), IMAGE(f#, s#)): thm
val Fin_SS =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Fin(s#) ==> !(t : mem(Pow(A#))). SS(t#, s#) ==> Fin(t#): thm
val Fin_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(Union(s1#, s2#)) <=> Fin(s1#) & Fin(s2#): thm
val Ins_Ins_Fin =
   {(A : set), (s1 : mem(A)), (s2 : mem(A))}, 
   |- Fin(Ins(s1, Ins(s2, Empty(A)))): thm
val Fin_Sing = {},  |- !(A : set)  (a : mem(A#)). Fin(Sing(a#)): thm
val it = (): unit
******

Loading SEAR file SEARList.sml

******
val isL's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        IN(a#, isL's(X)) <=> SS(App(isLf(X), a#), a#): thm
val isL_cases0 = {(X : set)},  |- App(isLf(X), isLs(X)) = isLs(X): thm
val isL_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_incond =
   !(ls : mem(Pow(N * X))).
     IN(ls#, isLs1) <=>
     ls# = Empty(N * X) |
     ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
       IN(ls0#, isLs0) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): form
val isL_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), ss#), ss#) ==> SS(isLs(X), ss#): thm
val isL_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        (!(a : mem(Pow(N * X))).
            a# = Empty(N * X) |
            (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
                IN(ls0#, ss#) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_rules0 = {(X : set)},  |- SS(App(isLf(X), isLs(X)), isLs(X)): thm
val isL_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        a# = Empty(N * X) |
        (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
        IN(a#, isLs(X)): thm
val isL_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (a# = Empty(N * X) ==> IN(a#, isLs(X))) &
        !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#) ==>
          IN(a#, isLs(X)): thm
val isL_rules3 =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val isLf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
        IN(ls#, App(isLf(X), a#)) <=>
        ls# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(N * X)), Pow(Pow(N * X)))).
        !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
          IN(ls#, App(f#, a#)) <=>
          ls# = Empty(N * X) |
          ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(N * X))))  (s2 : mem(Pow(Pow(N * X)))).
        SS(s1#, s2#) ==> SS(App(isLf(X), s1#), App(isLf(X), s2#)): thm
val isLs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), a#), a#) ==> SS(isLs(X), a#): thm
val isLs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (!(ss : mem(Pow(Pow(N * X)))).
            SS(App(isLf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isLs(X)):
   thm
val isLs_def = {(X : set)},  |- isLs(X) = BIGINTER(isL's(X)): thm
val x1 = "isLs0": string
val isL_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_rules =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val List_def =
   {}, 
   |- !(X : set).
        Inj(iL(X#)) &
        !(a : mem(Pow(N * X#))).
          IN(a#, isLs(X#)) <=> ?(b : mem(List(X#))). a# = App(iL(X#), b#):
   thm
val iL_Inj = {},  |- !(X : set). Inj(iL(X#)): thm
val isL_def =
   {},  |- !(X : set)  (l : mem(Pow(N * X#))). isL(l#) <=> IN(l#, isLs(X#)):
   thm
val isL_induct =
   {}, 
   |- !(X : set).
        P(Empty(N * X#)) &
        (!(ls0 : mem(Pow(N * X#)))  (x : mem(X#)).
            P(ls0#) ==> P(Ins(Pair(Card(ls0#), x#), ls0#))) ==>
        !(l : mem(Pow(N * X#))). isL(l#) ==> P(l#): thm
val isL_Empty = {},  |- !(X : set). isL(Empty(N * X#)): thm
val isL_Ins =
   {}, 
   |- !(X : set)  (ls0 : mem(Pow(N * X#))).
        isL(ls0#) ==> !(x : mem(X#)). isL(Ins(Pair(Card(ls0#), x#), ls0#)):
   thm
val Repl_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Repl(l#) = App(iL(X#), l#): thm
val Nil_def = {},  |- !(X : set). Repl(Nil(X#)) = Empty(N * X#): thm
val cons0_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- cons0(x, l) = Ins(Pair(Card(l), x), l): thm
val cons1_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- App(cons1(X), Pair(x, l)) = Ins(Pair(Card(l), x), l): thm
val iL_isL = {},  |- !(X : set)  (l : mem(List(X#))). isL(App(iL(X#), l#)):
   thm
val isL_Repl =
   {}, 
   |- !(X : set)  (a : mem(Pow(N * X#))).
        isL(a#) <=> ?(b : mem(List(X#))). a# = Repl(b#): thm
val CONS_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Ins(Pair(Card(Repl(l#)), x#), Repl(l#)) =
          Repl(App(CONS(X#), Pair(x#, l#))): thm
val lift_cond2 =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val lift_cond2' =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?!(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val Cons_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Cons(x#, l#) = App(CONS(X#), Pair(x#, l#)): thm
val Repl_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Repl(Cons(x#, l#)) = Ins(Pair(Card(Repl(l#)), x#), Repl(l#)): thm
val Repl_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(List(X#)))  (l2 : mem(List(X#))).
        Repl(l1#) = Repl(l2#) <=> l1# = l2#: thm
val Cons_NONNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(List(X#))). ~Cons(x#, l#) = Nil(X#):
   thm
val Repl_Empty_uex =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        Repl(l#) = Empty(N * X#) <=> l# = Nil(X#): thm
val List_induct =
   {}, 
   |- !(X : set).
        P(Nil(X#)) &
        (!(l : mem(List(X#))). P(l#) ==> !(x : mem(X#)). P(Cons(x#, l#))) ==>
        !(l : mem(List(X#))). P(l#): thm
val Fin_Repl = {},  |- !(X : set)  (l : mem(List(X#))). Fin(Repl(l#)): thm
val isL_Card_NOTIN0 =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (n : mem(N))  (x : mem(X#)).
        IN(Pair(n#, x#), Repl(l#)) ==> Lt(n#, Card(Repl(l#))): thm
val CONS_Inj = {},  |- !(X : set). Inj(CONS(X#)): thm
val Cons_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (l1 : mem(List(X#)))  (x2 : mem(X#))
      (l2 : mem(List(X#))).
        Cons(x1#, l1#) = Cons(x2#, l2#) <=> x1# = x2# & l1# = l2#: thm
val Cons_or_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        l# = Nil(X#) |
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Cons_xor_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        ~l# = Nil(X#) <=>
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Lind's_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        IN(a#, Lind's(a0, f0)) <=> SS(App(Lindf(a0, f0), a#), a#): thm
val Lind_cases0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- App(Lindf(a0, f0), Linds(a0, f0)) = Linds(a0, f0): thm
val Lind_cases1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_incond =
   !(p : mem(List(X) * A)).
     IN(p#, Lind1) <=>
     p# = Pair(Nil(X), a0) |
     ?(p0 : mem(List(X) * A))  (x : mem(X)).
       IN(p0#, Lind0) &
       p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): form
val Lind_ind =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), ss#), ss#) ==> SS(Linds(a0, f0), ss#): thm
val Lind_ind1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        (!(a : mem(List(X) * A)).
            a# = Pair(Nil(X), a0) |
            (?(p0 : mem(List(X) * A))  (x : mem(X)).
                IN(p0#, ss#) &
                a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_rules0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- SS(App(Lindf(a0, f0), Linds(a0, f0)), Linds(a0, f0)): thm
val Lind_rules1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        a# = Pair(Nil(X), a0) |
        (?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, Linds(a0, f0)) &
            a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
        IN(a#, Linds(a0, f0)): thm
val Lind_rules2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (a# = Pair(Nil(X), a0) ==> IN(a#, Linds(a0, f0))) &
        !(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))) ==>
          IN(a#, Linds(a0, f0)): thm
val Lind_rules3 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lindf_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
        IN(p#, App(Lindf(a0, f0), a#)) <=>
        p# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, a#) &
          p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_ex =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- ?!(f : fun(Pow(List(X) * A), Pow(List(X) * A))).
        !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Nil(X), a0) |
          ?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, a#) &
            p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_monotone =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(s1 : mem(Pow(List(X) * A)))  (s2 : mem(Pow(List(X) * A))).
        SS(s1#, s2#) ==> SS(App(Lindf(a0, f0), s1#), App(Lindf(a0, f0), s2#)):
   thm
val Linds_SS =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), a#), a#) ==> SS(Linds(a0, f0), a#): thm
val Linds_cond =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (!(ss : mem(Pow(List(X) * A))).
            SS(App(Lindf(a0, f0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Linds(a0, f0)): thm
val Linds_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- Linds(a0, f0) = BIGINTER(Lind's(a0, f0)): thm
val x1 = "Lind0": string
val Lind_cases =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_rules =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lind_uex =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#))). ?!(a : mem(A#)). IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_def =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (a : mem(List(X#))).
        IN(Pair(a#, App(Lrec(a0#, f0#), a#)), Linds(a0#, f0#)): thm
val Lrec_Nil =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        App(Lrec(a0#, f0#), Nil(X#)) = a0#: thm
val App_Lrec_Linds =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (a : mem(A#)).
        App(Lrec(a0#, f0#), l#) = a# <=> IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_Cons =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (x : mem(X#)).
        App(Lrec(a0#, f0#), Cons(x#, l#)) =
          App(f0#, Pair(x#, App(Lrec(a0#, f0#), l#))): thm
val Lrec_unique =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f : fun(X# * A#, A#))
      (r : fun(List(X#), A#)).
        App(r#, Nil(X#)) = a0# & r# o CONS(X#) = f# o Prla(Id(X#), r#) ==>
        r# = Lrec(a0#, f#): thm
val Lrec_Cons_eqn =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        Lrec(a0#, f0#) o CONS(X#) = f0# o Prla(Id(X#), Lrec(a0#, f0#)): thm
val LENGTH_def = {},  |- !(X : set). LENGTH(X#) = Lrec(O, SUC o p2(X#, N)):
   thm
val Length_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Length(l#) = App(LENGTH(X#), l#):
   thm
val Length_Nil = {},  |- !(X : set). Length(Nil(X#)) = O: thm
val Length_Cons =
   {}, 
   |- !(A : set)  (a : mem(A#))  (l : mem(List(A#))).
        Length(Cons(a#, l#)) = Suc(Length(l#)): thm
val HD_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        App(HD(X#), Cons(x#, l#)) = SOME(x#): thm
val HD_Nil = {(X : set)},  |- App(HD(X), Nil(X)) = NONE(X): thm
val HD_def =
   {},  |- !(X : set). HD(X#) = Lrec(NONE(X#), i1(X#, 1) o p1(X#, X# + 1)):
   thm
val Hd_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Hd(Cons(x#, l#)) = SOME(x#): thm
val Hd_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Hd(l#) = App(HD(X#), l#): thm
val TL_Nil = {(X : set)},  |- App(TL(X), Nil(X)) = Nil(X): thm
val TL_def =
   {}, 
   |- !(X : set)  (a : mem(List(X#))).
        a# = Nil(X#) & App(TL(X#), a#) = Nil(X#) |
        ~a# = Nil(X#) & ?(x : mem(X#)). a# = Cons(x#, App(TL(X#), a#)): thm
val TL_ex =
   {(X : set)}, 
   |- !(l : mem(List(X))).
        ?!(tl : mem(List(X))).
          l# = Nil(X) & tl# = Nil(X) |
          ~l# = Nil(X) & ?(x : mem(X)). l# = Cons(x#, tl#): thm
val TL_Cons =
   {(X : set)}, 
   |- !(x : mem(X))  (tl : mem(List(X))). App(TL(X), Cons(x#, tl#)) = tl#:
   thm
val ELn_Nil = {(X : set)},  |- App(ELn(X), O) = Tpm(HD(X)): thm
val ELn_def =
   {(X : set)}, 
   |- ELn(X) = Nrec(Tpm(HD(X)), Ap1(MO(List(X), List(X), X + 1), Tpm(TL(X)))):
   thm
val Eln_Map =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(n : mem(N))  (l : mem(List(X))).
        Lt(n#, Length(l#)) ==> Eln(n#, Map(f, l#)) = App(OM(f), Eln(n#, l#)):
   thm
val Eln_O = {(X : set)},  |- !(a : mem(List(X))). Eln(O, a#) = Hd(a#): thm
val Eln_Suc =
   {(X : set)}, 
   |- !(n : mem(N))  (a : mem(List(X))). Eln(Suc(n#), a#) = Eln(n#, Tl(a#)):
   thm
val Eln_def =
   {(X : set), (l : mem(List(X))), (n : mem(N))}, 
   |- Eln(n, l) = App(tof(App(ELn(X), n)), l): thm
val MAP_Cons =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(l : mem(List(X)))  (x : mem(X)).
        App(MAP(f), Cons(x#, l#)) = Cons(App(f, x#), App(MAP(f), l#)): thm
val MAP_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        App(MAP(f#), Nil(X#)) = Nil(Y#): thm
val MAP_def =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        MAP(f#) = Lrec(Nil(Y#), CONS(Y#) o Prla(f#, Id(List(Y#)))): thm
val MO_def =
   {(A : set), (B : set), (C : set), (fm : mem(Exp(A, B))),
    (gm : mem(Exp(B, C)))},  |- App(MO(A, B, C), Pair(gm, fm)) = mo(gm, fm):
   thm
val Map_Cons =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#))  (l : mem(List(X#)))
      (x : mem(X#)). Map(f#, Cons(x#, l#)) = Cons(App(f#, x#), Map(f#, l#)):
   thm
val Map_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)). Map(f#, Nil(X#)) = Nil(Y#):
   thm
val Map_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (Y : set)  (f : fun(X#, Y#)).
        Map(f#, l#) = App(MAP(f#), l#): thm
val Tl_Cons =
   {}, 
   |- !(X : set)  (x : mem(X#))  (tl : mem(List(X#))).
        Tl(Cons(x#, tl#)) = tl#: thm
val Tl_Nil = {},  |- !(X : set). Tl(Nil(X#)) = Nil(X#): thm
val Tl_def = {(X : set), (l : mem(List(X)))},  |- Tl(l) = App(TL(X), l): thm
val mo_def =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (C : set)
      (g : mem(Exp(B#, C#))). mo(g#, f#) = Tpm(tof(g#) o tof(f#)): thm
val it = (): unit
******

Loading SEAR file SEARfm.sml

******
val InjA_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjA(A#), a#)) <=> a# = SOME(a#): thm
val InjN_def =
   {}, 
   |- !(A : set)  (a : mem(N))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjN(A#), a#)) <=> n# = a#: thm
val InjUU0_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * A)))  (b : mem(Pow(N * A)))  (n : mem(N))
      (a : mem(A)).
        IN(Pair(n#, a#), App(InjUU0(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val injUU0_char =
   {}, 
   |- (!(n : mem(N)).
          Even(n#) ==>
          !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
          (a : mem(A#)).
            IN(Pair(n#, a#), injUU0(u1#, u2#)) <=>
            IN(Pair(Div2(n#), a#), u1#)) &
      !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val injUU0_def =
   {(A : set), (u1 : mem(Pow(N * A))), (u2 : mem(Pow(N * A)))}, 
   |- injUU0(u1, u2) = App(InjUU0(A), Pair(u1, u2)): thm
val InjUU0_Inj = {},  |- !(A : set). Inj(InjUU0(A#)): thm
val injUU0_Even =
   {}, 
   |- !(n : mem(N)).
        Even(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u1#):
   thm
val injUU0_Odd =
   {}, 
   |- !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val F0_def = {(A : set)},  |- F0(A) = injN(A, O): thm
val InjA_Inj = {},  |- !(A : set). Inj(InjA(A#)): thm
val InjUU_Inj = {},  |- !(A : set). Inj(InjUU(A#)): thm
val InjUU_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * (A + 1))))  (b : mem(Pow(N * (A + 1))))
      (n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), App(InjUU(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val InjUU_def0 = {},  |- !(A : set). InjUU(A#) = InjUU0(A# + 1): thm
val injA_def = {(A : set), (a : mem(A))},  |- injA(a) = App(InjA(A), a): thm
val injN_def = {(A : set), (n : mem(N))},  |- injN(A, n) = App(InjN(A), n):
   thm
val VAR0_Inj = {},  |- !(A : set). Inj(VAR0(A#)): thm
val VAR0_def =
   {(A : set)}, 
   |- VAR0(A) = InjUU(A) o Pa(El(injN(A, num1)) o To1(A), InjA(A)): thm
val NEG0_Inj = {},  |- !(A : set). Inj(NEG0(A#)): thm
val NEG0_def =
   {(A : set)}, 
   |- NEG0(A) = InjUU(A) o
        Pa(El(injN(A, num2)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Var0_def = {(A : set), (a : mem(A))},  |- Var0(a) = App(VAR0(A), a): thm
val DISJ0_Inj = {},  |- !(A : set). Inj(DISJ0(A#)): thm
val DISJ0_def =
   {(A : set)}, 
   |- DISJ0(A) = InjUU(A) o
        Pa(El(injN(A, num3)) o To1(Pow((N * (A + 1))) * Pow(N * (A + 1))),
         InjUU(A)): thm
val Neg0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- Neg0(f0) = App(NEG0(A), f0):
   thm
val DIAM0_Inj = {},  |- !(A : set). Inj(DIAM0(A#)): thm
val DIAM0_def =
   {(A : set)}, 
   |- DIAM0(A) = InjUU(A) o
        Pa(El(injN(A, num4)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Disj0_def =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- Disj0(f1, f2) = App(DISJ0(A), Pair(f1, f2)): thm
val Diam0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- Diam0(f0) = App(DIAM0(A), f0): thm
val f =
   (nas = F0 ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_cl =
   (nas = F0(A) ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_incond =
   !(nas : mem(Pow(N * (A + 1)))).
     IN(nas#, isfms1) <=>
     nas# = F0(A) |
     (?(p : mem(A)). nas# = Var0(p#)) |
     (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Neg0(f0#)) |
     (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
         IN(f1#, isfms0) & IN(f2#, isfms0) & nas# = Disj0(f1#, f2#)) |
     ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Diam0(f0#): form
val x1 = "isfms0": string
val isfmf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(Pow(N * (A + 1))), Pow(Pow(N * (A + 1))))).
        !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
          IN(nas#, App(f#, a#)) <=>
          nas# = F0(A) |
          (?(p : mem(A)). nas# = Var0(p#)) |
          (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
          (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
              IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
          ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
        IN(nas#, App(isfmf(A), a#)) <=>
        nas# = F0(A) |
        (?(p : mem(A)). nas# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(Pow(N * (A + 1)))))  (s2 : mem(Pow(Pow(N * (A + 1))))).
        SS(s1#, s2#) ==> SS(App(isfmf(A), s1#), App(isfmf(A), s2#)): thm
val isfm's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        IN(a#, isfm's(A)) <=> SS(App(isfmf(A), a#), a#): thm
val isfms_def = {(A : set)},  |- isfms(A) = BIGINTER(isfm's(A)): thm
val isfms_cond =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (!(ss : mem(Pow(Pow(N * (A + 1))))).
            SS(App(isfmf(A), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isfms(A)):
   thm
val isfms_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), a#), a#) ==> SS(isfms(A), a#): thm
val isfm_rules0 = {(A : set)},  |- SS(App(isfmf(A), isfms(A)), isfms(A)): thm
val isfm_cases0 = {(A : set)},  |- App(isfmf(A), isfms(A)) = isfms(A): thm
val isfm_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), ss#), ss#) ==> SS(isfms(A), ss#): thm
val isfm_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (!(a : mem(Pow(N * (A + 1)))).
            a# = F0(A) |
            (?(p : mem(A)). a# = Var0(p#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Neg0(f0#)) |
            (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj0(f1#, f2#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Diam0(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases1 =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules1 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        a# = F0(A) |
        (?(p : mem(A)). a# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Diam0(f0#)) ==>
        IN(a#, isfms(A)): thm
val isfm_rules2 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (a# = F0(A) ==> IN(a#, isfms(A))) &
        (!(p : mem(A)). a# = Var0(p#) ==> IN(a#, isfms(A))) &
        (!(f0 : mem(Pow(N * (A + 1)))).
            IN(f0#, isfms(A)) & a# = Neg0(f0#) ==> IN(a#, isfms(A))) &
        (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#) ==>
            IN(a#, isfms(A))) &
        !(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) & a# = Diam0(f0#) ==> IN(a#, isfms(A)): thm
val isfm_rules3 =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_def =
   {}, 
   |- !(A : set)  (f : mem(Pow(N * (A# + 1)))).
        isfm(f#) <=> IN(f#, isfms(A#)): thm
val isfm_induct =
   {}, 
   |- !(A : set).
        P(F0(A#)) &
        (!(p : mem(A#)). P(Var0(p#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Neg0(f0#))) &
        (!(f1 : mem(Pow(N * (A# + 1))))  (f2 : mem(Pow(N * (A# + 1)))).
            P(f1#) & P(f2#) ==> P(Disj0(f1#, f2#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Diam0(f0#))) ==>
        !(f0 : mem(Pow(N * (A# + 1)))). isfm(f0#) ==> P(f0#): thm
val isfm_F0 = {},  |- !(A : set). isfm(F0(A#)): thm
val isfm_Diam0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val isfm_Neg0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#)): thm
val isfm_Var0 = {},  |- !(A : set)  (p : mem(A#)). isfm(Var0(p#)): thm
val isfm_clauses =
   {(A : set)}, 
   |- isfm(F0(A)) &
      (!(p : mem(A)). isfm(Var0(p#))) &
      (!(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#))) &
      !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val form_def =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). a# = App(repf(A), b#): thm
val isfm_Disj0 =
   {(A : set)}, 
   |- !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
        isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#)): thm
val repf_Inj = {(A : set)},  |- Inj(repf(A)): thm
val Bot_def = {(A : set)},  |- Repf(Bot(A)) = F0(A): thm
val Repf_def =
   {},  |- !(A : set)  (f : mem(form(A#))). Repf(f#) = App(repf(A#), f#): thm
val VAR_def =
   {(A : set)},  |- !(a : mem(A)). App(repf(A) o VAR(A), a#) = Var0(a#): thm
val flip_fconv = fn: form -> thm
val form_def' =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). App(repf(A), b#) = a#: thm
val repf_isfm = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Repf(f0#)): thm
val VAR_VAR0 = {},  |- !(A : set). repf(A#) o VAR(A#) = VAR0(A#): thm
val VAR_Inj = {},  |- !(A : set). Inj(VAR(A#)): thm
val NEG_NEG0 = {},  |- !(A : set). repf(A#) o NEG(A#) = NEG0(A#) o repf(A#):
   thm
val NEG_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(NEG(A), a#)) = Neg0(Repf(a#)): thm
val Neg0_Repf = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Neg0(Repf(f0#))):
   thm
val NEG_Inj = {},  |- !(A : set). Inj(NEG(A#)): thm
val DIAM_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(DIAM(A), a#)) = Diam0(Repf(a#)): thm
val Diam0_Repf =
   {(A : set)},  |- !(f0 : mem(form(A))). isfm(Diam0(Repf(f0#))): thm
val form_def_uex =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (?!(b : mem(form(A))). a# = Repf(b#)) <=> isfm(a#): thm
val DISJ_DISJ0 =
   {}, 
   |- !(A : set). repf(A#) o DISJ(A#) = DISJ0(A#) o Prla(repf(A#), repf(A#)):
   thm
val DISJ_def =
   {(A : set)}, 
   |- !(a' : mem(form(A)))  (b : mem(form(A))).
        Repf(App(DISJ(A), Pair(a'#, b#))) = Disj0(Repf(a'#), Repf(b#)): thm
val DISJ_Inj = {},  |- !(A : set). Inj(DISJ(A#)): thm
val DIAM_DIAM0 =
   {},  |- !(A : set). repf(A#) o DIAM(A#) = DIAM0(A#) o repf(A#): thm
val DIAM_Inj = {},  |- !(A : set). Inj(DIAM(A#)): thm
val Diam_def =
   {(A : set), (f : mem(form(A)))},  |- Diam(f) = App(DIAM(A), f): thm
val Disj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Disj(f1, f2) = App(DISJ(A), Pair(f1, f2)): thm
val Neg_def = {(A : set), (f : mem(form(A)))},  |- Neg(f) = App(NEG(A), f):
   thm
val Var_def = {(A : set), (a : mem(A))},  |- Var(a) = App(VAR(A), a): thm
val Var_eq_eq =
   {(A : set)}, 
   |- !(p1 : mem(A))  (p2 : mem(A)). Var(p1#) = Var(p2#) <=> p1# = p2#: thm
val Neg_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Neg(f1#) = Neg(f2#) <=> f1# = f2#: thm
val Diam_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Diam(f1#) = Diam(f2#) <=> f1# = f2#: thm
val Disj_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A)))  (g1 : mem(form(A)))
      (g2 : mem(form(A))).
        Disj(f1#, f2#) = Disj(g1#, g2#) <=> f1# = g1# & f2# = g2#: thm
val Repf_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Repf(f1#) = Repf(f2#) <=> f1# = f2#: thm
val form_induct =
   {}, 
   |- !(A : set).
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Neg(f0#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Diam(f0#))) ==>
        !(f0 : mem(form(A#))). P(f0#): thm
val fmind's_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        IN(a#, fmind's(djf, dmf, nf, vf, x0)) <=>
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#): thm
val fmind_cases0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)) =
        fminds(djf, dmf, nf, vf, x0): thm
val fmind_cases1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_incond =
   !(p : mem(form(A) * X)).
     IN(p#, fmind1) <=>
     p# = Pair(Bot(A), x0) |
     (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
     ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
       IN(p1#, fmind0) &
       IN(p2#, fmind0) &
       p# =
         Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))):
   form
val fmind_ind =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), ss#): thm
val fmind_ind1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (!(a : mem(form(A) * X)).
            a# = Pair(Bot(A), x0) |
            (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
            (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
                IN(p1#, ss#) &
                IN(p2#, ss#) &
                a# =
                  Pair(Disj(Fst(p1#), Fst(p2#)),
                   App(djf, Pair(Snd(p1#), Snd(p2#))))) ==> IN(a#, ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_rules0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- SS(App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)),
       fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        a# = Pair(Bot(A), x0) |
        (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
            IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
            a# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#))))) ==>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (a# = Pair(Bot(A), x0) ==> IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(a' : mem(A)).
            a# = Pair(Var(a'#), App(vf, a'#)) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          a# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))) ==>
          IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules3 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val fmindf_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
        IN(p#, App(fmindf(djf, dmf, nf, vf, x0), a#)) <=>
        p# = Pair(Bot(A), x0) |
        (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, a#) &
          IN(p2#, a#) &
          p# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_ex =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(form(A) * X), Pow(form(A) * X))).
        !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Bot(A), x0) |
          (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
          ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, a#) &
            IN(p2#, a#) &
            p# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_monotone =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(form(A) * X)))  (s2 : mem(Pow(form(A) * X))).
        SS(s1#, s2#) ==>
        SS(App(fmindf(djf, dmf, nf, vf, x0), s1#),
         App(fmindf(djf, dmf, nf, vf, x0), s2#)): thm
val fminds_SS =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), a#): thm
val fminds_cond =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (!(ss : mem(Pow(form(A) * X))).
            SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fminds_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- fminds(djf, dmf, nf, vf, x0) = BIGINTER(fmind's(djf, dmf, nf, vf, x0)):
   thm
val x1 = "fmind0": string
val fmind_cases =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_rules =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val IN_F0 =
   {(A : set)}, 
   |- !(n : mem(N))  (a : mem(A + 1)). IN(Pair(n#, a#), F0(A)) <=> n# = O:
   thm
val IN_Var0 =
   {(A : set), (a0 : mem(A))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Var0(a0)) <=>
        Even(n#) & Div2(n#) = num1 | Odd(n#) & a# = SOME(a0): thm
val IN_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Neg0(f0)) <=>
        Even(n#) & Div2(n#) = num2 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Diam0(f0)) <=>
        Even(n#) & Div2(n#) = num4 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Disj0(f1, f2)) <=>
        Even(n#) & Div2(n#) = num3 |
        Odd(n#) &
        (Even(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f1) |
          Odd(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f2)): thm
val F0_NOT_Var0 = {(A : set), (p : mem(A))},  |- ~F0(A) = Var0(p): thm
val Bot_NOT_Var = {(A : set), (p : mem(A))},  |- ~Bot(A) = Var(p): thm
val F0_NOT_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- ~F0(A) = Disj0(f1, f2): thm
val Bot_NOT_Disj =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Bot(A) = Disj(f1, f2): thm
val F0_NOT_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Neg0(f0): thm
val Bot_NOT_Neg = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Neg(f): thm
val F0_NOT_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Diam0(f0): thm
val Bot_NOT_Diam = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Diam(f):
   thm
val Bot_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Bot(A#) = Var(p#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Neg(f#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Diam(f#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Bot(A#) = Disj(f1#, f2#): thm
val InjN_Inj = {},  |- !(A : set). Inj(InjN(A#)): thm
val Var0_NOT_Diam0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Diam0(f0): thm
val VAR_def' =
   {(A : set)},  |- !(a : mem(A)). Repf(App(VAR(A), a#)) = Var0(a#): thm
val Var_NOT_Diam =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Diam(f): thm
val Var0_NOT_Disj0 =
   {(A : set), (a : mem(A)), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Var0(a) = Disj0(f1, f2): thm
val Var_NOT_Disj =
   {(A : set), (a : mem(A)), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Var(a) = Disj(f1, f2): thm
val Var0_NOT_Neg0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Neg0(f0): thm
val Var_NOT_Neg =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Neg(f): thm
val Var_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Var(p#) = Bot(A#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Neg(f#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Diam(f#)) &
        !(p : mem(A#))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Var(p#) = Disj(f1#, f2#): thm
val Neg0_NOT_Diam0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Neg0(f) = Diam0(f0): thm
val Neg_NOT_Diam =
   {(A : set), (f : mem(form(A))), (f0 : mem(form(A)))}, 
   |- ~Neg(f) = Diam(f0): thm
val Neg0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Neg0(f) = Disj0(f1, f2): thm
val Neg_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Neg(f) = Disj(f1, f2): thm
val Neg_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Neg(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Neg(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Neg(f#) = Diam(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Neg(f#) = Disj(f1#, f2#): thm
val Diam0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Diam0(f) = Disj0(f1, f2): thm
val Diam_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Diam(f) = Disj(f1, f2): thm
val Diam_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Diam(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Diam(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Diam(f#) = Neg(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Diam(f#) = Disj(f1#, f2#): thm
val Disj_NOT =
   {}, 
   |- !(A : set).
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            ~Disj(f1#, f2#) = Bot(A#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (p : mem(A#)).
            ~Disj(f1#, f2#) = Var(p#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f0 : mem(form(A#))).
            ~Disj(f1#, f2#) = Diam(f0#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f : mem(form(A#))).
          ~Disj(f1#, f2#) = Neg(f#): thm
val fmind_Neg =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Neg(f), App(nf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_Disj =
   {}, 
   |- !(A : set)  (f1 : mem(form(A#)))  (X : set)  (djf : fun(X# * X#, X#))
      (dmf : fun(X#, X#))  (nf : fun(X#, X#))  (vf : fun(A#, X#))
      (x0 : mem(X#))  (x1 : mem(X#)).
        IN(Pair(f1#, x1#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
        !(f2 : mem(form(A#)))  (x2 : mem(X#)).
          IN(Pair(f2#, x2#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
          IN(Pair(Disj(f1#, f2#), App(djf#, Pair(x1#, x2#))),
           fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmind_Diam =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Diam(f), App(dmf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_uex =
   {(X : set)}, 
   |- !(A : set)  (x0 : mem(X))  (vf : fun(A#, X))  (nf : fun(X, X))
      (djf : fun(X * X, X))  (dmf : fun(X, X))  (f : mem(form(A#))).
        ?!(x : mem(X)). IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)):
   thm
val fmrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (a : mem(form(A#))).
        IN(Pair(a#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), a#)),
       fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val App_fmrec_fminds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (f : mem(form(A#)))  (x : mem(X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#) = x# <=>
        IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmrec_clauses =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), Bot(A#)) = x0# &
        (!(p : mem(A#)).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Var(p#)) = App(vf#, p#)) &
        (!(f : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Neg(f#)) =
              App(nf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Disj(f1#, f2#)) =
              App(djf#,
               Pair(App(fmrec(x0#, vf#, nf#, djf#, dmf#), f1#),
                App(fmrec(x0#, vf#, nf#, djf#, dmf#), f2#)))) &
        !(f : mem(form(A#))).
          App(fmrec(x0#, vf#, nf#, djf#, dmf#), Diam(f#)) =
            App(dmf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#)): thm
val it = (): unit
******

Loading SEAR file SEARUF.sml

******
val Inter_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val Inter_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val filter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- filter(L) <=>
      ~EMPTY(J) &
      IN(Whole(J), L) &
      (!(X : mem(Pow(J)))  (Y : mem(Pow(J))).
          IN(X#, L) & IN(Y#, L) ==> IN(Inter(X#, Y#), L)) &
      !(X : mem(Pow(J))).
        IN(X#, L) ==> !(Y : mem(Pow(J))). SS(X#, Y#) ==> IN(Y#, L): thm
val ufilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). ~IN(Compl(X#), L) <=> IN(X#, L): thm
val ufilter_filter =
   {},  |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> filter(L#):
   thm
val SS_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val SS_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val Whole_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). filter(L#) ==> IN(Whole(J#), L#):
   thm
val Whole_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> IN(Whole(J#), L#):
   thm
val Empty_NOTIN_UF =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> ~IN(Empty(J#), L#):
   thm
val IN_UF_NONEMPTY =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==> !(X : mem(Pow(J#))). IN(X#, L#) ==> ~X# = Empty(J#):
   thm
val Repu_def = {(J : set), (u : mem(UFs(J)))},  |- Repu(u) = App(iUF(J), u):
   thm
val Repu_ufilter = {},  |- !(A : set)  (u : mem(UFs(A#))). ufilter(Repu(u#)):
   thm
val UFs_def =
   {(J : set)}, 
   |- Inj(iUF(J)) &
      !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = App(iUF(J), b#): thm
val from_UFs =
   {(J : set)}, 
   |- !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = Repu(b#): thm
val Empty_NOTIN_UFs =
   {},  |- !(J : set)  (u : mem(UFs(J#))). ~IN(Empty(J#), Repu(u#)): thm
val ufilter_alt =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). IN(Compl(X#), L) <=> ~IN(X#, L): thm
val Compl_Repu =
   {(J : set), (X : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Compl(X), Repu(u)) <=> ~IN(X, Repu(u)): thm
val Union_Repu =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Union(s1, s2), Repu(u)) <=> IN(s1, Repu(u)) | IN(s2, Repu(u)): thm
val CUI_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- CUI(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        IN(BIGINTER(ss0#), ss): thm
val CUI_iff_binary =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#)))).
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) <=>
        !(s : mem(Pow(Pow(W#)))).
          SS(s#, A#) & Fin(s#) & ~s# = Empty(Pow(W#)) ==>
          IN(BIGINTER(s#), A#): thm
val FIP_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- FIP(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        ~BIGINTER(ss0#) = Empty(A): thm
val FIP_CUI_lemma =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        ~IN(Empty(W#), A#) & ~IN(Empty(W#), B#): thm
val FIP_closed_under_Inter =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) &
        (!(b1 : mem(Pow(W#))).
            IN(b1#, B#) ==>
            !(b2 : mem(Pow(W#))). IN(b2#, B#) ==> IN(Inter(b1#, b2#), B#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        FIP(Union(A#, B#)): thm
val IN_gfilter =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(x : mem(Pow(A))).
        IN(x#, gfilter(s)) <=>
        !(ss : mem(Pow(Pow(A)))). SS(s, ss#) & filter(ss#) ==> IN(x#, ss#):
   thm
val gfilter_def =
   {(A : set), (s : mem(Pow(Pow(A))))},  |- gfilter(s) = BIGINTER(gfss(s)):
   thm
val gfilter_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter(s#)): thm
val gfilter_ind =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(A#)))).
        SS(s#, ss#) & filter(ss#) ==>
        !(x : mem(Pow(A#))). IN(x#, gfilter(s#)) ==> IN(x#, ss#): thm
val gfss_def =
   {(A : set), (s0 : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(Pow(A)))). IN(a#, gfss(s0)) <=> SS(s0, a#) & filter(a#):
   thm
val SS_gfilter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter(s#)): thm
val pfilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- pfilter(L) <=> filter(L) & ~L = Whole(Pow(J)): thm
val gfilter1_def =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, gfilter1(s)) <=>
        a# = Whole(A) |
        ?(ss : mem(Pow(Pow(A)))).
          SS(ss#, s) &
          Fin(ss#) & ~ss# = Empty(Pow(A)) & SS(BIGINTER(ss#), a#): thm
val gfilter1_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter1(s#)): thm
val SS_gfilter1 =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter1(s#)): thm
val CUI_filter =
   {},  |- !(A : set)  (L : mem(Pow(Pow(A#)))). filter(L#) ==> CUI(L#): thm
val gfilter_gfilter1 =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) ==> gfilter(s#) = gfilter1(s#): thm
val Empty_NOTIN_pfilter =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) <=> filter(s#) & ~IN(Empty(A#), s#): thm
val FIP_Empty_NOTIN_gfilter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))). FIP(s#) ==> ~IN(Empty(A#), gfilter(s#)):
   thm
val FIP_PSUBSET_proper_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))).
          FIP(s#) ==> ?(v : mem(Pow(Pow(A#)))). pfilter(v#) & SS(s#, v#): thm
val filter_Whole = {},  |- !(J : set). ~EMPTY(J#) ==> filter(Whole(Pow(J#))):
   thm
val filter_Empty_Whole =
   {}, 
   |- !(J : set).
        ~EMPTY(J#) ==>
        !(L : mem(Pow(Pow(J#)))).
          filter(L#) & IN(Empty(J#), L#) <=> L# = Whole(Pow(J#)): thm
val ufilter_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        ufilter(u#) ==>
        !(s : mem(Pow(Pow(J#)))).
          filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#)): thm
val CUI_Empty_NOTIN_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        CUI(s#) & ~IN(Empty(W#), s#) ==> FIP(s#): thm
val pfilter_FIP =
   {},  |- !(W : set)  (s : mem(Pow(Pow(W#)))). pfilter(s#) ==> FIP(s#): thm
val pfilter_filter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). pfilter(s#) ==> filter(s#):
   thm
val pfilter_INSERT_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        pfilter(s#) ==>
        !(b : mem(Pow(W#))).
          ~IN(b#, s#) & ~IN(Compl(b#), s#) ==> FIP(Ins(b#, s#)): thm
val maximal_ufilter =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        (!(s : mem(Pow(Pow(J#)))).
            filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) ==> ufilter(u#):
   thm
val chain_def =
   {(A : set), (R : rel(A, A)), (t : mem(Pow(A)))}, 
   |- chain(t, R) <=>
      !(a1 : mem(A))  (a2 : mem(A)).
        IN(a1#, t) & IN(a2#, t) ==> Holds(R, a1#, a2#) | Holds(R, a2#, a1#):
   thm
val ismax_def =
   {(A : set), (R : rel(A, A)), (m : mem(A))}, 
   |- ismax(R, m) <=> !(x : mem(A)). Holds(R, m, x#) ==> x# = m: thm
val ptorder_def =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> Trans(R) & Refl(R) & Asym(R): thm
val ubound_def =
   {(A : set), (R : rel(A, A)), (s : mem(Pow(A))), (x : mem(A))}, 
   |- ubound(s, R, x) <=> !(y : mem(A)). IN(y#, s) ==> Holds(R, y#, x): thm
******

Loading SEAR file zorns.sml

******
val AC =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). Holds(R#, a#, App(f#, a#)): thm
val antisym_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        antisym(r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, x#), r#) ==> x# = y#: thm
val chain0_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        chain0(s#, r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==>
          IN(Pair(x#, y#), r#) | IN(Pair(y#, x#), r#): thm
val domain_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, domain(r#)) <=> ?(y : mem(A#)). IN(Pair(a#, y#), r#): thm
val ischoice_def =
   {(A : set), (f : fun(Pow(A), A)), (s : mem(Pow(Pow(A))))}, 
   |- ischoice(f, s) <=>
      ~IN(Empty(A), s) &
      !(s0 : mem(Pow(A))). IN(s0#, s) ==> IN(App(f, s0#), s0#): thm
val ischoice_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) & ~IN(Empty(A#), s#) ==>
        ?(f : fun(Pow(A#), A#)). ischoice(f#, s#): thm
val maximal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, maximal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(a#, x'#), r#) ==> a# = x'#:
   thm
val minimal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, minimal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(x'#, a#), r#) ==> a# = x'#:
   thm
val partial_order_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        partial_order(r#, s#) <=>
        SS(domain(r#), s#) &
        SS(range(r#), s#) & transitive(r#) & reflexive(r#, s#) & antisym(r#):
   thm
val range_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, range(r#)) <=> ?(x : mem(A#)). IN(Pair(x#, a#), r#): thm
val reflexive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        reflexive(r#, s#) <=>
        !(x : mem(A#)). IN(x#, s#) ==> IN(Pair(x#, x#), r#): thm
val transitive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        transitive(r#) <=>
        !(x : mem(A#))  (y : mem(A#))  (z : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, z#), r#) ==>
          IN(Pair(x#, z#), r#): thm
val upper_bounds_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, upper_bounds(s#, r#)) <=>
        IN(a#, range(r#)) &
        !(y : mem(A#)). IN(y#, s#) ==> IN(Pair(y#, a#), r#): thm
val fchains_def =
   {(A : set), (f : fun(Pow(A), A)), (r : mem(Pow(A * A)))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, fchains(r, f)) <=>
        chain0(a#, r) &
        ~a# = Empty(A) &
        !(C : mem(Pow(A))).
          chain0(C#, r) &
          SS(C#, a#) & ~Inter(Diff(upper_bounds(C#, r), C#), a#) = Empty(A) ==>
          IN(App(f, Diff(upper_bounds(C#, r), C#)),
           minimal_elements(Inter(Diff(upper_bounds(C#, r), C#), a#), r)):
   thm
val hatclass_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(Pow(A#))).
        IN(a#, hatclass(r#)) <=>
        ~a# = Empty(A#) &
        ?(C : mem(Pow(A#))). a# = Diff(upper_bounds(C#, r#), C#): thm
val lemma1 =
   {(A : set)}, 
   |- !(x : mem(A))  (s : mem(Pow(A)))  (r : mem(Pow(A * A))).
        chain0(s#, r#) & IN(x#, s#) ==>
        IN(x#, domain(r#)) & IN(x#, range(r#)): thm
val lemma2 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A)))  (x : mem(A))  (x' : mem(A)).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        IN(k1#, fchains(r#, f#)) &
        IN(k2#, fchains(r#, f#)) & IN(x#, k1#) & IN(x'#, k2#) & ~IN(x'#, k1#) ==>
        IN(Pair(x#, x'#), r#): thm
val lemma3 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) & IN(k1#, fchains(r#, f#)) & IN(k2#, fchains(r#, f#)) ==>
        SS(k1#, k2#) | SS(k2#, k1#): thm
val lemma4 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A)).
        ischoice(f#, hatclass(r#)) & antisym(r#) & transitive(r#) ==>
        chain0(BIGUNION(fchains(r#, f#)), r#) &
        !(x : mem(A))  (x' : mem(A))  (k : mem(Pow(A))).
          IN(Pair(x'#, x#), r#) &
          IN(x'#, BIGUNION(fchains(r#, f#))) &
          IN(x#, BIGUNION(fchains(r#, f#))) &
          IN(k#, fchains(r#, f#)) & IN(x#, k#) ==> IN(x'#, k#): thm
val lemma5 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) & ~range(r#) = Empty(A) & reflexive(r#, s#) ==>
        IN(Sing(App(f#, range(r#))), fchains(r#, f#)): thm
val lemma6 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (k : mem(Pow(A)))
      (x : mem(A))  (C : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) &
        IN(k#, fchains(r#, f#)) &
        IN(x#, k#) &
        chain0(C#, r#) &
        IN(x#, Diff(upper_bounds(C#, r#), C#)) &
        SS(C#, BIGUNION(fchains(r#, f#))) ==>
        IN(App(f#, Diff(upper_bounds(C#, r#), C#)), k#) &
        IN(Pair(App(f#, Diff(upper_bounds(C#, r#), C#)), x#), r#): thm
val lemma7 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        IN(BIGUNION(fchains(r#, f#)), fchains(r#, f#)): thm
val lemma8 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A)))
      (k : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        reflexive(r#, s#) &
        antisym(r#) &
        transitive(r#) &
        IN(k#, fchains(r#, f#)) & ~Diff(upper_bounds(k#, r#), k#) = Empty(A) ==>
        IN(Ins(App(f#, Diff(upper_bounds(k#, r#), k#)), k#), fchains(r#, f#)):
   thm
val upper_bounds_lem =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A)))  (x1 : mem(A))
      (x2 : mem(A)).
        transitive(r#) &
        IN(x1#, upper_bounds(s#, r#)) & IN(Pair(x1#, x2#), r#) ==>
        IN(x2#, upper_bounds(s#, r#)): thm
val lemma9 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        SS(upper_bounds(BIGUNION(fchains(r#, f#)), r#),
         maximal_elements(s#, r#)): thm
val zorns_lemma0 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A))).
        ~s# = Empty(A) &
        partial_order(r#, s#) &
        (!(t : mem(Pow(A))).
            chain0(t#, r#) ==> ~upper_bounds(t#, r#) = Empty(A)) ==>
        ?(x : mem(A)). IN(x#, maximal_elements(s#, r#)): thm
val Trans_transitive =
   {},  |- !(A : set)  (R : rel(A#, A#)). Trans(R#) <=> transitive(r2m(R#)):
   thm
val Refl_reflexive =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> reflexive(r2m(R#), Whole(A#)): thm
val Asym_antisym =
   {},  |- !(A : set)  (R : rel(A#, A#)). Asym(R#) <=> antisym(r2m(R#)): thm
val ptorder_partial_order =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> partial_order(r2m(R), Whole(A)): thm
val zorns_lemma =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ~EMPTY(A#) & ptorder(R#) ==>
        (!(c : mem(Pow(A#))).
            chain(c#, R#) & ~c# = Empty(A#) ==>
            ?(ub : mem(A#)). ubound(c#, R#, ub#)) ==>
        ?(m : mem(A#)). ismax(R#, m#): thm
val it = (): unit
val ufilter_iff_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        ((!(s : mem(Pow(Pow(J#)))).
              filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) <=>
          ufilter(u#)): thm
val UNION_chain_filter_filter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> filter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          filter(BIGUNION(ss#)): thm
val UNION_chain_pfilter_pfilter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> pfilter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          pfilter(BIGUNION(ss#)): thm
val ufilter_thm =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) ==> ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(s#, u#):
   thm
val ufilter_thm_coro =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==>
        ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(ss#, u#): thm
val Prop_5_3 =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==> ?(u : mem(UFs(A#))). SS(ss#, Repu(u#)): thm
val FIP_Sing =
   {},  |- !(W : set)  (a : mem(Pow(W#))). ~a# = Empty(W#) ==> FIP(Sing(a#)):
   thm
val it = (): unit
******

Loading SEAR file SEARmmmt.sml

******
val Rm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w1 : mem(W)), (w2 : mem(W))}, 
   |- Rm(M, w1, w2) <=> IN(Pair(w1, w2), Rof(M)): thm
val Rof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Rof(M#) = Fst(M#): thm
val Vof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Vof(M#) = tof(Snd(M#)): thm
val HAT_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(A))  (w : mem(W)).
        IN(w#, App(HAT(M), a#)) <=> IN(a#, App(Vof(M), w#)): thm
val satis_def0 =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A))), (w : mem(W))}, 
   |- satis(M, w, f) <=> IN(w, App(satisf(M), f)): thm
val satis_dmf =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(Pow(W)))  (w : mem(W)).
        IN(w#, App(sdmf(M), a#)) <=>
        ?(w0 : mem(W)). IN(w0#, a#) & Rm(M, w#, w0#): thm
val satisf_clause =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- App(satisf(M), Bot(A)) = Empty(W) &
      (!(p : mem(A)). App(satisf(M), Var(p#)) = App(HAT(M), p#)) &
      (!(f : mem(form(A))).
          App(satisf(M), Neg(f#)) = App(COMPL(W), App(satisf(M), f#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          App(satisf(M), Disj(f1#, f2#)) =
            App(UNION(W), Pair(App(satisf(M), f1#), App(satisf(M), f2#)))) &
      !(f : mem(form(A))).
        App(satisf(M), Diam(f#)) = App(sdmf(M), App(satisf(M), f#)): thm
val satisf_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- satisf(M) = fmrec(Empty(W), HAT(M), COMPL(W), UNION(W), sdmf(M)): thm
val satis_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))}, 
   |- ~satis(M, w, Bot(A)) &
      (!(a : mem(A)). satis(M, w, Var(a#)) <=> IN(a#, App(Vof(M), w))) &
      (!(f : mem(form(A))). satis(M, w, Neg(f#)) <=> ~satis(M, w, f#)) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          satis(M, w, Disj(f1#, f2#)) <=> satis(M, w, f1#) | satis(M, w, f2#)) &
      !(f : mem(form(A))).
        satis(M, w, Diam(f#)) <=>
        ?(v : mem(W)). Rm(M, w, v#) & satis(M, v#, f#): thm
val SATIS_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (fs : mem(Pow(form(A)))), (w : mem(W))}, 
   |- SATIS(M, w, fs) <=> !(f : mem(form(A))). IN(f#, fs) ==> satis(M, w, f#):
   thm
val Top_def = {(A : set)},  |- Top(A) = Neg(Bot(A)): thm
val Conj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Conj(f1, f2) = Neg(Disj(Neg(f1), Neg(f2))): thm
val satis_Conj =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f1 : mem(form(A)))  (f2 : mem(form(A))).
        satis(M#, w#, Conj(f1#, f2#)) <=>
        satis(M#, w#, f1#) & satis(M#, w#, f2#): thm
val PE's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). IN(a#, PE's(A)) <=> SS(App(PEf(A), a#), a#):
   thm
val PE_cases0 = {(A : set)},  |- App(PEf(A), PEs(A)) = PEs(A): thm
val PE_cases1 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_incond =
   !(f : mem(form(A))).
     IN(f#, PEs1) <=>
     f# = Top(A) |
     f# = Bot(A) |
     (?(p : mem(A)). f# = Var(p#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Conj(f1#, f2#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Disj(f1#, f2#)) |
     ?(f0 : mem(form(A))). IN(f0#, PEs0) & f# = Diam(f0#): form
val PE_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        (!(a : mem(form(A))).
            a# = Top(A) |
            a# = Bot(A) |
            (?(p : mem(A)). a# = Var(p#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Conj(f1#, f2#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj(f1#, f2#)) |
            (?(f0 : mem(form(A))). IN(f0#, ss#) & a# = Diam(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_rules0 = {(A : set)},  |- SS(App(PEf(A), PEs(A)), PEs(A)): thm
val PE_rules1 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        a# = Top(A) |
        a# = Bot(A) |
        (?(p : mem(A)). a# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#)) |
        (?(f0 : mem(form(A))). IN(f0#, PEs(A)) & a# = Diam(f0#)) ==>
        IN(a#, PEs(A)): thm
val PE_rules2 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (a# = Top(A) ==> IN(a#, PEs(A))) &
        (a# = Bot(A) ==> IN(a#, PEs(A))) &
        (!(p : mem(A)). a# = Var(p#) ==> IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        !(f0 : mem(form(A))).
          IN(f0#, PEs(A)) & a# = Diam(f0#) ==> IN(a#, PEs(A)): thm
val PE_rules3 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PEf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A))))  (f : mem(form(A))).
        IN(f#, App(PEf(A), a#)) <=>
        f# = Top(A) |
        f# = Bot(A) |
        (?(p : mem(A)). f# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(form(A)), Pow(form(A)))).
        !(a : mem(Pow(form(A))))  (f : mem(form(A))).
          IN(f#, App(f#, a#)) <=>
          f# = Top(A) |
          f# = Bot(A) |
          (?(p : mem(A)). f# = Var(p#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
          ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==> SS(App(PEf(A), s1#), App(PEf(A), s2#)): thm
val PEs_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). SS(App(PEf(A), a#), a#) ==> SS(PEs(A), a#):
   thm
val PEs_cond =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (!(ss : mem(Pow(form(A)))). SS(App(PEf(A), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, PEs(A)): thm
val PEs_def = {(A : set)},  |- PEs(A) = BIGINTER(PE's(A)): thm
val x1 = "PEs0": string
val PE_cases0 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_rules0 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PE_def0 = {(A : set), (f : mem(form(A)))},  |- PE(f) <=> IN(f, PEs(A)):
   thm
val PE_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). PE(a#) ==> IN(a#, ss#): thm
val PE_cases =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        PE(x#) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). PE(f0#) & x# = Diam(f0#): thm
val PE_rules =
   {(A : set)}, 
   |- PE(Top(A)) &
      PE(Bot(A)) &
      (!(p : mem(A)). PE(Var(p#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#))) &
      !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val PE_induct =
   {}, 
   |- !(A : set).
        P(Top(A#)) &
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Conj(f1#, f2#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f : mem(form(A#))). P(f#) ==> P(Diam(f#))) ==>
        !(f : mem(form(A#))). PE(f#) ==> P(f#): thm
val satis_Bot =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
      (w : mem(W#)). ~satis(M#, w#, Bot(A#)): thm
val satis_Top =
   {(W : set)}, 
   |- !(A : set)  (M : mem(Pow((W * W)) * Exp(W, Pow(A#))))  (w : mem(W)).
        satis(M#, w#, Top(A#)): thm
val PUS_Var = {},  |- !(A : set)  (p : mem(A#)). PUS(Var(p#)): thm
val PUS_def =
   {(A : set), (f : mem(form(A)))}, 
   |- PUS(f) <=>
      !(W1 : set)  (W2 : set)  (R : rel(W1#, W2#))
      (M1 : mem(Pow((W1# * W1#)) * Exp(W1#, Pow(A))))
      (M2 : mem(Pow((W2# * W2#)) * Exp(W2#, Pow(A)))).
        Sim(R#, M1#, M2#) ==>
        !(w1 : mem(W1#))  (w2 : mem(W2#)).
          Holds(R#, w1#, w2#) ==> satis(M1#, w1#, f) ==> satis(M2#, w2#, f):
   thm
val Sim_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (R : rel(W1, W2)),
    (W1 : set), (W2 : set)}, 
   |- Sim(R, M1, M2) <=>
      !(w1 : mem(W1))  (w2 : mem(W2)).
        Holds(R, w1#, w2#) ==>
        (!(p : mem(A)).
            IN(p#, App(Vof(M1), w1#)) ==> IN(p#, App(Vof(M2), w2#))) &
        !(v : mem(W1)).
          Rm(M1, w1#, v#) ==>
          ?(v' : mem(W2)). Holds(R, v#, v'#) & Rm(M2, w2#, v'#): thm
val PUS_Top = {},  |- !(A : set). PUS(Top(A#)): thm
val PUS_Bot = {},  |- !(A : set). PUS(Bot(A#)): thm
val Thm_6_25_r2l0 =
   {},  |- !(A : set)  (f : mem(form(A#))). PE(f#) ==> PUS(f#): thm
val EQV_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- EQV(f1, f2) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, f1) <=> satis(M#, w#, f2): thm
val Thm_6_25_r2l =
   {}, 
   |- !(A : set)  (f : mem(form(A#)))  (f0 : mem(form(A#))).
        PE(f0#) & EQV(f#, f0#) ==> PUS(f#): thm
val Fsab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Fsab(fs, X, M) <=>
      !(ss : mem(Pow(form(A)))). Fin(ss#) & SS(ss#, fs) ==> Sab(ss#, X, M):
   thm
val Msat_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- Msat(M) <=>
      !(w : mem(W))  (fs : mem(Pow(form(A)))).
        Fsab(fs#, Sucm(M, w#), M) ==> Sab(fs#, Sucm(M, w#), M): thm
val Sab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Sab(fs, X, M) <=> ?(x : mem(W)). IN(x#, X) & SATIS(M, x#, fs): thm
val Sucm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))},  |- !(a : mem(W)). IN(a#, Sucm(M, w)) <=> Rm(M, w, a#):
   thm
val Tat_def =
   {(A : set), (W : set), (a : mem(A)), (f0 : fun(W, Pow(A)))}, 
   |- !(a' : mem(W)). IN(a'#, Tat(f0, a)) <=> IN(a, App(f0, a'#)): thm
val fun_mem_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(f : fun(A#, B#)). P(f#)) <=> ?(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val mem_fun_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(m : mem(Exp(A#, B#))). P(m#)) <=> ?(f : fun(A#, B#)). P(Tpm(f#)):
   thm
val fun_mem_uex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?!(f : fun(A#, B#)). P(f#)) <=> ?!(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val UE_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- UE(M) = Pair(ueR(M), ueV(M)): thm
val csee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, csee(M, X)) <=> ?(v : mem(W)). Rm(M, a#, v#) & IN(v#, X): thm
val osee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, osee(M, X)) <=> !(v : mem(W)). Rm(M, a#, v#) ==> IN(v#, X):
   thm
val ueR_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a' : mem(UFs(W)))  (b : mem(UFs(W))).
        IN(Pair(a'#, b#), ueR(M)) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(b#)) ==> IN(csee(M, X#), Repu(a'#)):
   thm
val ueV_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(u : mem(UFs(W)))  (a : mem(A)).
        IN(a#, App(tof(ueV(M)), u#)) <=> IN(Tat(Vof(M), a#), Repu(u#)): thm
val ufilter_Compl =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))). ~IN(Compl(X#), L#) <=> IN(X#, L#): thm
val exists_forall_dual =
   {},  |- !(A : set). (?(a : mem(A#)). P(a#)) <=> ~!(a : mem(A#)). ~P(a#):
   thm
val Prop_5_4_1 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        csee(M#, X#) = Compl(osee(M#, Compl(X#))): thm
val Prop_5_4_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        osee(M#, X#) = Compl(csee(M#, Compl(X#))): thm
val Prop_5_6 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val MEQ_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (W1 : set), (W2 : set),
    (w1 : mem(W1)), (w2 : mem(W2))}, 
   |- MEQ(M1, w1, M2, w2) <=>
      !(f : mem(form(A))). satis(M1, w1, f#) <=> satis(M2, w2, f#): thm
val pufilter_def =
   {(A : set), (a : mem(A))}, 
   |- !(a' : mem(Pow(A))). IN(a'#, pufilter(a)) <=> IN(a, a'#): thm
val pufilter_filter =
   {},  |- !(A : set)  (a : mem(A#)). filter(pufilter(a#)): thm
val ueR_alt =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val pufilter_ufilter =
   {},  |- !(A : set)  (a : mem(A#)). ufilter(pufilter(a#)): thm
val Repu_eq_eq =
   {}, 
   |- !(W : set)  (u1 : mem(UFs(W#)))  (u2 : mem(UFs(W#))).
        Repu(u1#) = Repu(u2#) ==> u1# = u2#: thm
val Pft_def =
   {(W : set), (w0 : mem(W))}, 
   |- !(ws : mem(Pow(W))). IN(ws#, Repu(Pft(w0))) <=> IN(w0, ws#): thm
val Prop_5_5_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W)))
      (Y : mem(Pow(W))).
        osee(M#, Inter(X#, Y#)) = Inter(osee(M#, X#), osee(M#, Y#)): thm
val SW_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(form(A)))  (w : mem(W)).
        IN(w#, App(SW(M), a#)) <=> satis(M, w#, a#): thm
val Sw_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A)))},  |- Sw(M, f) = App(SW(M), f): thm
val Sw_Bot =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Sw(M#, Bot(A)) = Empty(W):
   thm
val Sw_Var =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        Sw(M#, Var(p#)) = App(HAT(M#), p#): thm
val Vof_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Vof(UE(M#)) = tof(ueV(M#)):
   thm
val HAT_Tat =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        App(HAT(M#), p#) = Tat(Vof(M#), p#): thm
val Sw_Neg =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        Sw(M#, Neg(f#)) = Compl(Sw(M#, f#)): thm
val Sw_Disj =
   {(A : set), (W : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        Sw(M#, Disj(f1, f2)) = Union(Sw(M#, f1), Sw(M#, f2)): thm
val Rm_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (u' : mem(UFs(W))).
        Rm(UE(M#), u#, u'#) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(u'#)) ==> IN(csee(M#, X#), Repu(u#)):
   thm
val csee_Sw_DIAM =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        csee(M#, Sw(M#, f#)) = Sw(M#, Diam(f#)): thm
val Prop_5_8 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
      (phi : mem(form(A)))  (u : mem(UFs(W#))).
        IN(Sw(M#, phi#), Repu(u#)) <=> satis(UE(M#), u#, phi#): thm
val Prop_5_7 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        MEQ(M#, w#, UE(M#), Pft(w#)): thm
val SATIS_Sing =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f : mem(form(A))). SATIS(M#, w#, Sing(f#)) <=> satis(M#, w#, f#): thm
val Fin_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(s1#) | Fin(s2#) ==> Fin(Inter(s1#, s2#)): thm
val SATIS_Union =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SATIS(M#, w#, Union(s1#, s2#)) <=>
        SATIS(M#, w#, s1#) & SATIS(M#, w#, s2#): thm
val only_see_whole_world =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        osee(M#, Whole(W)) = Whole(W): thm
val SATIS_Empty =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        SATIS(M#, w#, Empty(form(A))): thm
val BIGCONJ_EXISTS =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        ?(ff : mem(form(A))).
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val SS_Union_of =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s1#, s#) & SS(s2#, s#) ==> SS(Union(s1#, s2#), s#): thm
val Prop_5_9 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Msat(UE(M#)): thm
val PE_BIGCONJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val PE_Conj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#)): thm
val PE_BIGDISJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)).
            satis(M#, w#, ff#) <=>
            ?(f : mem(form(A))). IN(f#, s#) & satis(M#, w#, f#): thm
val PE_Disj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#)): thm
val PE_Diam =
   {(A : set)},  |- !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val Thm_6_22 =
   {(A : set), (W1 : set), (W2 : set)}, 
   |- !(M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A))))
      (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))).
        Msat(M1#) & Msat(M2#) ==>
        !(w1 : mem(W1))  (w2 : mem(W2)).
          (!(f : mem(form(A))).
              PE(f#) ==> satis(M1#, w1#, f#) ==> satis(M2#, w2#, f#)) ==>
          ?(R : rel(W1, W2)). Sim(R#, M1#, M2#) & Holds(R#, w1#, w2#): thm
val ENT_def =
   {(A : set), (phis : mem(Pow(form(A)))), (psi : mem(form(A)))}, 
   |- ENT(phis, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        SATIS(M#, w#, phis) ==> satis(M#, w#, psi): thm
val MCOMPACT_def =
   {}, 
   |- MCOMPACT <=>
      !(A : set)  (fs : mem(Pow(form(A#)))).
        (!(ffs : mem(Pow(form(A#)))).
            SS(ffs#, fs#) & Fin(ffs#) ==>
            ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
            (w : mem(W#)). SATIS(M#, w#, ffs#)) ==>
        ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
        (w : mem(W#)). SATIS(M#, w#, fs#): thm
val satis_Neg =
   {(A : set), (W : set), (f : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        satis(M#, w#, Neg(f)) <=> ~satis(M#, w#, f): thm
val Ent_def =
   {(A : set), (phi : mem(form(A))), (psi : mem(form(A)))}, 
   |- Ent(phi, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, phi) ==> satis(M#, w#, psi): thm
val SATIS_SS =
   {(A : set), (W : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==>
        !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
          SATIS(M#, w#, s2#) ==> SATIS(M#, w#, s1#): thm
val Thm_6_24 =
   {(A : set)}, 
   |- MCOMPACT ==>
      !(fs : mem(Pow(form(A))))  (phi : mem(form(A))).
        ENT(fs#, phi#) ==>
        ?(ffs : mem(Pow(form(A)))).
          SS(ffs#, fs#) & Fin(ffs#) & ENT(ffs#, phi#): thm
val Fin_ENT_PE =
   {(A : set)}, 
   |- !(fs : mem(Pow(form(A)))).
        Fin(fs#) & (!(f : mem(form(A))). IN(f#, fs#) ==> PE(f#)) ==>
        ?(phi : mem(form(A))).
          PE(phi#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). SATIS(M#, w#, fs#) <=> satis(M#, w#, phi#): thm
val PEC_def =
   {(A : set), (f : mem(form(A)))}, 
   |- !(a : mem(form(A))). IN(a#, PEC(f)) <=> PE(a#) & Ent(f, a#): thm
val SATIS_PEC =
   {(A : set), (W : set)}, 
   |- !(f : mem(form(A)))  (M : mem(Pow((W * W)) * Exp(W, Pow(A))))
      (w : mem(W)). satis(M#, w#, f#) ==> SATIS(M#, w#, PEC(f#)): thm
val Del_Fin =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        Fin(Del(s#, a#)) ==> Fin(s#): thm
val Fin_Inj0 =
   {}, 
   |- !(B : set)  (s : mem(Pow(B#))).
        Fin(s#) ==>
        !(A : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
          s# = IMAGE(f#, ss#) ==> Inj(f#) ==> Fin(ss#): thm
val Fin_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(ss : mem(Pow(A#))). Fin(IMAGE(f#, ss#)) ==> Fin(ss#):
   thm
val Thm_6_25_iff =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) <=> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val Thm_6_25_l2r =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) ==> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val it = (): unit
******

Loading SEAR file SEARllist.sml

******
val IN_gfp =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (a : mem(A)).
        IN(a#, gfp(f#)) <=>
        ?(sa : mem(Pow(A))). SS(sa#, App(f#, sa#)) & IN(a#, sa#): thm
val gfp_def =
   {}, 
   |- !(A : set)  (f : fun(Pow(A#), Pow(A#))). gfp(f#) = BIGUNION(prims(f#)):
   thm
val prims_def =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- !(a : mem(Pow(A))). IN(a#, prims(f)) <=> SS(a#, App(f, a#)): thm
val weak_coind =
   {}, 
   |- !(A : set)  (sa : mem(Pow(A#)))  (a : mem(A#))
      (f : fun(Pow(A#), Pow(A#))).
        IN(a#, sa#) & SS(sa#, App(f#, sa#)) ==> IN(a#, gfp(f#)): thm
val SS_gfp_fgfp =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(gfp(f), App(f, gfp(f))): thm
val monotone_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(Pow(A#), Pow(B#))).
        monotone(f#) <=>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          SS(s1#, s2#) ==> SS(App(f#, s1#), App(f#, s2#)): thm
val rules0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(App(f, gfp(f)), gfp(f)): thm
val cases0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> gfp(f) = App(f, gfp(f)): thm
val coind0 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (sa : mem(Pow(A))).
        SS(sa#, App(f#, sa#)) ==> SS(sa#, gfp(f#)): thm
val lcons0_def =
   {}, 
   |- !(X : set)  (f0 : fun(N, X# + 1))  (x : mem(X#)).
        App(lcons0(x#, f0#), O) = SOME(x#) &
        !(n : mem(N)). App(lcons0(x#, f0#), Suc(n#)) = App(f0#, n#): thm
val llf_uex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Exp(N, X + 1)), Pow(Exp(N, X + 1)))).
        !(gs : mem(Pow(Exp(N, X + 1))))  (g : mem(Exp(N, X + 1))).
          IN(g#, App(f#, gs#)) <=>
          g# = Tpm(Null(X)) |
          ?(h : mem(X))  (t : fun(N, X + 1)).
            g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_def =
   {}, 
   |- !(X : set)  (gs : mem(Pow(Exp(N, X# + 1))))  (g : mem(Exp(N, X# + 1))).
        IN(g#, App(llf(X#), gs#)) <=>
        g# = Tpm(Null(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_monotone = {},  |- !(X : set). monotone(llf(X#)): thm
val islls_def = {(X : set)},  |- islls(X) = gfp(llf(X)): thm
val llist_def1 =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          IN(a#, islls(X#)) <=>
          ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_Inj = {},  |- !(X : set). Inj(repll(X#)): thm
val isll_def =
   {}, 
   |- !(X : set)  (l : mem(Exp(N, X# + 1))). isll(l#) <=> IN(l#, islls(X#)):
   thm
val ll_cases = {},  |- !(X : set). islls(X#) = App(llf(X#), islls(X#)): thm
val ll_coind =
   {}, 
   |- !(X : set)  (sa : mem(Pow(Exp(N, X# + 1)))).
        (!(a : mem(Exp(N, X# + 1))).
            IN(a#, sa#) ==>
            a# = Tpm(Null(X#)) |
            ?(h : mem(X#))  (t : fun(N, X# + 1)).
              a# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), sa#)) ==>
        !(a : mem(Exp(N, X# + 1))). IN(a#, sa#) ==> IN(a#, islls(X#)): thm
val ll_rules =
   {}, 
   |- !(X : set).
        IN(Tpm(Null(X#)), islls(X#)) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          IN(Tpm(t#), islls(X#)) ==> IN(Tpm(lcons0(h#, t#)), islls(X#)): thm
val isll_lnil = {},  |- !(X : set). isll(Tpm(Null(X#))): thm
val isll_shift =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val Repll_def =
   {},  |- !(X : set)  (l : mem(llist(X#))). Repll(l#) = App(repll(X#), l#):
   thm
val LNil_def = {},  |- !(X : set). Repll(LNil(X#)) = Tpm(Null(X#)): thm
val llist_def =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          isll(a#) <=> ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_isll =
   {},  |- !(X : set)  (ll : mem(llist(X#))). isll(App(repll(X#), ll#)): thm
val isll_Repll =
   {}, 
   |- !(X : set)  (a : mem(Exp(N, X# + 1))).
        isll(a#) <=> ?(b : mem(llist(X#))). a# = Repll(b#): thm
val Repll_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(llist(X#)))  (l2 : mem(llist(X#))).
        Repll(l1#) = Repll(l2#) <=> l1# = l2#: thm
val Repll_isll = {},  |- !(X : set)  (ll : mem(llist(X#))). isll(Repll(ll#)):
   thm
val isll_lcons0 =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val isll_rules =
   {}, 
   |- !(X : set).
        isll(Tpm(Null(X#))) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          isll(Tpm(t#)) ==> isll(Tpm(lcons0(h#, t#))): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LCons_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#)))  (x : mem(X#)).
        Repll(LCons(x#, ll#)) = Tpm(lcons0(x#, tof(Repll(ll#)))): thm
val Repll_lnil_uex =
   {}, 
   |- !(X : set)  (l : mem(llist(X#))).
        Repll(l#) = Tpm(Null(X#)) <=> l# = LNil(X#): thm
val FPB_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- App(FPB(f), NONE(B * A)) = NONE(B * A) &
      !(b : mem(B))  (a : mem(A)).
        App(FPB(f), SOME(Pair(b#, a#))) = App(f, b#): thm
val FP_def =
   {(X : set), (f : fun(X, X))}, 
   |- !(x : mem(X)).
        App(FP(f), Pair(O, x#)) = x# &
        !(n : mem(N)).
          App(FP(f), Pair(Suc(n#), x#)) = App(FP(f), Pair(n#, App(f, x#))):
   thm
val OB_def =
   {(A : set), (B : set)}, 
   |- !(f : fun(A, B + 1)).
        App(OB(A, B), Pair(NONE(A), Tpm(f#))) = NONE(B) &
        !(a : mem(A)). App(OB(A, B), Pair(SOME(a#), Tpm(f#))) = App(f#, a#):
   thm
val lnil_def = {(X : set)},  |- lnil(X) = Tpm(Null(X)): thm
val toabs_char0 =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)).
        (App(f#, z#) = NONE(B * A) ==> toabs(f#, z#) = Null(A)) &
        !(b : mem(B))  (a : mem(A)).
          App(f#, z#) = SOME(Pair(b#, a#)) ==>
          toabs(f#, z#) = lcons0(a#, toabs(f#, b#)): thm
val toabs_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1)), (z : mem(B))}, 
   |- !(n : mem(N)).
        App(toabs(f, z), n#) =
          App(OM(p2(B, A)), App(FP(FPB(f)), Pair(n#, App(f, z)))): thm
val toabs_isll =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)). isll(Tpm(toabs(f#, z#))): thm
val toabs_unique =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (g : fun(B, Exp(N, A + 1))).
        (!(z : mem(B)).
            (App(f#, z#) = NONE(B * A) ==> App(g#, z#) = Tpm(Null(A))) &
            !(b : mem(B))  (a : mem(A)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(g#, z#) = Tpm(lcons0(a#, tof(App(g#, b#))))) ==>
        !(z : mem(B)). App(g#, z#) = Tpm(toabs(f#, z#)): thm
val llcr0_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- !(z : mem(B)). App(llcr0(f), z#) = Tpm(toabs(f, z#)): thm
val llrec0_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, Exp(N, A# + 1))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = Tpm(Null(A#))) &
            (!(b : mem(B#))  (a : mem(A#)).
                App(f#, z#) = SOME(Pair(b#, a#)) ==>
                App(cr#, z#) = Tpm(lcons0(a#, tof(App(cr#, b#))))) &
            isll(App(cr#, z#)): thm
val llcr_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, llist(A#))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = LNil(A#)) &
            !(b : mem(B#))  (a : mem(A#)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(cr#, z#) = LCons(a#, App(cr#, b#)): thm
val CB_def =
   {(X : set)}, 
   |- !(R : mem(Pow(llist(X) * llist(X))))  (ll1 : mem(llist(X)))
      (ll2 : mem(llist(X))).
        IN(Pair(ll1#, ll2#), App(CB(X), R#)) <=>
        ll1# = LNil(X) & ll2# = LNil(X) |
        ?(l01 : mem(llist(X)))  (l02 : mem(llist(X)))  (x : mem(X)).
          IN(Pair(l01#, l02#), R#) &
          ll1# = LCons(x#, l01#) & ll2# = LCons(x#, l02#): thm
val CB_monotone = {(X : set)},  |- monotone(CB(X)): thm
val CB_cases = {},  |- !(X : set). gfp(CB(X#)) = App(CB(X#), gfp(CB(X#))):
   thm
val CB_rules0 =
   {}, 
   |- !(X : set).
        IN(Pair(LNil(X#), LNil(X#)), gfp(CB(X#))) &
        !(l01 : mem(llist(X#)))  (l02 : mem(llist(X#))).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          !(x : mem(X#)).
            IN(Pair(LCons(x#, l01#), LCons(x#, l02#)), gfp(CB(X#))): thm
val CB_rules00 =
   {}, 
   |- !(X : set).
        (!(b : mem(llist(X#)))  (a' : mem(llist(X#))).
            a'# = LNil(X#) ==>
            b# = LNil(X#) ==> IN(Pair(a'#, b#), gfp(CB(X#)))) &
        !(a' : mem(llist(X#)))  (b : mem(llist(X#)))  (l01 : mem(llist(X#)))
        (l02 : mem(llist(X#)))  (x : mem(X#)).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          a'# = LCons(x#, l01#) ==>
          b# = LCons(x#, l02#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val CB_coind0 =
   {}, 
   |- !(X : set)  (sa : mem(Pow(llist(X#) * llist(X#)))).
        (!(a' : mem(llist(X#)))  (b : mem(llist(X#))).
            IN(Pair(a'#, b#), sa#) ==>
            a'# = LNil(X#) & b# = LNil(X#) |
            ?(l01 : mem(llist(X#)))  (l02 : mem(llist(X#)))  (x : mem(X#)).
              IN(Pair(l01#, l02#), sa#) &
              a'# = LCons(x#, l01#) & b# = LCons(x#, l02#)) ==>
        !(a' : mem(llist(X#)))  (b : mem(llist(X#))).
          IN(Pair(a'#, b#), sa#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val LHD_THM =
   {(X : set)}, 
   |- LHD(LNil(X)) = NONE(X) &
      !(h : mem(X))  (t : mem(llist(X))). LHD(LCons(h#, t#)) = SOME(h#): thm
val LHD_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))). LHD(ll#) = App(tof(Repll(ll#)), O):
   thm
val LNTH_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). LNTH(n#, ll1#) = LNTH(n#, ll2#)) <=> ll1# = ll2#: thm
val LNTH_def =
   {}, 
   |- !(A : set)  (ll : mem(llist(A#)))  (n : mem(N)).
        LNTH(n#, ll#) = App(tof(Repll(ll#)), n#): thm
val Repll_n_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). App(tof(Repll(ll1#)), n#) = App(tof(Repll(ll2#)), n#)) <=>
        ll1# = ll2#: thm
val isll_cases0 =
   {}, 
   |- !(X : set)  (x : mem(Exp(N, X# + 1))).
        isll(x#) <=>
        x# = Repll(LNil(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          x# = Tpm(lcons0(h#, t#)) & isll(Tpm(t#)): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LTL_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        (LHD(ll#) = NONE(X#) ==> LTL(ll#) = NONE(llist(X#))) &
        !(hd : mem(X#)).
          LHD(ll#) = SOME(hd#) ==>
          ?(ltl0 : mem(llist(X#))).
            LTL(ll#) = SOME(ltl0#) &
            !(n : mem(N)).
              App(tof(Repll(ltl0#)), n#) = App(tof(Repll(ll#)), Suc(n#)): thm
val LCons_xor_LNil =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        ~ll# = LNil(X#) <=>
        ?(h : mem(X#))  (t : mem(llist(X#))). ll# = LCons(h#, t#): thm
val LTL_THM =
   {(X : set)}, 
   |- LTL(LNil(X)) = NONE(llist(X)) &
      !(h : mem(X))  (t : mem(llist(X))). LTL(LCons(h#, t#)) = SOME(t#): thm
val LNTH_THM =
   {}, 
   |- !(X : set).
        (!(n : mem(N)). LNTH(n#, LNil(X#)) = NONE(X#)) &
        (!(h : mem(X#))  (t : mem(llist(X#))).
            LNTH(O, LCons(h#, t#)) = SOME(h#)) &
        !(n : mem(N))  (h : mem(X#))  (t : mem(llist(X#))).
          LNTH(Suc(n#), LCons(h#, t#)) = LNTH(n#, t#): thm
val gfp_CB =
   {}, 
   |- !(X : set)  (g1 : mem(llist(X#)))  (g2 : mem(llist(X#))).
        IN(Pair(g1#, g2#), gfp(CB(X#))) <=> g1# = g2#: thm
val LLIST_BISIMULATION0 =
   {(X : set)}, 
   |- !(ll1 : mem(llist(X)))  (ll2 : mem(llist(X))).
        ll1# = ll2# <=>
        ?(R : mem(Pow(llist(X) * llist(X)))).
          IN(Pair(ll1#, ll2#), R#) &
          !(ll3 : mem(llist(X)))  (ll4 : mem(llist(X))).
            IN(Pair(ll3#, ll4#), R#) ==>
            ll3# = LNil(X) & ll4# = LNil(X) |
            ?(h : mem(X))  (t1 : mem(llist(X)))  (t2 : mem(llist(X))).
              IN(Pair(t1#, t2#), R#) &
              ll3# = LCons(h#, t1#) & ll4# = LCons(h#, t2#): thm
val lcons0_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : fun(N, X + 1))
      (t2 : fun(N, X + 1)).
        lcons0(h1#, t1#) = lcons0(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LCons_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : mem(llist(X)))
      (t2 : mem(llist(X))).
        LCons(h1#, t1#) = LCons(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LMAP_def =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(z : mem(llist(X))).
        (App(lmapf(f), z#) = NONE(llist(X) * Y) ==>
          App(LMAP(f), z#) = LNil(Y)) &
        !(b : mem(llist(X)))  (a : mem(Y)).
          App(lmapf(f), z#) = SOME(Pair(b#, a#)) ==>
          App(LMAP(f), z#) = LCons(a#, App(LMAP(f), b#)): thm
val LMap_def =
   {(X : set), (Y : set), (f : fun(X, Y)), (l : mem(llist(X)))}, 
   |- LMap(f, l) = App(LMAP(f), l): thm
val f_ex0 =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(l : mem(llist(X))).
        ?!(opv : mem(llist(X) * A + 1)).
          l# = LNil(X) & opv# = NONE(llist(X) * A) |
          ?(lh : mem(X))  (lt : mem(llist(X))).
            l# = LCons(lh#, lt#) & opv# = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LNil =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A)). App(lmapf(f#), LNil(X)) = NONE(llist(X) * A): thm
val lmapf_def =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(a : mem(llist(X))).
        a# = LNil(X) & App(lmapf(f), a#) = NONE(llist(X) * A) |
        ?(lh : mem(X))  (lt : mem(llist(X))).
          a# = LCons(lh#, lt#) &
          App(lmapf(f), a#) = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LCons =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A))  (lh : mem(X))  (lt : mem(llist(X))).
        App(lmapf(f#), LCons(lh#, lt#)) = SOME(Pair(lt#, App(f#, lh#))): thm
val LMAP_LNil =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y)). App(LMAP(f#), LNil(X)) = LNil(Y): thm
val LMAP_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        App(LMAP(f#), LCons(lh#, lt#)) =
          LCons(App(f#, lh#), App(LMAP(f#), lt#)): thm
val LMap_LNil =
   {(X : set), (Y : set)},  |- !(f : fun(X, Y)). LMap(f#, LNil(X)) = LNil(Y):
   thm
val LMap_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        LMap(f#, LCons(lh#, lt#)) = LCons(App(f#, lh#), LMap(f#, lt#)): thm
val LMap_functorial =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (g : fun(Z, X))  (ll : mem(llist(Z))).
        LMap(f#, LMap(g#, ll#)) = LMap(f# o g#, ll#): thm
val it = (): unit
******

Loading SEAR file SEARGrp.sml

******
val Grp_def =
   {}, 
   |- !(G : set).
        Inj(iG(G#)) &
        !(a : mem(Exp((G# * G#), G#) * Exp(G#, G#) * G#)).
          isgrp(a#) <=> ?(b : mem(Grp(G#))). a# = App(iG(G#), b#): thm
val RepG_def = {(G : set), (g : mem(Grp(G)))},  |- RepG(g) = App(iG(G), g):
   thm
val RepG_isgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isgrp(RepG(g#)): thm
val asc_def =
   {(A : set), (m : fun(A * A, A))}, 
   |- asc(m) <=>
      !(a1 : mem(A))  (a2 : mem(A))  (a3 : mem(A)).
        mul(m, mul(m, a1#, a2#), a3#) = mul(m, a1#, mul(m, a2#, a3#)): thm
val isgrp_def =
   {(G : set), (g : mem(Exp((G * G), G) * Exp(G, G) * G))}, 
   |- isgrp(g) <=>
      asc(tof(c31(g))) &
      isunit(tof(c31(g)), c33(g)) & isinv(tof(c31(g)), tof(c32(g)), c33(g)):
   thm
val isinv_def =
   {(A : set), (e : mem(A)), (i : fun(A, A)), (m : fun(A * A, A))}, 
   |- isinv(m, i, e) <=>
      !(a : mem(A)). mul(m, App(i, a#), a#) = e & mul(m, a#, App(i, a#)) = e:
   thm
val isunit_def =
   {(A : set), (e : mem(A)), (m : fun(A * A, A))}, 
   |- isunit(m, e) <=> !(a : mem(A)). mul(m, e, a#) = a# & mul(m, a#, e) = a#:
   thm
val mul_def =
   {(G : set), (g1 : mem(G)), (g2 : mem(G)), (m : fun(G * G, G))}, 
   |- mul(m, g1, g2) = App(m, Pair(g1, g2)): thm
val Rnsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rnsg(g#)): thm
val eof_def = {(G : set), (g : mem(Grp(G)))},  |- eof(g) = c33(RepG(g)): thm
val ginv_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G))}, 
   |- ginv(g, x) = App(iof(g), x): thm
val gmul_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G)), (y : mem(G))}, 
   |- gmul(g, x, y) = mul(mof(g), x, y): thm
val iof_def = {(G : set), (g : mem(Grp(G)))},  |- iof(g) = tof(c32(RepG(g))):
   thm
val isghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (f : fun(G1#, G2#))
      (g2 : mem(Grp(G2#))).
        isghom(f#, g1#, g2#) <=>
        !(a : mem(G1#))  (b : mem(G1#)).
          App(f#, gmul(g1#, a#, b#)) = gmul(g2#, App(f#, a#), App(f#, b#)):
   thm
val isnml_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(sgrp(g)))}, 
   |- isnml(h) <=> !(a : mem(G)). rcs(h, a#) = lcs(a#, h): thm
val issgrp_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(Pow(G)))}, 
   |- issgrp(h, g) <=>
      IN(eof(g), h) &
      (!(a : mem(G))  (b : mem(G)).
          IN(a#, h) & IN(b#, h) ==> IN(gmul(g, a#, b#), h)) &
      !(a : mem(G)). IN(a#, h) ==> IN(ginv(g, a#), h): thm
val lcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, lcs(a, H)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, a, h#): thm
val lsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (x : mem(G#))
      (a : mem(G#)).
        IN(a#, lsmul(g#, x#, s#)) <=>
        ?(y : mem(G#)). IN(y#, s#) & a# = gmul(g#, x#, y#): thm
val mof_def = {(G : set), (g : mem(Grp(G)))},  |- mof(g) = tof(c31(RepG(g))):
   thm
val nsg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(sgrp(g))).
        (?(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#) <=>
        ?!(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#: thm
val nsg_uex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(sgrp(g#))).
        isnml(a#) ==> ?!(a : mem(nsgrp(g#))). App(Rnsg(g#), a#) = a#: thm
val nsgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))).
        Inj(Rnsg(g#)) &
        !(a : mem(sgrp(g#))).
          isnml(a#) <=> ?(b : mem(nsgrp(g#))). a# = App(Rnsg(g#), b#): thm
val rcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, rcs(H, a)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, h#, a): thm
val rcs_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        rcs(H#, a#) = rsmul(g#, rsg(H#), a#): thm
val rsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        rsg(H#) = App(Rsg(g#), H#): thm
val rsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (y : mem(G#))
      (a : mem(G#)).
        IN(a#, rsmul(g#, s#, y#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = gmul(g#, x#, y#): thm
val sgrp_def =
   {(G : set), (g : mem(Grp(G)))}, 
   |- Inj(Rsg(g)) &
      !(a : mem(Pow(G))).
        issgrp(a#, g) <=> ?(b : mem(sgrp(g))). a# = App(Rsg(g), b#): thm
val lcs_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        lcs(a#, H#) = lsmul(g#, a#, rsg(H#)): thm
val Rsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rsg(g#)): thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val sg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(Pow(G))).
        (?(a : mem(sgrp(g))). App(Rsg(g), a#) = b#) <=>
        ?!(a : mem(sgrp(g))). App(Rsg(g), a#) = b#: thm
val sg_uex =
   {}, 
   |- !(G : set)  (a : mem(Pow(G#)))  (g : mem(Grp(G#))).
        issgrp(a#, g#) ==> ?!(a : mem(sgrp(g#))). App(Rsg(g#), a#) = a#: thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val gmul_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, ginv(g#, a#), a#) = eof(g#) &
        gmul(g#, a#, ginv(g#, a#)) = eof(g#): thm
val asc_mof = {},  |- !(G : set)  (g : mem(Grp(G#))). asc(mof(g#)): thm
val gmul_assoc =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (c : mem(G#)).
        gmul(g#, gmul(g#, a#, b#), c#) = gmul(g#, a#, gmul(g#, b#, c#)): thm
val gmul_lcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, x#, y#) = gmul(g#, x#, z#) <=> y# = z#: thm
val gmul_rcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, y#, x#) = gmul(g#, z#, x#) <=> y# = z#: thm
val is_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        a1# = ginv(g#, a#) <=>
        gmul(g#, a#, a1#) = eof(g#) | gmul(g#, a1#, a#) = eof(g#): thm
val ginv_e =
   {},  |- !(G : set)  (g : mem(Grp(G#))). ginv(g#, eof(g#)) = eof(g#): thm
val e_sgrp =
   {},  |- !(G : set)  (g : mem(Grp(G#))). issgrp(Sing(eof(g#)), g#): thm
val esg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))). App(Rsg(g#), esg(g#)) = Sing(eof(g#)):
   thm
val rsg_esg =
   {},  |- !(G : set)  (g : mem(Grp(G#))). rsg(esg(g#)) = Sing(eof(g#)): thm
val e_nsgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isnml(esg(g#)): thm
val ensg_def =
   {},  |- !(G : set)  (g : mem(Grp(G#))). App(Rnsg(g#), ensg(g#)) = esg(g#):
   thm
val nsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(sgrp(g#))).
        nsg(h#) = App(LINV(Rnsg(g#), ensg(g#)), h#): thm
val qgR_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        Holds(qgR(H#), a#, b#) <=> lcs(a#, rnsg(H#)) = lcs(b#, rnsg(H#)): thm
val rnsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rnsg(H#) = App(Rnsg(g#), H#): thm
val qgR_Refl =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Refl(qgR(H#)):
   thm
val qgR_Sym =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Sym(qgR(H#)):
   thm
val qgR_Trans =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Trans(qgR(H#)):
   thm
val qgR_ER =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). ER(qgR(H#)):
   thm
val css_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Inj(Rcss(H#)) &
        !(a : mem(Pow(G#))).
          (?(a : mem(G#)). a# = rsi(qgR(H#), a#)) <=>
          ?(b : mem(css(H#))). a# = App(Rcss(H#), b#): thm
val Rcss_Inj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Inj(Rcss(H#)):
   thm
val rcss_def =
   {(G : set), (H : mem(nsgrp(g))), (cs : mem(css(H))), (g : mem(Grp(G)))}, 
   |- rcss(cs) = App(Rcss(H), cs): thm
val rcss_eq_eq =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (a : mem(css(H#)))  (b : mem(css(H#))). rcss(a#) = rcss(b#) <=> a# = b#:
   thm
val mem_css_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ?!(a : mem(css(H#))). rcss(a#) = rsi(qgR(H#), eof(g#)): thm
val Quot_qgR_Rcss =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(qgR(H#), Rcss(H#)): thm
val cs_def =
   {}, 
   |- !(G : set)  (a : mem(G#))  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        cs(a#, H#) = abs(qgR(H#), Rcss(H#), ecs(H#), a#): thm
val ecs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rcss(ecs(H#)) = rsi(qgR(H#), eof(g#)): thm
val rcss_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcss(cs(a#, H#)) = rsi(qgR(H#), a#): thm
val nsgrp_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val nsgrp_swap_l2r =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, a#, h#) = gmul(g#, h#, a#): thm
val smul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, smul(g#, s1#, s2#)) <=>
        ?(x : mem(G#))  (y : mem(G#)).
          IN(x#, s1#) & IN(y#, s2#) & a# = gmul(g#, x#, y#): thm
val nsgrp_swap_r2l =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, h#, a#) = gmul(g#, a#, h#): thm
val rsg_issgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        issgrp(rsg(H#), g#): thm
val e_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        IN(eof(g#), rsg(H#)): thm
val gmul_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h1 : mem(G#)).
        IN(h1#, rsg(H#)) ==>
        !(h2 : mem(G#)). IN(h2#, rsg(H#)) ==> IN(gmul(g#, h1#, h2#), rsg(H#)):
   thm
val ginv_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(H#)) ==> IN(ginv(g#, h#), rsg(H#)): thm
val gmul_lcs_smul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        lcs(gmul(g#, a#, b#), rnsg(H#)) =
          smul(g#, lcs(a#, rnsg(H#)), lcs(b#, rnsg(H#))): thm
val mof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o mof(g#),
       prrel(qgR(H#), qgR(H#))): thm
val prrel_qgR_ER =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ER(prrel(qgR(H#), qgR(H#))): thm
val qgR_Rcss_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#))): thm
val qgR_Rcss_abs_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        abs(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#)),
           Pair(ecs(H#), ecs(H#)), Pair(a#, b#)) =
          Pair(abs(qgR(H#), Rcss(H#), ecs(H#), a#),
           abs(qgR(H#), Rcss(H#), ecs(H#), b#)): thm
val ginv_oneside =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        gmul(g#, a#, a1#) = eof(g#) <=> gmul(g#, a1#, a#) = eof(g#): thm
val mulcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        mul(mulcs(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val sinv_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, sinv(g#, s#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = ginv(g#, x#): thm
val is_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        a# = eof(g#) <=>
        (?(x : mem(G#)). gmul(g#, a#, x#) = x#) |
        ?(x : mem(G#)). gmul(g#, x#, a#) = x#: thm
val ginv_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#)).
        ginv(g#, gmul(g#, a#, b#)) = gmul(g#, ginv(g#, b#), ginv(g#, a#)):
   thm
val ginv_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        ginv(g#, ginv(g#, a#)) = a#: thm
val ginv_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        lcs(ginv(g#, a#), rnsg(H#)) = sinv(g#, lcs(a#, rnsg(H#))): thm
val iof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o iof(g#), qgR(H#)): thm
val invcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(invcs(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_Surj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Surj(qmap(H#)):
   thm
val qmap_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qmap(H#) = Abs(qgR(H#), Rcss(H#), ecs(H#)): thm
val css_rep_ex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (b : mem(css(H#))). ?(a : mem(G#)). b# = cs(a#, H#): thm
val ecs_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ecs(H#) = cs(eof(g#), H#): thm
val mulcs_invcs_ecs_isgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isgrp(Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#)))): thm
val mof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        mof(qgrp(H#)) = mulcs(H#): thm
val qgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        RepG(qgrp(H#)) = Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#))):
   thm
val iof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        iof(qgrp(H#)) = invcs(H#): thm
val eof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        eof(qgrp(H#)) = ecs(H#): thm
val gmul_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        gmul(qgrp(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val ginv_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : set). ginv(qgrp(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(qmap(H#), a#) = cs(a#, H#): thm
val qmap_isghom =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isghom(qmap(H#), g#, qgrp(H#)): thm
val constf_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        isghom(constf(G1#, eof(g2#)), g1#, g2#): thm
val ghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)) &
        !(a : mem(Exp(G1#, G2#))).
          isghom(tof(a#), g1#, g2#) <=>
          ?(b : mem(ghom(g1#, g2#))). a# = App(ih(g1#, g2#), b#): thm
val ghom_ex_uex =
   {(G1 : set), (G2 : set), (g1 : mem(Grp(G1))), (g2 : mem(Grp(G2)))}, 
   |- !(b : mem(Exp(G1, G2))).
        (?(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#) <=>
        ?!(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#: thm
val ghom_uex =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (a : mem(Exp(G1#, G2#))).
        isghom(tof(a#), g1#, g2#) ==>
        ?!(a : mem(ghom(g1#, g2#))). App(ih(g1#, g2#), a#) = a#: thm
val ih_Inj =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)): thm
val eghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        App(ih(g1#, g2#), eghm(g1#, g2#)) = Tpm(constf(G1#, eof(g2#))): thm
val ghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : fun(G1#, G2#)).
        ghm(h#, g1#, g2#) = App(LINV(ih(g1#, g2#), eghm(g1#, g2#)), Tpm(h#)):
   thm
val homfun_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : mem(ghom(g1#, g2#))). homfun(h#) = tof(App(ih(g1#, g2#), h#)): thm
val isghom_homfun_ghm =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : fun(G1#, G2#)).
        isghom(f#, g1#, g2#) <=> homfun(ghm(f#, g1#, g2#)) = f#: thm
val IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#)).
        IN(x#, kers(f#)) <=> App(homfun(f#), x#) = eof(g2#): thm
val ker_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). ker(f#) = nsg(sg(kers(f#), g1#)): thm
val kers_def =
   {(G1 : set), (G2 : set), (f : mem(ghom(g1, g2))), (g1 : mem(Grp(G1))),
    (g2 : mem(Grp(G2)))},  |- kers(f) = PREIM(homfun(f), Sing(eof(g2))): thm
val sg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(Pow(G#))).
        sg(h#, g#) = App(LINV(Rsg(g#), esg(g#)), h#): thm
val homfun_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isghom(homfun(f#), g1#, g2#): thm
val homfun_gmul =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#))  (y : mem(G1#)).
        App(homfun(f#), gmul(g1#, x#, y#)) =
          gmul(g2#, App(homfun(f#), x#), App(homfun(f#), y#)): thm
val homfun_e =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). App(homfun(f#), eof(g1#)) = eof(g2#): thm
val homfun_ginv =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a : mem(G1#)).
        App(homfun(f#), ginv(g1#, a#)) = ginv(g2#, App(homfun(f#), a#)): thm
val e_IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). IN(eof(g1#), kers(f#)): thm
val kers_issgrp =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). issgrp(kers(f#), g1#): thm
val cjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (h : mem(G))}, 
   |- cjg(g, a, h) = gmul(g, a, gmul(g, h, ginv(g, a))): thm
val lsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (s : mem(Pow(G#))).
        lsmul(g#, a#, lsmul(g#, b#, s#)) = lsmul(g#, gmul(g#, a#, b#), s#):
   thm
val qhom_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qhom(H#) = ghm(qmap(H#), g#, qgrp(H#)): thm
val rsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        rsmul(g#, rsmul(g#, s#, a#), b#) = rsmul(g#, s#, gmul(g#, a#, b#)):
   thm
val lsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        lsmul(g#, eof(g#), s#) = s#: thm
val rsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        rsmul(g#, s#, eof(g#)) = s#: thm
val lsmul_rsmul_comm =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#)))
      (b : mem(G#)).
        rsmul(g#, lsmul(g#, a#, s#), b#) = lsmul(g#, a#, rsmul(g#, s#, b#)):
   thm
val isnml_alt =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). scjg(g#, a#, rsg(H#)) = rsg(H#): thm
val scjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (s : mem(Pow(G)))}, 
   |- scjg(g, a, s) = lsmul(g, a, rsmul(g, s, ginv(g, a))): thm
val scjg_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (H : mem(Pow(G#)))
      (x : mem(G#)).
        IN(x#, scjg(g#, a#, H#)) <=>
        ?(h : mem(G#)). IN(h#, H#) & x# = cjg(g#, a#, h#): thm
val SS_scjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#))).
        SS(scjg(g#, a#, s#), s#) <=>
        !(x : mem(G#)). IN(x#, s#) ==> IN(cjg(g#, a#, x#), s#): thm
val SS_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(rsmul(g#, s1#, a#), rsmul(g#, s2#, a#)): thm
val SS_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val isnml_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). SS(scjg(g#, a#, rsg(H#)), rsg(H#)): thm
val IN_gmul_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, H#) <=>
        !(b : mem(G#)). IN(gmul(g#, a#, b#), rsmul(g#, H#, b#)): thm
val IN_gmul_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (b : mem(G#)).
        IN(b#, H#) <=>
        !(a : mem(G#)). IN(gmul(g#, a#, b#), lsmul(g#, a#, H#)): thm
val gmul_IN_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val gmul_IN_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val rnsg_isnml =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). isnml(rnsg(H#)):
   thm
val rnsg_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val SS_ex_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        ?(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val same_cs_cond =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        cs(a#, H#) = cs(b#, H#) <=>
        IN(gmul(g#, a#, ginv(g#, b#)), rsg(rnsg(H#))): thm
val sg_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        sg(rsg(H#), g#) = H#: thm
val nsg_rnsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        nsg(rnsg(H#)) = H#: thm
val issgrp_rsg_sg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#))).
        issgrp(H#, g#) <=> rsg(sg(H#, g#)) = H#: thm
val isnml_rnsg_nsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> rnsg(nsg(H#)) = H#: thm
val sg_kers_isnml =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isnml(sg(kers(f#), g1#)): thm
val rsg_rnsg_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rsg(rnsg(ker(f#))) = kers(f#): thm
val rgh_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rgh(f#) = App(ih(g1#, g2#), f#): thm
val rgh_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        rgh(f1#) = rgh(f2#) <=> f1# = f2#: thm
val homfun_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        homfun(f1#) = homfun(f2#) <=> f1# = f2#: thm
val homfun_eq_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a1 : mem(G1#))  (a2 : mem(G1#)).
        App(homfun(f#), a1#) = App(homfun(f#), a2#) <=>
        App(homfun(f#), gmul(g1#, ginv(g1#, a1#), a2#)) = eof(g2#): thm
val homfun_resp1_qgR_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). resp1(homfun(f#), qgR(ker(f#))): thm
val first_iso_thm =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))).
        ?!(fb : mem(ghom(qgrp(ker(f#)), g2#))).
          Inj(homfun(fb#)) & homfun(fb#) o qmap(ker(f#)) = homfun(f#): thm
val it = (): unit
******

Loading SEAR file SEARexamplecol.sml

******
val AX5 =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
val cardeq_REFL = {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, s#): thm
val cardeq_def =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=>
      ?(R : rel(A, B)).
        (!(a : mem(A)).
            IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R#, a#, b#)) &
        !(b : mem(B)).
          IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R#, a#, b#): thm
val isset_def =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
val cardeq_SYM =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(s2#, s1#): thm
val cardeq_TRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#))).
          cardeq(s2#, s3#) ==> cardeq(s1#, s3#): thm
val restrict_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (R : rel(A#, B#))
      (s2 : mem(Pow(B#)))  (a : mem(A#))  (b : mem(B#)).
        Holds(restrict(R#, s1#, s2#), a#, b#) <=>
        IN(a#, s1#) & IN(b#, s2#) & Holds(R#, a#, b#): thm
val cardeq_Whole_Inj_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set).
        cardeq(s#, Whole(B#)) ==>
        ?(i : fun(B#, A#)). Inj(i#) & IMAGE(i#, Whole(B#)) = s#: thm
val cardeq_Inj_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> cardeq(Whole(A#), IMAGE(f#, Whole(A#))): thm
val Inj_Image =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Inj(f#) ==> Inj(Image(f#)):
   thm
val IMAGE_INJ_cardeq =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#)))
      (f : fun(A#, B#)).
        INJ(f#, s1#, s2#) ==>
        !(s01 : mem(Pow(A#))).
          SS(s01#, s1#) ==> cardeq(s01#, IMAGE(f#, s01#)): thm
val INJ_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (t : mem(Pow(B#))).
        INJ(f#, s#, t#) <=>
        (!(x : mem(A#)). IN(x#, s#) ==> IN(App(f#, x#), t#)) &
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==> App(f#, x#) = App(f#, y#) ==> x# = y#:
   thm
val Inj_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). INJ(f#, s#, IMAGE(f#, s#)): thm
val INJ_SS_dom =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(A#))). SS(s#, s1#) ==> INJ(f#, s#, s2#): thm
val INJ_SS_cod =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(B#))). SS(s2#, s#) ==> INJ(f#, s1#, s#): thm
val o_INJ_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(C : set)  (g : fun(B#, C#))  (s3 : mem(Pow(C#))).
          INJ(g#, s2#, s3#) ==> INJ(g# o f#, s1#, s3#): thm
val cardeq_Inj_IMAGE_gen =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). cardeq(s#, IMAGE(f#, s#)): thm
val INJ_INS_NONE =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X# + 1)))).
        (!(s0 : mem(Pow(X# + 1))). IN(s0#, s#) ==> ~IN(NONE(X#), s0#)) ==>
        INJ(INS(NONE(X#)), s#, IMAGE(INS(NONE(X#)), s#)): thm
val INS_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (a : mem(Pow(X#))).
        App(INS(x0#), a#) = Ins(x0#, a#): thm
val POW_Whole_Pow = {},  |- !(A : set). POW(Whole(A#)) = Whole(Pow(A#)): thm
val POW_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (a : mem(Pow(A#))).
        IN(a#, POW(s0#)) <=> SS(a#, s0#): thm
val cardeq_POW_Whole_Pow =
   {},  |- !(A : set). cardeq(POW(Whole(A#)), Whole(Pow(A#))): thm
val FIB_constf =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#)).
        FIB(constf(A#, b#), b#) = Whole(A#): thm
val nPow_def =
   {}, 
   |- !(A : set)  (B : set)  (n : mem(N)).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)).
          cardeq(FIB(f#, O), Whole(A#)) &
          cardeq(FIB(f#, n#), Whole(B#)) &
          !(n0 : mem(N)).
            Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPow_O = {},  |- !(A : set). nPow(O, A#, A#): thm
val OE_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- OE(f, b0) = coPa(f, El(b0)): thm
val Sg_Sing = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Sgf_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- (!(a : mem(A)). App(Sgf(f, b0), Sing(a#)) = App(f, a#)) &
      !(s : mem(Pow(A))).
        (!(a : mem(A)). ~s# = Sing(a#)) ==> App(Sgf(f, b0), s#) = b0: thm
val content_Sing =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        App(content(x0#), Sing(x#)) = x#: thm
val content_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#)).
        (!(s : mem(Pow(X#)))  (x : mem(X#)).
            s# = Sing(x#) ==> App(content(x0#), s#) = x#) &
        !(s : mem(Pow(X#))).
          (!(x : mem(X#)). ~s# = Sing(x#)) ==> App(content(x0#), s#) = x0#:
   thm
val ctt_def =
   {}, 
   |- !(X : set)  (s : mem(Pow(X#)))  (x0 : mem(X#)).
        ctt(s#, x0#) = App(content(x0#), s#): thm
val PREIM_i1_Sing_SOME =
   {(X : set), (x0 : mem(X))},  |- PREIM(i1(X, 1), Sing(SOME(x0))) = Sing(x0):
   thm
val IMAGE_Sing =
   {(A : set), (B : set), (a : mem(A)), (f : fun(A, B))}, 
   |- IMAGE(f, Sing(a)) = Sing(App(f, a)): thm
val ctt_Sing =
   {},  |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)). ctt(Sing(a#), a0#) = a#:
   thm
val Sing_SOME_NEQ_Ins_NONE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A# + 1))).
        ~Sing(SOME(a#)) = Ins(NONE(A#), s#): thm
val SS_Ri_restrict =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (a : mem(Pow(A#)))  (B : set)
      (R : rel(A#, B#))  (s2 : mem(Pow(B#))).
        SS(App(Ri(restrict(R#, s1#, s2#)), a#), s2#): thm
val biunique_def =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) <=>
      (!(a : mem(A)).
          IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R, a#, b#)) &
      !(b : mem(B)).
        IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R, a#, b#): thm
val nPow_Suc_ex_lemma =
   {}, 
   |- !(C : set)  (X : set)  (i : fun(C#, Pow(X#))).
        Inj(i#) ==>
        !(B : set)  (f : fun(X#, B#))  (bs : mem(Pow(B#)))  (b0 : mem(B#)).
          (!(x : mem(X#)). ~App(f#, x#) = b0#) ==>
          ~IN(b0#, bs#) ==>
          !(b1 : mem(B#)).
            ~b1# = b0# & ~IN(b1#, bs#) ==>
            ?(f1 : fun(Pow(X# + 1), B#)).
              (!(b : mem(B#)).
                  IN(b#, bs#) ==>
                  FIB(f1#, b#) = IMAGE(Sg(X# + 1) o i1(X#, 1), FIB(f#, b#))) &
              FIB(f1#, b0#) =
                IMAGE(INS(NONE(X#)) o Image(i1(X#, 1)) o i#, Whole(C#)): thm
val biunique_op =
   {(A : set), (B : set)}, 
   |- !(R : rel(A, B))  (s1 : mem(Pow(A)))  (s2 : mem(Pow(B))).
        biunique(R#, s1#, s2#) ==> biunique(op(R#), s2#, s1#): thm
val biunique_Ri_restrict =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) ==>
      !(s : mem(Pow(A))).
        SS(s#, s1) ==>
        App(Ri(restrict(op(R), s2, s1)), App(Ri(restrict(R, s1, s2)), s#)) =
          s#: thm
val cardeq_POW =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(POW(s1#), POW(s2#)): thm
val cardeq_biunique =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=> ?(R : rel(A, B)). biunique(R#, s1, s2): thm
val cardeq_BITRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#)))  (D : set)  (s4 : mem(Pow(D#))).
          cardeq(s3#, s4#) ==> (cardeq(s1#, s3#) <=> cardeq(s2#, s4#)): thm
val NONE_NOTIN_IMAGE_i1 =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X#))))  (s0 : mem(Pow(X# + 1))).
        IN(s0#, IMAGE(Image(i1(X#, 1)), s#)) ==> ~IN(NONE(X#), s0#): thm
val shrink_IMAGE =
   {}, 
   |- !(X : set)  (B : set)  (f0 : fun(X#, B#))  (s : mem(Pow(B#)))
      (b0 : mem(B#)).
        ~IN(b0#, s#) ==>
        (!(b : mem(B#)).
            IN(b#, s#) ==> FIB(shrink(f0#, s#, b0#), b#) = FIB(f0#, b#)) &
        !(x : mem(X#)).
          ~IN(App(f0#, x#), s#) ==> App(shrink(f0#, s#, b0#), x#) = b0#: thm
val shrink_def =
   {(B : set), (X : set), (b0 : mem(B)), (f0 : fun(X, B)), (s : mem(Pow(B)))},
   
   |- !(a : mem(X)).
        (IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = App(f0, a#)) &
        (~IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = b0): thm
val nPow_shrink_IMAGE_ex =
   {(A : set), (An : set), (n : mem(N))}, 
   |- nPow(n, A, An) ==>
      ?(X : set)  (f : fun(X#, N)).
        cardeq(FIB(f#, O), Whole(A)) &
        cardeq(FIB(f#, n), Whole(An)) &
        (!(n0 : mem(N)).
            Lt(n0#, n) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#)))) &
        !(x : mem(X#)). ~App(f#, x#) = Suc(n): thm
val nPow_Suc =
   {(n : mem(N))}, 
   |- !(A : set)  (An : set). nPow(n, A#, An#) ==> nPow(Suc(n), A#, Pow(An#)):
   thm
val nPow_ex =
   {},  |- !(A : set)  (n : mem(N)). ?(An : set). nPow(n#, A#, An#): thm
val cardeq_m2s =
   {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, Whole(m2s(s#))): thm
val m2s_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Inj(minc(s#)) &
        !(a : mem(A#)).
          IN(a#, s#) <=> ?(b : mem(m2s(s#))). a# = App(minc(s#), b#): thm
val nPowf_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, N))  (n : mem(N)).
        nPowf(n#, A#, B#, f#) <=>
        cardeq(FIB(f#, O), Whole(A#)) &
        cardeq(FIB(f#, n#), Whole(B#)) &
        !(n0 : mem(N)).
          Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPowf_Preds =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> ?(B0 : set). nPowf(n0#, A#, B0#, f#):
   thm
val nPowf_Preds_FIB =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> nPowf(n0#, A#, m2s(FIB(f#, n0#)), f#):
   thm
val nPow_nPowf =
   {}, 
   |- !(A : set)  (n : mem(N))  (B : set).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)). nPowf(n#, A#, B#, f#): thm
val nPow_unique =
   {}, 
   |- !(A : set)  (n : mem(N))  (An1 : set)  (An2 : set).
        nPow(n#, A#, An1#) & nPow(n#, A#, An2#) ==>
        cardeq(Whole(An1#), Whole(An2#)): thm
val nPow_uex =
   {}, 
   |- !(A : set)  (n : mem(N)).
        ?(An : set).
          nPow(n#, A#, An#) &
          !(An1 : set).
            nPow(n#, A#, An1#) ==> cardeq(Whole(An#), Whole(An1#)): thm
val Pn_def = {},  |- !(A : set)  (n : mem(N)). nPow(n#, A#, Pn(A#, n#)): thm
val cardeq_Whole_REFL = {},  |- !(An : set). cardeq(Whole(An#), Whole(An#)):
   thm
val cardeq_Whole_SYM =
   {}, 
   |- !(An : set)  (An' : set).
        cardeq(Whole(An#), Whole(An'#)) ==> cardeq(Whole(An'#), Whole(An#)):
   thm
val cardeq_Whole_TRANS =
   {}, 
   |- !(An : set)  (An' : set)  (An'' : set).
        cardeq(Whole(An#), Whole(An'#)) & cardeq(Whole(An'#), Whole(An''#)) ==>
        cardeq(Whole(An#), Whole(An''#)): thm
val isset_minc = {},  |- !(A : set)  (s : mem(Pow(A#))). isset(minc(s#), s#):
   thm
val large_ex =
   {}, 
   |- !(A : set).
        ?(P : set). !(n : mem(N)). ?(i : fun(Pn(A#, n#), P#)). Inj(i#): thm
val nPow_ts_ex = {},  |- !(A : set)  (n : mem(N)). ?(An : set). T: thm
val it = (): unit
val it = (): unit
> # # # # # # # val isset_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (A0 : set)
      (i : fun(A0#, A#))  (b : mem(B#)).
        isset(i#, FIB(f#, b#)) ==> f# o i# = constf(A0#, b#): thm
> > val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
               ?(V : set)  (p : fun(V#, U)).
                 Surj(p#) &
                 ?(A : set)  (fa : fun(A#, V#)).
                   !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                     isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol5pJSPOScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holKLF1HUScript.sml

******
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holKLF1HUScript.sml:14: error: Type error in function application.
   Function: strip_tac : tactic
   Argument: qby_tac : form frag list -> tactic
   Reason:
      Can't unify cont * form list * form to form frag list -> tactic
         (Incompatible types)
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (... >> ... >> ... ... >-- arw [...]) before
     Feedback.set_trace "show_typecheck_errors" old end)
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holKLF1HUScript.sml:14: error: Type error in function application.
   Function: strip_tac qby_tac : goal list * validation
   Argument:
      [QUOTE " (*#loc 44 17*)Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))"] :
      'a frag list
   Reason: Value being applied does not have a function type
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (... >> ... >> ... ... >-- arw [...]) before
     Feedback.set_trace "show_typecheck_errors" old end)
Exception- Fail "Static Errors" raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holTGVxi6Script.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.Fst(App(inc, App(i, x1))) = Fst(Pair(a, b))
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = a ==> a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   a' = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x2))) = a' ==> a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(Pair(a, b)) = Fst(App(inc, App(i, x2)))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = a'
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x2))) = a' ==> a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.Inj(i)
   9.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   10.App(inc, App(i, x1)) = Pair(a, b)
   11.App(inc, App(i, x2)) = Pair(a', b')
   12.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   p1(B, Y) o inc o i = constf(vA, v) ==>
             Fst(App(inc, App(i, x2))) = a' ==>
             a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   
   ----------------------------------------------------------------------
   p1(B, Y) o inc o i = constf(vA, v) ==>
             Fst(App(inc, App(i, x2))) = a' ==>
             a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.p1(B, Y) o inc o i = constf(vA, v)
   2.Fst(App(inc, App(i, x2))) = a'
   ----------------------------------------------------------------------
   a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.p1(B, Y) o inc o i = constf(vA, v)
   2.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.p1(B, Y) o inc o i = constf(vA, v)
   2.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x2))) = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.p1(B, Y) o inc o i = constf(vA, v)
   2.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(App(inc o i, x2)) = Fst(App(inc o i, x1))
   : proofmanager.proof
> # val it =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p1(A, B), x) = Fst(x):
   thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.p1(B, Y) o inc o i = constf(vA, v)
   2.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   App(constf(vA, v), x2) = App(constf(vA, v), x1)
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.p1(B, Y) o inc o i = constf(vA, v)
   2.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(App(inc o i, x2)) = Fst(App(inc o i, x1))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i) & IMAGE(p2(B, Y) o inc o i, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   IMAGE(p2(B, Y) o inc o i, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   !(x : mem(Y)).
               (?(a : mem(vA)). x# = App(p2(B, Y) o inc o i, a#)) <=>
               IN(x#, rsi(M, v))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   IMAGE(p2(B, Y) o inc o i, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   !(x : mem(Y)).
               (?(a : mem(vA)). x# = App(p2(B, Y) o inc o i, a#)) <=>
               IN(x#, App(Rsi(M), v))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   IMAGE(p2(B, Y) o inc o i, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   !(x : mem(Y)).
               (?(a : mem(vA)). x# = App(p2(B, Y) o inc o i, a#)) <=>
               IN(x#, rsi(M, v))
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
> val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   IMAGE(p2(B, Y) o inc o i, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   !(x : mem(Y)).
               (?(a : mem(vA)). x# = App(p2(B, Y) o inc o i, a#)) <=>
               IN(x#, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   !(x : mem(Y)).
               (?(a : mem(vA)). x# = App(p2(B, Y) o inc o i, a#)) <=>
               IN(x#, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y) o inc o i, a#)) <=> IN(x, rsi(M, v))
   : proofmanager.proof
> IN_rsi;
val it =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y) o inc o i, a#)) <=>
             IN(x, App(Ri(M) o Sg(B), v))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y) o inc o i, a#)) <=> IN(x, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y) o inc o i, a#)) <=>
             IN(x, App(Ri(M) o Sg(B), v))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y) o inc o i, a#)) <=> IN(x, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))) <=>
             ?(a : mem(B)). IN(a#, App(Sg(B), v)) & Holds(M, a#, x)
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set)  (a : mem(A#))  (a0 : mem(A#)).
        IN(a0#, App(Sg(A#), a#)) <=> a0# = a#: thm
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y) o inc o i, a#)) <=> IN(x, rsi(M, v))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   (?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))) <=>
             ?(a : mem(B)). a# = v & Holds(M, a#, x)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.a = v
   9.Holds(M, a, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.x = App(p2(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   ?(a : mem(B)). a# = v & Holds(M, a#, x)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.x = App(p2(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   v = v & Holds(M, v, x)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.x = App(p2(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   Holds(M, v, x)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.x = App(p2(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   Holds(M, v, App(p2(B, Y), App(inc, App(i, a))))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("drule.find", [], [], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, Fst(Pair(v, App(p2(B, Y), App(inc, App(i, a))))),
              Snd(Pair(v, App(p2(B, Y), App(inc, App(i, a)))))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   ----------------------------------------------------------------------
   Holds(M, v, App(p2(B, Y), App(inc, App(i, a))))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(b : mem(R)). Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   ----------------------------------------------------------------------
   Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, App(i, a))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- Fail "match_term.unexpected term constructor" raised
> # val it =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#): thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- Fail "match_term.unexpected term constructor" raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.?(a' : mem(B))  (b : mem(Y)). App(inc, App(i, a)) = Pair(a'#, b#)
   ----------------------------------------------------------------------
   Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, App(i, a))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   ----------------------------------------------------------------------
   Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, App(i, a))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   ----------------------------------------------------------------------
   Pair(v, App(p2(B, Y), Pair(b, y))) = Pair(b, y)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   ----------------------------------------------------------------------
   Pair(v, App(p2(B, Y), Pair(b, y))) = Pair(b, y)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   ----------------------------------------------------------------------
   Pair(v, y) = Pair(b, y)
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   ----------------------------------------------------------------------
   Pair(v, App(p2(B, Y), Pair(b, y))) = Pair(b, y)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   ----------------------------------------------------------------------
   v = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.App(p1(B, Y), App(inc, App(i, a))) = App(p1(B, Y), Pair(b, y))
   ----------------------------------------------------------------------
   v = b
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   ----------------------------------------------------------------------
   App(p1(B, Y), App(inc, App(i, a))) = App(p1(B, Y), Pair(b, y))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = App(p2(B, Y), App(inc, App(i, a)))
   8.Holds(M, v, App(p2(B, Y), App(inc, App(i, a)))) <=>
             ?(b : mem(R)).
               Pair(v, App(p2(B, Y), App(inc, App(i, a)))) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.App(p1(B, Y), App(inc, App(i, a))) = App(p1(B, Y), Pair(b, y))
   ----------------------------------------------------------------------
   v = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = y
   8.Holds(M, v, y) <=> ?(b : mem(R)). Pair(v, y) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.App(p1(B, Y), App(inc, App(i, a))) = b
   ----------------------------------------------------------------------
   v = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = y
   8.Holds(M, v, y) <=> ?(b : mem(R)). Pair(v, y) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.b = App(p1(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   v = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Process HOL killed: 9
> Loading empty hol-mode.sml
> > > use "SEARmaster.ML";
val use = fn: string -> unit
******

Loading SEAR file SEARsorts.sml

******
val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = set: sort
val it = (): unit
******

Loading SEAR file SEARnewspec.sml

******
val define_fsym = fn: string * (string * sort) list -> term -> thm
val define_fsym_lemma_fun =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : fun(A#, B#)).
        ?!(newfsym : fun(A#, B#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_mem =
   {}, 
   |- !(A : set)  (newfsym0 : mem(A#)).
        ?!(newfsym : mem(A#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_rel =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : rel(A#, B#)).
        ?!(newfsym : rel(A#, B#)). newfsym# = newfsym0#: thm
val funeqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : fun(A#, B#)). i# = i#) &
        (!(i : fun(A#, B#))  (i' : fun(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : fun(A#, B#))  (i' : fun(A#, B#))  (i'' : fun(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val memeqeqvth =
   {}, 
   |- !(A : set).
        (!(i : mem(A#)). i# = i#) &
        (!(i : mem(A#))  (i' : mem(A#)). i# = i'# ==> i'# = i#) &
        !(i : mem(A#))  (i' : mem(A#))  (i'' : mem(A#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val qdefine_fsym = fn: string * term frag list list -> term frag list -> thm
val qsimple_uex_spec = fn: string -> term frag list list -> thm -> thm
val quex_spec = fn: string -> term frag list list -> thm -> thm -> thm
val releqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : rel(A#, B#)). i# = i#) &
        (!(i : rel(A#, B#))  (i' : rel(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : rel(A#, B#))  (i' : rel(A#, B#))  (i'' : rel(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val simple_uex_spec = fn: string -> (string * sort) list -> thm -> thm
val uex_spec = fn: string -> (string * sort) list -> thm -> thm -> thm
val it = (): unit
******

Loading SEAR file SEARrel.sml

******
val AX1 =
   {}, 
   |- !(A : set)  (B : set).
        ?!(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val Fun_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=> !(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#): thm
val R_EXT =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        (!(a : mem(A#))  (b : mem(B#)).
            Holds(R1#, a#, b#) <=> Holds(R2#, a#, b#)) <=> R1# = R2#: thm
val AX1_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val ao_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, c#)) <=>
        Holds(psi# @ phi#, a#, c#): thm
val ao_def0 =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (b : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, b#)) <=>
        Holds(psi# @ phi#, a#, b#): thm
val ao_uex =
   {(A : set), (B : set), (C : set), (phi : rel(A, B)), (psi : rel(B, C))}, 
   |- ?!(R : rel(A, C)).
        !(a : mem(A))  (b : mem(C)).
          Holds(R#, a#, b#) <=>
          ?(b : mem(B)). Holds(phi, a#, b#) & Holds(psi, b#, b#): thm
val Fun_expand =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=>
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) &
        !(a : mem(A#))  (b1 : mem(B#))  (b2 : mem(B#)).
          Holds(R#, a#, b1#) & Holds(R#, a#, b2#) ==> b1# = b2#: thm
val id_Fun = {},  |- !(A : set). isFun(id(A#)): thm
val id_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)).
        Holds(id(A#), a#, b#) <=> a# = b#: thm
val id_uex =
   {(A : set)}, 
   |- ?!(R : rel(A, A)).
        !(a : mem(A))  (b : mem(A)). Holds(R#, a#, b#) <=> a# = b#: thm
val idL = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). id(B#) @ f# = f#:
   thm
val idR = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). f# @ id(A#) = f#:
   thm
val Thm_2_7_ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val Thm_2_7_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val Thm_2_7_id =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#)).
        phi# @ id(A#) = phi# & id(B#) @ phi# = phi#: thm
val op_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(B#))  (b : mem(A#)).
        Holds(op(R#), a#, b#) <=> Holds(R#, b#, a#): thm
val op_uex =
   {(A : set), (B : set), (R : rel(A, B))}, 
   |- ?!(R' : rel(B, A)).
        !(a : mem(B))  (b : mem(A)). Holds(R'#, a#, b#) <=> Holds(R, b#, a#):
   thm
val ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val ao_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val op_DISTR =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#)). op(psi# @ phi#) = op(phi#) @ op(psi#): thm
val Refl_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> !(a : mem(A#)). Holds(R#, a#, a#): thm
val Sym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> Holds(R#, a2#, a1#): thm
val Trans_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Trans(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#))  (a3 : mem(A#)).
          Holds(R#, a1#, a2#) & Holds(R#, a2#, a3#) ==> Holds(R#, a1#, a3#):
   thm
val ER_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) <=> Refl(R#) & Sym(R#) & Trans(R#): thm
val Sym_Trans_Rright =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) & Trans(R#) ==>
        !(x : mem(A#))  (y : mem(A#)).
          Holds(R#, x#, y#) ==>
          !(z : mem(A#)). Holds(R#, x#, z#) <=> Holds(R#, y#, z#): thm
val op_op =
   {},  |- !(A : set)  (B : set)  (R : rel(A#, B#)). op(op(R#)) = R#: thm
val it = (): unit
******

Loading SEAR file SEARfun.sml

******
val rel2fun =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val rel2fun_ex =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val rel2fun_ex' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val asR_Fun =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). isFun(asR(f#)): thm
val asR_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- !(a : mem(A))  (b : mem(B)). Holds(asR(f), a#, b#) <=> App(f, a#) = b#:
   thm
val asR_uex =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- ?!(R : rel(A, B)).
        !(a : mem(A))  (b : mem(B)). Holds(R#, a#, b#) <=> App(f, a#) = b#:
   thm
val FUN_EXT =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        (!(a : mem(A#)). App(f1#, a#) = App(f2#, a#)) <=> f1# = f2#: thm
val P2fun_uex =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val fun_tm_compr = fn: string * sort -> term -> thm
val fun_tm_compr_uex = fn: string * sort -> term -> thm
val qfun_compr = fn: term frag list -> term frag list -> thm
val unique_lemma =
   {},  |- !(A : set)  (a : mem(A#)). ?!(a' : mem(A#)). a'# = a#: thm
val App_Id = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_def = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_uex =
   {(A : set)}, 
   |- ?!(f : fun(A, A)).
        !(a : mem(A))  (b : mem(A)).
          App(f#, a#) = b# <=> Holds(id(A), a#, b#): thm
val o_ex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val o_uex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?!(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val Inj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) <=>
        !(x1 : mem(A#))  (x2 : mem(A#)).
          App(f#, x1#) = App(f#, x2#) ==> x1# = x2#: thm
val o_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        App(psi# o phi#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#):
   thm
val Surj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) <=> !(b : mem(B#)). ?(a : mem(A#)). App(f#, a#) = b#: thm
val Bij_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> Inj(f#) & Surj(f#): thm
val Bij_op =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> ?(f' : fun(B#, A#)). asR(f'#) = op(asR(f#)): thm
val App_App_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val App_o_l =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val asR_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        asR(g# o f#) = asR(g#) @ asR(f#): thm
val asR_Id = {},  |- !(A : set). asR(Id(A#)) = id(A#): thm
val asR_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        asR(f1#) = asR(f2#) <=> f1# = f2#: thm
val Thm_2_7_bij =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#)).
        Bij(phi#) <=>
        ?(psi : fun(B#, A#)). psi# o phi# = Id(A#) & phi# o psi# = Id(B#):
   thm
val Inj_lcancel =
   {}, 
   |- !(A : set)  (B : set)  (m : fun(A#, B#)).
        Inj(m#) ==>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, A#)).
          m# o f# = m# o g# ==> f# = g#: thm
val IdL = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Id(B#) o f# = f#:
   thm
val IdR = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). f# o Id(A#) = f#:
   thm
val Inj_lift_R_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(R : rel(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?!(a2 : mem(A#)). Holds(R#, App(i#, a1#), App(i#, a2#))) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). Holds(R#, App(i#, a#), App(i# o f#, a#)): thm
val Inj_lift_fun_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val asR_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        Holds(asR(f#), a#, b#) <=> App(f#, a#) = b#: thm
val Inj_lift_fun_lemma' =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?!(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val Inj_eq_eq =
   {}, 
   |- !(X : set)  (Y : set)  (i : fun(X#, Y#)).
        Inj(i#) ==>
        !(x1 : mem(X#))  (x2 : mem(X#)).
          App(i#, x1#) = App(i#, x2#) <=> x1# = x2#: thm
val Inj_lift_fun =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?(f : fun(X#, A#)). !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#):
   thm
val Inj_lift_fun_uex =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?!(f : fun(X#, A#)).
            !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#): thm
val o_assoc =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (D : set)  (h : fun(C#, D#)). (h# o g#) o f# = h# o g# o f#: thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val P2fun_uex0 =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val it = (): unit
******

Loading SEAR file SEARsetting.sml

******
val AX0 = {},  |- ?(A : set)  (a : mem(A#)). T: thm
val Tab_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) <=>
        (!(x : mem(A#))  (y : mem(B#)).
            Holds(R#, x#, y#) <=>
            ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val AX2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        ?(TR : set)  (p : fun(TR#, A#))  (q : fun(TR#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              Holds(R#, x#, y#) <=>
              ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
          !(r : mem(TR#))  (s : mem(TR#)).
            App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Empty_unique =
   {}, 
   |- !(E1 : set)  (E2 : set).
        (!(a : mem(E1#)). F) & (!(a : mem(E2#)). F) ==>
        ?(i : fun(E1#, E2#))  (j : fun(E2#, E1#)).
          i# o j# = Id(E2#) & j# o i# = Id(E1#): thm
val Thm_2_2 = {},  |- ?(Empty : set). !(a : mem(Empty#)). F: thm
val Thm_2_3 =
   {},  |- ?(ONE : set)  (x : mem(ONE#)). !(x' : mem(ONE#)). x'# = x#: thm
val unique_fun_to_ONE =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#)).
        (!(a : mem(ONE#)). a# = x#) ==> !(A : set). ?!(f : fun(A#, ONE#)). T:
   thm
val ONE_unique =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#))  (ONE' : set)  (x' : mem(ONE'#)).
        (!(a : mem(ONE#)). a# = x#) & (!(a : mem(ONE'#)). a# = x'#) ==>
        ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
          i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso0_REFL =
   {}, 
   |- !(A : set).
        ?(i : fun(A#, A#))  (j : fun(A#, A#)).
          i# o j# = Id(A#) & j# o i# = Id(A#): thm
val iso0_SYM =
   {}, 
   |- !(A : set)  (A' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
        ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
          i# o j# = Id(A#) & j# o i# = Id(A'#): thm
val iso0_TRANS =
   {}, 
   |- !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_uex =
   {}, 
   |- ?(ONE : set).
        (?(x : mem(ONE#)). !(a : mem(ONE#)). a# = x#) &
        !(ONE' : set).
          (?(x : mem(ONE'#)). !(a : mem(ONE'#)). a# = x#) ==>
          ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
            i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso_Reqv =
   {}, 
   |- (!(A : set).
          ?(i : fun(A#, A#))  (j : fun(A#, A#)).
            i# o j# = Id(A#) & j# o i# = Id(A#)) &
      (!(A : set)  (A' : set).
          (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
              i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
          ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
            i# o j# = Id(A#) & j# o i# = Id(A'#)) &
      !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_def = {},  |- ?(x : mem(1)). !(a : mem(1)). a# = x#: thm
val dot_uex = {},  |- ?!(x : mem(1)). x# = x#: thm
val dot_def = {},  |- !(a : mem(1)). a# = dot: thm
val dot_def0 = {},  |- dot = dot: thm
val ONE = 1: term
val Thm_2_3_5 = {},  |- !(A : set). ?!(f : rel(A#, 1)). isFun(f#): thm
val To1_ex = {},  |- !(A : set). ?!(f : fun(A#, 1)). T: thm
val dot = dot: term
val To1_uex = {},  |- !(A : set). ?!(f : fun(A#, 1)). f# = f#: thm
val To1_def = {},  |- !(A : set)  (f' : fun(A#, 1)). f'# = To1(A#): thm
val To1_def0 = {(A : set)},  |- To1(A) = To1(A): thm
val Thm_2_4_R_ver =
   {}, 
   |- !(A : set)  (R : rel(1, A#)).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)).
            Holds(R#, dot, a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Rel_Pred1 =
   {}, 
   |- !(A : set).
        ?!(R : rel(1, A#)). !(a : mem(A#)). Holds(R#, dot, a#) <=> P(a#): thm
val Tab_App_Rel =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (x : mem(A#))  (y : mem(B#)).
          App(p#, r#) = x# & App(q#, r#) = y# ==> Holds(R#, x#, y#): thm
val Thm_2_4 =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Tab_mem_R =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#)). Holds(R#, App(p#, r#), App(q#, r#)): thm
val Tab_prop1 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(x : mem(A#))  (y : mem(B#)).
          Holds(R#, x#, y#) <=>
          ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#: thm
val T_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(T0 : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(T0#, a#, b#): thm
val T_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          (!(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#)) &
          !(R' : rel(A#, B#)).
            (!(a : mem(A#))  (b : mem(B#)). Holds(R'#, a#, b#)) ==> R'# = R#:
   thm
val Tab_prop2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Thm_2_5 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (T1 : set)
      (p1 : fun(T1#, A#))  (q1 : fun(T1#, B#))  (T2 : set)
      (p2 : fun(T2#, A#))  (q2 : fun(T2#, B#)).
        isTab(R#, p1#, q1#) & isTab(R#, p2#, q2#) ==>
        ?(b : fun(T1#, T2#)). Bij(b#): thm
val isPair_def =
   {(A : set), (AxB : set), (B : set), (p1 : fun(AxB, A)), (p2 : fun(AxB, B))},
   
   |- isPair(p1, p2) <=>
      !(x : mem(A))  (y : mem(B)).
        ?!(r : mem(AxB)). App(p1, r#) = x# & App(p2, r#) = y#: thm
val isPair_uex =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (p1 : fun(AB#, A#))
      (p2 : fun(AB#, B#))  (AB' : set)  (p1' : fun(AB'#, A#))
      (p2' : fun(AB'#, B#)).
        isPair(p1#, p2#) & isPair(p1'#, p2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          p1'# o i# = p1# &
          p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AxB : set)  (p1 : fun(AxB#, A#))  (p2 : fun(AxB#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              ?(r : mem(AxB#)). App(p1#, r#) = x# & App(p2#, r#) = y#) &
          !(r : mem(AxB#))  (s : mem(AxB#)).
            App(p1#, r#) = App(p1#, s#) & App(p2#, r#) = App(p2#, s#) ==>
            r# = s#: thm
val Pr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)).
          isPair(p1#, p2#) &
          !(AB' : set)  (p1' : fun(AB'#, A#))  (p2' : fun(AB'#, B#)).
            isPair(p1'#, p2'#) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_p12_def =
   {},  |- !(A : set)  (B : set). isPair(p1(A#, B#), p2(A#, B#)): thm
val Pr_ts_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)). T: thm
val isPair_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            p1# o i# = p1# & p2# o i# = p2# & p1# o j# = p1# & p2# o j# = p2#) &
      (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
        (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            p1# o i# = p1'# &
            p2# o i# = p2'# & p1'# o j# = p1# & p2'# o j# = p2#) &
      !(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
      (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B))  (AB'' : set)
      (p1'' : fun(AB''#, A))  (p2'' : fun(AB''#, B)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            p1'# o i# = p1# &
            p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            p1''# o i# = p1'# &
            p2''# o i# = p2'# & p1'# o j# = p1''# & p2'# o j# = p2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          p1''# o i# = p1# &
          p2''# o i# = p2# & p1# o j# = p1''# & p2# o j# = p2''#: thm
val p2_def =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#))  (y : mem(B#)).
            ?(r : mem(A# * B#)).
              App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#) &
        !(r : mem(A# * B#))  (s : mem(A# * B#)).
          App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
          App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val SetPr_def =
   {}, 
   |- !(A : set)  (AB : set)  (p1 : fun(AB#, A#))  (B : set)
      (p2 : fun(AB#, B#)).
        SetPr(p1#, p2#) <=>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
          ?!(fg : fun(X#, AB#)). p1# o fg# = f# & p2# o fg# = g#: thm
val Cross = fn: term -> term -> term
val Pa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        (p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#) &
        !(fg' : fun(X#, A# * B#)).
          p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==>
          fg'# = Pa(f#, g#): thm
val Pa_def0 =
   {(A : set), (B : set), (X : set), (f : fun(X, A)), (g : fun(X, B))}, 
   |- p1(A, B) o Pa(f, g) = f & p2(A, B) o Pa(f, g) = g: thm
val Thm_2_8_SetPr =
   {},  |- !(A : set)  (B : set). SetPr(p1(A#, B#), p2(A#, B#)): thm
val p12_of_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#: thm
val p1_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f#: thm
val p2_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p2(A#, B#) o Pa(f#, g#) = g#: thm
val is_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (fg' : fun(X#, A# * B#)).
        p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==> fg'# = Pa(f#, g#):
   thm
val AX3 =
   {}, 
   |- !(A : set).
        ?(PA : set)  (e : rel(A#, PA#)).
          !(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#): thm
val Pow_uex =
   {(A : set)}, 
   |- ?(PA : set)  (e : rel(A, PA#)).
        (!(S0 : rel(1, A)).
            ?!(s : mem(PA#)).
              !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        !(PA' : set)  (e' : rel(A, PA'#)).
          (!(S0 : rel(1, A)).
              ?!(s : mem(PA'#)).
                !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
          ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val Pow_unique =
   {}, 
   |- !(A : set)  (PA : set)  (e : rel(A#, PA#))  (PA' : set)
      (e' : rel(A#, PA'#)).
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA'#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
        ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
          i# o j# = Id(PA'#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val SetEz_def =
   {(A : set), (B : set), (E : set), (e : fun(E, A)), (f : fun(A, B)),
    (g : fun(A, B))}, 
   |- SetEz(f, g, e) <=>
      !(X : set)  (x : fun(X#, A)).
        f o x# = g o x# ==> ?!(x0 : fun(X#, E)). x# = e o x0#: thm
val Thm_2_10 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(M : set)  (e : fun(A#, M#))  (m : fun(M#, B#)).
          f# = m# o e# & Surj(e#) & Inj(m#): thm
val Thm_2_9_Eqlz =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
        ?(E : set)  (e : fun(E#, A#)). SetEz(f#, g#, e#): thm
val BC0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))).
        Holds(BC0(f#), a#, b#) <=>
        !(z : mem(Z#)).
          Holds(In(Z#), z#, b#) <=> Holds(In(Y#), App(f#, z#), a#): thm
val Pow = fn: term -> term
val Pow_REFL =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#)).
        ?(i : fun(PA#, PA#))  (j : fun(PA#, PA#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e# & asR(j#) @ e# = e#: thm
val Pow_SYM =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) ==>
        ?(i : fun(PA'#, PA#))  (j : fun(PA#, PA'#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA'#) & asR(i#) @ e'# = e# & asR(j#) @ e# = e'#: thm
val Pow_TRANS =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#))
      (PA'' : set)  (e'' : rel(A, PA''#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) &
        (?(i : fun(PA'#, PA''#))  (j : fun(PA''#, PA'#)).
            i# o j# = Id(PA''#) &
            j# o i# = Id(PA'#) & asR(i#) @ e'# = e''# & asR(j#) @ e''# = e'#) ==>
        ?(i : fun(PA#, PA''#))  (j : fun(PA''#, PA#)).
          i# o j# = Id(PA''#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e''# & asR(j#) @ e''# = e#: thm
val Pow_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val All0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(All0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, a#): thm
val All0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(All0(f#)): thm
val BC0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(BC0(f#)): thm
val Ex0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(Ex0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          ?(z : mem(Z#)). Holds(In(Z#), z#, a#) & App(f#, z#) = y#: thm
val Ex0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(Ex0(f#)): thm
val In_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). Holds(In(A#), x#, s1#) <=> Holds(In(A#), x#, s2#)) ==>
        s1# = s2#: thm
val In_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val In_def_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (s0 : fun(A0#, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)).
            (?(a0 : mem(A0#)). x# = App(s0#, a0#)) <=> Holds(In(A#), x#, s#):
   thm
val In_def_P =
   {}, 
   |- !(A : set).
        ?!(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> Holds(In(A#), a#, s#):
   thm
val PO_def =
   {}, 
   |- !(A : set)  (S1 : mem(Pow(A#)))  (S2 : mem(Pow(A#))).
        PO(S1#, S2#) <=>
        !(a : mem(A#)). Holds(In(A#), a#, S1#) ==> Holds(In(A#), a#, S2#):
   thm
val BC_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))). App(BC(f#), a#) = b# <=> Holds(BC0(f#), a#, b#):
   thm
val In_App_BC =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (z : mem(Z#))
      (ys : mem(Pow(Y#))).
        Holds(In(Z#), z#, App(BC(f#), ys#)) <=>
        Holds(In(Y#), App(f#, z#), ys#): thm
val Ex_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(Ex(f#), a#) = b# <=> Holds(Ex0(f#), a#, b#):
   thm
val In_App_Ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(Ex(f#), zs#)) <=>
        ?(z : mem(Z#)). Holds(In(Z#), z#, zs#) & App(f#, z#) = y#: thm
val All_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(All(f#), a#) = b# <=> Holds(All0(f#), a#, b#):
   thm
val In_App_All =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(All(f#), zs#)) <=>
        !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, zs#): thm
val Thm_2_11_SEx_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (zs : mem(Pow(Z#)))
      (ys : mem(Pow(Y#))).
        PO(App(Ex(f#), zs#), ys#) <=> PO(zs#, App(BC(f#), ys#)): thm
val Thm_2_11_SAll_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (ys : mem(Pow(Y#)))
      (zs : mem(Pow(Z#))).
        PO(App(BC(f#), ys#), zs#) <=> PO(ys#, App(All(f#), zs#)): thm
val Sub_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, R2#) <=>
        !(a : mem(A#))  (b : mem(B#)).
          Holds(R1#, a#, b#) ==> Holds(R2#, a#, b#): thm
val Meet_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Meet(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) & Holds(R2#, a#, b#): thm
val Sub_Meet =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(Meet(R1#, R2#), R1#) &
        Sub(Meet(R1#, R2#), R2#) &
        !(R0 : rel(A#, B#)).
          Sub(R0#, R1#) & Sub(R0#, R2#) ==> Sub(R0#, Meet(R1#, R2#)): thm
val Join_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Join(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) | Holds(R2#, a#, b#): thm
val Sub_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, Join(R1#, R2#)) &
        Sub(R2#, Join(R1#, R2#)) &
        !(R0 : rel(A#, B#)).
          Sub(R1#, R0#) & Sub(R2#, R0#) ==> Sub(Join(R1#, R2#), R0#): thm
val MODULAR_LAW =
   {}, 
   |- !(x : set)  (y : set)  (phi : rel(x#, y#))  (z : set)
      (psi : rel(y#, z#))  (chi : rel(x#, z#)).
        Sub(Meet(psi# @ phi#, chi#), psi# @ Meet(phi#, op(psi#) @ chi#)): thm
val left_o_pres_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (C : set)  (R : rel(B#, C#)).
        R# @ Join(R1#, R2#) = Join(R# @ R1#, R# @ R2#): thm
val right_o_pres_Join =
   {(C : set)}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (R : rel(C, A#)). Join(R1#, R2#) @ R# = Join(R1# @ R#, R2# @ R#): thm
val Div_ex =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (C : set)  (s : rel(A#, C#)).
        ?(sdr : rel(B#, C#)).
          !(t : rel(B#, C#)). Sub(t#, sdr#) <=> Sub(t# @ r#, s#): thm
val MF_def = {},  |- !(A : set)  (a : mem(A#)). App(MF(a#), dot) = a#: thm
val Pair_uex =
   {}, 
   |- !(A : set)  (B : set)  (x : mem(A#))  (y : mem(B#)).
        ?!(r : mem(A# * B#)).
          App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#: thm
val Thm_2_12 =
   {}, 
   |- !(B : set)  (A : set)  (R : rel(B#, A#)).
        ?!(fR : fun(B#, Pow(A#))).
          !(y : mem(B#))  (x : mem(A#)).
            Holds(R#, y#, x#) <=> Holds(In(A#), x#, App(fR#, y#)): thm
val Thm_2_3_5_el =
   {},  |- !(A : set)  (a : mem(A#)). ?!(R : fun(1, A#)). App(R#, dot) = a#:
   thm
val Pair_App_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val Pair_def =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val Pair_component =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)).
        Pair(App(p1(A#, B#), r#), App(p2(A#, B#), r#)) = r#: thm
val Pair_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
      (b2 : mem(B#)).
        Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#: thm
val Pair_p12 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        Pair(App(p1(A#, B#), ab#), App(p2(A#, B#), ab#)) = ab#: thm
val Ap1_def =
   {}, 
   |- !(A : set)  (X : set)  (x : mem(X#))  (B : set)  (f : fun(A# * X#, B#))
      (a : mem(A#)). App(Ap1(f#, x#), a#) = App(f#, Pair(a#, x#)): thm
val Ap1_uex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#))
      (x : mem(X#)).
        ?!(fx : fun(A#, B#)).
          !(a : mem(A#)). App(fx#, a#) = App(f#, Pair(a#, x#)): thm
val Cross_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val App_Pa =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (D : set)
      (g : fun(B#, D#))  (ab : mem(A# * B#)).
        App(Pa(f# o p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(f# o p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_o_p2 =
   {}, 
   |- !(B : set)  (C : set)  (f : fun(B#, C#))  (A : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p2(A#, B#), Pair(a#, b#)) = App(f#, b#): thm
val App_o_p1 =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p1(A#, B#), Pair(a#, b#)) = App(f#, a#): thm
val Fst_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p1(A, B), x) = Fst(x):
   thm
val Pair_def' =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#: thm
val Snd_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p2(A, B), x) = Snd(x):
   thm
val Pair_Fst_Snd =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)). Pair(Fst(r#), Snd(r#)) = r#:
   thm
val Pair_has_comp =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#): thm
val p12_of_Pair =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val dest_cross = fn: term -> term * term
val basic_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_fconv = fn: form -> thm
val mk_Pair = fn: term -> term -> term
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val Prla_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (D : set)
      (g : fun(C#, D#)). Prla(f#, g#) = Pa(f# o p1(A#, C#), g# o p2(A#, C#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Exp_ev_unique =
   {}, 
   |- !(A : set)  (B : set)  (A2B : set)  (ev : fun(A# * A2B#, B#))
      (A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B'#)).
              !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
        ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
          i# o j# = Id(A2B'#) &
          j# o i# = Id(A2B#) &
          ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#: thm
val Exp_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#): thm
val Exp_ex_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          (!(f : fun(A#, B#)).
              ?!(sf : mem(A2B#)).
                !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
          !(A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
            (!(f : fun(A#, B#)).
                ?!(sf : mem(A2B'#)).
                  !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
            ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
              i# o j# = Id(A2B'#) &
              j# o i# = Id(A2B#) &
              ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#:
   thm
val Thm_2_13 =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A2B# * A#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(sf#, a#)) = App(f#, a#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Ev_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_uex_refl =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B)).
        ?(i : fun(A2B#, A2B#))  (j : fun(A2B#, A2B#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B#) &
          ev# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_sym =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) ==>
        ?(i : fun(A2B'#, A2B#))  (j : fun(A2B#, A2B'#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B'#) &
          ev# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_trans =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B))  (A2B'' : set)  (ev'' : fun(A * A2B''#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) &
        (?(i : fun(A2B'#, A2B''#))  (j : fun(A2B''#, A2B'#)).
            i# o j# = Id(A2B''#) &
            j# o i# = Id(A2B'#) &
            ev''# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev''#) ==>
        ?(i : fun(A2B#, A2B''#))  (j : fun(A2B''#, A2B#)).
          i# o j# = Id(A2B''#) &
          j# o i# = Id(A2B#) &
          ev''# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev''#: thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val Tpm_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
        !(sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#): thm
val Tpm_def0 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#): thm
val is_Tpm =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sf' : mem(Exp(A#, B#))).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
        sf'# = Tpm(f#): thm
val Tp_def0 =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f: thm
val Tp_ex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#)).
        ?!(h : fun(X#, Exp(A#, B#))).
          Ev(A#, B#) o Pa(p1(A#, X#), h# o p2(A#, X#)) = f#: thm
val Tp_def =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f &
      !(h' : fun(X, Exp(A, B))).
        Ev(A, B) o Pa(p1(A, X), h'# o p2(A, X)) = f ==> h'# = Tp(f): thm
val is_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (h' : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), h'# o p2(A#, X#)) = f# ==> h'# = Tp(f#):
   thm
val Thm_2_14 =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        ?(B : set)  (q : fun(A#, B#)).
          Surj(q#) &
          !(x : mem(A#))  (y : mem(A#)).
            Holds(R#, x#, y#) <=> App(q#, x#) = App(q#, y#): thm
val IN_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#))).
        IN(a#, ss#) <=> Holds(In(A#), a#, ss#): thm
val IN_def_P_expand =
   {}, 
   |- !(A : set).
        ?(s : mem(Pow(A#))).
          (!(a : mem(A#)). P(a#) <=> IN(a#, s#)) &
          !(s' : mem(Pow(A#))).
            (!(a : mem(A#)). P(a#) <=> IN(a#, s'#)) ==> s'# = s#: thm
val IN_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) ==> s1# = s2#: thm
val SS_def =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) <=> !(a : mem(A#)). IN(a#, P1#) ==> IN(a#, P2#): thm
val SS_Trans =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) ==> !(P3 : mem(Pow(A#))). SS(P2#, P3#) ==> SS(P1#, P3#):
   thm
val SS_SS_eq =
   {}, 
   |- !(A : set)  (p1 : mem(Pow(A#)))  (p2 : mem(Pow(A#))).
        SS(p1#, p2#) & SS(p2#, p1#) ==> p1# = p2#: thm
val IN_def_P_ex =
   {}, 
   |- !(A : set). ?(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> IN(a#, s#):
   thm
val IN_def_P =
   {}, 
   |- !(A : set). ?!(s : mem(Pow(A#))). !(a : mem(A#)). IN(a#, s#) <=> P(a#):
   thm
val AX4 =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set).
        ?!(BI : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BI#, sss#)) <=>
            !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val BI_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BI(A#), sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val N0 = N0: term
val N0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val O0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val S0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_def =
   {(A : set), (sss : mem(Pow(Pow(A))))},  |- App(BI(A), sss) = BIGINTER(sss):
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        ?(isss : mem(Pow(A#))). App(BI(A#), sss#) = isss#: thm
val IN_BIGINTER =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGINTER(sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
******

Loading SEAR file SEARreln.sml

******
val mk_App = fn: term -> term -> term
SEARreln.sml:75: warning: Matches are not exhaustive.
Found near
  case (view_form ante, view_form conseq) of
     (vConn ("&", ...), vConn (...)) =>
     let val ip1 = ... ...; val ... = ... in conj_monotone ip1 ip2 end |
     (vConn (...), ... ...) => let val ... = ...; val ... in ... ... ip2 end
     |
     (... ..., ...) => let val ... in ... ... end |
     (...) => let ... in ... end
SEARreln.sml:247: warning: Pattern is not exhaustive.
Found near
  val [fnterm, LFP] = fLFP |> #3 o dest_fun handle _ => raise ... ...
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
val conj_monotone = fn: thm -> thm -> thm
val disj_monotone = fn: thm -> thm -> thm
val exists_monotone = fn: thm -> thm
val forall_monotone = fn: thm -> thm
val imp_induce = fn: thm -> form -> thm
val mk_LFP = fn: term -> thm
val mk_Pow = fn: term -> term
val mk_SS = fn: thm -> thm -> thm
val mk_cases = fn: thm -> thm -> thm -> thm
val mk_cond = fn: thm -> thm -> thm
val mk_fdef = fn: string -> thm -> thm
val mk_fex = fn: form -> string -> thm
val mk_ind = fn: thm -> thm
val mk_ind1 = fn: thm -> thm -> thm
val mk_monotone = fn: thm -> thm
val mk_prim = fn: thm -> thm
val mk_rules = fn: thm -> thm -> thm -> thm
val trivial_imp = fn: form -> thm
val PULL_CONJ = fn: (form -> bool) -> form -> thm option
val conj_assoc_fconv = fn: form -> thm
val conj_cossa_fconv = fn: form -> thm
val conj_swap_fconv = fn: form -> thm
val disj_imp_distr_fconv = fn: form -> thm
val exists_eq_fconv = fn: form -> thm
val forall_conj_split_fconv = fn: form -> thm
val forall_eq_fconv = fn: form -> thm
val mk_case1 = fn: thm -> thm -> thm
val mk_rules1 = fn: thm -> thm -> thm
val mk_rules2 = fn: thm -> thm
val pull_conj_fconv = fn: (form -> bool) -> form -> thm
val pull_exists_fconv1 = fn: form -> thm
SEARreln.sml:599: warning: Pattern is not exhaustive.
Found near val [qv, newtm] = conc |> dest_pred |> #2
val conj_imp_fconv = fn: form -> thm
val disj_imp_undistr_fconv = fn: form -> thm
val forall_in_eq_fconv = fn: form -> thm
val mk_incond = fn: form -> form * string
val mk_ind2 = fn: thm -> thm
val mk_rules3 = fn: thm -> thm
val remove_list_item = fn: ''a -> ''a list -> ''a list
val unpull_exists_fconv1 = fn: form -> thm
val it = (): unit
val inN's_def =
   {},  |- !(a : mem(Pow(N0))). IN(a#, inN's) <=> SS(App(inNf, a#), a#): thm
val inN_cases0 = {},  |- App(inNf, inNs) = inNs: thm
val inN_cases1 =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_incond =
   !(n : mem(N0)).
     IN(n#, inN1) <=>
     n# = O0 | ?(n0 : mem(N0)). IN(n0#, inN0) & n# = App(S0, n0#): form
val inN_ind =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_ind0 =
   {},  |- !(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> SS(inNs, ss#):
   thm
val inN_ind1 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        (!(a : mem(N0)).
            a# = O0 | (?(n0 : mem(N0)). IN(n0#, ss#) & a# = App(S0, n0#)) ==>
            IN(a#, ss#)) ==> !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#):
   thm
val inN_ind2 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_rules0 = {},  |- SS(App(inNf, inNs), inNs): thm
val inN_rules1 =
   {}, 
   |- !(a : mem(N0)).
        a# = O0 | (?(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#)) ==>
        IN(a#, inNs): thm
val inN_rules2 =
   {}, 
   |- !(a : mem(N0)).
        (a# = O0 ==> IN(a#, inNs)) &
        !(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#) ==> IN(a#, inNs):
   thm
val inN_rules3 =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val inNf_def =
   {}, 
   |- !(a : mem(Pow(N0)))  (n : mem(N0)).
        IN(n#, App(inNf, a#)) <=>
        n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_ex =
   {}, 
   |- ?!(f : fun(Pow(N0), Pow(N0))).
        !(a : mem(Pow(N0)))  (n : mem(N0)).
          IN(n#, App(f#, a#)) <=>
          n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_monotone =
   {}, 
   |- !(s1 : mem(Pow(N0)))  (s2 : mem(Pow(N0))).
        SS(s1#, s2#) ==> SS(App(inNf, s1#), App(inNf, s2#)): thm
val inNs_SS =
   {},  |- !(a : mem(Pow(N0))). SS(App(inNf, a#), a#) ==> SS(inNs, a#): thm
val inNs_cond =
   {}, 
   |- !(a : mem(N0)).
        (!(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, inNs): thm
val inNs_def = {},  |- inNs = BIGINTER(inN's): thm
val x1 = "inN0": string
val inN_cases =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_rules =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val N_def =
   {}, 
   |- Inj(iN) &
      !(a : mem(N0)). IN(a#, inNs) <=> ?(b : mem(N)). a# = App(iN, b#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val iN_Inj = {},  |- Inj(iN): thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val iN_inNs = {},  |- !(n : mem(N)). IN(App(iN, n#), inNs): thm
val SUC_ex_lemma =
   {},  |- !(n1 : mem(N)). ?(b : mem(N)). App(S0 o iN, n1#) = App(iN, b#):
   thm
val SUC_def = {},  |- !(a : mem(N)). App(iN o SUC, a#) = App(S0 o iN, a#):
   thm
val iN_eq_eq =
   {}, 
   |- !(x1 : mem(N))  (x2 : mem(N)).
        App(iN, x1#) = App(iN, x2#) ==> x1# = x2#: thm
val O_def = {},  |- O0 = App(iN, O): thm
val iN_ex_uex =
   {}, 
   |- !(b : mem(N0)).
        (?(a : mem(N)). App(iN, a#) = b#) <=>
        ?!(a : mem(N)). App(iN, a#) = b#: thm
val S0_eq_eq =
   {}, 
   |- !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) ==> n# = m#:
   thm
val SUC_Inj = {},  |- Inj(SUC): thm
val iN_O = {},  |- !(n : mem(N)). App(iN, n#) = O0 <=> n# = O: thm
val SUC_NONZERO = {},  |- !(n : mem(N)). ~App(SUC, n#) = O: thm
val Image_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(im : fun(Pow(A#), Pow(B#))).
          !(sa : mem(Pow(A#)))  (b : mem(B#)).
            IN(b#, App(im#, sa#)) <=>
            ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val Image_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sa : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Image(f#), sa#)) <=>
        ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val IMAGE_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (b : mem(B#)).
        IN(b#, IMAGE(f#, s0#)) <=>
        ?(a : mem(A#)). IN(a#, s0#) & b# = App(f#, a#): thm
val IMAGE_def0 =
   {(A : set), (B : set), (f : fun(A, B)), (s0 : mem(Pow(A)))}, 
   |- IMAGE(f, s0) = App(Image(f), s0): thm
val Whole_def = {},  |- !(A : set)  (a : mem(A#)). IN(a#, Whole(A#)): thm
val IN_IMAGE_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(s : mem(Pow(A#)))  (a : mem(A#)).
          IN(a#, s#) <=> IN(App(i#, a#), IMAGE(i#, s#)): thm
val N_ind_P =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(App(SUC, n#))) ==>
      !(n : mem(N)). P(n#): thm
val O_xor_SUC =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = App(SUC, pn#): thm
val SUC_eq_eq =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)).
        App(SUC, n1#) = App(SUC, n2#) <=> n1# = n2#: thm
val Suc_def = {},  |- !(n : mem(N)). Suc(n#) = App(SUC, n#): thm
val O_xor_Suc =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = Suc(pn#): thm
val Suc_eq_eq =
   {},  |- !(n1 : mem(N))  (n2 : mem(N)). Suc(n1#) = Suc(n2#) <=> n1# = n2#:
   thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val N_induct =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Eqv_def =
   {},  |- !(A : set)  (B : set). Eqv(A#, B#) <=> ?(f : fun(A#, B#)). Bij(f#):
   thm
val Asset_def =
   {}, 
   |- !(B : set)  (bs : mem(Pow(B#)))  (B0 : set).
        Asset(bs#, B0#) <=>
        !(B1 : set)  (i : fun(B1#, B#)).
          Inj(i#) &
          (!(b : mem(B#)).
              (?(b0 : mem(B1#)). App(i#, b0#) = b#) <=> IN(b#, bs#)) ==>
          Eqv(B0#, B1#): thm
val Sg_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (a0 : mem(A#)).
        IN(a0#, App(Sg(A#), a#)) <=> a0# = a#: thm
val Sing_def = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Empty_def = {},  |- !(X : set)  (a : mem(X#)). ~IN(a#, Empty(X#)): thm
val Sing_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Sing(a1#) = Sing(a2#) <=> a1# = a2#: thm
val Sing_NONEMPTY = {},  |- !(A : set)  (a : mem(A#)). ~Sing(a#) = Empty(A#):
   thm
val iscoPr_def =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (i1 : fun(A#, AB#))
      (i2 : fun(B#, AB#)).
        iscoPr(i1#, i2#) <=>
        !(X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
          ?!(fg : fun(AB#, X#)). fg# o i1# = f# & fg# o i2# = g#: thm
val tof_def =
   {(A : set), (B : set), (f0 : mem(Exp(A, B)))}, 
   |- !(a : mem(A)). App(Ev(A, B), Pair(a#, f0)) = App(tof(f0), a#): thm
val coPr_unique =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        iscoPr(i1#, i2#) & iscoPr(i1'#, i2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          j# o i1'# = i1# &
          j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val iscoPr_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          iscoPr(i1#, i2#) &
          Inj(i1#) &
          Inj(i2#) &
          (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
          !(ab : mem(AB#)).
            (?(a : mem(A#)). ab# = App(i1#, a#)) |
            ?(b : mem(B#)). ab# = App(i2#, b#): thm
val coPr_REFL =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
        ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB#) &
          j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#:
   thm
val coPr_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#) &
      (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
        (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            j# o i1# = i1'# &
            j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#) &
      !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_SYM =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
        ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB'#) &
          j# o i1# = i1'# &
          j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#: thm
val coPr_TRANS =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          (iscoPr(i1#, i2#) &
            Inj(i1#) &
            Inj(i2#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
            !(ab : mem(AB#)).
              (?(a : mem(A#)). ab# = App(i1#, a#)) |
              ?(b : mem(B#)). ab# = App(i2#, b#)) &
          !(AB' : set)  (i1' : fun(A#, AB'#))  (i2' : fun(B#, AB'#)).
            iscoPr(i1'#, i2'#) &
            Inj(i1'#) &
            Inj(i2'#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1'#, a#) = App(i2'#, b#)) &
            (!(ab : mem(AB'#)).
                (?(a : mem(A#)). ab# = App(i1'#, a#)) |
                ?(b : mem(B#)). ab# = App(i2'#, b#)) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val coPo_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i2_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val coPa_def0 =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#: thm
val coPa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        (coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#) &
        !(fg' : fun(A# + B#, X#)).
          fg'# o i1(A#, B#) = f# & fg'# o i2(A#, B#) = g# ==>
          fg'# = coPa(f#, g#): thm
val i1_Inj = {},  |- !(A : set)  (B : set). Inj(i1(A#, B#)): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val i1_or_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
        ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_xor_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) <=>
        ?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#): thm
val i2_xor_i1 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#)) <=>
        ?(a : mem(A#)). ab# = App(i1(A#, B#), a#): thm
val it = (): unit
******

Loading SEAR file SEARpred_set.sml

******
val tof_Tpm_inv =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). tof(Tpm(f#)) = f#: thm
val Tpm_tof_inv =
   {},  |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#))). Tpm(tof(f#)) = f#:
   thm
val Tpm_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        Tpm(f1#) = Tpm(f2#) <=> f1# = f2#: thm
val tof_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (g : mem(Exp(A#, B#))).
        tof(f#) = tof(g#) <=> f# = g#: thm
val IN_Sing =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)).
        IN(a#, Sing(a0#)) <=> a# = a0#: thm
val BU_ex =
   {}, 
   |- !(A : set).
        ?!(BU : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BU#, sss#)) <=>
            ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val EMPTY_def = {(A : set)},  |- EMPTY(A) <=> !(x : mem(A)). F: thm
val BU_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BU(A#), sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val BIGUNION_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        BIGUNION(sss#) = App(BU(A#), sss#): thm
val IN_BIGUNION =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGUNION(sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val IMAGE_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (s : mem(Pow(A#))). IMAGE(g# o f#, s#) = IMAGE(g#, IMAGE(f#, s#)): thm
val ex_eq_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#))).
        (!(b : mem(B#)). IN(b#, s#) ==> ?(a : mem(A#)). b# = App(f#, a#)) ==>
        ?(s0 : mem(Pow(A#))). s# = IMAGE(f#, s0#): thm
val App_IN_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))
      (a : mem(A#)). IN(a#, s#) ==> IN(App(f#, a#), IMAGE(f#, s#)): thm
val IMAGE_BIGUNION =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(Pow(A#)))).
        IMAGE(f#, BIGUNION(ss#)) = BIGUNION(IMAGE(Image(f#), ss#)): thm
val Prla_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(C : set)  (D : set)  (g : fun(C#, D#)).
          Inj(g#) ==> Inj(Prla(f#, g#)): thm
val Id_Inj = {},  |- !(X : set). Inj(Id(X#)): thm
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Pa_distr =
   {}, 
   |- !(A : set)  (X : set)  (a1 : fun(X#, A#))  (B : set)
      (a2 : fun(X#, B#))  (X0 : set)  (x : fun(X0#, X#)).
        Pa(a1#, a2#) o x# = Pa(a1# o x#, a2# o x#): thm
val Pa_eq_eq =
   {}, 
   |- !(A : set)  (X : set)  (f1 : fun(X#, A#))  (f2 : fun(X#, A#))
      (B : set)  (g1 : fun(X#, B#))  (g2 : fun(X#, B#)).
        Pa(f1#, g1#) = Pa(f2#, g2#) <=> f1# = f2# & g1# = g2#: thm
val p2_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(B#, C#)).
        f# o p2(A#, B#) = p2(A#, C#) o Prla(Id(A#), f#): thm
val p1_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(A#, C#)).
        f# o p1(A#, B#) = p1(C#, B#) o Prla(f#, Id(B#)): thm
val p1_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#)). p1(X#, Y#) o Prla(f#, g#) = f# o p1(A#, B#): thm
val IMAGE_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#))  (x : mem(X#))  (y : mem(Y#))
      (s : mem(Pow(A# * B#))).
        IN(Pair(x#, y#), IMAGE(Prla(f#, g#), s#)) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          IN(Pair(a#, b#), s#) & x# = App(f#, a#) & y# = App(g#, b#): thm
val exists_cross_fconv = fn: form -> thm
val Image_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        App(Image(f#), s#) = IMAGE(f#, s#): thm
val IMAGE_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        IMAGE(f#, Empty(A#)) = Empty(B#): thm
val IN_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        (?(a : mem(A#)). IN(a#, s#)) <=> ~s# = Empty(A#): thm
val IMAGE_Empty_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val BIGUNION_Empty_Empty =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        BIGUNION(ss#) = Empty(A#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val BIGUNION_NONEMPTY =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        ~BIGUNION(ss#) = Empty(A#) <=>
        ?(s : mem(Pow(A#))). IN(s#, ss#) & ~s# = Empty(A#): thm
val BIGUNION_Empty_Empty' =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        Empty(A#) = BIGUNION(ss#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val INTER_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(INTER(A), Pair(a'#, b#))) <=> IN(a#, a'#) & IN(a#, b#):
   thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Inter_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Inter(s1, s2) = App(INTER(A), Pair(s1, s2)): thm
val UNION_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(UNION(A), Pair(a'#, b#))) <=> IN(a#, a'#) | IN(a#, b#):
   thm
val COMPL_def =
   {(A : set)}, 
   |- !(a : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(COMPL(A), a#)) <=> ~IN(a#, a#): thm
val Compl_def =
   {(A : set), (s : mem(Pow(A)))},  |- Compl(s) = App(COMPL(A), s): thm
val IN_Compl =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Compl(s#)) <=> ~IN(a#, s#): thm
val IN_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Union(s1#, s2#)) <=> IN(a#, s1#) | IN(a#, s2#): thm
val Union_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Union(s1, s2) = App(UNION(A), Pair(s1, s2)): thm
val m2r_def =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (od : mem(Pow(A# * A#))).
        Holds(m2r(od#), a1#, a2#) <=> IN(Pair(a1#, a2#), od#): thm
val r2m_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(Pair(a1#, a2#), r2m(R#)) <=> Holds(R#, a1#, a2#): thm
val Union_Empty_Empty =
   {},  |- !(A : set). Union(Empty(A#), Empty(A#)) = Empty(A#): thm
val SS_Refl = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(s#, s#): thm
val NONE_def = {(X : set)},  |- NONE(X) = App(i2(X, 1), dot): thm
val Null_def =
   {},  |- !(X : set)  (n : mem(N)). App(Null(X#), n#) = App(i2(X#, 1), dot):
   thm
val PREIM_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#)))
      (a : mem(A#)).
        IN(a#, PREIM(f#, s#)) <=>
        ?(b : mem(B#)). IN(b#, s#) & App(f#, a#) = b#: thm
val SOME_def =
   {},  |- !(A : set)  (a : mem(A#)). SOME(a#) = App(i1(A#, 1), a#): thm
val Surj_Epi =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) ==>
        !(C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
          g1# o f# = g2# o f# ==> g1# = g2#: thm
val false_def = {},  |- false = App(i1(1, 1), dot): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val true_def = {},  |- true = App(i2(1, 1), dot): thm
val true_ne_false = {},  |- ~true = false: thm
val true_or_false = {},  |- !(tv : mem(1 + 1)). tv# = true | tv# = false: thm
val true_xor_false = {},  |- !(tv : mem(1 + 1)). ~tv# = true <=> tv# = false:
   thm
val false_xor_true = {},  |- !(tv : mem(1 + 1)). ~tv# = false <=> tv# = true:
   thm
val tv_eq_true =
   {}, 
   |- !(tv1 : mem(1 + 1))  (tv2 : mem(1 + 1)).
        tv1# = tv2# <=> tv1# = true <=> tv2# = true: thm
val tf_eq_true =
   {}, 
   |- !(A : set)  (tf1 : fun(A#, 1 + 1))  (tf2 : fun(A#, 1 + 1)).
        tf1# = tf2# <=>
        !(a : mem(A#)). App(tf1#, a#) = true <=> App(tf2#, a#) = true: thm
val basic_fconv_tac = fn: conv -> fconv -> tactic
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
******

Loading SEAR file lambda.sml

******
val TAUT = {},  |- A | ~A: thm
val cond_unique_lemma =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b# = b'#: thm
val cond_unique_lemma' =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b'# = b#: thm
val conj1 = fn: form -> form
val conj2 = fn: form -> form
val conjIs = fn: thm list -> thm
val disj1 = fn: form -> form
val disj2 = fn: form -> form
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val disj_neg_absorb = {},  |- A | ~A & B <=> A | B: thm
val disj_of_negconj = {},  |- ~A & ~B <=> ~(A | B): thm
val djE = fn: form * thm -> form * thm -> form * thm
val djEs = fn: (form * thm) list -> form * thm
val drop_last_cj = fn: form -> form * form
val iant = fn: form -> form
val iconc = fn: form -> form
val imp_dimp_distr = {},  |- A ==> (B <=> C) <=> A ==> B <=> A ==> C: thm
val strip_conj = fn: form -> form list
val strip_disj = fn: form -> form list
val cond_rw_fconv = fn: form -> thm
val conj_assoc_fm = fn: form -> form
val define_lambda = fn: form -> thm
val define_lambda_fun = fn: form -> thm
val nlist = fn: int -> int list
val normalise_lambda_input = fn: form -> form
val it = (): unit
val NOT_def = {},  |- App(NOT, true) = false & App(NOT, false) = true: thm
val OR_def =
   {}, 
   |- App(OR, Pair(true, true)) = true &
      App(OR, Pair(true, false)) = true &
      App(OR, Pair(false, true)) = true & App(OR, Pair(false, false)) = false:
   thm
val constf_def =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#))  (a : mem(A#)).
        App(constf(A#, b#), a#) = b#: thm
val f2r_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * B#, 1 + 1))  (a : mem(A#))
      (b : mem(B#)). Holds(f2r(f#), a#, b#) <=> App(f#, Pair(a#, b#)) = true:
   thm
val r2f_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = App(i2(1, 1), dot) <=> Holds(R#, a#, b#):
   thm
val r2f_def' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = true <=> Holds(R#, a#, b#): thm
val ss2f =
   {(A : set), (s : mem(Pow(A)))}, 
   |- !(a : mem(A)). App(ss2f(s), a#) = true <=> IN(a#, s): thm
val FIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : fun(A, B))}, 
   |- FIB(f, b) = PREIM(f, Sing(b)): thm
val Inj_Image_Inj =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(A#, B#)). Inj(i#) ==> Inj(Image(i#)):
   thm
val mApp_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (f : mem(Exp(A#, B#))).
        mApp(f#, a#) = App(tof(f#), a#): thm
val mFIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : mem(Exp(A, B)))}, 
   |- mFIB(f, b) = PREIM(tof(f), Sing(b)): thm
val Compl_Whole = {},  |- !(A : set). Compl(Whole(A#)) = Empty(A#): thm
val Compl_Empty = {},  |- !(A : set). Compl(Empty(A#)) = Whole(A#): thm
val Inter_Compl_Compl =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J)))}, 
   |- Inter(Compl(s1), Compl(s2)) = Compl(Union(s1, s2)): thm
val neg_or_distr = {},  |- ~(A | B) <=> ~A & ~B: thm
val SS_Union =
   {}, 
   |- (!(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
          SS(a#, Union(a#, b#))) &
      !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val SS_Union1 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(a#, b#)): thm
val SS_Union2 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val Ins_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (s0 : mem(Pow(X#)))  (a : mem(X#)).
        IN(a#, Ins(x0#, s0#)) <=> a# = x0# | IN(a#, s0#): thm
val Union_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Union(Sing(a#), s#) = Ins(a#, s#): thm
val SS_Ins =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(s#, Ins(a#, s#)):
   thm
val BIGINTER_Sing =
   {},  |- !(A : set)  (s : mem(Pow(A#))). BIGINTER(Sing(s#)) = s#: thm
val Whole_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Whole(A#), s#) = s#: thm
val Inter_Whole =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Whole(A#)) = s#: thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Empty_SS = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(Empty(A#), s#): thm
val BIGINTER_Empty = {(A : set)},  |- BIGINTER(Empty(Pow(A))) = Whole(A): thm
val BIGINTER_Ins_Empty =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#))). BIGINTER(Ins(x#, Empty(Pow(A#)))) = x#:
   thm
val Inter_same = {},  |- !(A : set)  (x : mem(Pow(A#))). Inter(x#, x#) = x#:
   thm
val BIGINTER_Ins =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#)))  (xs0 : mem(Pow(Pow(A#)))).
        BIGINTER(Ins(x#, xs0#)) = Inter(x#, BIGINTER(xs0#)): thm
val imp_or_distr = {},  |- A | B ==> C <=> (A ==> C) & (B ==> C): thm
val BIGINTER_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(Pow(A#))))  (s2 : mem(Pow(Pow(A#)))).
        BIGINTER(Union(s1#, s2#)) = Inter(BIGINTER(s1#), BIGINTER(s2#)): thm
val Empty_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Empty(A#), s#) = Empty(A#):
   thm
val Union_EMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val neg_and_distr = {},  |- ~(A & B) <=> ~A | ~B: thm
val SS_Union_split =
   {}, 
   |- !(W : set)  (A : mem(Pow(W#)))  (B : mem(Pow(W#)))  (s : mem(Pow(W#))).
        SS(s#, Union(A#, B#)) <=>
        ?(s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
          SS(s1#, A#) & SS(s2#, B#) & s# = Union(s1#, s2#): thm
val Inter_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Empty(A#)) = Empty(A#):
   thm
val SS_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        SS(s#, Sing(a#)) <=> s# = Sing(a#) | s# = Empty(A#): thm
val Empty_Union =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(Empty(A#), s#) = s#: thm
val SS_Empty =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))). SS(s#, Empty(A#)) <=> s# = Empty(A#):
   thm
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val Union_assoc =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Union(Union(s1#, s2#), s3#) = Union(s1#, Union(s2#, s3#)): thm
val Inter_Whole_Whole =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Whole(A#) <=> s1# = Whole(A#) & s2# = Whole(A#):
   thm
val Union_SS1 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(Union(s1#, s2#), s#) <=> SS(s1#, s#) & SS(s2#, s#): thm
val SS_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s#, Inter(s1#, s2#)) <=> SS(s#, s1#) & SS(s#, s2#): thm
val Union_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        SS(Inter(s1#, s2#), s1#) & SS(Inter(s1#, s2#), s2#): thm
val Whole_SS =
   {}, 
   |- !(A : set)  (X : mem(Pow(A#))). SS(Whole(A#), X#) ==> X# = Whole(A#):
   thm
val SS_Whole = {},  |- !(A : set)  (X : mem(Pow(A#))). SS(X#, Whole(A#)): thm
val Sing_Ins_Empty =
   {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = Ins(a#, Empty(A#)): thm
val EMPTY_Empty_Whole =
   {},  |- !(A : set). EMPTY(A#) <=> Empty(A#) = Whole(A#): thm
val NOT_EMPTY = {},  |- !(A : set). ~EMPTY(A#) <=> ?(a : mem(A#)). T: thm
val NEQ_IN =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val PSS_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- PSS(s1, s2) <=> SS(s1, s2) & ~s1 = s2: thm
val PSS_alt =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) <=>
        SS(s1#, s2#) & ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val Inter_Compl =
   {},  |- !(A : set)  (a : mem(Pow(A#))). Inter(a#, Compl(a#)) = Empty(A#):
   thm
val neg_iff = {},  |- ~(A <=> B) <=> A & ~B | B & ~A: thm
val Union_Empty2 =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(s#, Empty(A#)) = s#: thm
val Inter_eq_Empty =
   {}, 
   |- !(W : set)  (s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
        Inter(s1#, s2#) = Empty(W#) <=> SS(s2#, Compl(s1#)): thm
val PSS_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) ==> SS(s1#, s2#): thm
val SS_BIGUNION =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(Pow(A#)))))
      (s0 : mem(Pow(Pow(A#)))).
        IN(s0#, ss#) & SS(s#, s0#) ==> SS(s#, BIGUNION(ss#)): thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val Del_def =
   {}, 
   |- !(X : set)  (s0 : mem(Pow(X#)))  (x0 : mem(X#))  (a : mem(X#)).
        IN(a#, Del(s0#, x0#)) <=> IN(a#, s0#) & ~a# = x0#: thm
val c31_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c31(abc) = Fst(abc): thm
val c32_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c32(abc) = Fst(Snd(abc)): thm
val c33_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c33(abc) = Snd(Snd(abc)): thm
val Del_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        ~IN(x0#, xs0#) ==> Del(Ins(x0#, xs0#), x0#) = xs0#: thm
val Ins_absorb =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        IN(x0#, xs0#) ==> Ins(x0#, xs0#) = xs0#: thm
val Ins_Del =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, s#) ==> Ins(a#, Del(s#, a#)) = s#: thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
        IMAGE(f#, ss#) = Empty(B#) <=> ss# = Empty(A#): thm
val NOTIN_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        ~IN(a#, s#) ==> Del(s#, a#) = s#: thm
val Inj_IMAGE_Del =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#)))
      (a : mem(A#)).
        Inj(f#) ==>
        IMAGE(f#, Del(ss#, a#)) = Del(IMAGE(f#, ss#), App(f#, a#)): thm
val disj_not_imp = {},  |- A | ~B <=> B ==> A: thm
val exists_forall = fn: string * sort -> thm
val exists_forall_th =
   {(A : set)},  |- (?(a : mem(A)). f0(a#)) <=> ~!(a : mem(A)). ~f0(a#): thm
val not_disj_imp = {},  |- ~B | A <=> B ==> A: thm
val set_NEQ =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). ~IN(a#, s1#) & IN(a#, s2#): thm
val Pa_Inj =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#)).
        Inj(f#) ==> !(B : set)  (g : fun(X#, B#)). Inj(Pa(g#, f#)): thm
val o_Inj_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_restrict =
   {}, 
   |- !(D : set)  (D0 : set)  (i1 : fun(D#, D0#)).
        Inj(i1#) ==>
        !(C : set)  (C0 : set)  (i2 : fun(C#, C0#)).
          Inj(i2#) ==>
          !(f0 : fun(D0#, C0#)).
            (!(d : mem(D#)).
                ?!(c : mem(C#)). App(f0# o i1#, d#) = App(i2#, c#)) ==>
            ?!(f : fun(D#, C#)). i2# o f# = f0# o i1#: thm
val SS_Del =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(Del(s#, a#), s#):
   thm
val Inj_o_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        Inj(g# o f#) ==> Inj(f#): thm
val SS_Ins_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#)))  (G : mem(Pow(A#))).
        SS(ss#, Ins(a#, G#)) ==> SS(Del(ss#, a#), G#): thm
val SOME_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (x2 : mem(X#)).
        SOME(x1#) = SOME(x2#) <=> x1# = x2#: thm
val option_xor =
   {}, 
   |- !(A : set)  (a1 : mem(A# + 1)).
        ~a1# = NONE(A#) <=> ?!(a0 : mem(A#)). a1# = SOME(a0#): thm
val NOT_true_iff_false =
   {},  |- !(tv : mem(1 + 1)). App(NOT, tv#) = true <=> tv# = false: thm
val SOME_NOTNONE = {},  |- !(X : set)  (x : mem(X#)). ~SOME(x#) = NONE(X#):
   thm
val OM_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- App(OM(f), NONE(A)) = NONE(B) &
      !(a : mem(A)). App(OM(f), SOME(a#)) = SOME(App(f, a#)): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val Diff_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Diff(s1#, s2#)) <=> IN(a#, s1#) & ~IN(a#, s2#): thm
val Inter_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        ~Inter(s#, Sing(a#)) = Empty(A#) <=> IN(a#, s#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val Diff_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Diff(s#, Empty(A#)) = s#: thm
val Diff_Empty_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Diff(s1#, s2#) = Empty(A#) <=> SS(s1#, s2#): thm
val Ins_Union =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Ins(a#, s#) = Union(Sing(a#), s#): thm
val Union_Empty_both_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Inter(s1#, Union(s2#, s3#)) = Union(Inter(s1#, s2#), Inter(s1#, s3#)):
   thm
val Inter_Diff_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Sing(x#)) = Empty(A#) <=>
        IN(x#, Diff(s1#, s2#)): thm
val Diff_Ins_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Ins(x#, s3#)) = Empty(A#) <=>
        ~Inter(Diff(s1#, s2#), s3#) = Empty(A#) | IN(x#, Diff(s1#, s2#)): thm
val Inter_Empty2 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Empty(A#) ==>
        !(a : mem(A#)). IN(a#, s2#) ==> ~IN(a#, s1#): thm
val Inter_both_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~Inter(s1#, s2#) = Empty(A#) ==> ~s1# = Empty(A#) & ~s2# = Empty(A#):
   thm
val neg_imp_conj = {},  |- ~(A ==> B) <=> A & ~B: thm
val forall_exists_dual =
   {},  |- !(A : set). (!(a : mem(A#)). P(a#)) <=> ~?(a : mem(A#)). ~P(a#):
   thm
val neg_conj_imp = {},  |- ~(A & B) <=> A ==> ~B: thm
val it = (): unit
******

Loading SEAR file SEARNarith.sml

******
val Nind's_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        IN(a#, Nind's(f0, x0)) <=> SS(App(Nindf(f0, x0), a#), a#): thm
val Nind_cases0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- App(Nindf(f0, x0), Ninds(f0, x0)) = Ninds(f0, x0): thm
val Nind_cases1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_incond =
   !(nx : mem(N * X)).
     IN(nx#, Nind1) <=>
     nx# = Pair(O, x0) |
     ?(nx0 : mem(N * X)).
       IN(nx0#, Nind0) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): form
val Nind_ind =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), ss#), ss#) ==> SS(Ninds(f0, x0), ss#): thm
val Nind_ind1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        (!(a : mem(N * X)).
            a# = Pair(O, x0) |
            (?(nx0 : mem(N * X)).
                IN(nx0#, ss#) & a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_rules0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- SS(App(Nindf(f0, x0), Ninds(f0, x0)), Ninds(f0, x0)): thm
val Nind_rules1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        a# = Pair(O, x0) |
        (?(nx0 : mem(N * X)).
            IN(nx0#, Ninds(f0, x0)) &
            a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
        IN(a#, Ninds(f0, x0)): thm
val Nind_rules2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (a# = Pair(O, x0) ==> IN(a#, Ninds(f0, x0))) &
        !(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))) ==>
          IN(a#, Ninds(f0, x0)): thm
val Nind_rules3 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nindf_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
        IN(nx#, App(Nindf(f0, x0), a#)) <=>
        nx# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nindf_ex =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(N * X), Pow(N * X))).
        !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
          IN(nx#, App(f#, a#)) <=>
          nx# = Pair(O, x0) |
          ?(nx0 : mem(N * X)).
            IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))):
   thm
val Nindf_monotone =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(N * X)))  (s2 : mem(Pow(N * X))).
        SS(s1#, s2#) ==> SS(App(Nindf(f0, x0), s1#), App(Nindf(f0, x0), s2#)):
   thm
val Ninds_SS =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), a#), a#) ==> SS(Ninds(f0, x0), a#): thm
val Ninds_cond =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (!(ss : mem(Pow(N * X))).
            SS(App(Nindf(f0, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Ninds(f0, x0)): thm
val Ninds_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- Ninds(f0, x0) = BIGINTER(Nind's(f0, x0)): thm
val x1 = "Nind0": string
val Nind_cases =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_rules =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nind_uex =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        ?!(x : mem(X#)). IN(Pair(n#, x#), Ninds(f0#, x0#)): thm
val Nrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (a : mem(N)).
        IN(Pair(a#, App(Nrec(x0#, f0#), a#)), Ninds(f0#, x0#)): thm
val Nrec_O =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        App(Nrec(x0#, f0#), O) = x0#: thm
val App_Nrec_Ninds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N))
      (x : mem(X#)).
        App(Nrec(x0#, f0#), n#) = x# <=> IN(Pair(n#, x#), Ninds(f0#, x0#)):
   thm
val Nrec_Suc =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        App(Nrec(x0#, f0#), Suc(n#)) = App(f0#, App(Nrec(x0#, f0#), n#)): thm
val Nrec_unique =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Nrec_Suc_eqn =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        Nrec(x0#, f0#) o SUC = f0# o Nrec(x0#, f0#): thm
val El_def = {},  |- !(A : set)  (a : mem(A#)). App(El(a#), dot) = a#: thm
val El_eq_eq =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). El(a#) = El(b#) <=> a# = b#:
   thm
val App_o_El =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(f#, a#) = App(f# o El(a#), dot): thm
val Nrec_El =
   {}, 
   |- !(X : set)  (a : mem(X#))  (f : fun(X#, X#)).
        Nrec(a#, f#) o El(O) = El(a#) &
        Nrec(a#, f#) o SUC = f# o Nrec(a#, f#) &
        !(u : fun(N, X#)).
          u# o El(O) = El(a#) & u# o SUC = f# o u# ==> u# = Nrec(a#, f#): thm
val App_El_mem =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(f#, a#) = b# <=> f# o El(a#) = El(b#): thm
val Nrec_O_SUC = {},  |- Nrec(O, SUC) = Id(N): thm
val comm_with_SUC_id0 =
   {}, 
   |- !(f : fun(N, N)). App(f#, O) = O & f# o SUC = SUC o f# ==> f# = Id(N):
   thm
val comm_with_SUC_id =
   {}, 
   |- !(f : fun(N, N)).
        f# o El(O) = El(O) & f# o SUC = SUC o f# ==> f# = Id(N): thm
val Thm1_case1_comm_condition =
   {}, 
   |- !(B : set)  (f0 : fun(N, B#))  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        f0# o El(O) = g# & f0# o SUC = h# o Pa(Id(N), f0#) <=>
        Pa(Id(N), f0#) o El(O) = Pa(El(O), g#) &
        Pa((SUC o p1(N, B#)), h#) o Pa(Id(N), f0#) = Pa(Id(N), f0#) o SUC:
   thm
val Dot_def = {},  |- !(A : set)  (f : fun(1, A#)). Dot(f#) = App(f#, dot):
   thm
val Dot_of_El = {},  |- !(A : set)  (a : mem(A#)). Dot(El(a#)) = a#: thm
val El_of_Dot = {},  |- !(X : set)  (f : fun(1, X#)). El(Dot(f#)) = f#: thm
val to_P_component =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#)).
        Pa(p1(A#, B#) o f#, p2(A#, B#) o f#) = f#: thm
val Thm1_case_1 =
   {}, 
   |- !(B : set)  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        ?!(f : fun(N, B#)). f# o El(O) = g# & f# o SUC = h# o Pa(Id(N), f#):
   thm
val is_Nrec =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Tp1_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(tpf : fun(1, Exp(A#, B#))). Tp(f# o p1(A#, 1)) = tpf#: thm
val Ev_of_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#)).
        Ev(A#, B#) o Pa(p1(A#, X#), Tp(f#) o p2(A#, X#)) = f#: thm
val Tp1_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Tp(f# o p1(A#, 1)) = Tp1(f#):
   thm
val Tp_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (g : fun(A# * X#, B#)). Tp(f#) = Tp(g#) <=> f# = g#: thm
val Ev_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, Exp(A#, B#)))
      (g : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), f# o p2(A#, X#)) = Ev(A#, B#) o
          Pa(p1(A#, X#), g# o p2(A#, X#)) ==> f# = g#: thm
val to_P_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#))
      (g : fun(X#, A# * B#)).
        p1(A#, B#) o f# = p1(A#, B#) o g# & p2(A#, B#) o f# = p2(A#, B#) o g# ==>
        f# = g#: thm
val Pa_o_split =
   {}, 
   |- !(B : set)  (X : set)  (f : fun(B#, X#))  (Y : set)  (g : fun(X#, Y#))
      (A : set).
        Pa(p1(A#, B#), g# o f# o p2(A#, B#)) =
          Pa(p1(A#, X#), (g# o p2(A#, X#))) o Pa(p1(A#, B#), f# o p2(A#, B#)):
   thm
val Thm1_comm_eq_left =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))  (g : fun(A#, B#)).
        Tp(f#) o El(O) = Tp1(g#) <=>
        f# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1): thm
val Pa_p1_p2 =
   {},  |- !(A : set)  (B : set). Pa(p1(A#, B#), p2(A#, B#)) = Id(A# * B#):
   thm
val Thm1_comm_eq_right =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))
      (h : fun((A# * N) * B#, B#))
      (l : fun(A# * N * Exp(A#, B#), (A# * N) * B#)).
        Pa(Pa(p1(A#, N * Exp(A#, B#)), p1(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#))), Ev(A#, B#) o
           Pa(p1(A#, N * Exp(A#, B#)), p2(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#)))) = l# ==>
        (h# o Pa(Id(A# * N), f#) = f# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
          Tp((h# o l#)) o Pa(Id(N), Tp(f#)) = Tp(f#) o SUC): thm
val Ev_of_Tp_el =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))  (P : set)
      (a : fun(P#, A#))  (x : fun(P#, X#)).
        Ev(A#, B#) o Pa(a#, Tp(f#) o x#) = f# o Pa(a#, x#): thm
val Ev_of_Tp_el' =
   {}, 
   |- !(A : set)  (B : set)  (P : set)  (f : fun(A# * P#, B#))
      (a : fun(P#, A#)). Ev(A#, B#) o Pa(a#, Tp(f#)) = f# o Pa(a#, Id(P#)):
   thm
val Tp_of_Ev =
   {(A : set), (B : set), (X : set), (f : fun(X, Exp(A, B)))}, 
   |- Tp(Ev(A, B) o Pa(p1(A, X), f o p2(A, X))) = f: thm
val Thm1 =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val Thm1_uex =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?!(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val PRE_def = {},  |- PRE o El(O) = El(O) & PRE o SUC = Id(N): thm
val Pre_def = {},  |- !(n : mem(N)). Pre(n#) = App(PRE, n#): thm
val Pre_eqn = {},  |- Pre(O) = O & !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val ADD_def =
   {}, 
   |- ADD o Pa(p1(N, 1), El(O) o To1(N * 1)) = p1(N, 1) &
      SUC o ADD = ADD o Pa(p1(N, N), SUC o p2(N, N)): thm
val Add_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Add(n1#, n2#) = App(ADD, Pair(n1#, n2#)):
   thm
val Add_O = {},  |- !(n : mem(N)). Add(n#, O) = n#: thm
val App_input_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a1 : mem(A#))
      (a2 : mem(A#)). a1# = a2# ==> App(f#, a1#) = App(f#, a2#): thm
val Add_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, Suc(n#)) = Suc(Add(m#, n#)):
   thm
val Pre_O = {},  |- Pre(O) = O: thm
val Pre_Suc = {},  |- !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val SUB_def =
   {}, 
   |- SUB o Pa(p1(N, 1), El(O) o p2(N, 1)) = p1(N, 1) &
      PRE o SUB = SUB o Pa(p1(N, N), SUC o p2(N, N)): thm
val o_eq_r =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        f1# = f2# ==> !(C : set)  (g : fun(B#, C#)). g# o f1# = g# o f2#: thm
val Sub_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Sub(n1#, n2#) = App(SUB, Pair(n1#, n2#)):
   thm
val Sub_O = {},  |- !(n : mem(N)). Sub(n#, O) = n#: thm
val Sub_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, Suc(n#)) = Pre(Sub(m#, n#)):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Le_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Pre_eq_O = {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O):
   thm
val Lt_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val Le_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val Lt_Le = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> Le(m#, n#):
   thm
val Lt_NE = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> ~m# = n#: thm
val Le_NE_Lt =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) & ~m# = n# ==> Lt(m#, n#):
   thm
val Lt_Le_NE =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val Sub_mono_eq =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(Suc(m#), Suc(n#)) = Sub(m#, n#):
   thm
val Add_Sub = {},  |- !(c : mem(N))  (a : mem(N)). Sub(Add(a#, c#), c#) = a#:
   thm
val Add_O2 = {},  |- !(n : mem(N)). Add(O, n#) = n#: thm
val Sub_EQ_O = {},  |- !(n : mem(N)). Sub(n#, n#) = O: thm
val Le_refl = {},  |- !(n : mem(N)). Le(n#, n#): thm
val Le_O_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val o_eq_l =
   {}, 
   |- !(B : set)  (C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
        g1# = g2# ==> !(A : set)  (f : fun(A#, B#)). g1# o f# = g2# o f#: thm
val Le_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) ==> Lt(m#, n#) | m# = n#:
   thm
val Le_Sub =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val cancel_Sub =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Le(a#, c#) ==> (Sub(b#, a#) = Sub(c#, a#) <=> b# = c#):
   thm
val th =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Sub_of_O = {},  |- !(n : mem(N)). Sub(O, n#) = O: thm
val O_LESS_EQ = {},  |- !(x : mem(N)). Le(O, x#): thm
val LESS_EQ_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val LESS_O = {},  |- !(n : mem(N)). Lt(O, Suc(n#)): thm
val LESS_MONO_EQ =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val LE_O_iff = {},  |- !(n : mem(N)). Le(n#, O) <=> n# = O: thm
val LESS_cases =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | Le(b#, a#): thm
val LESS_EQ_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) | Le(n#, m#): thm
val Add_Suc1 =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(Suc(a#), b#) = Suc(Add(a#, b#)):
   thm
val Add_comm =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(a#, b#) = Add(b#, a#): thm
val Suc_Sub = {},  |- !(n : mem(N)). Sub(Suc(n#), n#) = Suc(O): thm
val Sub_DIFF_1 =
   {},  |- !(a : mem(N))  (b : mem(N)). Sub(a#, b#) = Suc(O) <=> a# = Suc(b#):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Sub_Suc_O_cases =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, Suc(b#)) = O ==> a# = Suc(b#) | Sub(a#, b#) = O: thm
val Le_cases_iff =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) <=> Lt(a#, b#) | a# = b#:
   thm
val Lt_Suc_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Suc(b#)) <=> Le(a#, b#): thm
val Sub_EQ_O1 =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, n#) = O <=> Le(m#, n#): thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val strong_ind =
   {}, 
   |- (!(a : mem(N)). (!(a0 : mem(N)). Lt(a0#, a#) ==> P(a0#)) ==> P(a#)) ==>
      !(a : mem(N)). P(a#): thm
val WOP =
   {}, 
   |- !(a : mem(N)).
        P(a#) ==>
        ?(a0 : mem(N)). P(a0#) & !(a1 : mem(N)). P(a1#) ==> Le(a0#, a1#): thm
val MUL_def0 =
   {}, 
   |- MUL o Pa(p1(N, 1), El(O) o To1(N * 1)) = El(O) o To1(N * 1) &
      ADD o Pa(MUL, p1(N, N)) = MUL o Pa(p1(N, N), SUC o p2(N, N)): thm
val Mul_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Mul(n1#, n2#) = App(MUL, Pair(n1#, n2#)):
   thm
val App_Pa2 =
   {}, 
   |- !(A : set)  (B : set)  (D : set)  (g : fun(B#, D#))
      (ab : mem(A# * B#)).
        App(Pa(p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_p1_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p1(A#, B#), Pair(a#, b#)) = a#: thm
val App_p2_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p2(A#, B#), Pair(a#, b#)) = b#: thm
val Mul_O = {},  |- !(n : mem(N)). Mul(n#, O) = O: thm
val Mul_Suc =
   {}, 
   |- !(n : mem(N))  (n0 : mem(N)). Mul(n#, Suc(n0#)) = Add(Mul(n#, n0#), n#):
   thm
val Mul_LEFT_O = {},  |- !(m : mem(N)). Mul(O, m#) = O: thm
val Mul_LEFT_1 = {},  |- !(m : mem(N)). Mul(Suc(O), m#) = m#: thm
val Mul_RIGHT_1 = {},  |- !(m : mem(N)). Mul(m#, Suc(O)) = m#: thm
val Add_comm' =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(b#, a#) = Add(a#, b#): thm
val Add_assoc =
   {}, 
   |- !(m : mem(N))  (n0 : mem(N))  (p : mem(N)).
        Add(m#, Add(n0#, p#)) = Add(Add(m#, n0#), p#): thm
val Add_eq_eq =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (a : mem(N)).
        Add(m#, a#) = Add(n#, a#) ==> m# = n#: thm
val Mul_Suc1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Mul(Suc(n#), m#) = Add(m#, Mul(n#, m#)):
   thm
val Mul_clauses =
   {}, 
   |- (!(m : mem(N)).
          Mul(O, m#) = O &
          Mul(m#, O) = O & Mul(Suc(O), m#) = m# & Mul(m#, Suc(O)) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Mul(Suc(m#), n#) = Add(Mul(m#, n#), n#) &
        Mul(m#, Suc(n#)) = Add(m#, Mul(m#, n#)): thm
val Mul_comm =
   {},  |- !(m : mem(N))  (n : mem(N)). Mul(m#, n#) = Mul(n#, m#): thm
val Add_clauses =
   {}, 
   |- (!(m : mem(N)). Add(O, m#) = m# & Add(m#, O) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Add(Suc(m#), n#) = Suc(Add(m#, n#)) &
        Add(m#, Suc(n#)) = Suc(Add(m#, n#)): thm
val Nind_tac = fn: tactic
val RIGHT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Add(m#, n#), p#) = Add(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Add(m#, n#)) = Add(Mul(p#, m#), Mul(p#, n#)): thm
val Mul_assoc =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(m#, Mul(n#, p#)) = Mul(Mul(m#, n#), p#): thm
val Sub_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Sub(a#, Add(b#, c#)) = Sub(Sub(a#, b#), c#): thm
val Le_O_iff = {},  |- !(a : mem(N)). Le(a#, O) <=> a# = O: thm
val Le_Suc =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, Suc(b#)) ==> Le(a#, b#) | a# = Suc(b#): thm
val Le_Add_ex =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(n#, m#) ==> ?(p : mem(N)). Add(p#, n#) = m#: thm
val LE_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Sub(a#, b#) = O:
   thm
val LT_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Holds(LT, a#, b#) <=> Holds(LE, a#, b#) & ~a# = b#: thm
val LE_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Le(a#, b#): thm
val LT_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LT, a#, b#) <=> Lt(a#, b#): thm
val LE_Trans = {},  |- Trans(LE): thm
val LESS_MONO_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(m#, n#) <=> Lt(Add(m#, p#), Add(n#, p#)): thm
val EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val LESS_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(Add(m#, p#), Add(n#, p#)) <=> Lt(m#, n#): thm
val LESS_OR_EQ =
   {(m : mem(N)), (n : mem(N))},  |- Le(m, n) <=> Lt(m, n) | m = n: thm
val LESS_EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(Add(m#, p#), Add(n#, p#)) <=> Le(m#, n#): thm
val Le_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, c#) & Le(b#, d#) ==> Le(Add(a#, b#), Add(c#, d#)): thm
val Le_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Le(a1#, a2#) & Le(a2#, a3#) ==> Le(a1#, a3#): thm
val Asym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Asym(R#) <=>
        !(a : mem(A#))  (b : mem(A#)).
          Holds(R#, a#, b#) & Holds(R#, b#, a#) ==> a# = b#: thm
val Lt_Suc = {},  |- !(a : mem(N)). Lt(a#, Suc(a#)): thm
val Suc_NEQ = {},  |- !(a : mem(N)). ~a# = Suc(a#): thm
val Add_Suc_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Add(a#, Suc(b#))): thm
val LT_Trans = {},  |- Trans(LT): thm
val Lt_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Lt(a1#, a2#) & Lt(a2#, a3#) ==> Lt(a1#, a3#): thm
val LE_Asym = {},  |- Asym(LE): thm
val Le_Asym =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) ==> a# = b#:
   thm
val LESS_EQ_LESS_EQ_MONO =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N))  (q : mem(N)).
        Le(m#, p#) & Le(n#, q#) ==> Le(Add(m#, n#), Add(p#, q#)): thm
val Le_MONO_Mul =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(m#, n#) ==> Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul' =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(m#, n#) ==> !(p : mem(N)). Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Le(m#, i#) & Le(n#, j#) ==> Le(Mul(m#, n#), Mul(i#, j#)): thm
val Le_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val Le_O' = {},  |- !(x : mem(N)). Le(O, x#): thm
val Sub_Suc1 =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(b#, a#) ==> Sub(Suc(a#), b#) = Suc(Sub(a#, b#)): thm
val SUB_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Le(n#, m#) ==> Add(Sub(m#, n#), n#) = m#:
   thm
val ADD_EQ_SUB =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(n#, p#) ==> (Add(m#, n#) = p# <=> m# = Sub(p#, n#)): thm
val NOT_SUC_LESS_EQ_O = {},  |- !(n : mem(N)). ~Le(Suc(n#), O): thm
val NOT_SUC_LT_O = {},  |- !(n : mem(N)). ~Lt(Suc(n#), O): thm
val Lt_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val Lt_trichotomy =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | a# = b# | Lt(b#, a#):
   thm
val NEQ_O_Lt = {},  |- !(a : mem(N)). ~a# = O <=> Lt(O, a#): thm
val Add_eq_O =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, n#) = O <=> m# = O & n# = O:
   thm
val Mul_eq_O =
   {}, 
   |- !(a : mem(N)). ~a# = O ==> !(b : mem(N)). Mul(a#, b#) = O <=> b# = O:
   thm
val Sub_Sub_O_eq =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, b#) = O & Sub(b#, a#) = O ==> a# = b#: thm
val NOT_LESS =
   {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#): thm
val RIGHT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Sub(m#, n#), p#) = Sub(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Sub(m#, n#)) = Sub(Mul(p#, m#), Mul(p#, n#)): thm
val MULT_MONO_EQ =
   {}, 
   |- !(n : mem(N))  (m : mem(N))  (i : mem(N)).
        Mul(Suc(n#), m#) = Mul(Suc(n#), i#) <=> m# = i#: thm
val Mul_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        ~p# = O ==> (Mul(m#, p#) = Mul(n#, p#) <=> m# = n#): thm
val Lt_MONO_Mul =
   {}, 
   |- !(p : mem(N)).
        Lt(O, p#) ==>
        !(m : mem(N))  (n : mem(N)).
          Lt(m#, n#) ==> Lt(Mul(m#, p#), Mul(n#, p#)): thm
val Le_Lt_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Lt(a#, c#): thm
val Lt_O_Lt = {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) ==> Lt(O, b#):
   thm
val Lt_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Lt(m#, i#) & Lt(n#, j#) ==> Lt(Mul(m#, n#), Mul(i#, j#)): thm
val LESS_ADD_NONZERO =
   {},  |- !(m : mem(N))  (n : mem(N)). ~n# = O ==> Lt(m#, Add(m#, n#)): thm
val SUB_LESS =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Lt(O, n#) & Le(n#, m#) ==> Lt(Sub(m#, n#), m#): thm
val Add_leq =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (b : mem(N)).
        a1# = a2# ==> Add(a1#, b#) = Add(a2#, b#): thm
val Add_req =
   {}, 
   |- !(a : mem(N))  (b1 : mem(N))  (b2 : mem(N)).
        b1# = b2# ==> Add(a#, b1#) = Add(a#, b2#): thm
val Add_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, b#), Add(c#, d#)): thm
val Add_split_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(a#, Add(Add(b#, c#), d#)): thm
val Add_last_middle_split =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, d#), Add(b#, c#)): thm
val Add_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val Add_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (m : mem(N))  (n : mem(N)).
        Add(a#, m#) = Add(a#, n#) <=> m# = n#: thm
val Lt_Sub_O =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) <=> Lt(O, Sub(b#, a#)):
   thm
val Lt_Le_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(a#, b#) & Le(b#, c#) ==> Lt(a#, c#): thm
val LESS_EQ_SUC = {},  |- !(n : mem(N)). Le(n#, Suc(n#)): thm
val Le_Lt_Le =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Le(a#, c#): thm
val Add_Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(Add(a#, b#), Add(c#, d#)) = Add(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_Lt_Lt_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Lt(c#, d#) ==> Lt(Add(a#, c#), Add(b#, d#)): thm
val Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Add(a#, Add(b#, c#)) = Add(b#, Add(a#, c#)): thm
val NOT_LESS_EQ =
   {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
val SUC_NOT_LESS_EQ = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
val Lt_Le_Suc =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(b#, a#) <=> Le(Suc(b#), a#): thm
val Le_Le_iff_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) <=> a# = b#:
   thm
val Le_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Le(a#, b#) ==> Le(Sub(a#, c#), Sub(b#, c#)): thm
val Lt_imp_Sub_O =
   {(a : mem(N)), (b : mem(N))},  |- Lt(a, b) ==> Sub(a, b) = O: thm
val Lt_Sub_imp_Le =
   {(a : mem(N)), (b : mem(N)), (c : mem(N))}, 
   |- Lt(a, Sub(b, c)) ==> Le(c, b): thm
val Lt_MONO_Sub_hard_direction =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(Sub(a#, c#), Sub(b#, c#)) & Le(c#, a#) ==> Lt(a#, b#): thm
val Lt_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Lt(a#, b#) <=> Lt(Sub(a#, c#), Sub(b#, c#)): thm
val Add_Le = {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, Add(a#, b#)): thm
val Add_pos_Lt =
   {}, 
   |- !(a : mem(N)).
        Lt(O, a#) ==>
        !(b : mem(N))  (c : mem(N)). Add(a#, b#) = c# ==> Lt(b#, c#): thm
val Le_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Le(c#, d#) ==>
          Le(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val Lt_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Lt(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Lt(c#, d#) ==>
          Lt(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val num1_def = {},  |- num1 = Suc(O): thm
val num2_def = {},  |- num2 = Suc(num1): thm
val num3_def = {},  |- num3 = Suc(num2): thm
val num4_def = {},  |- num4 = Suc(num3): thm
val WOP' =
   {}, 
   |- !(s : mem(Pow(N))).
        ~s# = Empty(N) ==>
        ?(a0 : mem(N)).
          IN(a0#, s#) & !(a1 : mem(N)). IN(a1#, s#) ==> Le(a0#, a1#): thm
val division_theorem_N_ex0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Lt(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val division_theorem_N_ex =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Le(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val NOT_Lt_O_O = {},  |- ~Lt(O, O): thm
val it = (): unit
******

Loading SEAR file SEARZarith.sml

******
val ZR_def =
   {}, 
   |- !(x : mem(N))  (y : mem(N))  (u : mem(N))  (v : mem(N)).
        Holds(ZR, Pair(x#, y#), Pair(u#, v#)) <=> Add(x#, v#) = Add(u#, y#):
   thm
val ZR_Refl = {},  |- Refl(ZR): thm
val ZR_Trans = {},  |- Trans(ZR): thm
val ZR_Sym = {},  |- Sym(ZR): thm
val ZR_ER = {},  |- ER(ZR): thm
val Ri_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (s : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Ri(r#), s#)) <=>
        ?(a : mem(A#)). IN(a#, s#) & Holds(r#, a#, b#): thm
val Rsi_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#)). Rsi(r#) = Ri(r#) o Sg(A#):
   thm
val rsi_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (r : rel(A#, B#)).
        rsi(r#, a#) = App(Rsi(r#), a#): thm
val IN_rsi =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
val ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          (!(x : mem(A#)). Holds(r#, a1#, x#) <=> Holds(r#, a2#, x#)) <=>
          Holds(r#, a1#, a2#): thm
val rsi_eq_ER =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          rsi(r#, a1#) = rsi(r#, a2#) <=> Holds(r#, a1#, a2#): thm
val Z_def =
   {}, 
   |- Inj(iZ) &
      !(a : mem(Pow(N * N))).
        (?(n : mem(N * N)). a# = rsi(ZR, n#)) <=>
        ?(b : mem(Z)). a# = App(iZ, b#): thm
val iZ_Inj = {},  |- Inj(iZ): thm
val iZ_eq_eq =
   {}, 
   |- !(x1 : mem(Z))  (x2 : mem(Z)).
        App(iZ, x1#) = App(iZ, x2#) ==> x1# = x2#: thm
val iZ_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(m : mem(N))  (n : mem(N)). App(iZ, z#) = rsi(ZR, Pair(m#, n#)): thm
val rsi_iZ =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        ?(b : mem(Z)). rsi(ZR, Pair(m#, n#)) = App(iZ, b#): thm
val resp_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#)).
        resp(f#, r1#, r2#) <=>
        !(y : mem(A#))  (z : mem(A#)).
          Holds(r1#, y#, z#) ==> Holds(r2#, App(f#, y#), App(f#, z#)): thm
val rext_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a0 : mem(Pow(A#)))  (b0 : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a0#, b0#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a0# = rsi(r1#, a#) & b0# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val rext_def0 =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a : mem(Pow(A#)))  (b : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a#, b#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a# = rsi(r1#, a#) & b# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val prrel_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#))
      (a1 : mem(A#))  (b1 : mem(B#))  (a2 : mem(A#))  (b2 : mem(B#)).
        Holds(prrel(r1#, r2#), Pair(a1#, b1#), Pair(a2#, b2#)) <=>
        Holds(r1#, a1#, a2#) & Holds(r2#, b1#, b2#): thm
val main =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val ipow2_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (b : mem(B#))  (Q1 : set)
      (aq : mem(Q1#))  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (bq : mem(Q2#))
      (i2 : fun(Q2#, Pow(B#))).
        IN(Pair(a#, b#), App(ipow2(i1#, i2#), Pair(aq#, bq#))) <=>
        IN(a#, App(i1#, aq#)) & IN(b#, App(i2#, bq#)): thm
val addf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(addf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(a#, a'#), Add(b#, b''#)): thm
val prrel_ER_ER =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#)).
        ER(r1#) & ER(r2#) ==> ER(prrel(r1#, r2#)): thm
val Pow_conj_eq0 =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3#: thm
val Pow_conj_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3# & s2# = s4#: thm
val ipow2_Inj_Inj =
   {}, 
   |- !(Q1 : set)  (A : set)  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (B : set)
      (i2 : fun(Q2#, Pow(B#))).
        (!(q1 : mem(Q1#)). ?(a : mem(A#)). IN(a#, App(i1#, q1#))) &
        (!(q2 : mem(Q2#)). ?(b : mem(B#)). IN(b#, App(i2#, q2#))) &
        Inj(i1#) & Inj(i2#) ==> Inj(ipow2(i1#, i2#)): thm
val Quo_def =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quo(r#, i#) <=>
        !(s : mem(Pow(A#))).
          (?!(q : mem(Q#)). s# = App(i#, q#)) <=>
          ?(a : mem(A#)). s# = rsi(r#, a#): thm
val Inj_Quo =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Inj(i) &
      (!(s : mem(Pow(A))).
          (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#)) <=>
      Inj(i) & Quo(r, i): thm
val ER_rsi_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a : mem(A#)).
        ER(r#) ==> IN(a#, rsi(r#, a#)): thm
val Quo_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) & Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        Quo(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val Quo_fun =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val main_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val Inj_Quo_Z = {},  |- Inj(iZ) & Quo(ZR, iZ): thm
val Quo_fun_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val iZ_nonempty =
   {},  |- !(z : mem(Z)). ?(ab : mem(N * N)). IN(ab#, App(iZ, z#)): thm
val addf0_resp = {},  |- resp(addf0, prrel(ZR, ZR), ZR): thm
val addz_conds =
   {}, 
   |- ER(prrel(ZR, ZR)) &
      ER(ZR) &
      resp(addf0, prrel(ZR, ZR), ZR) &
      Inj(ipow2(iZ, iZ)) &
      Inj(iZ) & Quo(prrel(ZR, ZR), ipow2(iZ, iZ)) & Quo(ZR, iZ): thm
val main_addz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(addz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(addf0, a#) = b#: thm
val main_addz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(addz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val Inj_Quo_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Inj(i#) & Quo(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). App(i#, q#) = rsi(r#, a#): thm
val Z_has_rep =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). App(iZ, z#) = rsi(ZR, Pair(a'#, b#)):
   thm
val Addz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Addz(z1#, z2#) = App(addz, Pair(z1#, z2#)): thm
val Repz_def = {},  |- !(z : mem(Z)). Repz(z#) = App(iZ, z#): thm
val Repz_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = rsi(ZR, Pair(a'#, b#)): thm
val ZC_def = {},  |- !(ab : mem(N * N)). ZC(ab#) = rsi(ZR, ab#): thm
val Repz_ZC =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = ZC(Pair(a'#, b#)): thm
val Addz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Addz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val ZC_ZR =
   {}, 
   |- !(ab : mem(N * N))  (cd : mem(N * N)).
        ZC(ab#) = ZC(cd#) <=> Holds(ZR, ab#, cd#): thm
val Addz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Addz(z1#, z2#)) = ZC(Pair(Add(a1#, a3#), Add(a2#, a4#))): thm
val Repz_eq_eq =
   {},  |- !(x1 : mem(Z))  (x2 : mem(Z)). Repz(x1#) = Repz(x2#) ==> x1# = x2#:
   thm
val Repz_eq_ZR =
   {}, 
   |- !(a1 : mem(N * N))  (a2 : mem(N * N)).
        ZC(a1#) = ZC(a2#) <=> Holds(ZR, a1#, a2#): thm
val eq_ZR =
   {},  |- !(a : mem(N * N))  (b : mem(N * N)). a# = b# ==> Holds(ZR, a#, b#):
   thm
val Addz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Addz(z1#, z2#) = Addz(z2#, z1#):
   thm
val negf0_def =
   {},  |- !(a : mem(N * N)). App(negf0, a#) = Pair(Snd(a#), Fst(a#)): thm
val negf0_def1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). App(negf0, Pair(m#, n#)) = Pair(n#, m#):
   thm
val negf0_resp = {},  |- resp(negf0, ZR, ZR): thm
val Negz_def = {},  |- !(z : mem(Z)). Negz(z#) = App(negz, z#): thm
val main_negz =
   {(z : mem(Z))}, 
   |- ?(a : mem(N * N))  (b : mem(N * N)).
        Repz(z) = ZC(a#) & Repz(App(negz, z)) = ZC(b#) & App(negf0, a#) = b#:
   thm
val Negz_char =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = ZC(Pair(a#, b#)) ==> Repz(Negz(z#)) = ZC(Pair(b#, a#)):
   thm
val main_negz1 =
   {(z : mem(Z))}, 
   |- ?(a1' : mem(N))  (a2' : mem(N)).
        Repz(z) = ZC(Pair(a1'#, a2'#)) & Repz(Negz(z)) = ZC(Pair(a2'#, a1'#)):
   thm
val mulf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(mulf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(Mul(a#, a'#), Mul(b#, b''#)),
           Add(Mul(a#, b''#), Mul(b#, a'#))): thm
val mulf0_resp = {},  |- resp(mulf0, prrel(ZR, ZR), ZR): thm
val main_mulz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(mulz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(mulf0, a#) = b#: thm
val main_mulz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(mulz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
           Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Mulz(z1#, z2#) = App(mulz, Pair(z1#, z2#)): thm
val Mulz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Mulz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Mulz(z1#, z2#)) =
            ZC(Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
              Add(Mul(a1#, a4#), Mul(a2#, a3#)))): thm
val ZC_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        ?!(z : mem(Z)). Repz(z#) = ZC(Pair(a#, b#)): thm
val ZC_Repz' =
   {},  |- !(ab : mem(N * N)). ?!(z : mem(Z)). Repz(z#) = ZC(ab#): thm
val absz_def =
   {}, 
   |- !(a' : mem(N))  (b : mem(N))  (b : mem(Z)).
        App(absz, Pair(a'#, b#)) = b# <=> Repz(b#) = ZC(Pair(a'#, b#)): thm
val Absz_def = {},  |- !(ab : mem(N * N)). Absz(ab#) = App(absz, ab#): thm
val Asz_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Asz(a#, b#) = Absz(Pair(a#, b#)): thm
val Zc_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Zc(a#, b#) = ZC(Pair(a#, b#)): thm
val Absz_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Repz(Absz(Pair(a#, b#))) = ZC(Pair(a#, b#)): thm
val Asz_Repz =
   {},  |- !(a : mem(N))  (b : mem(N)). Repz(Asz(a#, b#)) = Zc(a#, b#): thm
val Oz_def = {},  |- Oz = Asz(O, O): thm
val En_def = {},  |- En = Suc(O): thm
val Ez_def = {},  |- Ez = Asz(En, O): thm
val Addz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Addz(z1#, z2#)) = Zc(Add(a1#, a3#), Add(a2#, a4#)): thm
val Addz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Addz(Asz(a#, b#), Asz(c#, d#)) = Asz(Add(a#, c#), Add(b#, d#)): thm
val Mulz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Mulz(z1#, z2#)) =
            Zc(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))): thm
val Mulz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Mulz(Asz(a#, b#), Asz(c#, d#)) =
          Asz(Add(Mul(a#, c#), Mul(b#, d#)), Add(Mul(a#, d#), Mul(b#, c#))):
   thm
val Negz_th0 =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) ==> Repz(Negz(z#)) = Zc(b#, a#): thm
val Negz_Asz =
   {},  |- !(a : mem(N))  (b : mem(N)). Negz(Asz(a#, b#)) = Asz(b#, a#): thm
val cases_z =
   {},  |- !(z : mem(Z)). ?(a : mem(N))  (b : mem(N)). z# = Asz(a#, b#): thm
val Addz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Addz(Addz(z1#, z2#), z3#) = Addz(z1#, Addz(z2#, z3#)): thm
val casesz =
   {}, 
   |- (!(a : mem(N))  (b : mem(N)). P(Asz(a#, b#))) <=> !(z : mem(Z)). P(z#):
   thm
SEARZarith.sml:1213: warning: Matches are not exhaustive. Found near fn [th0] => dimp_mp_l2r th0 th
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val casez_tac = fn: cont * form list * form -> goal list * validation
val Asz_eq_ZR =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Asz(a#, b#) = Asz(c#, d#) <=> Holds(ZR, Pair(a#, b#), Pair(c#, d#)):
   thm
val Addz_Negz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Negz(z#)) = Oz: thm
val Mulz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Mulz(z1#, z2#), z3#) = Mulz(z1#, Mulz(z2#, z3#)): thm
val LDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(z1#, Addz(z2#, z3#)) = Addz(Mulz(z1#, z2#), Mulz(z1#, z3#)): thm
val Mulz_Ez = {},  |- !(z : mem(Z)). Mulz(z#, Ez) = z#: thm
val Mulz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Mulz(z1#, z2#) = Mulz(z2#, z1#):
   thm
val RDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Addz(z2#, z3#), z1#) = Addz(Mulz(z2#, z1#), Mulz(z3#, z1#)): thm
val le0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b' : mem(N)).
        le0(Pair(a#, b#), Pair(a'#, b'#)) <=> Le(Add(a#, b'#), Add(b#, a'#)):
   thm
val Lez_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) <=>
        !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
          Repz(z1#) = Zc(a#, b#) & Repz(z2#) = Zc(c#, d#) ==>
          Le(Add(a#, d#), Add(b#, c#)): thm
val LEz_def =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Holds(LEz, a#, b#) <=> Lez(a#, b#):
   thm
val LEz_Refl = {},  |- Refl(LEz): thm
val Repz_Zc =
   {}, 
   |- !(z : mem(Z)). ?(a' : mem(N))  (b : mem(N)). Repz(z#) = Zc(a'#, b#):
   thm
val LEz_Trans = {},  |- Trans(LEz): thm
val LEz_Asym = {},  |- Asym(LEz): thm
val Total_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Total(R#) <=>
        !(a : mem(A#))  (b : mem(A#)). Holds(R#, a#, b#) | Holds(R#, b#, a#):
   thm
val Lez_resp0 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N))  (e : mem(N))
      (f : mem(N))  (g : mem(N))  (h : mem(N)).
        Holds(ZR, Pair(a#, b#), Pair(c#, d#)) &
        Holds(ZR, Pair(e#, f#), Pair(g#, h#)) ==>
        (Le(Add(a#, f#), Add(b#, e#)) <=> Le(Add(c#, h#), Add(d#, g#))): thm
val LEz_Total = {},  |- Total(LEz): thm
val Lez_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Lez(Asz(a#, b#), Asz(c#, d#)) <=> Le(Add(a#, d#), Add(b#, c#)): thm
val Lez_Addz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) ==> !(z3 : mem(Z)). Lez(Addz(z1#, z3#), Addz(z2#, z3#)):
   thm
val Lez_Mulz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Lez(z1#, z2#) & Lez(Oz, z3#) ==> Lez(Mulz(z1#, z3#), Mulz(z2#, z3#)):
   thm
val EVEN_def =
   {}, 
   |- (!(a : mem(1)). App(EVEN, O) = true) &
      !(a : mem(N)). App(EVEN, Suc(a#)) = App(NOT, App(EVEN, a#)): thm
val Even_def = {(n : mem(N))},  |- Even(n) <=> App(EVEN, n) = true: thm
val O_Even = {},  |- Even(O): thm
val Suc_Even = {},  |- !(n : mem(N)). Even(Suc(n#)) <=> ~Even(n#): thm
val Even_not_Odd = {},  |- !(n : mem(N)). Even(n#) <=> ~Odd(n#): thm
val Odd_def = {(n : mem(N))},  |- Odd(n) <=> ~Even(n): thm
val Odd_not_Even = {},  |- !(n : mem(N)). Odd(n#) <=> ~Even(n#): thm
val id_ER = {},  |- !(A : set). ER(id(A#)): thm
val Sg_Inj = {},  |- !(A : set). Inj(Sg(A#)): thm
val Quo_id_Sg = {},  |- !(A : set). Quo(id(A#), Sg(A#)): thm
val Pow_conj_eq' =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (s1 : mem(Pow(A#)))  (B : set)
      (b0 : mem(B#))  (s2 : mem(Pow(B#))).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        !(s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#))).
          (!(a : mem(A#))  (b : mem(B#)).
              IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) <=>
          s1# = s3# & s2# = s4#: thm
val Repz_iff_Asz =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) <=> Asz(a#, b#) = z#: thm
val ipow2_prrel_ZR =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N)), (z1 : mem(Z)),
    (z2 : mem(Z))}, 
   |- App(ipow2(iZ, iZ), Pair(z1, z2)) =
        rsi(prrel(ZR, ZR), Pair(Pair(a, b), Pair(c, d))) <=>
      Asz(a, b) = z1 & Asz(c, d) = z2: thm
val Asz_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, b#) = Asz(a#, c#) <=> b# = c#: thm
val Ltz_def =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Lez(a#, b#) & ~a# = b#:
   thm
val N2Z_def = {},  |- !(a : mem(N)). App(N2Z, a#) = Asz(a#, O): thm
val n2z_def = {},  |- !(n : mem(N)). n2z(n#) = App(N2Z, n#): thm
val Asz_eq_eq_l =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, c#) = Asz(b#, c#) <=> a# = b#: thm
val N2Z_Inj = {},  |- Inj(N2Z): thm
val Repz_eq_eq_iff =
   {(x1 : mem(Z)), (x2 : mem(Z))},  |- Repz(x1) = Repz(x2) <=> x1 = x2: thm
val prove_dimp_th = fn: thm -> thm
val Abv_positive_ex0 =
   {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> ?(n : mem(N)). Asz(n#, O) = z#: thm
val Lez_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Lez(Negz(z#), Negz(b#)) <=> Lez(b#, z#):
   thm
val Negz_eq_eq =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Negz(z#) = Negz(b#) <=> z# = b#: thm
val Negz_Oz = {},  |- Negz(Oz) = Oz: thm
val Abv_negative_ex0 =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> ?(n : mem(N)). Asz(O, n#) = z#: thm
val Lez_dichotomy =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Lez(z#, b#) | Lez(b#, z#): thm
val Ltz_Asz =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N))}, 
   |- Ltz(Asz(a, b), Asz(c, d)) <=> Lt(Add(a, d), Add(b, c)): thm
val NOT_Lez_Ltz =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Lez(z#, b#) <=> Ltz(b#, z#): thm
val Abv_def =
   {}, 
   |- !(z : mem(Z)).
        Lez(Oz, z#) & Asz(Abv(z#), O) = z# |
        Ltz(z#, Oz) & Asz(O, Abv(z#)) = z#: thm
val Abv_nonneg = {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> Asz(Abv(z#), O) = z#:
   thm
val Abv_uex =
   {}, 
   |- !(z : mem(Z)).
        ?!(n : mem(N)).
          Lez(Oz, z#) & Asz(n#, O) = z# | Ltz(z#, Oz) & Asz(O, n#) = z#: thm
val n2z_Abv = {},  |- !(a : mem(Z)). Lez(Oz, a#) ==> n2z(Abv(a#)) = a#: thm
val Oz_Mulz = {},  |- !(z : mem(Z)). Mulz(Oz, z#) = Oz: thm
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val Oz_Ltz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, Oz) & Ltz(b#, Oz) ==> Ltz(Oz, Mulz(z#, b#)): thm
val int1_NONZERO = {},  |- ~int1 = Oz: thm
val int1_def = {},  |- int1 = n2z(Suc(O)): thm
val Negz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Negz(Mulz(z#, b#)):
   thm
val Ltz_Addz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, b#) <=> Ltz(Addz(z#, Negz(b#)), Oz): thm
val Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(z#, Negz(b#)) = Negz(Mulz(z#, b#)):
   thm
val Mulz_int1 = {},  |- !(z : mem(Z)). Mulz(z#, int1) = z#: thm
val Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) ==> Lez(z#, b#): thm
val n2z_Oz_Lez = {},  |- !(a : mem(N)). Lez(Oz, n2z(a#)): thm
val Negz_Addz_Oz = {},  |- !(z : mem(Z)). Addz(Negz(z#), z#) = Oz: thm
val Lez_Addz_ex =
   {}, 
   |- !(z : mem(Z))  (m : mem(Z)).
        Lez(z#, m#) ==> ?(p : mem(Z)). Lez(Oz, p#) & Addz(p#, z#) = m#: thm
val Lez_Addz_2 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Lez(z#, c#) & Lez(b#, d#) ==> Lez(Addz(z#, b#), Addz(c#, d#)): thm
val Oz_Lez_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(Oz, z#) & Lez(Oz, b#) ==>
        Lez(z#, Addz(z#, b#)) & Lez(b#, Addz(z#, b#)): thm
val Oz_Ltz_Addz =
   {}, 
   |- !(z : mem(Z)). Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(b#, Addz(z#, b#)):
   thm
val int1_Asz = {},  |- int1 = Asz(Suc(O), O): thm
val Ltz_int1_Lez_Oz = {},  |- !(z : mem(Z)). Ltz(int1, z#) ==> Lez(Oz, z#):
   thm
val Lez_Oz_Addz_Lez =
   {}, 
   |- !(z : mem(Z)). Lez(z#, Oz) ==> !(a : mem(Z)). Lez(Addz(a#, z#), a#):
   thm
val Lez_Ltz_TRANS_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(z#, c#): thm
val Ltz_trans =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(a#, c#): thm
val NOT_Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Ltz(z#, b#) <=> Lez(b#, z#): thm
val Addz_Rarr =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = c# <=> z# = Addz(c#, Negz(b#)): thm
val Addz_eq_eq =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = Addz(z#, c#) <=> b# = c#: thm
val Negz_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Negz(Addz(z#, b#)) = Addz(Negz(z#), Negz(b#)): thm
val Lez_cases =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) <=> Ltz(a#, b#) | a# = b#:
   thm
val Lez_refl = {},  |- !(a : mem(Z)). Lez(a#, a#): thm
val Lez_REFL = {},  |- !(z : mem(Z)). Lez(z#, z#): thm
val Oz_Lez_int1 = {},  |- Lez(Oz, int1): thm
val Oz_Ltz_int1 = {},  |- Ltz(Oz, int1): thm
val Ltz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(Negz(z#), Negz(b#)) <=> Ltz(b#, z#):
   thm
val NEQ_Ltz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). ~a# = b# <=> Ltz(a#, b#) | Ltz(b#, a#):
   thm
val Ltz_iff_Lez_int1 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) <=> Lez(Addz(z#, int1), b#):
   thm
val Negz_Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Mulz(z#, Negz(b#)):
   thm
val Oz_Addz = {},  |- !(z : mem(Z)). Addz(Oz, z#) = z#: thm
val Addz_eq_eq' =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(a#, c#) = Addz(b#, c#) <=> a# = b#: thm
val between_int1_Oz =
   {},  |- !(z : mem(Z)). Ltz(Negz(int1), z#) & Ltz(z#, int1) <=> z# = Oz:
   thm
val Addz_Negz_Oz_eq =
   {}, 
   |- !(z : mem(Z))  (z2 : mem(Z)). Addz(z#, Negz(z2#)) = Oz <=> z# = z2#:
   thm
val Negz_Negz = {},  |- !(z : mem(Z)). Negz(Negz(z#)) = z#: thm
val Ltz_iff_O_Ltz_Sub =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) <=> Ltz(Oz, Addz(b#, Negz(a#))): thm
val Ltz_Ltz_Mulz_Ltz =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, Mulz(z#, b#)) ==> Ltz(Oz, b#):
   thm
val Ltz_Ltz_Mulz_pos =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, b#) ==> Ltz(Oz, Mulz(z#, b#)):
   thm
val Mulz_Ltz_Ltz =
   {}, 
   |- !(a : mem(Z)).
        Ltz(Oz, a#) ==>
        !(b : mem(Z))  (c : mem(Z)).
          Ltz(Mulz(a#, b#), Mulz(a#, c#)) <=> Ltz(b#, c#): thm
val Ltz_Oz_Lez_int1 = {},  |- !(z : mem(Z)). Ltz(Oz, z#) <=> Lez(int1, z#):
   thm
val Addz_Rarr_both_sides =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Addz(z#, b#) = Addz(c#, d#) <=>
        Addz(d#, Negz(b#)) = Addz(z#, Negz(c#)): thm
val Lez_Ltz_Addz_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==>
        !(c : mem(Z))  (d : mem(Z)).
          Ltz(c#, d#) ==> Ltz(Addz(z#, c#), Addz(b#, d#)): thm
val Mulz_Negz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), Negz(b#)) = Mulz(z#, b#):
   thm
val Lez_asym =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) & Lez(b#, a#) ==> a# = b#:
   thm
val Ltz_NOT_Ltz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) ==> ~Ltz(b#, a#): thm
val Abv_Negz = {},  |- !(z : mem(Z)). Abv(Negz(z#)) = Abv(z#): thm
val Abv_Oz = {},  |- Abv(Oz) = O: thm
val n2z_Abv_Negz =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> n2z(Abv(z#)) = Negz(z#): thm
val n2z_is_Abv =
   {},  |- !(n : mem(N))  (z : mem(Z)). n2z(n#) = z# ==> n# = Abv(z#): thm
val Le_Abv_Abv =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Lez(Oz, a#) & Lez(Oz, b#) ==> (Le(Abv(a#), Abv(b#)) <=> Lez(a#, b#)):
   thm
val division_theorem_ex0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_ex1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val Lez_trans =
   {}, 
   |- !(a1 : mem(Z))  (a2 : mem(Z))  (a3 : mem(Z)).
        Lez(a1#, a2#) & Lez(a2#, a3#) ==> Lez(a1#, a3#): thm
val division_theorem_ex =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?(q : mem(Z))  (r : mem(Z)).
            a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_unique0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem_unique1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        ?!(qr : mem(Z * Z)).
          a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
          Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val DIVRz_def =
   {}, 
   |- !(a : mem(Z * Z)).
        Snd(a#) = Oz & App(DIVRz, a#) = Pair(Oz, Oz) |
        ~Snd(a#) = Oz &
        Fst(a#) =
          Addz(Mulz(Fst(App(DIVRz, a#)), Snd(a#)), Snd(App(DIVRz, a#))) &
        Lez(Oz, Snd(App(DIVRz, a#))) &
        Ltz(Snd(App(DIVRz, a#)), n2z(Abv(Snd(a#)))): thm
val Divrz_Oz =
   {}, 
   |- !(d : mem(Z)). d# = Oz ==> !(a : mem(Z)). Divrz(a#, d#) = Pair(Oz, Oz):
   thm
val Divrz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divrz(a, d) = App(DIVRz, Pair(a, d)):
   thm
val Divrz_property0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        d# = Oz & Divrz(a#, d#) = Pair(Oz, Oz) |
        ~d# = Oz &
        a# = Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) &
        Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divrz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) = a# &
          Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divz_Remz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Divz(a#, d#), d#), Remz(a#, d#)) = a# &
          Lez(Oz, Remz(a#, d#)) & Ltz(Remz(a#, d#), n2z(Abv(d#))): thm
val Divz_Remz_Oz =
   {},  |- !(a : mem(Z)). Divz(a#, Oz) = Oz & Remz(a#, Oz) = Oz: thm
val Divz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divz(a, d) = Fst(Divrz(a, d)): thm
val Remz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Remz(a, d) = Snd(Divrz(a, d)): thm
val Subz_Addz =
   {},  |- !(m : mem(Z))  (n : mem(Z)). Addz(Subz(m#, n#), n#) = m#: thm
val Subz_def =
   {(a : mem(Z)), (b : mem(Z))},  |- Subz(a, b) = Addz(a, Negz(b)): thm
val Mulz_Oz = {},  |- !(z : mem(Z)). Mulz(z#, Oz) = Oz: thm
val Oz_Ltz_Negz = {},  |- !(a : mem(Z)). Ltz(Oz, a#) <=> Ltz(Negz(a#), Oz):
   thm
val Ltz_Oz_Negz = {},  |- !(a : mem(Z)). Ltz(a#, Oz) <=> Ltz(Oz, Negz(a#)):
   thm
val Mulz_Ltz_Ltz_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(Mulz(a#, b#), Oz) <=>
        Ltz(Oz, a#) & Ltz(b#, Oz) | Ltz(Oz, b#) & Ltz(a#, Oz): thm
val Mulz_Oz_iff_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Mulz(a#, b#) = Oz <=> a# = Oz | b# = Oz:
   thm
val Divz_Remz_unique =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z))  (q : mem(Z))  (r : mem(Z)).
          Addz(Mulz(q#, d#), r#) = a# & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))) ==>
          q# = Divz(a#, d#) & r# = Remz(a#, d#): thm
val division_theorem' =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?!(qr : mem(Z * Z)).
            a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
            Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val Ltz_Subz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Ltz(Oz, Subz(b#, a#)):
   thm
val Subz_Ltz =
   {}, 
   |- !(a : mem(Z)). Ltz(Oz, a#) ==> !(b : mem(Z)). Ltz(Subz(b#, a#), b#):
   thm
val int1_Mulz = {},  |- !(z : mem(Z)). Mulz(int1, z#) = z#: thm
val Addz_Subz_Rarr =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(Addz(a#, b#), Subz(c#, b#)) = Addz(a#, c#): thm
val Divz_pos_Remz =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(Oz, a#) & Ltz(Oz, d#) ==> Ltz(Remz(a#, d#), d#): thm
val n2z_eq_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). n2z(a#) = n2z(b#) <=> a# = b#: thm
val n2z_Asz = {},  |- !(n : mem(N)). n2z(n#) = Asz(n#, O): thm
val n2z_Oz = {},  |- n2z(O) = Oz: thm
val Lez_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Lez(n2z(a#), n2z(b#)) <=> Le(a#, b#):
   thm
val Ltz_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Ltz(n2z(a#), n2z(b#)) <=> Lt(a#, b#):
   thm
val Oz_Lez_n2z = {},  |- !(n : mem(N)). Lez(Oz, n2z(n#)): thm
val Mulz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Mulz(n2z(a#), n2z(b#)) = n2z(Mul(a#, b#)):
   thm
val Addz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Addz(n2z(a#), n2z(b#)) = n2z(Add(a#, b#)):
   thm
val n2z_Oz_O = {},  |- !(n : mem(N)). n2z(n#) = Oz <=> n# = O: thm
val Le_num1_Lt_O = {},  |- !(a : mem(N)). Le(num1, a#) <=> Lt(O, a#): thm
val division_theorem_N_uex =
   {}, 
   |- !(d : mem(N)).
        Le(num1, d#) ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val qfun_compr = fn: term frag list -> term frag list -> thm
******

Loading SEAR file quo.sml

******
val resp1_def =
   {(A : set), (B : set), (R : rel(A, A)), (f : fun(A, B))}, 
   |- resp1(f, R) <=> resp(f, R, id(B)): thm
val resp1_property =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (R : rel(A#, A#)).
        resp1(f#, R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> App(f#, a1#) = App(f#, a2#): thm
val Inj_INV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          ?!(ivf : fun(B#, A#)).
            ivf# o f# = Id(A#) &
            !(b : mem(B#)).
              (!(a : mem(A#)). ~App(f#, a#) = b#) ==> App(ivf#, b#) = a0#:
   thm
val Abs_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- Abs(r, i, q0) = LINV(i, q0) o Rsi(r): thm
val Inj_LINV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(a : mem(A#)). LINV(f#, a#) o f# = Id(A#): thm
val LINV_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          LINV(f#, a0#) o f# = Id(A#) &
          !(b : mem(B#)).
            (!(a : mem(A#)). ~App(f#, a#) = b#) ==>
            App(LINV(f#, a0#), b#) = a0#: thm
val Quot_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Quot(r, i) <=>
      Inj(i) &
      !(s : mem(Pow(A))).
        (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#):
   thm
val abs_def =
   {(A : set), (Q : set), (a : mem(A)), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- abs(r, i, q0, a) = App(Abs(r, i, q0), a): thm
val eth = {(A : set), (B : set), (a0 : mem(A))},  |- ?(f : fun(B, A)). T: thm
val fname = "LINV": string
val fun_mem_ex =
   {},  |- !(A : set)  (a0 : mem(A#))  (B : set). ?(f : fun(B#, A#)). T: thm
val qvl =
   [[QUOTE " (*#loc 80 35*)f:A->B"], [QUOTE " (*#loc 80 48*)a0:mem(A)"]]:
   term frag list list
val uexth0 =
   {(A : set), (B : set), (a0 : mem(A)), (f : fun(A, B))}, Inj(f)
   |- ?!(ivf : fun(B, A)).
        ivf# o f = Id(A) &
        !(b : mem(B)).
          (!(a : mem(A)). ~App(f, a#) = b#) ==> App(ivf#, b#) = a0: thm
val Abs_Surj =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==> !(q0 : mem(Q#)). Surj(Abs(r#, i#, q0#)): thm
val Quot_ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            App(i#, q1#) = rsi(r#, a1#) & App(i#, q2#) = rsi(r#, a2#) ==>
            (Holds(r#, a1#, a2#) <=> q1# = q2#): thm
val Quot_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            abs(r#, i#, q0#, a1#) = abs(r#, i#, q0#, a2#) <=>
            Holds(r#, a1#, a2#): thm
val Quot_UMP =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        !(B : set)  (f : fun(A#, B#)).
          resp1(f#, R#) ==>
          !(Q : set)  (i : fun(Q#, Pow(A#))).
            Quot(R#, i#) ==>
            !(q0 : mem(Q#)).
              ?!(fb : fun(Q#, B#)).
                !(a : mem(A#)). App(fb#, abs(R#, i#, q0#, a#)) = App(f#, a#):
   thm
val Quot_Quo =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) <=> Inj(i#) & Quo(r#, i#): thm
val ER_Quot_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). IN(a#, App(i#, q#)): thm
val Quot_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        Quot(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val abs_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        !(q1 : mem(Q1#))  (q2 : mem(Q2#))  (a : mem(A#))  (b : mem(B#)).
          abs(prrel(r1#, r2#), ipow2(i1#, i2#), Pair(q1#, q2#), Pair(a#, b#)) =
            Pair(abs(r1#, i1#, q1#, a#), abs(r2#, i2#, q2#, b#)): thm
val Rep_of_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(q0 : mem(Q#))  (a : mem(A#)).
          App(i#, abs(r#, i#, q0#, a#)) = rsi(r#, a#): thm
val Quot_rsi_uex =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). App(i#, q#) = rsi(r#, a#): thm
val ER_Quot_rsi_char =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q : mem(Q#))  (a : mem(A#)).
            IN(a#, App(i#, q#)) <=> App(i#, q#) = rsi(r#, a#): thm
val Quot_IN_BIGUNION_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            ?(a : mem(Q#)). IN(a#, s#) & abs(r#, i#, q0#, ra#) = a#: thm
val Quot_IN_BIGUNION_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            IN(abs(r#, i#, q0#, ra#), s#): thm
val Quot_el_same =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#)).
            q1# = q2# <=>
            ?(a1 : mem(A#))  (a2 : mem(A#)).
              IN(a1#, App(i#, q1#)) &
              IN(a2#, App(i#, q2#)) & Holds(r#, a1#, a2#): thm
val ER_Quot_has_mem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val ER_Quot_has_umem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val it = (): unit
val NONZERO_O_Lt = {},  |- !(n : mem(N)). ~n# = O <=> Lt(O, n#): thm
val DIVR_def =
   {}, 
   |- !(a : mem(N * N)).
        Snd(a#) = O & App(DIVR, a#) = Pair(O, O) |
        ~Snd(a#) = O &
        Fst(a#) = Add(Mul(Fst(App(DIVR, a#)), Snd(a#)), Snd(App(DIVR, a#))) &
        Lt(Snd(App(DIVR, a#)), Snd(a#)): thm
val Divr_O =
   {},  |- !(d : mem(N)). d# = O ==> !(a : mem(N)). Divr(a#, d#) = Pair(O, O):
   thm
val Divr_def =
   {(a : mem(N)), (d : mem(N))},  |- Divr(a, d) = App(DIVR, Pair(a, d)): thm
val Divr_property0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        d# = O & Divr(a#, d#) = Pair(O, O) |
        ~d# = O &
        a# = Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) &
        Lt(Snd(Divr(a#, d#)), d#): thm
val Z2N_def = {},  |- Z2N = LINV(N2Z, O): thm
val Divr_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) = a# &
          Lt(Snd(Divr(a#, d#)), d#): thm
val Div2_def = {(n : mem(N))},  |- Div2(n) = Div(n, num2): thm
val Div_Rem_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Div(a#, d#), d#), Rem(a#, d#)) = a# & Lt(Rem(a#, d#), d#):
   thm
val Div_def = {(a : mem(N)), (d : mem(N))},  |- Div(a, d) = Fst(Divr(a, d)):
   thm
val Rem_def = {(a : mem(N)), (d : mem(N))},  |- Rem(a, d) = Snd(Divr(a, d)):
   thm
val num2_NONZERO = {},  |- ~num2 = O: thm
val Mul_num2 = {},  |- !(a : mem(N)). Mul(num2, a#) = Add(a#, a#): thm
val Div_Rem_num2 =
   {}, 
   |- !(a : mem(N)).
        Add(Mul(Div2(a#), num2), Rem(a#, num2)) = a# &
        Lt(Rem(a#, num2), num2): thm
val Div_Rem_unique =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N))  (q : mem(N))  (r : mem(N)).
          Add(Mul(q#, d#), r#) = a# & Lt(r#, d#) ==>
          q# = Div(a#, d#) & r# = Rem(a#, d#): thm
val division_theorem_N_uex' =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val Div_Rem_Mul =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)). Div(Mul(d#, a#), d#) = a# & Rem(Mul(d#, a#), d#) = O:
   thm
val Div2_Mul = {},  |- !(n : mem(N)). Div2(Mul(num2, n#)) = n#: thm
val num1_Lt_num2 = {},  |- Lt(num1, num2): thm
val Div2_Suc_Mul_num2 =
   {}, 
   |- !(n : mem(N)).
        Div2(Suc(Mul(num2, n#))) = n# & Rem(Suc(Mul(num2, n#)), num2) = num1:
   thm
val Even_Suc = {},  |- !(a : mem(N)). Even(Suc(a#)) <=> ~Even(a#): thm
val num2_Mul_Even = {},  |- !(a : mem(N)). Even(Mul(num2, a#)): thm
val Suc_num2_Mul_Odd = {},  |- !(a : mem(N)). Odd(Suc(Mul(num2, a#))): thm
val O_Even = {},  |- Even(O): thm
val O_NEQ_num1 = {},  |- ~O = num1: thm
val O_NEQ_num2 = {},  |- ~O = num2: thm
val O_NEQ_num3 = {},  |- ~O = num3: thm
val O_NEQ_num4 = {},  |- ~O = num4: thm
val num1_NEQ_num4 = {},  |- ~num1 = num4: thm
val num1_NEQ_num3 = {},  |- ~num1 = num3: thm
val num1_NEQ_num2 = {},  |- ~num1 = num2: thm
val num2_NEQ_num3 = {},  |- ~num2 = num3: thm
val num2_NEQ_num4 = {},  |- ~num2 = num4: thm
val num4_NEQ_num3 = {},  |- ~num4 = num3: thm
val Div_of_O = {},  |- !(n : mem(N)). Div(O, n#) = O & Rem(O, n#) = O: thm
val Even_Sub_num2 = {},  |- !(a : mem(N)). Even(a#) ==> Even(Sub(a#, num2)):
   thm
val Odd_num1 = {},  |- Odd(num1): thm
val Lt_num2 = {},  |- !(a : mem(N)). Lt(a#, num2) <=> a# = O | a# = num1: thm
val Even_Div2 =
   {}, 
   |- !(a : mem(N)).
        Even(a#) <=> Mul(Div2(a#), num2) = a# & Rem(a#, num2) = O: thm
val Odd_Div2 =
   {}, 
   |- !(a : mem(N)).
        Odd(a#) <=> Suc(Mul(Div2(a#), num2)) = a# & Rem(a#, num2) = num1: thm
val it = (): unit
******

Loading SEAR file SEARFiniteness.sml

******
val FI's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). IN(a#, FI's(X)) <=> SS(App(FIf(X), a#), a#):
   thm
val FI_cases0 = {(X : set)},  |- App(FIf(X), FIs(X)) = FIs(X): thm
val FI_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_incond =
   !(xs : mem(Pow(X))).
     IN(xs#, FIs1) <=>
     xs# = Empty(X) |
     ?(xs0 : mem(Pow(X)))  (x : mem(X)). IN(xs0#, FIs0) & xs# = Ins(x#, xs0#):
   form
val FI_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> SS(FIs(X), ss#):
   thm
val FI_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        (!(a : mem(Pow(X))).
            a# = Empty(X) |
            (?(xs0 : mem(Pow(X)))  (x : mem(X)).
                IN(xs0#, ss#) & a# = Ins(x#, xs0#)) ==> IN(a#, ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_rules0 = {(X : set)},  |- SS(App(FIf(X), FIs(X)), FIs(X)): thm
val FI_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        a# = Empty(X) |
        (?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#)) ==> IN(a#, FIs(X)): thm
val FI_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (a# = Empty(X) ==> IN(a#, FIs(X))) &
        !(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#) ==> IN(a#, FIs(X)): thm
val FI_rules3 =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val FIf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
        IN(xs#, App(FIf(X), a#)) <=>
        xs# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X)), Pow(Pow(X)))).
        !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
          IN(xs#, App(f#, a#)) <=>
          xs# = Empty(X) |
          ?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X))))  (s2 : mem(Pow(Pow(X)))).
        SS(s1#, s2#) ==> SS(App(FIf(X), s1#), App(FIf(X), s2#)): thm
val FIs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). SS(App(FIf(X), a#), a#) ==> SS(FIs(X), a#):
   thm
val FIs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (!(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, FIs(X)): thm
val FIs_def = {(X : set)},  |- FIs(X) = BIGINTER(FI's(X)): thm
val x1 = "FIs0": string
val FI_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_rules =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val Fin_def =
   {},  |- !(X : set)  (A : mem(Pow(X#))). Fin(A#) <=> IN(A#, FIs(X#)): thm
val Cd's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))).
        IN(a#, Cd's(X)) <=> SS(App(Cdf(X), a#), a#): thm
val Cd_cases0 = {(X : set)},  |- App(Cdf(X), Cds(X)) = Cds(X): thm
val Cd_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_incond =
   !(xsn : mem(Pow(X) * N)).
     IN(xsn#, Cds1) <=>
     xsn# = Pair(Empty(X), O) |
     ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
       IN(xsn0#, Cds0) &
       ~IN(x#, Fst(xsn0#)) &
       xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): form
val Cd_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        SS(App(Cdf(X), ss#), ss#) ==> SS(Cds(X), ss#): thm
val Cd_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        (!(a : mem(Pow(X) * N)).
            a# = Pair(Empty(X), O) |
            (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
                IN(xsn0#, ss#) &
                ~IN(x#, Fst(xsn0#)) &
                a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_rules0 = {(X : set)},  |- SS(App(Cdf(X), Cds(X)), Cds(X)): thm
val Cd_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        a# = Pair(Empty(X), O) |
        (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, Cds(X)) &
            ~IN(x#, Fst(xsn0#)) &
            a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
        IN(a#, Cds(X)): thm
val Cd_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (a# = Pair(Empty(X), O) ==> IN(a#, Cds(X))) &
        !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))) ==> IN(a#, Cds(X)):
   thm
val Cd_rules3 =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cdf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
        IN(xsn#, App(Cdf(X), a#)) <=>
        xsn# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, a#) &
          ~IN(x#, Fst(xsn0#)) &
          xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X) * N), Pow(Pow(X) * N))).
        !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
          IN(xsn#, App(f#, a#)) <=>
          xsn# = Pair(Empty(X), O) |
          ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, a#) &
            ~IN(x#, Fst(xsn0#)) &
            xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X) * N)))  (s2 : mem(Pow(Pow(X) * N))).
        SS(s1#, s2#) ==> SS(App(Cdf(X), s1#), App(Cdf(X), s2#)): thm
val Cds_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))). SS(App(Cdf(X), a#), a#) ==> SS(Cds(X), a#):
   thm
val Cds_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (!(ss : mem(Pow(Pow(X) * N))).
            SS(App(Cdf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, Cds(X)):
   thm
val Cds_def = {(X : set)},  |- Cds(X) = BIGINTER(Cd's(X)): thm
val x1 = "Cds0": string
val Cd_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_rules =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cds_ind =
   {}, 
   |- !(X : set)  (ss : mem(Pow(Pow(X#) * N))).
        IN(Pair(Empty(X#), O), ss#) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            IN(Pair(xs0#, n0#), ss#) & ~IN(x#, xs0#) ==>
            IN(Pair(Ins(x#, xs0#), Suc(n0#)), ss#)) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> IN(Pair(xs#, n#), ss#): thm
val Cd_induct0 =
   {}, 
   |- !(X : set).
        P(Pair(Empty(X#), O)) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(Pair(xs0#, n0#)) & ~IN(x#, xs0#) ==>
            P(Pair(Ins(x#, xs0#), Suc(n0#)))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(Pair(xs#, n#)): thm
val Cd_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(xs#, n#): thm
val Fin_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#)) &
        (!(xs0 : mem(Pow(X#)))  (x : mem(X#)). P(xs0#) ==> P(Ins(x#, xs0#))) ==>
        !(xs : mem(Pow(X#))). Fin(xs#) ==> P(xs#): thm
val Cdr_def =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) <=> IN(Pair(xs#, n#), Cds(X#)): thm
val Cdr_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)). Cdr(xs#, n#) ==> P(xs#, n#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs0#, n#) ==>
        !(x : mem(X#)). ~IN(x#, xs0#) ==> Cdr(Ins(x#, xs0#), Suc(n#)): thm
val Ins_NONEMPTY =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs : mem(Pow(X#))).
        ~Ins(x0#, xs#) = Empty(X#): thm
val IN_Ins_SND =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (x : mem(X#)).
        IN(x#, Ins(x0#, xs0#)) & ~x# = x0# ==> IN(x#, xs0#): thm
val Cdr_Empty_unique =
   {},  |- !(X : set)  (n : mem(N)). Cdr(Empty(X#), n#) ==> n# = O: thm
val Del_Ins_SWAP =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        ~x0# = x# ==>
        !(xs : mem(Pow(X#))). Del(Ins(x0#, xs#), x#) = Ins(x0#, Del(xs#, x#)):
   thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(Ins(x0#, xs0#), n#) <=>
        ?(a : mem(Pow(X#)))  (b : mem(N))  (x : mem(X#)).
          Cdr(a#, b#) &
          ~IN(x#, a#) & Ins(x0#, xs0#) = Ins(x#, a#) & n# = Suc(b#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) ==>
        Cdr(xs#, n#) &
        !(x : mem(X#)). IN(x#, xs#) ==> Cdr(Del(xs#, x#), Pre(n#)): thm
val Fin_Card =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> ?!(n : mem(N)). Cdr(xs#, n#): thm
val CARD_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        Holds(CARD(X#), a#, b#) <=> Fin(a#) & Cdr(a#, b#) | ~Fin(a#) & b# = O:
   thm
val CARD_unique =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        ?!(n : mem(N)). Holds(CARD(X#), xs#, n#): thm
val Cd0_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        App(Cd0(X#), a#) = b# <=> Holds(CARD(X#), a#, b#): thm
val Card_def =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Card(xs#) = App(Cd0(X#), xs#):
   thm
val Del_Empty =
   {},  |- !(X : set)  (x : mem(X#)). Del(Empty(X#), x#) = Empty(X#): thm
val Ins_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (s1 : mem(Pow(A#)))  (a2 : mem(A#))
      (s2 : mem(Pow(A#))).
        ~IN(a1#, s1#) &
        ~IN(a2#, s2#) &
        ~IN(a1#, s2#) & ~IN(a2#, s1#) & Ins(a1#, s1#) = Ins(a2#, s2#) ==>
        a1# = a2# & s1# = s2#: thm
val Fin_Empty = {},  |- !(X : set). Fin(Empty(X#)): thm
val Fin_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#))).
        Fin(xs0#) ==> !(x : mem(X#)). Fin(Ins(x#, xs0#)): thm
val Fin_Ins_Ins =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Fin(Ins(a1#, Ins(a2#, Empty(A#)))): thm
val Fin_Del0 =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> Fin(xs#) & !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Fin_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Card_Fin =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(n : mem(N)). Card(xs#) = n# <=> Cdr(xs#, n#): thm
val Card_Empty = {},  |- !(X : set). Card(Empty(X#)) = O: thm
val Cdr_Card =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Fin(xs#) ==> Cdr(xs#, Card(xs#)):
   thm
val Card_Ins =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). ~IN(x#, xs#) ==> Card(Ins(x#, xs#)) = Suc(Card(xs#)):
   thm
val Card_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). IN(x#, xs#) ==> Card(Del(xs#, x#)) = Pre(Card(xs#)):
   thm
val IN_App_IMAGE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        IN(a#, s#) ==>
        !(B : set)  (f : fun(A#, B#)). IN(App(f#, a#), IMAGE(f#, s#)): thm
val Fin_SS =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Fin(s#) ==> !(t : mem(Pow(A#))). SS(t#, s#) ==> Fin(t#): thm
val Fin_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(Union(s1#, s2#)) <=> Fin(s1#) & Fin(s2#): thm
val Ins_Ins_Fin =
   {(A : set), (s1 : mem(A)), (s2 : mem(A))}, 
   |- Fin(Ins(s1, Ins(s2, Empty(A)))): thm
val Fin_Sing = {},  |- !(A : set)  (a : mem(A#)). Fin(Sing(a#)): thm
val it = (): unit
******

Loading SEAR file SEARList.sml

******
val isL's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        IN(a#, isL's(X)) <=> SS(App(isLf(X), a#), a#): thm
val isL_cases0 = {(X : set)},  |- App(isLf(X), isLs(X)) = isLs(X): thm
val isL_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_incond =
   !(ls : mem(Pow(N * X))).
     IN(ls#, isLs1) <=>
     ls# = Empty(N * X) |
     ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
       IN(ls0#, isLs0) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): form
val isL_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), ss#), ss#) ==> SS(isLs(X), ss#): thm
val isL_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        (!(a : mem(Pow(N * X))).
            a# = Empty(N * X) |
            (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
                IN(ls0#, ss#) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_rules0 = {(X : set)},  |- SS(App(isLf(X), isLs(X)), isLs(X)): thm
val isL_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        a# = Empty(N * X) |
        (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
        IN(a#, isLs(X)): thm
val isL_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (a# = Empty(N * X) ==> IN(a#, isLs(X))) &
        !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#) ==>
          IN(a#, isLs(X)): thm
val isL_rules3 =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val isLf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
        IN(ls#, App(isLf(X), a#)) <=>
        ls# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(N * X)), Pow(Pow(N * X)))).
        !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
          IN(ls#, App(f#, a#)) <=>
          ls# = Empty(N * X) |
          ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(N * X))))  (s2 : mem(Pow(Pow(N * X)))).
        SS(s1#, s2#) ==> SS(App(isLf(X), s1#), App(isLf(X), s2#)): thm
val isLs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), a#), a#) ==> SS(isLs(X), a#): thm
val isLs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (!(ss : mem(Pow(Pow(N * X)))).
            SS(App(isLf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isLs(X)):
   thm
val isLs_def = {(X : set)},  |- isLs(X) = BIGINTER(isL's(X)): thm
val x1 = "isLs0": string
val isL_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_rules =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val List_def =
   {}, 
   |- !(X : set).
        Inj(iL(X#)) &
        !(a : mem(Pow(N * X#))).
          IN(a#, isLs(X#)) <=> ?(b : mem(List(X#))). a# = App(iL(X#), b#):
   thm
val iL_Inj = {},  |- !(X : set). Inj(iL(X#)): thm
val isL_def =
   {},  |- !(X : set)  (l : mem(Pow(N * X#))). isL(l#) <=> IN(l#, isLs(X#)):
   thm
val isL_induct =
   {}, 
   |- !(X : set).
        P(Empty(N * X#)) &
        (!(ls0 : mem(Pow(N * X#)))  (x : mem(X#)).
            P(ls0#) ==> P(Ins(Pair(Card(ls0#), x#), ls0#))) ==>
        !(l : mem(Pow(N * X#))). isL(l#) ==> P(l#): thm
val isL_Empty = {},  |- !(X : set). isL(Empty(N * X#)): thm
val isL_Ins =
   {}, 
   |- !(X : set)  (ls0 : mem(Pow(N * X#))).
        isL(ls0#) ==> !(x : mem(X#)). isL(Ins(Pair(Card(ls0#), x#), ls0#)):
   thm
val Repl_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Repl(l#) = App(iL(X#), l#): thm
val Nil_def = {},  |- !(X : set). Repl(Nil(X#)) = Empty(N * X#): thm
val cons0_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- cons0(x, l) = Ins(Pair(Card(l), x), l): thm
val cons1_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- App(cons1(X), Pair(x, l)) = Ins(Pair(Card(l), x), l): thm
val iL_isL = {},  |- !(X : set)  (l : mem(List(X#))). isL(App(iL(X#), l#)):
   thm
val isL_Repl =
   {}, 
   |- !(X : set)  (a : mem(Pow(N * X#))).
        isL(a#) <=> ?(b : mem(List(X#))). a# = Repl(b#): thm
val CONS_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Ins(Pair(Card(Repl(l#)), x#), Repl(l#)) =
          Repl(App(CONS(X#), Pair(x#, l#))): thm
val lift_cond2 =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val lift_cond2' =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?!(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val Cons_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Cons(x#, l#) = App(CONS(X#), Pair(x#, l#)): thm
val Repl_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Repl(Cons(x#, l#)) = Ins(Pair(Card(Repl(l#)), x#), Repl(l#)): thm
val Repl_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(List(X#)))  (l2 : mem(List(X#))).
        Repl(l1#) = Repl(l2#) <=> l1# = l2#: thm
val Cons_NONNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(List(X#))). ~Cons(x#, l#) = Nil(X#):
   thm
val Repl_Empty_uex =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        Repl(l#) = Empty(N * X#) <=> l# = Nil(X#): thm
val List_induct =
   {}, 
   |- !(X : set).
        P(Nil(X#)) &
        (!(l : mem(List(X#))). P(l#) ==> !(x : mem(X#)). P(Cons(x#, l#))) ==>
        !(l : mem(List(X#))). P(l#): thm
val Fin_Repl = {},  |- !(X : set)  (l : mem(List(X#))). Fin(Repl(l#)): thm
val isL_Card_NOTIN0 =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (n : mem(N))  (x : mem(X#)).
        IN(Pair(n#, x#), Repl(l#)) ==> Lt(n#, Card(Repl(l#))): thm
val CONS_Inj = {},  |- !(X : set). Inj(CONS(X#)): thm
val Cons_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (l1 : mem(List(X#)))  (x2 : mem(X#))
      (l2 : mem(List(X#))).
        Cons(x1#, l1#) = Cons(x2#, l2#) <=> x1# = x2# & l1# = l2#: thm
val Cons_or_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        l# = Nil(X#) |
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Cons_xor_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        ~l# = Nil(X#) <=>
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Lind's_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        IN(a#, Lind's(a0, f0)) <=> SS(App(Lindf(a0, f0), a#), a#): thm
val Lind_cases0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- App(Lindf(a0, f0), Linds(a0, f0)) = Linds(a0, f0): thm
val Lind_cases1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_incond =
   !(p : mem(List(X) * A)).
     IN(p#, Lind1) <=>
     p# = Pair(Nil(X), a0) |
     ?(p0 : mem(List(X) * A))  (x : mem(X)).
       IN(p0#, Lind0) &
       p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): form
val Lind_ind =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), ss#), ss#) ==> SS(Linds(a0, f0), ss#): thm
val Lind_ind1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        (!(a : mem(List(X) * A)).
            a# = Pair(Nil(X), a0) |
            (?(p0 : mem(List(X) * A))  (x : mem(X)).
                IN(p0#, ss#) &
                a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_rules0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- SS(App(Lindf(a0, f0), Linds(a0, f0)), Linds(a0, f0)): thm
val Lind_rules1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        a# = Pair(Nil(X), a0) |
        (?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, Linds(a0, f0)) &
            a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
        IN(a#, Linds(a0, f0)): thm
val Lind_rules2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (a# = Pair(Nil(X), a0) ==> IN(a#, Linds(a0, f0))) &
        !(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))) ==>
          IN(a#, Linds(a0, f0)): thm
val Lind_rules3 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lindf_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
        IN(p#, App(Lindf(a0, f0), a#)) <=>
        p# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, a#) &
          p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_ex =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- ?!(f : fun(Pow(List(X) * A), Pow(List(X) * A))).
        !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Nil(X), a0) |
          ?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, a#) &
            p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_monotone =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(s1 : mem(Pow(List(X) * A)))  (s2 : mem(Pow(List(X) * A))).
        SS(s1#, s2#) ==> SS(App(Lindf(a0, f0), s1#), App(Lindf(a0, f0), s2#)):
   thm
val Linds_SS =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), a#), a#) ==> SS(Linds(a0, f0), a#): thm
val Linds_cond =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (!(ss : mem(Pow(List(X) * A))).
            SS(App(Lindf(a0, f0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Linds(a0, f0)): thm
val Linds_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- Linds(a0, f0) = BIGINTER(Lind's(a0, f0)): thm
val x1 = "Lind0": string
val Lind_cases =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_rules =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lind_uex =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#))). ?!(a : mem(A#)). IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_def =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (a : mem(List(X#))).
        IN(Pair(a#, App(Lrec(a0#, f0#), a#)), Linds(a0#, f0#)): thm
val Lrec_Nil =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        App(Lrec(a0#, f0#), Nil(X#)) = a0#: thm
val App_Lrec_Linds =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (a : mem(A#)).
        App(Lrec(a0#, f0#), l#) = a# <=> IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_Cons =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (x : mem(X#)).
        App(Lrec(a0#, f0#), Cons(x#, l#)) =
          App(f0#, Pair(x#, App(Lrec(a0#, f0#), l#))): thm
val Lrec_unique =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f : fun(X# * A#, A#))
      (r : fun(List(X#), A#)).
        App(r#, Nil(X#)) = a0# & r# o CONS(X#) = f# o Prla(Id(X#), r#) ==>
        r# = Lrec(a0#, f#): thm
val Lrec_Cons_eqn =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        Lrec(a0#, f0#) o CONS(X#) = f0# o Prla(Id(X#), Lrec(a0#, f0#)): thm
val LENGTH_def = {},  |- !(X : set). LENGTH(X#) = Lrec(O, SUC o p2(X#, N)):
   thm
val Length_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Length(l#) = App(LENGTH(X#), l#):
   thm
val Length_Nil = {},  |- !(X : set). Length(Nil(X#)) = O: thm
val Length_Cons =
   {}, 
   |- !(A : set)  (a : mem(A#))  (l : mem(List(A#))).
        Length(Cons(a#, l#)) = Suc(Length(l#)): thm
val HD_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        App(HD(X#), Cons(x#, l#)) = SOME(x#): thm
val HD_Nil = {(X : set)},  |- App(HD(X), Nil(X)) = NONE(X): thm
val HD_def =
   {},  |- !(X : set). HD(X#) = Lrec(NONE(X#), i1(X#, 1) o p1(X#, X# + 1)):
   thm
val Hd_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Hd(Cons(x#, l#)) = SOME(x#): thm
val Hd_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Hd(l#) = App(HD(X#), l#): thm
val TL_Nil = {(X : set)},  |- App(TL(X), Nil(X)) = Nil(X): thm
val TL_def =
   {}, 
   |- !(X : set)  (a : mem(List(X#))).
        a# = Nil(X#) & App(TL(X#), a#) = Nil(X#) |
        ~a# = Nil(X#) & ?(x : mem(X#)). a# = Cons(x#, App(TL(X#), a#)): thm
val TL_ex =
   {(X : set)}, 
   |- !(l : mem(List(X))).
        ?!(tl : mem(List(X))).
          l# = Nil(X) & tl# = Nil(X) |
          ~l# = Nil(X) & ?(x : mem(X)). l# = Cons(x#, tl#): thm
val TL_Cons =
   {(X : set)}, 
   |- !(x : mem(X))  (tl : mem(List(X))). App(TL(X), Cons(x#, tl#)) = tl#:
   thm
val ELn_Nil = {(X : set)},  |- App(ELn(X), O) = Tpm(HD(X)): thm
val ELn_def =
   {(X : set)}, 
   |- ELn(X) = Nrec(Tpm(HD(X)), Ap1(MO(List(X), List(X), X + 1), Tpm(TL(X)))):
   thm
val Eln_Map =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(n : mem(N))  (l : mem(List(X))).
        Lt(n#, Length(l#)) ==> Eln(n#, Map(f, l#)) = App(OM(f), Eln(n#, l#)):
   thm
val Eln_O = {(X : set)},  |- !(a : mem(List(X))). Eln(O, a#) = Hd(a#): thm
val Eln_Suc =
   {(X : set)}, 
   |- !(n : mem(N))  (a : mem(List(X))). Eln(Suc(n#), a#) = Eln(n#, Tl(a#)):
   thm
val Eln_def =
   {(X : set), (l : mem(List(X))), (n : mem(N))}, 
   |- Eln(n, l) = App(tof(App(ELn(X), n)), l): thm
val MAP_Cons =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(l : mem(List(X)))  (x : mem(X)).
        App(MAP(f), Cons(x#, l#)) = Cons(App(f, x#), App(MAP(f), l#)): thm
val MAP_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        App(MAP(f#), Nil(X#)) = Nil(Y#): thm
val MAP_def =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        MAP(f#) = Lrec(Nil(Y#), CONS(Y#) o Prla(f#, Id(List(Y#)))): thm
val MO_def =
   {(A : set), (B : set), (C : set), (fm : mem(Exp(A, B))),
    (gm : mem(Exp(B, C)))},  |- App(MO(A, B, C), Pair(gm, fm)) = mo(gm, fm):
   thm
val Map_Cons =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#))  (l : mem(List(X#)))
      (x : mem(X#)). Map(f#, Cons(x#, l#)) = Cons(App(f#, x#), Map(f#, l#)):
   thm
val Map_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)). Map(f#, Nil(X#)) = Nil(Y#):
   thm
val Map_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (Y : set)  (f : fun(X#, Y#)).
        Map(f#, l#) = App(MAP(f#), l#): thm
val Tl_Cons =
   {}, 
   |- !(X : set)  (x : mem(X#))  (tl : mem(List(X#))).
        Tl(Cons(x#, tl#)) = tl#: thm
val Tl_Nil = {},  |- !(X : set). Tl(Nil(X#)) = Nil(X#): thm
val Tl_def = {(X : set), (l : mem(List(X)))},  |- Tl(l) = App(TL(X), l): thm
val mo_def =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (C : set)
      (g : mem(Exp(B#, C#))). mo(g#, f#) = Tpm(tof(g#) o tof(f#)): thm
val it = (): unit
******

Loading SEAR file SEARfm.sml

******
val InjA_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjA(A#), a#)) <=> a# = SOME(a#): thm
val InjN_def =
   {}, 
   |- !(A : set)  (a : mem(N))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjN(A#), a#)) <=> n# = a#: thm
val InjUU0_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * A)))  (b : mem(Pow(N * A)))  (n : mem(N))
      (a : mem(A)).
        IN(Pair(n#, a#), App(InjUU0(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val injUU0_char =
   {}, 
   |- (!(n : mem(N)).
          Even(n#) ==>
          !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
          (a : mem(A#)).
            IN(Pair(n#, a#), injUU0(u1#, u2#)) <=>
            IN(Pair(Div2(n#), a#), u1#)) &
      !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val injUU0_def =
   {(A : set), (u1 : mem(Pow(N * A))), (u2 : mem(Pow(N * A)))}, 
   |- injUU0(u1, u2) = App(InjUU0(A), Pair(u1, u2)): thm
val InjUU0_Inj = {},  |- !(A : set). Inj(InjUU0(A#)): thm
val injUU0_Even =
   {}, 
   |- !(n : mem(N)).
        Even(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u1#):
   thm
val injUU0_Odd =
   {}, 
   |- !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val F0_def = {(A : set)},  |- F0(A) = injN(A, O): thm
val InjA_Inj = {},  |- !(A : set). Inj(InjA(A#)): thm
val InjUU_Inj = {},  |- !(A : set). Inj(InjUU(A#)): thm
val InjUU_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * (A + 1))))  (b : mem(Pow(N * (A + 1))))
      (n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), App(InjUU(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val InjUU_def0 = {},  |- !(A : set). InjUU(A#) = InjUU0(A# + 1): thm
val injA_def = {(A : set), (a : mem(A))},  |- injA(a) = App(InjA(A), a): thm
val injN_def = {(A : set), (n : mem(N))},  |- injN(A, n) = App(InjN(A), n):
   thm
val VAR0_Inj = {},  |- !(A : set). Inj(VAR0(A#)): thm
val VAR0_def =
   {(A : set)}, 
   |- VAR0(A) = InjUU(A) o Pa(El(injN(A, num1)) o To1(A), InjA(A)): thm
val NEG0_Inj = {},  |- !(A : set). Inj(NEG0(A#)): thm
val NEG0_def =
   {(A : set)}, 
   |- NEG0(A) = InjUU(A) o
        Pa(El(injN(A, num2)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Var0_def = {(A : set), (a : mem(A))},  |- Var0(a) = App(VAR0(A), a): thm
val DISJ0_Inj = {},  |- !(A : set). Inj(DISJ0(A#)): thm
val DISJ0_def =
   {(A : set)}, 
   |- DISJ0(A) = InjUU(A) o
        Pa(El(injN(A, num3)) o To1(Pow((N * (A + 1))) * Pow(N * (A + 1))),
         InjUU(A)): thm
val Neg0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- Neg0(f0) = App(NEG0(A), f0):
   thm
val DIAM0_Inj = {},  |- !(A : set). Inj(DIAM0(A#)): thm
val DIAM0_def =
   {(A : set)}, 
   |- DIAM0(A) = InjUU(A) o
        Pa(El(injN(A, num4)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Disj0_def =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- Disj0(f1, f2) = App(DISJ0(A), Pair(f1, f2)): thm
val Diam0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- Diam0(f0) = App(DIAM0(A), f0): thm
val f =
   (nas = F0 ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_cl =
   (nas = F0(A) ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_incond =
   !(nas : mem(Pow(N * (A + 1)))).
     IN(nas#, isfms1) <=>
     nas# = F0(A) |
     (?(p : mem(A)). nas# = Var0(p#)) |
     (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Neg0(f0#)) |
     (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
         IN(f1#, isfms0) & IN(f2#, isfms0) & nas# = Disj0(f1#, f2#)) |
     ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Diam0(f0#): form
val x1 = "isfms0": string
val isfmf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(Pow(N * (A + 1))), Pow(Pow(N * (A + 1))))).
        !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
          IN(nas#, App(f#, a#)) <=>
          nas# = F0(A) |
          (?(p : mem(A)). nas# = Var0(p#)) |
          (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
          (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
              IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
          ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
        IN(nas#, App(isfmf(A), a#)) <=>
        nas# = F0(A) |
        (?(p : mem(A)). nas# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(Pow(N * (A + 1)))))  (s2 : mem(Pow(Pow(N * (A + 1))))).
        SS(s1#, s2#) ==> SS(App(isfmf(A), s1#), App(isfmf(A), s2#)): thm
val isfm's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        IN(a#, isfm's(A)) <=> SS(App(isfmf(A), a#), a#): thm
val isfms_def = {(A : set)},  |- isfms(A) = BIGINTER(isfm's(A)): thm
val isfms_cond =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (!(ss : mem(Pow(Pow(N * (A + 1))))).
            SS(App(isfmf(A), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isfms(A)):
   thm
val isfms_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), a#), a#) ==> SS(isfms(A), a#): thm
val isfm_rules0 = {(A : set)},  |- SS(App(isfmf(A), isfms(A)), isfms(A)): thm
val isfm_cases0 = {(A : set)},  |- App(isfmf(A), isfms(A)) = isfms(A): thm
val isfm_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), ss#), ss#) ==> SS(isfms(A), ss#): thm
val isfm_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (!(a : mem(Pow(N * (A + 1)))).
            a# = F0(A) |
            (?(p : mem(A)). a# = Var0(p#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Neg0(f0#)) |
            (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj0(f1#, f2#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Diam0(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases1 =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules1 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        a# = F0(A) |
        (?(p : mem(A)). a# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Diam0(f0#)) ==>
        IN(a#, isfms(A)): thm
val isfm_rules2 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (a# = F0(A) ==> IN(a#, isfms(A))) &
        (!(p : mem(A)). a# = Var0(p#) ==> IN(a#, isfms(A))) &
        (!(f0 : mem(Pow(N * (A + 1)))).
            IN(f0#, isfms(A)) & a# = Neg0(f0#) ==> IN(a#, isfms(A))) &
        (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#) ==>
            IN(a#, isfms(A))) &
        !(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) & a# = Diam0(f0#) ==> IN(a#, isfms(A)): thm
val isfm_rules3 =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_def =
   {}, 
   |- !(A : set)  (f : mem(Pow(N * (A# + 1)))).
        isfm(f#) <=> IN(f#, isfms(A#)): thm
val isfm_induct =
   {}, 
   |- !(A : set).
        P(F0(A#)) &
        (!(p : mem(A#)). P(Var0(p#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Neg0(f0#))) &
        (!(f1 : mem(Pow(N * (A# + 1))))  (f2 : mem(Pow(N * (A# + 1)))).
            P(f1#) & P(f2#) ==> P(Disj0(f1#, f2#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Diam0(f0#))) ==>
        !(f0 : mem(Pow(N * (A# + 1)))). isfm(f0#) ==> P(f0#): thm
val isfm_F0 = {},  |- !(A : set). isfm(F0(A#)): thm
val isfm_Diam0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val isfm_Neg0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#)): thm
val isfm_Var0 = {},  |- !(A : set)  (p : mem(A#)). isfm(Var0(p#)): thm
val isfm_clauses =
   {(A : set)}, 
   |- isfm(F0(A)) &
      (!(p : mem(A)). isfm(Var0(p#))) &
      (!(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#))) &
      !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val form_def =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). a# = App(repf(A), b#): thm
val isfm_Disj0 =
   {(A : set)}, 
   |- !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
        isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#)): thm
val repf_Inj = {(A : set)},  |- Inj(repf(A)): thm
val Bot_def = {(A : set)},  |- Repf(Bot(A)) = F0(A): thm
val Repf_def =
   {},  |- !(A : set)  (f : mem(form(A#))). Repf(f#) = App(repf(A#), f#): thm
val VAR_def =
   {(A : set)},  |- !(a : mem(A)). App(repf(A) o VAR(A), a#) = Var0(a#): thm
val flip_fconv = fn: form -> thm
val form_def' =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). App(repf(A), b#) = a#: thm
val repf_isfm = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Repf(f0#)): thm
val VAR_VAR0 = {},  |- !(A : set). repf(A#) o VAR(A#) = VAR0(A#): thm
val VAR_Inj = {},  |- !(A : set). Inj(VAR(A#)): thm
val NEG_NEG0 = {},  |- !(A : set). repf(A#) o NEG(A#) = NEG0(A#) o repf(A#):
   thm
val NEG_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(NEG(A), a#)) = Neg0(Repf(a#)): thm
val Neg0_Repf = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Neg0(Repf(f0#))):
   thm
val NEG_Inj = {},  |- !(A : set). Inj(NEG(A#)): thm
val DIAM_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(DIAM(A), a#)) = Diam0(Repf(a#)): thm
val Diam0_Repf =
   {(A : set)},  |- !(f0 : mem(form(A))). isfm(Diam0(Repf(f0#))): thm
val form_def_uex =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (?!(b : mem(form(A))). a# = Repf(b#)) <=> isfm(a#): thm
val DISJ_DISJ0 =
   {}, 
   |- !(A : set). repf(A#) o DISJ(A#) = DISJ0(A#) o Prla(repf(A#), repf(A#)):
   thm
val DISJ_def =
   {(A : set)}, 
   |- !(a' : mem(form(A)))  (b : mem(form(A))).
        Repf(App(DISJ(A), Pair(a'#, b#))) = Disj0(Repf(a'#), Repf(b#)): thm
val DISJ_Inj = {},  |- !(A : set). Inj(DISJ(A#)): thm
val DIAM_DIAM0 =
   {},  |- !(A : set). repf(A#) o DIAM(A#) = DIAM0(A#) o repf(A#): thm
val DIAM_Inj = {},  |- !(A : set). Inj(DIAM(A#)): thm
val Diam_def =
   {(A : set), (f : mem(form(A)))},  |- Diam(f) = App(DIAM(A), f): thm
val Disj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Disj(f1, f2) = App(DISJ(A), Pair(f1, f2)): thm
val Neg_def = {(A : set), (f : mem(form(A)))},  |- Neg(f) = App(NEG(A), f):
   thm
val Var_def = {(A : set), (a : mem(A))},  |- Var(a) = App(VAR(A), a): thm
val Var_eq_eq =
   {(A : set)}, 
   |- !(p1 : mem(A))  (p2 : mem(A)). Var(p1#) = Var(p2#) <=> p1# = p2#: thm
val Neg_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Neg(f1#) = Neg(f2#) <=> f1# = f2#: thm
val Diam_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Diam(f1#) = Diam(f2#) <=> f1# = f2#: thm
val Disj_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A)))  (g1 : mem(form(A)))
      (g2 : mem(form(A))).
        Disj(f1#, f2#) = Disj(g1#, g2#) <=> f1# = g1# & f2# = g2#: thm
val Repf_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Repf(f1#) = Repf(f2#) <=> f1# = f2#: thm
val form_induct =
   {}, 
   |- !(A : set).
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Neg(f0#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Diam(f0#))) ==>
        !(f0 : mem(form(A#))). P(f0#): thm
val fmind's_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        IN(a#, fmind's(djf, dmf, nf, vf, x0)) <=>
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#): thm
val fmind_cases0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)) =
        fminds(djf, dmf, nf, vf, x0): thm
val fmind_cases1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_incond =
   !(p : mem(form(A) * X)).
     IN(p#, fmind1) <=>
     p# = Pair(Bot(A), x0) |
     (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
     ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
       IN(p1#, fmind0) &
       IN(p2#, fmind0) &
       p# =
         Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))):
   form
val fmind_ind =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), ss#): thm
val fmind_ind1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (!(a : mem(form(A) * X)).
            a# = Pair(Bot(A), x0) |
            (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
            (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
                IN(p1#, ss#) &
                IN(p2#, ss#) &
                a# =
                  Pair(Disj(Fst(p1#), Fst(p2#)),
                   App(djf, Pair(Snd(p1#), Snd(p2#))))) ==> IN(a#, ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_rules0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- SS(App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)),
       fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        a# = Pair(Bot(A), x0) |
        (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
            IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
            a# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#))))) ==>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (a# = Pair(Bot(A), x0) ==> IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(a' : mem(A)).
            a# = Pair(Var(a'#), App(vf, a'#)) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          a# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))) ==>
          IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules3 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val fmindf_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
        IN(p#, App(fmindf(djf, dmf, nf, vf, x0), a#)) <=>
        p# = Pair(Bot(A), x0) |
        (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, a#) &
          IN(p2#, a#) &
          p# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_ex =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(form(A) * X), Pow(form(A) * X))).
        !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Bot(A), x0) |
          (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
          ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, a#) &
            IN(p2#, a#) &
            p# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_monotone =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(form(A) * X)))  (s2 : mem(Pow(form(A) * X))).
        SS(s1#, s2#) ==>
        SS(App(fmindf(djf, dmf, nf, vf, x0), s1#),
         App(fmindf(djf, dmf, nf, vf, x0), s2#)): thm
val fminds_SS =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), a#): thm
val fminds_cond =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (!(ss : mem(Pow(form(A) * X))).
            SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fminds_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- fminds(djf, dmf, nf, vf, x0) = BIGINTER(fmind's(djf, dmf, nf, vf, x0)):
   thm
val x1 = "fmind0": string
val fmind_cases =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_rules =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val IN_F0 =
   {(A : set)}, 
   |- !(n : mem(N))  (a : mem(A + 1)). IN(Pair(n#, a#), F0(A)) <=> n# = O:
   thm
val IN_Var0 =
   {(A : set), (a0 : mem(A))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Var0(a0)) <=>
        Even(n#) & Div2(n#) = num1 | Odd(n#) & a# = SOME(a0): thm
val IN_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Neg0(f0)) <=>
        Even(n#) & Div2(n#) = num2 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Diam0(f0)) <=>
        Even(n#) & Div2(n#) = num4 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Disj0(f1, f2)) <=>
        Even(n#) & Div2(n#) = num3 |
        Odd(n#) &
        (Even(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f1) |
          Odd(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f2)): thm
val F0_NOT_Var0 = {(A : set), (p : mem(A))},  |- ~F0(A) = Var0(p): thm
val Bot_NOT_Var = {(A : set), (p : mem(A))},  |- ~Bot(A) = Var(p): thm
val F0_NOT_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- ~F0(A) = Disj0(f1, f2): thm
val Bot_NOT_Disj =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Bot(A) = Disj(f1, f2): thm
val F0_NOT_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Neg0(f0): thm
val Bot_NOT_Neg = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Neg(f): thm
val F0_NOT_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Diam0(f0): thm
val Bot_NOT_Diam = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Diam(f):
   thm
val Bot_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Bot(A#) = Var(p#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Neg(f#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Diam(f#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Bot(A#) = Disj(f1#, f2#): thm
val InjN_Inj = {},  |- !(A : set). Inj(InjN(A#)): thm
val Var0_NOT_Diam0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Diam0(f0): thm
val VAR_def' =
   {(A : set)},  |- !(a : mem(A)). Repf(App(VAR(A), a#)) = Var0(a#): thm
val Var_NOT_Diam =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Diam(f): thm
val Var0_NOT_Disj0 =
   {(A : set), (a : mem(A)), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Var0(a) = Disj0(f1, f2): thm
val Var_NOT_Disj =
   {(A : set), (a : mem(A)), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Var(a) = Disj(f1, f2): thm
val Var0_NOT_Neg0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Neg0(f0): thm
val Var_NOT_Neg =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Neg(f): thm
val Var_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Var(p#) = Bot(A#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Neg(f#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Diam(f#)) &
        !(p : mem(A#))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Var(p#) = Disj(f1#, f2#): thm
val Neg0_NOT_Diam0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Neg0(f) = Diam0(f0): thm
val Neg_NOT_Diam =
   {(A : set), (f : mem(form(A))), (f0 : mem(form(A)))}, 
   |- ~Neg(f) = Diam(f0): thm
val Neg0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Neg0(f) = Disj0(f1, f2): thm
val Neg_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Neg(f) = Disj(f1, f2): thm
val Neg_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Neg(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Neg(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Neg(f#) = Diam(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Neg(f#) = Disj(f1#, f2#): thm
val Diam0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Diam0(f) = Disj0(f1, f2): thm
val Diam_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Diam(f) = Disj(f1, f2): thm
val Diam_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Diam(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Diam(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Diam(f#) = Neg(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Diam(f#) = Disj(f1#, f2#): thm
val Disj_NOT =
   {}, 
   |- !(A : set).
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            ~Disj(f1#, f2#) = Bot(A#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (p : mem(A#)).
            ~Disj(f1#, f2#) = Var(p#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f0 : mem(form(A#))).
            ~Disj(f1#, f2#) = Diam(f0#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f : mem(form(A#))).
          ~Disj(f1#, f2#) = Neg(f#): thm
val fmind_Neg =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Neg(f), App(nf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_Disj =
   {}, 
   |- !(A : set)  (f1 : mem(form(A#)))  (X : set)  (djf : fun(X# * X#, X#))
      (dmf : fun(X#, X#))  (nf : fun(X#, X#))  (vf : fun(A#, X#))
      (x0 : mem(X#))  (x1 : mem(X#)).
        IN(Pair(f1#, x1#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
        !(f2 : mem(form(A#)))  (x2 : mem(X#)).
          IN(Pair(f2#, x2#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
          IN(Pair(Disj(f1#, f2#), App(djf#, Pair(x1#, x2#))),
           fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmind_Diam =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Diam(f), App(dmf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_uex =
   {(X : set)}, 
   |- !(A : set)  (x0 : mem(X))  (vf : fun(A#, X))  (nf : fun(X, X))
      (djf : fun(X * X, X))  (dmf : fun(X, X))  (f : mem(form(A#))).
        ?!(x : mem(X)). IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)):
   thm
val fmrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (a : mem(form(A#))).
        IN(Pair(a#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), a#)),
       fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val App_fmrec_fminds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (f : mem(form(A#)))  (x : mem(X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#) = x# <=>
        IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmrec_clauses =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), Bot(A#)) = x0# &
        (!(p : mem(A#)).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Var(p#)) = App(vf#, p#)) &
        (!(f : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Neg(f#)) =
              App(nf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Disj(f1#, f2#)) =
              App(djf#,
               Pair(App(fmrec(x0#, vf#, nf#, djf#, dmf#), f1#),
                App(fmrec(x0#, vf#, nf#, djf#, dmf#), f2#)))) &
        !(f : mem(form(A#))).
          App(fmrec(x0#, vf#, nf#, djf#, dmf#), Diam(f#)) =
            App(dmf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#)): thm
val it = (): unit
******

Loading SEAR file SEARUF.sml

******
val Inter_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val Inter_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val filter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- filter(L) <=>
      ~EMPTY(J) &
      IN(Whole(J), L) &
      (!(X : mem(Pow(J)))  (Y : mem(Pow(J))).
          IN(X#, L) & IN(Y#, L) ==> IN(Inter(X#, Y#), L)) &
      !(X : mem(Pow(J))).
        IN(X#, L) ==> !(Y : mem(Pow(J))). SS(X#, Y#) ==> IN(Y#, L): thm
val ufilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). ~IN(Compl(X#), L) <=> IN(X#, L): thm
val ufilter_filter =
   {},  |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> filter(L#):
   thm
val SS_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val SS_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val Whole_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). filter(L#) ==> IN(Whole(J#), L#):
   thm
val Whole_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> IN(Whole(J#), L#):
   thm
val Empty_NOTIN_UF =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> ~IN(Empty(J#), L#):
   thm
val IN_UF_NONEMPTY =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==> !(X : mem(Pow(J#))). IN(X#, L#) ==> ~X# = Empty(J#):
   thm
val Repu_def = {(J : set), (u : mem(UFs(J)))},  |- Repu(u) = App(iUF(J), u):
   thm
val Repu_ufilter = {},  |- !(A : set)  (u : mem(UFs(A#))). ufilter(Repu(u#)):
   thm
val UFs_def =
   {(J : set)}, 
   |- Inj(iUF(J)) &
      !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = App(iUF(J), b#): thm
val from_UFs =
   {(J : set)}, 
   |- !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = Repu(b#): thm
val Empty_NOTIN_UFs =
   {},  |- !(J : set)  (u : mem(UFs(J#))). ~IN(Empty(J#), Repu(u#)): thm
val ufilter_alt =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). IN(Compl(X#), L) <=> ~IN(X#, L): thm
val Compl_Repu =
   {(J : set), (X : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Compl(X), Repu(u)) <=> ~IN(X, Repu(u)): thm
val Union_Repu =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Union(s1, s2), Repu(u)) <=> IN(s1, Repu(u)) | IN(s2, Repu(u)): thm
val CUI_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- CUI(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        IN(BIGINTER(ss0#), ss): thm
val CUI_iff_binary =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#)))).
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) <=>
        !(s : mem(Pow(Pow(W#)))).
          SS(s#, A#) & Fin(s#) & ~s# = Empty(Pow(W#)) ==>
          IN(BIGINTER(s#), A#): thm
val FIP_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- FIP(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        ~BIGINTER(ss0#) = Empty(A): thm
val FIP_CUI_lemma =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        ~IN(Empty(W#), A#) & ~IN(Empty(W#), B#): thm
val FIP_closed_under_Inter =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) &
        (!(b1 : mem(Pow(W#))).
            IN(b1#, B#) ==>
            !(b2 : mem(Pow(W#))). IN(b2#, B#) ==> IN(Inter(b1#, b2#), B#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        FIP(Union(A#, B#)): thm
val IN_gfilter =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(x : mem(Pow(A))).
        IN(x#, gfilter(s)) <=>
        !(ss : mem(Pow(Pow(A)))). SS(s, ss#) & filter(ss#) ==> IN(x#, ss#):
   thm
val gfilter_def =
   {(A : set), (s : mem(Pow(Pow(A))))},  |- gfilter(s) = BIGINTER(gfss(s)):
   thm
val gfilter_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter(s#)): thm
val gfilter_ind =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(A#)))).
        SS(s#, ss#) & filter(ss#) ==>
        !(x : mem(Pow(A#))). IN(x#, gfilter(s#)) ==> IN(x#, ss#): thm
val gfss_def =
   {(A : set), (s0 : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(Pow(A)))). IN(a#, gfss(s0)) <=> SS(s0, a#) & filter(a#):
   thm
val SS_gfilter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter(s#)): thm
val pfilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- pfilter(L) <=> filter(L) & ~L = Whole(Pow(J)): thm
val gfilter1_def =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, gfilter1(s)) <=>
        a# = Whole(A) |
        ?(ss : mem(Pow(Pow(A)))).
          SS(ss#, s) &
          Fin(ss#) & ~ss# = Empty(Pow(A)) & SS(BIGINTER(ss#), a#): thm
val gfilter1_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter1(s#)): thm
val SS_gfilter1 =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter1(s#)): thm
val CUI_filter =
   {},  |- !(A : set)  (L : mem(Pow(Pow(A#)))). filter(L#) ==> CUI(L#): thm
val gfilter_gfilter1 =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) ==> gfilter(s#) = gfilter1(s#): thm
val Empty_NOTIN_pfilter =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) <=> filter(s#) & ~IN(Empty(A#), s#): thm
val FIP_Empty_NOTIN_gfilter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))). FIP(s#) ==> ~IN(Empty(A#), gfilter(s#)):
   thm
val FIP_PSUBSET_proper_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))).
          FIP(s#) ==> ?(v : mem(Pow(Pow(A#)))). pfilter(v#) & SS(s#, v#): thm
val filter_Whole = {},  |- !(J : set). ~EMPTY(J#) ==> filter(Whole(Pow(J#))):
   thm
val filter_Empty_Whole =
   {}, 
   |- !(J : set).
        ~EMPTY(J#) ==>
        !(L : mem(Pow(Pow(J#)))).
          filter(L#) & IN(Empty(J#), L#) <=> L# = Whole(Pow(J#)): thm
val ufilter_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        ufilter(u#) ==>
        !(s : mem(Pow(Pow(J#)))).
          filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#)): thm
val CUI_Empty_NOTIN_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        CUI(s#) & ~IN(Empty(W#), s#) ==> FIP(s#): thm
val pfilter_FIP =
   {},  |- !(W : set)  (s : mem(Pow(Pow(W#)))). pfilter(s#) ==> FIP(s#): thm
val pfilter_filter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). pfilter(s#) ==> filter(s#):
   thm
val pfilter_INSERT_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        pfilter(s#) ==>
        !(b : mem(Pow(W#))).
          ~IN(b#, s#) & ~IN(Compl(b#), s#) ==> FIP(Ins(b#, s#)): thm
val maximal_ufilter =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        (!(s : mem(Pow(Pow(J#)))).
            filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) ==> ufilter(u#):
   thm
val chain_def =
   {(A : set), (R : rel(A, A)), (t : mem(Pow(A)))}, 
   |- chain(t, R) <=>
      !(a1 : mem(A))  (a2 : mem(A)).
        IN(a1#, t) & IN(a2#, t) ==> Holds(R, a1#, a2#) | Holds(R, a2#, a1#):
   thm
val ismax_def =
   {(A : set), (R : rel(A, A)), (m : mem(A))}, 
   |- ismax(R, m) <=> !(x : mem(A)). Holds(R, m, x#) ==> x# = m: thm
val ptorder_def =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> Trans(R) & Refl(R) & Asym(R): thm
val ubound_def =
   {(A : set), (R : rel(A, A)), (s : mem(Pow(A))), (x : mem(A))}, 
   |- ubound(s, R, x) <=> !(y : mem(A)). IN(y#, s) ==> Holds(R, y#, x): thm
******

Loading SEAR file zorns.sml

******
val AC =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). Holds(R#, a#, App(f#, a#)): thm
val antisym_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        antisym(r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, x#), r#) ==> x# = y#: thm
val chain0_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        chain0(s#, r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==>
          IN(Pair(x#, y#), r#) | IN(Pair(y#, x#), r#): thm
val domain_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, domain(r#)) <=> ?(y : mem(A#)). IN(Pair(a#, y#), r#): thm
val ischoice_def =
   {(A : set), (f : fun(Pow(A), A)), (s : mem(Pow(Pow(A))))}, 
   |- ischoice(f, s) <=>
      ~IN(Empty(A), s) &
      !(s0 : mem(Pow(A))). IN(s0#, s) ==> IN(App(f, s0#), s0#): thm
val ischoice_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) & ~IN(Empty(A#), s#) ==>
        ?(f : fun(Pow(A#), A#)). ischoice(f#, s#): thm
val maximal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, maximal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(a#, x'#), r#) ==> a# = x'#:
   thm
val minimal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, minimal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(x'#, a#), r#) ==> a# = x'#:
   thm
val partial_order_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        partial_order(r#, s#) <=>
        SS(domain(r#), s#) &
        SS(range(r#), s#) & transitive(r#) & reflexive(r#, s#) & antisym(r#):
   thm
val range_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, range(r#)) <=> ?(x : mem(A#)). IN(Pair(x#, a#), r#): thm
val reflexive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        reflexive(r#, s#) <=>
        !(x : mem(A#)). IN(x#, s#) ==> IN(Pair(x#, x#), r#): thm
val transitive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        transitive(r#) <=>
        !(x : mem(A#))  (y : mem(A#))  (z : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, z#), r#) ==>
          IN(Pair(x#, z#), r#): thm
val upper_bounds_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, upper_bounds(s#, r#)) <=>
        IN(a#, range(r#)) &
        !(y : mem(A#)). IN(y#, s#) ==> IN(Pair(y#, a#), r#): thm
val fchains_def =
   {(A : set), (f : fun(Pow(A), A)), (r : mem(Pow(A * A)))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, fchains(r, f)) <=>
        chain0(a#, r) &
        ~a# = Empty(A) &
        !(C : mem(Pow(A))).
          chain0(C#, r) &
          SS(C#, a#) & ~Inter(Diff(upper_bounds(C#, r), C#), a#) = Empty(A) ==>
          IN(App(f, Diff(upper_bounds(C#, r), C#)),
           minimal_elements(Inter(Diff(upper_bounds(C#, r), C#), a#), r)):
   thm
val hatclass_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(Pow(A#))).
        IN(a#, hatclass(r#)) <=>
        ~a# = Empty(A#) &
        ?(C : mem(Pow(A#))). a# = Diff(upper_bounds(C#, r#), C#): thm
val lemma1 =
   {(A : set)}, 
   |- !(x : mem(A))  (s : mem(Pow(A)))  (r : mem(Pow(A * A))).
        chain0(s#, r#) & IN(x#, s#) ==>
        IN(x#, domain(r#)) & IN(x#, range(r#)): thm
val lemma2 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A)))  (x : mem(A))  (x' : mem(A)).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        IN(k1#, fchains(r#, f#)) &
        IN(k2#, fchains(r#, f#)) & IN(x#, k1#) & IN(x'#, k2#) & ~IN(x'#, k1#) ==>
        IN(Pair(x#, x'#), r#): thm
val lemma3 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) & IN(k1#, fchains(r#, f#)) & IN(k2#, fchains(r#, f#)) ==>
        SS(k1#, k2#) | SS(k2#, k1#): thm
val lemma4 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A)).
        ischoice(f#, hatclass(r#)) & antisym(r#) & transitive(r#) ==>
        chain0(BIGUNION(fchains(r#, f#)), r#) &
        !(x : mem(A))  (x' : mem(A))  (k : mem(Pow(A))).
          IN(Pair(x'#, x#), r#) &
          IN(x'#, BIGUNION(fchains(r#, f#))) &
          IN(x#, BIGUNION(fchains(r#, f#))) &
          IN(k#, fchains(r#, f#)) & IN(x#, k#) ==> IN(x'#, k#): thm
val lemma5 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) & ~range(r#) = Empty(A) & reflexive(r#, s#) ==>
        IN(Sing(App(f#, range(r#))), fchains(r#, f#)): thm
val lemma6 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (k : mem(Pow(A)))
      (x : mem(A))  (C : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) &
        IN(k#, fchains(r#, f#)) &
        IN(x#, k#) &
        chain0(C#, r#) &
        IN(x#, Diff(upper_bounds(C#, r#), C#)) &
        SS(C#, BIGUNION(fchains(r#, f#))) ==>
        IN(App(f#, Diff(upper_bounds(C#, r#), C#)), k#) &
        IN(Pair(App(f#, Diff(upper_bounds(C#, r#), C#)), x#), r#): thm
val lemma7 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        IN(BIGUNION(fchains(r#, f#)), fchains(r#, f#)): thm
val lemma8 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A)))
      (k : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        reflexive(r#, s#) &
        antisym(r#) &
        transitive(r#) &
        IN(k#, fchains(r#, f#)) & ~Diff(upper_bounds(k#, r#), k#) = Empty(A) ==>
        IN(Ins(App(f#, Diff(upper_bounds(k#, r#), k#)), k#), fchains(r#, f#)):
   thm
val upper_bounds_lem =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A)))  (x1 : mem(A))
      (x2 : mem(A)).
        transitive(r#) &
        IN(x1#, upper_bounds(s#, r#)) & IN(Pair(x1#, x2#), r#) ==>
        IN(x2#, upper_bounds(s#, r#)): thm
val lemma9 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        SS(upper_bounds(BIGUNION(fchains(r#, f#)), r#),
         maximal_elements(s#, r#)): thm
val zorns_lemma0 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A))).
        ~s# = Empty(A) &
        partial_order(r#, s#) &
        (!(t : mem(Pow(A))).
            chain0(t#, r#) ==> ~upper_bounds(t#, r#) = Empty(A)) ==>
        ?(x : mem(A)). IN(x#, maximal_elements(s#, r#)): thm
val Trans_transitive =
   {},  |- !(A : set)  (R : rel(A#, A#)). Trans(R#) <=> transitive(r2m(R#)):
   thm
val Refl_reflexive =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> reflexive(r2m(R#), Whole(A#)): thm
val Asym_antisym =
   {},  |- !(A : set)  (R : rel(A#, A#)). Asym(R#) <=> antisym(r2m(R#)): thm
val ptorder_partial_order =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> partial_order(r2m(R), Whole(A)): thm
val zorns_lemma =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ~EMPTY(A#) & ptorder(R#) ==>
        (!(c : mem(Pow(A#))).
            chain(c#, R#) & ~c# = Empty(A#) ==>
            ?(ub : mem(A#)). ubound(c#, R#, ub#)) ==>
        ?(m : mem(A#)). ismax(R#, m#): thm
val it = (): unit
val ufilter_iff_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        ((!(s : mem(Pow(Pow(J#)))).
              filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) <=>
          ufilter(u#)): thm
val UNION_chain_filter_filter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> filter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          filter(BIGUNION(ss#)): thm
val UNION_chain_pfilter_pfilter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> pfilter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          pfilter(BIGUNION(ss#)): thm
val ufilter_thm =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) ==> ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(s#, u#):
   thm
val ufilter_thm_coro =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==>
        ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(ss#, u#): thm
val Prop_5_3 =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==> ?(u : mem(UFs(A#))). SS(ss#, Repu(u#)): thm
val FIP_Sing =
   {},  |- !(W : set)  (a : mem(Pow(W#))). ~a# = Empty(W#) ==> FIP(Sing(a#)):
   thm
val it = (): unit
******

Loading SEAR file SEARmmmt.sml

******
val Rm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w1 : mem(W)), (w2 : mem(W))}, 
   |- Rm(M, w1, w2) <=> IN(Pair(w1, w2), Rof(M)): thm
val Rof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Rof(M#) = Fst(M#): thm
val Vof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Vof(M#) = tof(Snd(M#)): thm
val HAT_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(A))  (w : mem(W)).
        IN(w#, App(HAT(M), a#)) <=> IN(a#, App(Vof(M), w#)): thm
val satis_def0 =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A))), (w : mem(W))}, 
   |- satis(M, w, f) <=> IN(w, App(satisf(M), f)): thm
val satis_dmf =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(Pow(W)))  (w : mem(W)).
        IN(w#, App(sdmf(M), a#)) <=>
        ?(w0 : mem(W)). IN(w0#, a#) & Rm(M, w#, w0#): thm
val satisf_clause =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- App(satisf(M), Bot(A)) = Empty(W) &
      (!(p : mem(A)). App(satisf(M), Var(p#)) = App(HAT(M), p#)) &
      (!(f : mem(form(A))).
          App(satisf(M), Neg(f#)) = App(COMPL(W), App(satisf(M), f#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          App(satisf(M), Disj(f1#, f2#)) =
            App(UNION(W), Pair(App(satisf(M), f1#), App(satisf(M), f2#)))) &
      !(f : mem(form(A))).
        App(satisf(M), Diam(f#)) = App(sdmf(M), App(satisf(M), f#)): thm
val satisf_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- satisf(M) = fmrec(Empty(W), HAT(M), COMPL(W), UNION(W), sdmf(M)): thm
val satis_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))}, 
   |- ~satis(M, w, Bot(A)) &
      (!(a : mem(A)). satis(M, w, Var(a#)) <=> IN(a#, App(Vof(M), w))) &
      (!(f : mem(form(A))). satis(M, w, Neg(f#)) <=> ~satis(M, w, f#)) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          satis(M, w, Disj(f1#, f2#)) <=> satis(M, w, f1#) | satis(M, w, f2#)) &
      !(f : mem(form(A))).
        satis(M, w, Diam(f#)) <=>
        ?(v : mem(W)). Rm(M, w, v#) & satis(M, v#, f#): thm
val SATIS_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (fs : mem(Pow(form(A)))), (w : mem(W))}, 
   |- SATIS(M, w, fs) <=> !(f : mem(form(A))). IN(f#, fs) ==> satis(M, w, f#):
   thm
val Top_def = {(A : set)},  |- Top(A) = Neg(Bot(A)): thm
val Conj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Conj(f1, f2) = Neg(Disj(Neg(f1), Neg(f2))): thm
val satis_Conj =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f1 : mem(form(A)))  (f2 : mem(form(A))).
        satis(M#, w#, Conj(f1#, f2#)) <=>
        satis(M#, w#, f1#) & satis(M#, w#, f2#): thm
val PE's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). IN(a#, PE's(A)) <=> SS(App(PEf(A), a#), a#):
   thm
val PE_cases0 = {(A : set)},  |- App(PEf(A), PEs(A)) = PEs(A): thm
val PE_cases1 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_incond =
   !(f : mem(form(A))).
     IN(f#, PEs1) <=>
     f# = Top(A) |
     f# = Bot(A) |
     (?(p : mem(A)). f# = Var(p#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Conj(f1#, f2#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Disj(f1#, f2#)) |
     ?(f0 : mem(form(A))). IN(f0#, PEs0) & f# = Diam(f0#): form
val PE_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        (!(a : mem(form(A))).
            a# = Top(A) |
            a# = Bot(A) |
            (?(p : mem(A)). a# = Var(p#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Conj(f1#, f2#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj(f1#, f2#)) |
            (?(f0 : mem(form(A))). IN(f0#, ss#) & a# = Diam(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_rules0 = {(A : set)},  |- SS(App(PEf(A), PEs(A)), PEs(A)): thm
val PE_rules1 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        a# = Top(A) |
        a# = Bot(A) |
        (?(p : mem(A)). a# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#)) |
        (?(f0 : mem(form(A))). IN(f0#, PEs(A)) & a# = Diam(f0#)) ==>
        IN(a#, PEs(A)): thm
val PE_rules2 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (a# = Top(A) ==> IN(a#, PEs(A))) &
        (a# = Bot(A) ==> IN(a#, PEs(A))) &
        (!(p : mem(A)). a# = Var(p#) ==> IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        !(f0 : mem(form(A))).
          IN(f0#, PEs(A)) & a# = Diam(f0#) ==> IN(a#, PEs(A)): thm
val PE_rules3 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PEf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A))))  (f : mem(form(A))).
        IN(f#, App(PEf(A), a#)) <=>
        f# = Top(A) |
        f# = Bot(A) |
        (?(p : mem(A)). f# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(form(A)), Pow(form(A)))).
        !(a : mem(Pow(form(A))))  (f : mem(form(A))).
          IN(f#, App(f#, a#)) <=>
          f# = Top(A) |
          f# = Bot(A) |
          (?(p : mem(A)). f# = Var(p#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
          ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==> SS(App(PEf(A), s1#), App(PEf(A), s2#)): thm
val PEs_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). SS(App(PEf(A), a#), a#) ==> SS(PEs(A), a#):
   thm
val PEs_cond =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (!(ss : mem(Pow(form(A)))). SS(App(PEf(A), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, PEs(A)): thm
val PEs_def = {(A : set)},  |- PEs(A) = BIGINTER(PE's(A)): thm
val x1 = "PEs0": string
val PE_cases0 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_rules0 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PE_def0 = {(A : set), (f : mem(form(A)))},  |- PE(f) <=> IN(f, PEs(A)):
   thm
val PE_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). PE(a#) ==> IN(a#, ss#): thm
val PE_cases =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        PE(x#) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). PE(f0#) & x# = Diam(f0#): thm
val PE_rules =
   {(A : set)}, 
   |- PE(Top(A)) &
      PE(Bot(A)) &
      (!(p : mem(A)). PE(Var(p#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#))) &
      !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val PE_induct =
   {}, 
   |- !(A : set).
        P(Top(A#)) &
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Conj(f1#, f2#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f : mem(form(A#))). P(f#) ==> P(Diam(f#))) ==>
        !(f : mem(form(A#))). PE(f#) ==> P(f#): thm
val satis_Bot =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
      (w : mem(W#)). ~satis(M#, w#, Bot(A#)): thm
val satis_Top =
   {(W : set)}, 
   |- !(A : set)  (M : mem(Pow((W * W)) * Exp(W, Pow(A#))))  (w : mem(W)).
        satis(M#, w#, Top(A#)): thm
val PUS_Var = {},  |- !(A : set)  (p : mem(A#)). PUS(Var(p#)): thm
val PUS_def =
   {(A : set), (f : mem(form(A)))}, 
   |- PUS(f) <=>
      !(W1 : set)  (W2 : set)  (R : rel(W1#, W2#))
      (M1 : mem(Pow((W1# * W1#)) * Exp(W1#, Pow(A))))
      (M2 : mem(Pow((W2# * W2#)) * Exp(W2#, Pow(A)))).
        Sim(R#, M1#, M2#) ==>
        !(w1 : mem(W1#))  (w2 : mem(W2#)).
          Holds(R#, w1#, w2#) ==> satis(M1#, w1#, f) ==> satis(M2#, w2#, f):
   thm
val Sim_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (R : rel(W1, W2)),
    (W1 : set), (W2 : set)}, 
   |- Sim(R, M1, M2) <=>
      !(w1 : mem(W1))  (w2 : mem(W2)).
        Holds(R, w1#, w2#) ==>
        (!(p : mem(A)).
            IN(p#, App(Vof(M1), w1#)) ==> IN(p#, App(Vof(M2), w2#))) &
        !(v : mem(W1)).
          Rm(M1, w1#, v#) ==>
          ?(v' : mem(W2)). Holds(R, v#, v'#) & Rm(M2, w2#, v'#): thm
val PUS_Top = {},  |- !(A : set). PUS(Top(A#)): thm
val PUS_Bot = {},  |- !(A : set). PUS(Bot(A#)): thm
val Thm_6_25_r2l0 =
   {},  |- !(A : set)  (f : mem(form(A#))). PE(f#) ==> PUS(f#): thm
val EQV_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- EQV(f1, f2) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, f1) <=> satis(M#, w#, f2): thm
val Thm_6_25_r2l =
   {}, 
   |- !(A : set)  (f : mem(form(A#)))  (f0 : mem(form(A#))).
        PE(f0#) & EQV(f#, f0#) ==> PUS(f#): thm
val Fsab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Fsab(fs, X, M) <=>
      !(ss : mem(Pow(form(A)))). Fin(ss#) & SS(ss#, fs) ==> Sab(ss#, X, M):
   thm
val Msat_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- Msat(M) <=>
      !(w : mem(W))  (fs : mem(Pow(form(A)))).
        Fsab(fs#, Sucm(M, w#), M) ==> Sab(fs#, Sucm(M, w#), M): thm
val Sab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Sab(fs, X, M) <=> ?(x : mem(W)). IN(x#, X) & SATIS(M, x#, fs): thm
val Sucm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))},  |- !(a : mem(W)). IN(a#, Sucm(M, w)) <=> Rm(M, w, a#):
   thm
val Tat_def =
   {(A : set), (W : set), (a : mem(A)), (f0 : fun(W, Pow(A)))}, 
   |- !(a' : mem(W)). IN(a'#, Tat(f0, a)) <=> IN(a, App(f0, a'#)): thm
val fun_mem_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(f : fun(A#, B#)). P(f#)) <=> ?(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val mem_fun_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(m : mem(Exp(A#, B#))). P(m#)) <=> ?(f : fun(A#, B#)). P(Tpm(f#)):
   thm
val fun_mem_uex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?!(f : fun(A#, B#)). P(f#)) <=> ?!(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val UE_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- UE(M) = Pair(ueR(M), ueV(M)): thm
val csee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, csee(M, X)) <=> ?(v : mem(W)). Rm(M, a#, v#) & IN(v#, X): thm
val osee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, osee(M, X)) <=> !(v : mem(W)). Rm(M, a#, v#) ==> IN(v#, X):
   thm
val ueR_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a' : mem(UFs(W)))  (b : mem(UFs(W))).
        IN(Pair(a'#, b#), ueR(M)) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(b#)) ==> IN(csee(M, X#), Repu(a'#)):
   thm
val ueV_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(u : mem(UFs(W)))  (a : mem(A)).
        IN(a#, App(tof(ueV(M)), u#)) <=> IN(Tat(Vof(M), a#), Repu(u#)): thm
val ufilter_Compl =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))). ~IN(Compl(X#), L#) <=> IN(X#, L#): thm
val exists_forall_dual =
   {},  |- !(A : set). (?(a : mem(A#)). P(a#)) <=> ~!(a : mem(A#)). ~P(a#):
   thm
val Prop_5_4_1 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        csee(M#, X#) = Compl(osee(M#, Compl(X#))): thm
val Prop_5_4_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        osee(M#, X#) = Compl(csee(M#, Compl(X#))): thm
val Prop_5_6 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val MEQ_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (W1 : set), (W2 : set),
    (w1 : mem(W1)), (w2 : mem(W2))}, 
   |- MEQ(M1, w1, M2, w2) <=>
      !(f : mem(form(A))). satis(M1, w1, f#) <=> satis(M2, w2, f#): thm
val pufilter_def =
   {(A : set), (a : mem(A))}, 
   |- !(a' : mem(Pow(A))). IN(a'#, pufilter(a)) <=> IN(a, a'#): thm
val pufilter_filter =
   {},  |- !(A : set)  (a : mem(A#)). filter(pufilter(a#)): thm
val ueR_alt =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val pufilter_ufilter =
   {},  |- !(A : set)  (a : mem(A#)). ufilter(pufilter(a#)): thm
val Repu_eq_eq =
   {}, 
   |- !(W : set)  (u1 : mem(UFs(W#)))  (u2 : mem(UFs(W#))).
        Repu(u1#) = Repu(u2#) ==> u1# = u2#: thm
val Pft_def =
   {(W : set), (w0 : mem(W))}, 
   |- !(ws : mem(Pow(W))). IN(ws#, Repu(Pft(w0))) <=> IN(w0, ws#): thm
val Prop_5_5_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W)))
      (Y : mem(Pow(W))).
        osee(M#, Inter(X#, Y#)) = Inter(osee(M#, X#), osee(M#, Y#)): thm
val SW_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(form(A)))  (w : mem(W)).
        IN(w#, App(SW(M), a#)) <=> satis(M, w#, a#): thm
val Sw_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A)))},  |- Sw(M, f) = App(SW(M), f): thm
val Sw_Bot =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Sw(M#, Bot(A)) = Empty(W):
   thm
val Sw_Var =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        Sw(M#, Var(p#)) = App(HAT(M#), p#): thm
val Vof_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Vof(UE(M#)) = tof(ueV(M#)):
   thm
val HAT_Tat =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        App(HAT(M#), p#) = Tat(Vof(M#), p#): thm
val Sw_Neg =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        Sw(M#, Neg(f#)) = Compl(Sw(M#, f#)): thm
val Sw_Disj =
   {(A : set), (W : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        Sw(M#, Disj(f1, f2)) = Union(Sw(M#, f1), Sw(M#, f2)): thm
val Rm_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (u' : mem(UFs(W))).
        Rm(UE(M#), u#, u'#) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(u'#)) ==> IN(csee(M#, X#), Repu(u#)):
   thm
val csee_Sw_DIAM =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        csee(M#, Sw(M#, f#)) = Sw(M#, Diam(f#)): thm
val Prop_5_8 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
      (phi : mem(form(A)))  (u : mem(UFs(W#))).
        IN(Sw(M#, phi#), Repu(u#)) <=> satis(UE(M#), u#, phi#): thm
val Prop_5_7 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        MEQ(M#, w#, UE(M#), Pft(w#)): thm
val SATIS_Sing =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f : mem(form(A))). SATIS(M#, w#, Sing(f#)) <=> satis(M#, w#, f#): thm
val Fin_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(s1#) | Fin(s2#) ==> Fin(Inter(s1#, s2#)): thm
val SATIS_Union =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SATIS(M#, w#, Union(s1#, s2#)) <=>
        SATIS(M#, w#, s1#) & SATIS(M#, w#, s2#): thm
val only_see_whole_world =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        osee(M#, Whole(W)) = Whole(W): thm
val SATIS_Empty =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        SATIS(M#, w#, Empty(form(A))): thm
val BIGCONJ_EXISTS =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        ?(ff : mem(form(A))).
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val SS_Union_of =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s1#, s#) & SS(s2#, s#) ==> SS(Union(s1#, s2#), s#): thm
val Prop_5_9 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Msat(UE(M#)): thm
val PE_BIGCONJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val PE_Conj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#)): thm
val PE_BIGDISJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)).
            satis(M#, w#, ff#) <=>
            ?(f : mem(form(A))). IN(f#, s#) & satis(M#, w#, f#): thm
val PE_Disj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#)): thm
val PE_Diam =
   {(A : set)},  |- !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val Thm_6_22 =
   {(A : set), (W1 : set), (W2 : set)}, 
   |- !(M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A))))
      (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))).
        Msat(M1#) & Msat(M2#) ==>
        !(w1 : mem(W1))  (w2 : mem(W2)).
          (!(f : mem(form(A))).
              PE(f#) ==> satis(M1#, w1#, f#) ==> satis(M2#, w2#, f#)) ==>
          ?(R : rel(W1, W2)). Sim(R#, M1#, M2#) & Holds(R#, w1#, w2#): thm
val ENT_def =
   {(A : set), (phis : mem(Pow(form(A)))), (psi : mem(form(A)))}, 
   |- ENT(phis, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        SATIS(M#, w#, phis) ==> satis(M#, w#, psi): thm
val MCOMPACT_def =
   {}, 
   |- MCOMPACT <=>
      !(A : set)  (fs : mem(Pow(form(A#)))).
        (!(ffs : mem(Pow(form(A#)))).
            SS(ffs#, fs#) & Fin(ffs#) ==>
            ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
            (w : mem(W#)). SATIS(M#, w#, ffs#)) ==>
        ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
        (w : mem(W#)). SATIS(M#, w#, fs#): thm
val satis_Neg =
   {(A : set), (W : set), (f : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        satis(M#, w#, Neg(f)) <=> ~satis(M#, w#, f): thm
val Ent_def =
   {(A : set), (phi : mem(form(A))), (psi : mem(form(A)))}, 
   |- Ent(phi, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, phi) ==> satis(M#, w#, psi): thm
val SATIS_SS =
   {(A : set), (W : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==>
        !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
          SATIS(M#, w#, s2#) ==> SATIS(M#, w#, s1#): thm
val Thm_6_24 =
   {(A : set)}, 
   |- MCOMPACT ==>
      !(fs : mem(Pow(form(A))))  (phi : mem(form(A))).
        ENT(fs#, phi#) ==>
        ?(ffs : mem(Pow(form(A)))).
          SS(ffs#, fs#) & Fin(ffs#) & ENT(ffs#, phi#): thm
val Fin_ENT_PE =
   {(A : set)}, 
   |- !(fs : mem(Pow(form(A)))).
        Fin(fs#) & (!(f : mem(form(A))). IN(f#, fs#) ==> PE(f#)) ==>
        ?(phi : mem(form(A))).
          PE(phi#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). SATIS(M#, w#, fs#) <=> satis(M#, w#, phi#): thm
val PEC_def =
   {(A : set), (f : mem(form(A)))}, 
   |- !(a : mem(form(A))). IN(a#, PEC(f)) <=> PE(a#) & Ent(f, a#): thm
val SATIS_PEC =
   {(A : set), (W : set)}, 
   |- !(f : mem(form(A)))  (M : mem(Pow((W * W)) * Exp(W, Pow(A))))
      (w : mem(W)). satis(M#, w#, f#) ==> SATIS(M#, w#, PEC(f#)): thm
val Del_Fin =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        Fin(Del(s#, a#)) ==> Fin(s#): thm
val Fin_Inj0 =
   {}, 
   |- !(B : set)  (s : mem(Pow(B#))).
        Fin(s#) ==>
        !(A : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
          s# = IMAGE(f#, ss#) ==> Inj(f#) ==> Fin(ss#): thm
val Fin_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(ss : mem(Pow(A#))). Fin(IMAGE(f#, ss#)) ==> Fin(ss#):
   thm
val Thm_6_25_iff =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) <=> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val Thm_6_25_l2r =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) ==> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val it = (): unit
******

Loading SEAR file SEARllist.sml

******
val IN_gfp =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (a : mem(A)).
        IN(a#, gfp(f#)) <=>
        ?(sa : mem(Pow(A))). SS(sa#, App(f#, sa#)) & IN(a#, sa#): thm
val gfp_def =
   {}, 
   |- !(A : set)  (f : fun(Pow(A#), Pow(A#))). gfp(f#) = BIGUNION(prims(f#)):
   thm
val prims_def =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- !(a : mem(Pow(A))). IN(a#, prims(f)) <=> SS(a#, App(f, a#)): thm
val weak_coind =
   {}, 
   |- !(A : set)  (sa : mem(Pow(A#)))  (a : mem(A#))
      (f : fun(Pow(A#), Pow(A#))).
        IN(a#, sa#) & SS(sa#, App(f#, sa#)) ==> IN(a#, gfp(f#)): thm
val SS_gfp_fgfp =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(gfp(f), App(f, gfp(f))): thm
val monotone_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(Pow(A#), Pow(B#))).
        monotone(f#) <=>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          SS(s1#, s2#) ==> SS(App(f#, s1#), App(f#, s2#)): thm
val rules0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(App(f, gfp(f)), gfp(f)): thm
val cases0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> gfp(f) = App(f, gfp(f)): thm
val coind0 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (sa : mem(Pow(A))).
        SS(sa#, App(f#, sa#)) ==> SS(sa#, gfp(f#)): thm
val lcons0_def =
   {}, 
   |- !(X : set)  (f0 : fun(N, X# + 1))  (x : mem(X#)).
        App(lcons0(x#, f0#), O) = SOME(x#) &
        !(n : mem(N)). App(lcons0(x#, f0#), Suc(n#)) = App(f0#, n#): thm
val llf_uex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Exp(N, X + 1)), Pow(Exp(N, X + 1)))).
        !(gs : mem(Pow(Exp(N, X + 1))))  (g : mem(Exp(N, X + 1))).
          IN(g#, App(f#, gs#)) <=>
          g# = Tpm(Null(X)) |
          ?(h : mem(X))  (t : fun(N, X + 1)).
            g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_def =
   {}, 
   |- !(X : set)  (gs : mem(Pow(Exp(N, X# + 1))))  (g : mem(Exp(N, X# + 1))).
        IN(g#, App(llf(X#), gs#)) <=>
        g# = Tpm(Null(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_monotone = {},  |- !(X : set). monotone(llf(X#)): thm
val islls_def = {(X : set)},  |- islls(X) = gfp(llf(X)): thm
val llist_def1 =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          IN(a#, islls(X#)) <=>
          ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_Inj = {},  |- !(X : set). Inj(repll(X#)): thm
val isll_def =
   {}, 
   |- !(X : set)  (l : mem(Exp(N, X# + 1))). isll(l#) <=> IN(l#, islls(X#)):
   thm
val ll_cases = {},  |- !(X : set). islls(X#) = App(llf(X#), islls(X#)): thm
val ll_coind =
   {}, 
   |- !(X : set)  (sa : mem(Pow(Exp(N, X# + 1)))).
        (!(a : mem(Exp(N, X# + 1))).
            IN(a#, sa#) ==>
            a# = Tpm(Null(X#)) |
            ?(h : mem(X#))  (t : fun(N, X# + 1)).
              a# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), sa#)) ==>
        !(a : mem(Exp(N, X# + 1))). IN(a#, sa#) ==> IN(a#, islls(X#)): thm
val ll_rules =
   {}, 
   |- !(X : set).
        IN(Tpm(Null(X#)), islls(X#)) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          IN(Tpm(t#), islls(X#)) ==> IN(Tpm(lcons0(h#, t#)), islls(X#)): thm
val isll_lnil = {},  |- !(X : set). isll(Tpm(Null(X#))): thm
val isll_shift =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val Repll_def =
   {},  |- !(X : set)  (l : mem(llist(X#))). Repll(l#) = App(repll(X#), l#):
   thm
val LNil_def = {},  |- !(X : set). Repll(LNil(X#)) = Tpm(Null(X#)): thm
val llist_def =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          isll(a#) <=> ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_isll =
   {},  |- !(X : set)  (ll : mem(llist(X#))). isll(App(repll(X#), ll#)): thm
val isll_Repll =
   {}, 
   |- !(X : set)  (a : mem(Exp(N, X# + 1))).
        isll(a#) <=> ?(b : mem(llist(X#))). a# = Repll(b#): thm
val Repll_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(llist(X#)))  (l2 : mem(llist(X#))).
        Repll(l1#) = Repll(l2#) <=> l1# = l2#: thm
val Repll_isll = {},  |- !(X : set)  (ll : mem(llist(X#))). isll(Repll(ll#)):
   thm
val isll_lcons0 =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val isll_rules =
   {}, 
   |- !(X : set).
        isll(Tpm(Null(X#))) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          isll(Tpm(t#)) ==> isll(Tpm(lcons0(h#, t#))): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LCons_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#)))  (x : mem(X#)).
        Repll(LCons(x#, ll#)) = Tpm(lcons0(x#, tof(Repll(ll#)))): thm
val Repll_lnil_uex =
   {}, 
   |- !(X : set)  (l : mem(llist(X#))).
        Repll(l#) = Tpm(Null(X#)) <=> l# = LNil(X#): thm
val FPB_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- App(FPB(f), NONE(B * A)) = NONE(B * A) &
      !(b : mem(B))  (a : mem(A)).
        App(FPB(f), SOME(Pair(b#, a#))) = App(f, b#): thm
val FP_def =
   {(X : set), (f : fun(X, X))}, 
   |- !(x : mem(X)).
        App(FP(f), Pair(O, x#)) = x# &
        !(n : mem(N)).
          App(FP(f), Pair(Suc(n#), x#)) = App(FP(f), Pair(n#, App(f, x#))):
   thm
val OB_def =
   {(A : set), (B : set)}, 
   |- !(f : fun(A, B + 1)).
        App(OB(A, B), Pair(NONE(A), Tpm(f#))) = NONE(B) &
        !(a : mem(A)). App(OB(A, B), Pair(SOME(a#), Tpm(f#))) = App(f#, a#):
   thm
val lnil_def = {(X : set)},  |- lnil(X) = Tpm(Null(X)): thm
val toabs_char0 =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)).
        (App(f#, z#) = NONE(B * A) ==> toabs(f#, z#) = Null(A)) &
        !(b : mem(B))  (a : mem(A)).
          App(f#, z#) = SOME(Pair(b#, a#)) ==>
          toabs(f#, z#) = lcons0(a#, toabs(f#, b#)): thm
val toabs_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1)), (z : mem(B))}, 
   |- !(n : mem(N)).
        App(toabs(f, z), n#) =
          App(OM(p2(B, A)), App(FP(FPB(f)), Pair(n#, App(f, z)))): thm
val toabs_isll =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)). isll(Tpm(toabs(f#, z#))): thm
val toabs_unique =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (g : fun(B, Exp(N, A + 1))).
        (!(z : mem(B)).
            (App(f#, z#) = NONE(B * A) ==> App(g#, z#) = Tpm(Null(A))) &
            !(b : mem(B))  (a : mem(A)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(g#, z#) = Tpm(lcons0(a#, tof(App(g#, b#))))) ==>
        !(z : mem(B)). App(g#, z#) = Tpm(toabs(f#, z#)): thm
val llcr0_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- !(z : mem(B)). App(llcr0(f), z#) = Tpm(toabs(f, z#)): thm
val llrec0_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, Exp(N, A# + 1))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = Tpm(Null(A#))) &
            (!(b : mem(B#))  (a : mem(A#)).
                App(f#, z#) = SOME(Pair(b#, a#)) ==>
                App(cr#, z#) = Tpm(lcons0(a#, tof(App(cr#, b#))))) &
            isll(App(cr#, z#)): thm
val llcr_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, llist(A#))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = LNil(A#)) &
            !(b : mem(B#))  (a : mem(A#)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(cr#, z#) = LCons(a#, App(cr#, b#)): thm
val CB_def =
   {(X : set)}, 
   |- !(R : mem(Pow(llist(X) * llist(X))))  (ll1 : mem(llist(X)))
      (ll2 : mem(llist(X))).
        IN(Pair(ll1#, ll2#), App(CB(X), R#)) <=>
        ll1# = LNil(X) & ll2# = LNil(X) |
        ?(l01 : mem(llist(X)))  (l02 : mem(llist(X)))  (x : mem(X)).
          IN(Pair(l01#, l02#), R#) &
          ll1# = LCons(x#, l01#) & ll2# = LCons(x#, l02#): thm
val CB_monotone = {(X : set)},  |- monotone(CB(X)): thm
val CB_cases = {},  |- !(X : set). gfp(CB(X#)) = App(CB(X#), gfp(CB(X#))):
   thm
val CB_rules0 =
   {}, 
   |- !(X : set).
        IN(Pair(LNil(X#), LNil(X#)), gfp(CB(X#))) &
        !(l01 : mem(llist(X#)))  (l02 : mem(llist(X#))).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          !(x : mem(X#)).
            IN(Pair(LCons(x#, l01#), LCons(x#, l02#)), gfp(CB(X#))): thm
val CB_rules00 =
   {}, 
   |- !(X : set).
        (!(b : mem(llist(X#)))  (a' : mem(llist(X#))).
            a'# = LNil(X#) ==>
            b# = LNil(X#) ==> IN(Pair(a'#, b#), gfp(CB(X#)))) &
        !(a' : mem(llist(X#)))  (b : mem(llist(X#)))  (l01 : mem(llist(X#)))
        (l02 : mem(llist(X#)))  (x : mem(X#)).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          a'# = LCons(x#, l01#) ==>
          b# = LCons(x#, l02#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val CB_coind0 =
   {}, 
   |- !(X : set)  (sa : mem(Pow(llist(X#) * llist(X#)))).
        (!(a' : mem(llist(X#)))  (b : mem(llist(X#))).
            IN(Pair(a'#, b#), sa#) ==>
            a'# = LNil(X#) & b# = LNil(X#) |
            ?(l01 : mem(llist(X#)))  (l02 : mem(llist(X#)))  (x : mem(X#)).
              IN(Pair(l01#, l02#), sa#) &
              a'# = LCons(x#, l01#) & b# = LCons(x#, l02#)) ==>
        !(a' : mem(llist(X#)))  (b : mem(llist(X#))).
          IN(Pair(a'#, b#), sa#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val LHD_THM =
   {(X : set)}, 
   |- LHD(LNil(X)) = NONE(X) &
      !(h : mem(X))  (t : mem(llist(X))). LHD(LCons(h#, t#)) = SOME(h#): thm
val LHD_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))). LHD(ll#) = App(tof(Repll(ll#)), O):
   thm
val LNTH_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). LNTH(n#, ll1#) = LNTH(n#, ll2#)) <=> ll1# = ll2#: thm
val LNTH_def =
   {}, 
   |- !(A : set)  (ll : mem(llist(A#)))  (n : mem(N)).
        LNTH(n#, ll#) = App(tof(Repll(ll#)), n#): thm
val Repll_n_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). App(tof(Repll(ll1#)), n#) = App(tof(Repll(ll2#)), n#)) <=>
        ll1# = ll2#: thm
val isll_cases0 =
   {}, 
   |- !(X : set)  (x : mem(Exp(N, X# + 1))).
        isll(x#) <=>
        x# = Repll(LNil(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          x# = Tpm(lcons0(h#, t#)) & isll(Tpm(t#)): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LTL_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        (LHD(ll#) = NONE(X#) ==> LTL(ll#) = NONE(llist(X#))) &
        !(hd : mem(X#)).
          LHD(ll#) = SOME(hd#) ==>
          ?(ltl0 : mem(llist(X#))).
            LTL(ll#) = SOME(ltl0#) &
            !(n : mem(N)).
              App(tof(Repll(ltl0#)), n#) = App(tof(Repll(ll#)), Suc(n#)): thm
val LCons_xor_LNil =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        ~ll# = LNil(X#) <=>
        ?(h : mem(X#))  (t : mem(llist(X#))). ll# = LCons(h#, t#): thm
val LTL_THM =
   {(X : set)}, 
   |- LTL(LNil(X)) = NONE(llist(X)) &
      !(h : mem(X))  (t : mem(llist(X))). LTL(LCons(h#, t#)) = SOME(t#): thm
val LNTH_THM =
   {}, 
   |- !(X : set).
        (!(n : mem(N)). LNTH(n#, LNil(X#)) = NONE(X#)) &
        (!(h : mem(X#))  (t : mem(llist(X#))).
            LNTH(O, LCons(h#, t#)) = SOME(h#)) &
        !(n : mem(N))  (h : mem(X#))  (t : mem(llist(X#))).
          LNTH(Suc(n#), LCons(h#, t#)) = LNTH(n#, t#): thm
val gfp_CB =
   {}, 
   |- !(X : set)  (g1 : mem(llist(X#)))  (g2 : mem(llist(X#))).
        IN(Pair(g1#, g2#), gfp(CB(X#))) <=> g1# = g2#: thm
val LLIST_BISIMULATION0 =
   {(X : set)}, 
   |- !(ll1 : mem(llist(X)))  (ll2 : mem(llist(X))).
        ll1# = ll2# <=>
        ?(R : mem(Pow(llist(X) * llist(X)))).
          IN(Pair(ll1#, ll2#), R#) &
          !(ll3 : mem(llist(X)))  (ll4 : mem(llist(X))).
            IN(Pair(ll3#, ll4#), R#) ==>
            ll3# = LNil(X) & ll4# = LNil(X) |
            ?(h : mem(X))  (t1 : mem(llist(X)))  (t2 : mem(llist(X))).
              IN(Pair(t1#, t2#), R#) &
              ll3# = LCons(h#, t1#) & ll4# = LCons(h#, t2#): thm
val lcons0_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : fun(N, X + 1))
      (t2 : fun(N, X + 1)).
        lcons0(h1#, t1#) = lcons0(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LCons_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : mem(llist(X)))
      (t2 : mem(llist(X))).
        LCons(h1#, t1#) = LCons(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LMAP_def =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(z : mem(llist(X))).
        (App(lmapf(f), z#) = NONE(llist(X) * Y) ==>
          App(LMAP(f), z#) = LNil(Y)) &
        !(b : mem(llist(X)))  (a : mem(Y)).
          App(lmapf(f), z#) = SOME(Pair(b#, a#)) ==>
          App(LMAP(f), z#) = LCons(a#, App(LMAP(f), b#)): thm
val LMap_def =
   {(X : set), (Y : set), (f : fun(X, Y)), (l : mem(llist(X)))}, 
   |- LMap(f, l) = App(LMAP(f), l): thm
val f_ex0 =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(l : mem(llist(X))).
        ?!(opv : mem(llist(X) * A + 1)).
          l# = LNil(X) & opv# = NONE(llist(X) * A) |
          ?(lh : mem(X))  (lt : mem(llist(X))).
            l# = LCons(lh#, lt#) & opv# = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LNil =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A)). App(lmapf(f#), LNil(X)) = NONE(llist(X) * A): thm
val lmapf_def =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(a : mem(llist(X))).
        a# = LNil(X) & App(lmapf(f), a#) = NONE(llist(X) * A) |
        ?(lh : mem(X))  (lt : mem(llist(X))).
          a# = LCons(lh#, lt#) &
          App(lmapf(f), a#) = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LCons =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A))  (lh : mem(X))  (lt : mem(llist(X))).
        App(lmapf(f#), LCons(lh#, lt#)) = SOME(Pair(lt#, App(f#, lh#))): thm
val LMAP_LNil =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y)). App(LMAP(f#), LNil(X)) = LNil(Y): thm
val LMAP_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        App(LMAP(f#), LCons(lh#, lt#)) =
          LCons(App(f#, lh#), App(LMAP(f#), lt#)): thm
val LMap_LNil =
   {(X : set), (Y : set)},  |- !(f : fun(X, Y)). LMap(f#, LNil(X)) = LNil(Y):
   thm
val LMap_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        LMap(f#, LCons(lh#, lt#)) = LCons(App(f#, lh#), LMap(f#, lt#)): thm
val LMap_functorial =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (g : fun(Z, X))  (ll : mem(llist(Z))).
        LMap(f#, LMap(g#, ll#)) = LMap(f# o g#, ll#): thm
val it = (): unit
******

Loading SEAR file SEARGrp.sml

******
val Grp_def =
   {}, 
   |- !(G : set).
        Inj(iG(G#)) &
        !(a : mem(Exp((G# * G#), G#) * Exp(G#, G#) * G#)).
          isgrp(a#) <=> ?(b : mem(Grp(G#))). a# = App(iG(G#), b#): thm
val RepG_def = {(G : set), (g : mem(Grp(G)))},  |- RepG(g) = App(iG(G), g):
   thm
val RepG_isgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isgrp(RepG(g#)): thm
val asc_def =
   {(A : set), (m : fun(A * A, A))}, 
   |- asc(m) <=>
      !(a1 : mem(A))  (a2 : mem(A))  (a3 : mem(A)).
        mul(m, mul(m, a1#, a2#), a3#) = mul(m, a1#, mul(m, a2#, a3#)): thm
val isgrp_def =
   {(G : set), (g : mem(Exp((G * G), G) * Exp(G, G) * G))}, 
   |- isgrp(g) <=>
      asc(tof(c31(g))) &
      isunit(tof(c31(g)), c33(g)) & isinv(tof(c31(g)), tof(c32(g)), c33(g)):
   thm
val isinv_def =
   {(A : set), (e : mem(A)), (i : fun(A, A)), (m : fun(A * A, A))}, 
   |- isinv(m, i, e) <=>
      !(a : mem(A)). mul(m, App(i, a#), a#) = e & mul(m, a#, App(i, a#)) = e:
   thm
val isunit_def =
   {(A : set), (e : mem(A)), (m : fun(A * A, A))}, 
   |- isunit(m, e) <=> !(a : mem(A)). mul(m, e, a#) = a# & mul(m, a#, e) = a#:
   thm
val mul_def =
   {(G : set), (g1 : mem(G)), (g2 : mem(G)), (m : fun(G * G, G))}, 
   |- mul(m, g1, g2) = App(m, Pair(g1, g2)): thm
val Rnsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rnsg(g#)): thm
val eof_def = {(G : set), (g : mem(Grp(G)))},  |- eof(g) = c33(RepG(g)): thm
val ginv_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G))}, 
   |- ginv(g, x) = App(iof(g), x): thm
val gmul_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G)), (y : mem(G))}, 
   |- gmul(g, x, y) = mul(mof(g), x, y): thm
val iof_def = {(G : set), (g : mem(Grp(G)))},  |- iof(g) = tof(c32(RepG(g))):
   thm
val isghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (f : fun(G1#, G2#))
      (g2 : mem(Grp(G2#))).
        isghom(f#, g1#, g2#) <=>
        !(a : mem(G1#))  (b : mem(G1#)).
          App(f#, gmul(g1#, a#, b#)) = gmul(g2#, App(f#, a#), App(f#, b#)):
   thm
val isnml_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(sgrp(g)))}, 
   |- isnml(h) <=> !(a : mem(G)). rcs(h, a#) = lcs(a#, h): thm
val issgrp_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(Pow(G)))}, 
   |- issgrp(h, g) <=>
      IN(eof(g), h) &
      (!(a : mem(G))  (b : mem(G)).
          IN(a#, h) & IN(b#, h) ==> IN(gmul(g, a#, b#), h)) &
      !(a : mem(G)). IN(a#, h) ==> IN(ginv(g, a#), h): thm
val lcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, lcs(a, H)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, a, h#): thm
val lsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (x : mem(G#))
      (a : mem(G#)).
        IN(a#, lsmul(g#, x#, s#)) <=>
        ?(y : mem(G#)). IN(y#, s#) & a# = gmul(g#, x#, y#): thm
val mof_def = {(G : set), (g : mem(Grp(G)))},  |- mof(g) = tof(c31(RepG(g))):
   thm
val nsg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(sgrp(g))).
        (?(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#) <=>
        ?!(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#: thm
val nsg_uex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(sgrp(g#))).
        isnml(a#) ==> ?!(a : mem(nsgrp(g#))). App(Rnsg(g#), a#) = a#: thm
val nsgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))).
        Inj(Rnsg(g#)) &
        !(a : mem(sgrp(g#))).
          isnml(a#) <=> ?(b : mem(nsgrp(g#))). a# = App(Rnsg(g#), b#): thm
val rcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, rcs(H, a)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, h#, a): thm
val rcs_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        rcs(H#, a#) = rsmul(g#, rsg(H#), a#): thm
val rsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        rsg(H#) = App(Rsg(g#), H#): thm
val rsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (y : mem(G#))
      (a : mem(G#)).
        IN(a#, rsmul(g#, s#, y#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = gmul(g#, x#, y#): thm
val sgrp_def =
   {(G : set), (g : mem(Grp(G)))}, 
   |- Inj(Rsg(g)) &
      !(a : mem(Pow(G))).
        issgrp(a#, g) <=> ?(b : mem(sgrp(g))). a# = App(Rsg(g), b#): thm
val lcs_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        lcs(a#, H#) = lsmul(g#, a#, rsg(H#)): thm
val Rsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rsg(g#)): thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val sg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(Pow(G))).
        (?(a : mem(sgrp(g))). App(Rsg(g), a#) = b#) <=>
        ?!(a : mem(sgrp(g))). App(Rsg(g), a#) = b#: thm
val sg_uex =
   {}, 
   |- !(G : set)  (a : mem(Pow(G#)))  (g : mem(Grp(G#))).
        issgrp(a#, g#) ==> ?!(a : mem(sgrp(g#))). App(Rsg(g#), a#) = a#: thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val gmul_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, ginv(g#, a#), a#) = eof(g#) &
        gmul(g#, a#, ginv(g#, a#)) = eof(g#): thm
val asc_mof = {},  |- !(G : set)  (g : mem(Grp(G#))). asc(mof(g#)): thm
val gmul_assoc =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (c : mem(G#)).
        gmul(g#, gmul(g#, a#, b#), c#) = gmul(g#, a#, gmul(g#, b#, c#)): thm
val gmul_lcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, x#, y#) = gmul(g#, x#, z#) <=> y# = z#: thm
val gmul_rcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, y#, x#) = gmul(g#, z#, x#) <=> y# = z#: thm
val is_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        a1# = ginv(g#, a#) <=>
        gmul(g#, a#, a1#) = eof(g#) | gmul(g#, a1#, a#) = eof(g#): thm
val ginv_e =
   {},  |- !(G : set)  (g : mem(Grp(G#))). ginv(g#, eof(g#)) = eof(g#): thm
val e_sgrp =
   {},  |- !(G : set)  (g : mem(Grp(G#))). issgrp(Sing(eof(g#)), g#): thm
val esg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))). App(Rsg(g#), esg(g#)) = Sing(eof(g#)):
   thm
val rsg_esg =
   {},  |- !(G : set)  (g : mem(Grp(G#))). rsg(esg(g#)) = Sing(eof(g#)): thm
val e_nsgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isnml(esg(g#)): thm
val ensg_def =
   {},  |- !(G : set)  (g : mem(Grp(G#))). App(Rnsg(g#), ensg(g#)) = esg(g#):
   thm
val nsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(sgrp(g#))).
        nsg(h#) = App(LINV(Rnsg(g#), ensg(g#)), h#): thm
val qgR_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        Holds(qgR(H#), a#, b#) <=> lcs(a#, rnsg(H#)) = lcs(b#, rnsg(H#)): thm
val rnsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rnsg(H#) = App(Rnsg(g#), H#): thm
val qgR_Refl =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Refl(qgR(H#)):
   thm
val qgR_Sym =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Sym(qgR(H#)):
   thm
val qgR_Trans =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Trans(qgR(H#)):
   thm
val qgR_ER =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). ER(qgR(H#)):
   thm
val css_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Inj(Rcss(H#)) &
        !(a : mem(Pow(G#))).
          (?(a : mem(G#)). a# = rsi(qgR(H#), a#)) <=>
          ?(b : mem(css(H#))). a# = App(Rcss(H#), b#): thm
val Rcss_Inj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Inj(Rcss(H#)):
   thm
val rcss_def =
   {(G : set), (H : mem(nsgrp(g))), (cs : mem(css(H))), (g : mem(Grp(G)))}, 
   |- rcss(cs) = App(Rcss(H), cs): thm
val rcss_eq_eq =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (a : mem(css(H#)))  (b : mem(css(H#))). rcss(a#) = rcss(b#) <=> a# = b#:
   thm
val mem_css_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ?!(a : mem(css(H#))). rcss(a#) = rsi(qgR(H#), eof(g#)): thm
val Quot_qgR_Rcss =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(qgR(H#), Rcss(H#)): thm
val cs_def =
   {}, 
   |- !(G : set)  (a : mem(G#))  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        cs(a#, H#) = abs(qgR(H#), Rcss(H#), ecs(H#), a#): thm
val ecs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rcss(ecs(H#)) = rsi(qgR(H#), eof(g#)): thm
val rcss_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcss(cs(a#, H#)) = rsi(qgR(H#), a#): thm
val nsgrp_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val nsgrp_swap_l2r =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, a#, h#) = gmul(g#, h#, a#): thm
val smul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, smul(g#, s1#, s2#)) <=>
        ?(x : mem(G#))  (y : mem(G#)).
          IN(x#, s1#) & IN(y#, s2#) & a# = gmul(g#, x#, y#): thm
val nsgrp_swap_r2l =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, h#, a#) = gmul(g#, a#, h#): thm
val rsg_issgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        issgrp(rsg(H#), g#): thm
val e_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        IN(eof(g#), rsg(H#)): thm
val gmul_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h1 : mem(G#)).
        IN(h1#, rsg(H#)) ==>
        !(h2 : mem(G#)). IN(h2#, rsg(H#)) ==> IN(gmul(g#, h1#, h2#), rsg(H#)):
   thm
val ginv_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(H#)) ==> IN(ginv(g#, h#), rsg(H#)): thm
val gmul_lcs_smul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        lcs(gmul(g#, a#, b#), rnsg(H#)) =
          smul(g#, lcs(a#, rnsg(H#)), lcs(b#, rnsg(H#))): thm
val mof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o mof(g#),
       prrel(qgR(H#), qgR(H#))): thm
val prrel_qgR_ER =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ER(prrel(qgR(H#), qgR(H#))): thm
val qgR_Rcss_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#))): thm
val qgR_Rcss_abs_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        abs(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#)),
           Pair(ecs(H#), ecs(H#)), Pair(a#, b#)) =
          Pair(abs(qgR(H#), Rcss(H#), ecs(H#), a#),
           abs(qgR(H#), Rcss(H#), ecs(H#), b#)): thm
val ginv_oneside =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        gmul(g#, a#, a1#) = eof(g#) <=> gmul(g#, a1#, a#) = eof(g#): thm
val mulcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        mul(mulcs(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val sinv_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, sinv(g#, s#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = ginv(g#, x#): thm
val is_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        a# = eof(g#) <=>
        (?(x : mem(G#)). gmul(g#, a#, x#) = x#) |
        ?(x : mem(G#)). gmul(g#, x#, a#) = x#: thm
val ginv_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#)).
        ginv(g#, gmul(g#, a#, b#)) = gmul(g#, ginv(g#, b#), ginv(g#, a#)):
   thm
val ginv_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        ginv(g#, ginv(g#, a#)) = a#: thm
val ginv_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        lcs(ginv(g#, a#), rnsg(H#)) = sinv(g#, lcs(a#, rnsg(H#))): thm
val iof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o iof(g#), qgR(H#)): thm
val invcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(invcs(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_Surj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Surj(qmap(H#)):
   thm
val qmap_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qmap(H#) = Abs(qgR(H#), Rcss(H#), ecs(H#)): thm
val css_rep_ex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (b : mem(css(H#))). ?(a : mem(G#)). b# = cs(a#, H#): thm
val ecs_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ecs(H#) = cs(eof(g#), H#): thm
val mulcs_invcs_ecs_isgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isgrp(Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#)))): thm
val mof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        mof(qgrp(H#)) = mulcs(H#): thm
val qgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        RepG(qgrp(H#)) = Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#))):
   thm
val iof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        iof(qgrp(H#)) = invcs(H#): thm
val eof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        eof(qgrp(H#)) = ecs(H#): thm
val gmul_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        gmul(qgrp(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val ginv_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : set). ginv(qgrp(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(qmap(H#), a#) = cs(a#, H#): thm
val qmap_isghom =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isghom(qmap(H#), g#, qgrp(H#)): thm
val constf_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        isghom(constf(G1#, eof(g2#)), g1#, g2#): thm
val ghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)) &
        !(a : mem(Exp(G1#, G2#))).
          isghom(tof(a#), g1#, g2#) <=>
          ?(b : mem(ghom(g1#, g2#))). a# = App(ih(g1#, g2#), b#): thm
val ghom_ex_uex =
   {(G1 : set), (G2 : set), (g1 : mem(Grp(G1))), (g2 : mem(Grp(G2)))}, 
   |- !(b : mem(Exp(G1, G2))).
        (?(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#) <=>
        ?!(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#: thm
val ghom_uex =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (a : mem(Exp(G1#, G2#))).
        isghom(tof(a#), g1#, g2#) ==>
        ?!(a : mem(ghom(g1#, g2#))). App(ih(g1#, g2#), a#) = a#: thm
val ih_Inj =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)): thm
val eghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        App(ih(g1#, g2#), eghm(g1#, g2#)) = Tpm(constf(G1#, eof(g2#))): thm
val ghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : fun(G1#, G2#)).
        ghm(h#, g1#, g2#) = App(LINV(ih(g1#, g2#), eghm(g1#, g2#)), Tpm(h#)):
   thm
val homfun_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : mem(ghom(g1#, g2#))). homfun(h#) = tof(App(ih(g1#, g2#), h#)): thm
val isghom_homfun_ghm =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : fun(G1#, G2#)).
        isghom(f#, g1#, g2#) <=> homfun(ghm(f#, g1#, g2#)) = f#: thm
val IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#)).
        IN(x#, kers(f#)) <=> App(homfun(f#), x#) = eof(g2#): thm
val ker_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). ker(f#) = nsg(sg(kers(f#), g1#)): thm
val kers_def =
   {(G1 : set), (G2 : set), (f : mem(ghom(g1, g2))), (g1 : mem(Grp(G1))),
    (g2 : mem(Grp(G2)))},  |- kers(f) = PREIM(homfun(f), Sing(eof(g2))): thm
val sg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(Pow(G#))).
        sg(h#, g#) = App(LINV(Rsg(g#), esg(g#)), h#): thm
val homfun_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isghom(homfun(f#), g1#, g2#): thm
val homfun_gmul =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#))  (y : mem(G1#)).
        App(homfun(f#), gmul(g1#, x#, y#)) =
          gmul(g2#, App(homfun(f#), x#), App(homfun(f#), y#)): thm
val homfun_e =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). App(homfun(f#), eof(g1#)) = eof(g2#): thm
val homfun_ginv =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a : mem(G1#)).
        App(homfun(f#), ginv(g1#, a#)) = ginv(g2#, App(homfun(f#), a#)): thm
val e_IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). IN(eof(g1#), kers(f#)): thm
val kers_issgrp =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). issgrp(kers(f#), g1#): thm
val cjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (h : mem(G))}, 
   |- cjg(g, a, h) = gmul(g, a, gmul(g, h, ginv(g, a))): thm
val lsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (s : mem(Pow(G#))).
        lsmul(g#, a#, lsmul(g#, b#, s#)) = lsmul(g#, gmul(g#, a#, b#), s#):
   thm
val qhom_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qhom(H#) = ghm(qmap(H#), g#, qgrp(H#)): thm
val rsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        rsmul(g#, rsmul(g#, s#, a#), b#) = rsmul(g#, s#, gmul(g#, a#, b#)):
   thm
val lsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        lsmul(g#, eof(g#), s#) = s#: thm
val rsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        rsmul(g#, s#, eof(g#)) = s#: thm
val lsmul_rsmul_comm =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#)))
      (b : mem(G#)).
        rsmul(g#, lsmul(g#, a#, s#), b#) = lsmul(g#, a#, rsmul(g#, s#, b#)):
   thm
val isnml_alt =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). scjg(g#, a#, rsg(H#)) = rsg(H#): thm
val scjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (s : mem(Pow(G)))}, 
   |- scjg(g, a, s) = lsmul(g, a, rsmul(g, s, ginv(g, a))): thm
val scjg_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (H : mem(Pow(G#)))
      (x : mem(G#)).
        IN(x#, scjg(g#, a#, H#)) <=>
        ?(h : mem(G#)). IN(h#, H#) & x# = cjg(g#, a#, h#): thm
val SS_scjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#))).
        SS(scjg(g#, a#, s#), s#) <=>
        !(x : mem(G#)). IN(x#, s#) ==> IN(cjg(g#, a#, x#), s#): thm
val SS_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(rsmul(g#, s1#, a#), rsmul(g#, s2#, a#)): thm
val SS_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val isnml_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). SS(scjg(g#, a#, rsg(H#)), rsg(H#)): thm
val IN_gmul_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, H#) <=>
        !(b : mem(G#)). IN(gmul(g#, a#, b#), rsmul(g#, H#, b#)): thm
val IN_gmul_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (b : mem(G#)).
        IN(b#, H#) <=>
        !(a : mem(G#)). IN(gmul(g#, a#, b#), lsmul(g#, a#, H#)): thm
val gmul_IN_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val gmul_IN_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val rnsg_isnml =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). isnml(rnsg(H#)):
   thm
val rnsg_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val SS_ex_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        ?(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val same_cs_cond =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        cs(a#, H#) = cs(b#, H#) <=>
        IN(gmul(g#, a#, ginv(g#, b#)), rsg(rnsg(H#))): thm
val sg_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        sg(rsg(H#), g#) = H#: thm
val nsg_rnsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        nsg(rnsg(H#)) = H#: thm
val issgrp_rsg_sg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#))).
        issgrp(H#, g#) <=> rsg(sg(H#, g#)) = H#: thm
val isnml_rnsg_nsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> rnsg(nsg(H#)) = H#: thm
val sg_kers_isnml =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isnml(sg(kers(f#), g1#)): thm
val rsg_rnsg_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rsg(rnsg(ker(f#))) = kers(f#): thm
val rgh_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rgh(f#) = App(ih(g1#, g2#), f#): thm
val rgh_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        rgh(f1#) = rgh(f2#) <=> f1# = f2#: thm
val homfun_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        homfun(f1#) = homfun(f2#) <=> f1# = f2#: thm
val homfun_eq_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a1 : mem(G1#))  (a2 : mem(G1#)).
        App(homfun(f#), a1#) = App(homfun(f#), a2#) <=>
        App(homfun(f#), gmul(g1#, ginv(g1#, a1#), a2#)) = eof(g2#): thm
val homfun_resp1_qgR_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). resp1(homfun(f#), qgR(ker(f#))): thm
val first_iso_thm =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))).
        ?!(fb : mem(ghom(qgrp(ker(f#)), g2#))).
          Inj(homfun(fb#)) & homfun(fb#) o qmap(ker(f#)) = homfun(f#): thm
val it = (): unit
******

Loading SEAR file SEARexamplecol.sml

******
val AX5 =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
val cardeq_REFL = {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, s#): thm
val cardeq_def =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=>
      ?(R : rel(A, B)).
        (!(a : mem(A)).
            IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R#, a#, b#)) &
        !(b : mem(B)).
          IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R#, a#, b#): thm
val isset_def =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
val cardeq_SYM =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(s2#, s1#): thm
val cardeq_TRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#))).
          cardeq(s2#, s3#) ==> cardeq(s1#, s3#): thm
val restrict_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (R : rel(A#, B#))
      (s2 : mem(Pow(B#)))  (a : mem(A#))  (b : mem(B#)).
        Holds(restrict(R#, s1#, s2#), a#, b#) <=>
        IN(a#, s1#) & IN(b#, s2#) & Holds(R#, a#, b#): thm
val cardeq_Whole_Inj_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set).
        cardeq(s#, Whole(B#)) ==>
        ?(i : fun(B#, A#)). Inj(i#) & IMAGE(i#, Whole(B#)) = s#: thm
val cardeq_Inj_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> cardeq(Whole(A#), IMAGE(f#, Whole(A#))): thm
val Inj_Image =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Inj(f#) ==> Inj(Image(f#)):
   thm
val IMAGE_INJ_cardeq =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#)))
      (f : fun(A#, B#)).
        INJ(f#, s1#, s2#) ==>
        !(s01 : mem(Pow(A#))).
          SS(s01#, s1#) ==> cardeq(s01#, IMAGE(f#, s01#)): thm
val INJ_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (t : mem(Pow(B#))).
        INJ(f#, s#, t#) <=>
        (!(x : mem(A#)). IN(x#, s#) ==> IN(App(f#, x#), t#)) &
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==> App(f#, x#) = App(f#, y#) ==> x# = y#:
   thm
val Inj_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). INJ(f#, s#, IMAGE(f#, s#)): thm
val INJ_SS_dom =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(A#))). SS(s#, s1#) ==> INJ(f#, s#, s2#): thm
val INJ_SS_cod =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(B#))). SS(s2#, s#) ==> INJ(f#, s1#, s#): thm
val o_INJ_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(C : set)  (g : fun(B#, C#))  (s3 : mem(Pow(C#))).
          INJ(g#, s2#, s3#) ==> INJ(g# o f#, s1#, s3#): thm
val cardeq_Inj_IMAGE_gen =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). cardeq(s#, IMAGE(f#, s#)): thm
val INJ_INS_NONE =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X# + 1)))).
        (!(s0 : mem(Pow(X# + 1))). IN(s0#, s#) ==> ~IN(NONE(X#), s0#)) ==>
        INJ(INS(NONE(X#)), s#, IMAGE(INS(NONE(X#)), s#)): thm
val INS_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (a : mem(Pow(X#))).
        App(INS(x0#), a#) = Ins(x0#, a#): thm
val POW_Whole_Pow = {},  |- !(A : set). POW(Whole(A#)) = Whole(Pow(A#)): thm
val POW_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (a : mem(Pow(A#))).
        IN(a#, POW(s0#)) <=> SS(a#, s0#): thm
val cardeq_POW_Whole_Pow =
   {},  |- !(A : set). cardeq(POW(Whole(A#)), Whole(Pow(A#))): thm
val FIB_constf =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#)).
        FIB(constf(A#, b#), b#) = Whole(A#): thm
val nPow_def =
   {}, 
   |- !(A : set)  (B : set)  (n : mem(N)).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)).
          cardeq(FIB(f#, O), Whole(A#)) &
          cardeq(FIB(f#, n#), Whole(B#)) &
          !(n0 : mem(N)).
            Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPow_O = {},  |- !(A : set). nPow(O, A#, A#): thm
val OE_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- OE(f, b0) = coPa(f, El(b0)): thm
val Sg_Sing = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Sgf_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- (!(a : mem(A)). App(Sgf(f, b0), Sing(a#)) = App(f, a#)) &
      !(s : mem(Pow(A))).
        (!(a : mem(A)). ~s# = Sing(a#)) ==> App(Sgf(f, b0), s#) = b0: thm
val content_Sing =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        App(content(x0#), Sing(x#)) = x#: thm
val content_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#)).
        (!(s : mem(Pow(X#)))  (x : mem(X#)).
            s# = Sing(x#) ==> App(content(x0#), s#) = x#) &
        !(s : mem(Pow(X#))).
          (!(x : mem(X#)). ~s# = Sing(x#)) ==> App(content(x0#), s#) = x0#:
   thm
val ctt_def =
   {}, 
   |- !(X : set)  (s : mem(Pow(X#)))  (x0 : mem(X#)).
        ctt(s#, x0#) = App(content(x0#), s#): thm
val PREIM_i1_Sing_SOME =
   {(X : set), (x0 : mem(X))},  |- PREIM(i1(X, 1), Sing(SOME(x0))) = Sing(x0):
   thm
val IMAGE_Sing =
   {(A : set), (B : set), (a : mem(A)), (f : fun(A, B))}, 
   |- IMAGE(f, Sing(a)) = Sing(App(f, a)): thm
val ctt_Sing =
   {},  |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)). ctt(Sing(a#), a0#) = a#:
   thm
val Sing_SOME_NEQ_Ins_NONE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A# + 1))).
        ~Sing(SOME(a#)) = Ins(NONE(A#), s#): thm
val SS_Ri_restrict =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (a : mem(Pow(A#)))  (B : set)
      (R : rel(A#, B#))  (s2 : mem(Pow(B#))).
        SS(App(Ri(restrict(R#, s1#, s2#)), a#), s2#): thm
val biunique_def =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) <=>
      (!(a : mem(A)).
          IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R, a#, b#)) &
      !(b : mem(B)).
        IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R, a#, b#): thm
val nPow_Suc_ex_lemma =
   {}, 
   |- !(C : set)  (X : set)  (i : fun(C#, Pow(X#))).
        Inj(i#) ==>
        !(B : set)  (f : fun(X#, B#))  (bs : mem(Pow(B#)))  (b0 : mem(B#)).
          (!(x : mem(X#)). ~App(f#, x#) = b0#) ==>
          ~IN(b0#, bs#) ==>
          !(b1 : mem(B#)).
            ~b1# = b0# & ~IN(b1#, bs#) ==>
            ?(f1 : fun(Pow(X# + 1), B#)).
              (!(b : mem(B#)).
                  IN(b#, bs#) ==>
                  FIB(f1#, b#) = IMAGE(Sg(X# + 1) o i1(X#, 1), FIB(f#, b#))) &
              FIB(f1#, b0#) =
                IMAGE(INS(NONE(X#)) o Image(i1(X#, 1)) o i#, Whole(C#)): thm
val biunique_op =
   {(A : set), (B : set)}, 
   |- !(R : rel(A, B))  (s1 : mem(Pow(A)))  (s2 : mem(Pow(B))).
        biunique(R#, s1#, s2#) ==> biunique(op(R#), s2#, s1#): thm
val biunique_Ri_restrict =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) ==>
      !(s : mem(Pow(A))).
        SS(s#, s1) ==>
        App(Ri(restrict(op(R), s2, s1)), App(Ri(restrict(R, s1, s2)), s#)) =
          s#: thm
val cardeq_POW =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(POW(s1#), POW(s2#)): thm
val cardeq_biunique =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=> ?(R : rel(A, B)). biunique(R#, s1, s2): thm
val cardeq_BITRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#)))  (D : set)  (s4 : mem(Pow(D#))).
          cardeq(s3#, s4#) ==> (cardeq(s1#, s3#) <=> cardeq(s2#, s4#)): thm
val NONE_NOTIN_IMAGE_i1 =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X#))))  (s0 : mem(Pow(X# + 1))).
        IN(s0#, IMAGE(Image(i1(X#, 1)), s#)) ==> ~IN(NONE(X#), s0#): thm
val shrink_IMAGE =
   {}, 
   |- !(X : set)  (B : set)  (f0 : fun(X#, B#))  (s : mem(Pow(B#)))
      (b0 : mem(B#)).
        ~IN(b0#, s#) ==>
        (!(b : mem(B#)).
            IN(b#, s#) ==> FIB(shrink(f0#, s#, b0#), b#) = FIB(f0#, b#)) &
        !(x : mem(X#)).
          ~IN(App(f0#, x#), s#) ==> App(shrink(f0#, s#, b0#), x#) = b0#: thm
val shrink_def =
   {(B : set), (X : set), (b0 : mem(B)), (f0 : fun(X, B)), (s : mem(Pow(B)))},
   
   |- !(a : mem(X)).
        (IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = App(f0, a#)) &
        (~IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = b0): thm
val nPow_shrink_IMAGE_ex =
   {(A : set), (An : set), (n : mem(N))}, 
   |- nPow(n, A, An) ==>
      ?(X : set)  (f : fun(X#, N)).
        cardeq(FIB(f#, O), Whole(A)) &
        cardeq(FIB(f#, n), Whole(An)) &
        (!(n0 : mem(N)).
            Lt(n0#, n) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#)))) &
        !(x : mem(X#)). ~App(f#, x#) = Suc(n): thm
val nPow_Suc =
   {(n : mem(N))}, 
   |- !(A : set)  (An : set). nPow(n, A#, An#) ==> nPow(Suc(n), A#, Pow(An#)):
   thm
val nPow_ex =
   {},  |- !(A : set)  (n : mem(N)). ?(An : set). nPow(n#, A#, An#): thm
val cardeq_m2s =
   {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, Whole(m2s(s#))): thm
val m2s_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Inj(minc(s#)) &
        !(a : mem(A#)).
          IN(a#, s#) <=> ?(b : mem(m2s(s#))). a# = App(minc(s#), b#): thm
val nPowf_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, N))  (n : mem(N)).
        nPowf(n#, A#, B#, f#) <=>
        cardeq(FIB(f#, O), Whole(A#)) &
        cardeq(FIB(f#, n#), Whole(B#)) &
        !(n0 : mem(N)).
          Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPowf_Preds =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> ?(B0 : set). nPowf(n0#, A#, B0#, f#):
   thm
val nPowf_Preds_FIB =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> nPowf(n0#, A#, m2s(FIB(f#, n0#)), f#):
   thm
val nPow_nPowf =
   {}, 
   |- !(A : set)  (n : mem(N))  (B : set).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)). nPowf(n#, A#, B#, f#): thm
val nPow_unique =
   {}, 
   |- !(A : set)  (n : mem(N))  (An1 : set)  (An2 : set).
        nPow(n#, A#, An1#) & nPow(n#, A#, An2#) ==>
        cardeq(Whole(An1#), Whole(An2#)): thm
val nPow_uex =
   {}, 
   |- !(A : set)  (n : mem(N)).
        ?(An : set).
          nPow(n#, A#, An#) &
          !(An1 : set).
            nPow(n#, A#, An1#) ==> cardeq(Whole(An#), Whole(An1#)): thm
val Pn_def = {},  |- !(A : set)  (n : mem(N)). nPow(n#, A#, Pn(A#, n#)): thm
val cardeq_Whole_REFL = {},  |- !(An : set). cardeq(Whole(An#), Whole(An#)):
   thm
val cardeq_Whole_SYM =
   {}, 
   |- !(An : set)  (An' : set).
        cardeq(Whole(An#), Whole(An'#)) ==> cardeq(Whole(An'#), Whole(An#)):
   thm
val cardeq_Whole_TRANS =
   {}, 
   |- !(An : set)  (An' : set)  (An'' : set).
        cardeq(Whole(An#), Whole(An'#)) & cardeq(Whole(An'#), Whole(An''#)) ==>
        cardeq(Whole(An#), Whole(An''#)): thm
val isset_minc = {},  |- !(A : set)  (s : mem(Pow(A#))). isset(minc(s#), s#):
   thm
val large_ex =
   {}, 
   |- !(A : set).
        ?(P : set). !(n : mem(N)). ?(i : fun(Pn(A#, n#), P#)). Inj(i#): thm
val nPow_ts_ex = {},  |- !(A : set)  (n : mem(N)). ?(An : set). T: thm
val it = (): unit
val it = (): unit
> # # # # # # # val isset_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (A0 : set)
      (i : fun(A0#, A#))  (b : mem(B#)).
        isset(i#, FIB(f#, b#)) ==> f# o i# = constf(A0#, b#): thm
> > val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
               ?(V : set)  (p : fun(V#, U)).
                 Surj(p#) &
                 ?(A : set)  (fa : fun(A#, V#)).
                   !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                     isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol3kLDXgScript.sml

******
Exception-
   ERR
     ("exists_tac.goal is not an existential", [], [],
      [Pred ("=", true, [App((p1(B, Y) o inc) o i, x1), a'])]) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holmNiTfiScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holgtsJrnScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.constf(vA, v) = p1(B, Y) o inc o i
   ----------------------------------------------------------------------
   App((p1(B, Y) o inc) o i, x1) = a'
   : proofmanager.proof
val it = (): unit
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holEaHFA6Script.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
val it = (): unit
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holIQJ9kcScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holdW1D1EScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.constf(vA, v) = p1(B, Y) o inc o i
   ----------------------------------------------------------------------
   App((p1(B, Y) o inc) o i, x1) = a'
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holCHVmjPScript.sml

******
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holCHVmjPScript.sml:22: error: ) expected but end was found
Exception- Fail "Static Errors" raised
> val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holFZzrluScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holIXF25OScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.constf(vA, v) = p1(B, Y) o inc o i
   ----------------------------------------------------------------------
   App((p1(B, Y) o inc) o i, x1) = a'
   : proofmanager.proof
val it = (): unit
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holsvhzGWScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.Inj(i)
   9.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   10.App(inc, App(i, x1)) = Pair(a, b)
   11.App(inc, App(i, x2)) = Pair(a', b')
   12.a = Fst(App(inc, App(i, x1)))
   13.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   p1(B, Y) o inc o i = constf(vA, v) ==> Fst(App(inc, App(i, x1))) = a'
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Process HOL killed: 9
> Loading empty hol-mode.sml
> > > use "SEARmaster.ML";
val use = fn: string -> unit
******

Loading SEAR file SEARsorts.sml

******
val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = set: sort
val it = (): unit
******

Loading SEAR file SEARnewspec.sml

******
val define_fsym = fn: string * (string * sort) list -> term -> thm
val define_fsym_lemma_fun =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : fun(A#, B#)).
        ?!(newfsym : fun(A#, B#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_mem =
   {}, 
   |- !(A : set)  (newfsym0 : mem(A#)).
        ?!(newfsym : mem(A#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_rel =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : rel(A#, B#)).
        ?!(newfsym : rel(A#, B#)). newfsym# = newfsym0#: thm
val funeqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : fun(A#, B#)). i# = i#) &
        (!(i : fun(A#, B#))  (i' : fun(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : fun(A#, B#))  (i' : fun(A#, B#))  (i'' : fun(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val memeqeqvth =
   {}, 
   |- !(A : set).
        (!(i : mem(A#)). i# = i#) &
        (!(i : mem(A#))  (i' : mem(A#)). i# = i'# ==> i'# = i#) &
        !(i : mem(A#))  (i' : mem(A#))  (i'' : mem(A#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val qdefine_fsym = fn: string * term frag list list -> term frag list -> thm
val qsimple_uex_spec = fn: string -> term frag list list -> thm -> thm
val quex_spec = fn: string -> term frag list list -> thm -> thm -> thm
val releqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : rel(A#, B#)). i# = i#) &
        (!(i : rel(A#, B#))  (i' : rel(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : rel(A#, B#))  (i' : rel(A#, B#))  (i'' : rel(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val simple_uex_spec = fn: string -> (string * sort) list -> thm -> thm
val uex_spec = fn: string -> (string * sort) list -> thm -> thm -> thm
val it = (): unit
******

Loading SEAR file SEARrel.sml

******
val AX1 =
   {}, 
   |- !(A : set)  (B : set).
        ?!(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val Fun_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=> !(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#): thm
val R_EXT =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        (!(a : mem(A#))  (b : mem(B#)).
            Holds(R1#, a#, b#) <=> Holds(R2#, a#, b#)) <=> R1# = R2#: thm
val AX1_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val ao_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, c#)) <=>
        Holds(psi# @ phi#, a#, c#): thm
val ao_def0 =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (b : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, b#)) <=>
        Holds(psi# @ phi#, a#, b#): thm
val ao_uex =
   {(A : set), (B : set), (C : set), (phi : rel(A, B)), (psi : rel(B, C))}, 
   |- ?!(R : rel(A, C)).
        !(a : mem(A))  (b : mem(C)).
          Holds(R#, a#, b#) <=>
          ?(b : mem(B)). Holds(phi, a#, b#) & Holds(psi, b#, b#): thm
val Fun_expand =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=>
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) &
        !(a : mem(A#))  (b1 : mem(B#))  (b2 : mem(B#)).
          Holds(R#, a#, b1#) & Holds(R#, a#, b2#) ==> b1# = b2#: thm
val id_Fun = {},  |- !(A : set). isFun(id(A#)): thm
val id_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)).
        Holds(id(A#), a#, b#) <=> a# = b#: thm
val id_uex =
   {(A : set)}, 
   |- ?!(R : rel(A, A)).
        !(a : mem(A))  (b : mem(A)). Holds(R#, a#, b#) <=> a# = b#: thm
val idL = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). id(B#) @ f# = f#:
   thm
val idR = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). f# @ id(A#) = f#:
   thm
val Thm_2_7_ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val Thm_2_7_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val Thm_2_7_id =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#)).
        phi# @ id(A#) = phi# & id(B#) @ phi# = phi#: thm
val op_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(B#))  (b : mem(A#)).
        Holds(op(R#), a#, b#) <=> Holds(R#, b#, a#): thm
val op_uex =
   {(A : set), (B : set), (R : rel(A, B))}, 
   |- ?!(R' : rel(B, A)).
        !(a : mem(B))  (b : mem(A)). Holds(R'#, a#, b#) <=> Holds(R, b#, a#):
   thm
val ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val ao_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val op_DISTR =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#)). op(psi# @ phi#) = op(phi#) @ op(psi#): thm
val Refl_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> !(a : mem(A#)). Holds(R#, a#, a#): thm
val Sym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> Holds(R#, a2#, a1#): thm
val Trans_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Trans(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#))  (a3 : mem(A#)).
          Holds(R#, a1#, a2#) & Holds(R#, a2#, a3#) ==> Holds(R#, a1#, a3#):
   thm
val ER_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) <=> Refl(R#) & Sym(R#) & Trans(R#): thm
val Sym_Trans_Rright =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) & Trans(R#) ==>
        !(x : mem(A#))  (y : mem(A#)).
          Holds(R#, x#, y#) ==>
          !(z : mem(A#)). Holds(R#, x#, z#) <=> Holds(R#, y#, z#): thm
val op_op =
   {},  |- !(A : set)  (B : set)  (R : rel(A#, B#)). op(op(R#)) = R#: thm
val it = (): unit
******

Loading SEAR file SEARfun.sml

******
val rel2fun =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val rel2fun_ex =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val rel2fun_ex' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val asR_Fun =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). isFun(asR(f#)): thm
val asR_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- !(a : mem(A))  (b : mem(B)). Holds(asR(f), a#, b#) <=> App(f, a#) = b#:
   thm
val asR_uex =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- ?!(R : rel(A, B)).
        !(a : mem(A))  (b : mem(B)). Holds(R#, a#, b#) <=> App(f, a#) = b#:
   thm
val FUN_EXT =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        (!(a : mem(A#)). App(f1#, a#) = App(f2#, a#)) <=> f1# = f2#: thm
val P2fun_uex =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val fun_tm_compr = fn: string * sort -> term -> thm
val fun_tm_compr_uex = fn: string * sort -> term -> thm
val qfun_compr = fn: term frag list -> term frag list -> thm
val unique_lemma =
   {},  |- !(A : set)  (a : mem(A#)). ?!(a' : mem(A#)). a'# = a#: thm
val App_Id = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_def = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_uex =
   {(A : set)}, 
   |- ?!(f : fun(A, A)).
        !(a : mem(A))  (b : mem(A)).
          App(f#, a#) = b# <=> Holds(id(A), a#, b#): thm
val o_ex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val o_uex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?!(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val Inj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) <=>
        !(x1 : mem(A#))  (x2 : mem(A#)).
          App(f#, x1#) = App(f#, x2#) ==> x1# = x2#: thm
val o_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        App(psi# o phi#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#):
   thm
val Surj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) <=> !(b : mem(B#)). ?(a : mem(A#)). App(f#, a#) = b#: thm
val Bij_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> Inj(f#) & Surj(f#): thm
val Bij_op =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> ?(f' : fun(B#, A#)). asR(f'#) = op(asR(f#)): thm
val App_App_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val App_o_l =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val asR_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        asR(g# o f#) = asR(g#) @ asR(f#): thm
val asR_Id = {},  |- !(A : set). asR(Id(A#)) = id(A#): thm
val asR_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        asR(f1#) = asR(f2#) <=> f1# = f2#: thm
val Thm_2_7_bij =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#)).
        Bij(phi#) <=>
        ?(psi : fun(B#, A#)). psi# o phi# = Id(A#) & phi# o psi# = Id(B#):
   thm
val Inj_lcancel =
   {}, 
   |- !(A : set)  (B : set)  (m : fun(A#, B#)).
        Inj(m#) ==>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, A#)).
          m# o f# = m# o g# ==> f# = g#: thm
val IdL = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Id(B#) o f# = f#:
   thm
val IdR = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). f# o Id(A#) = f#:
   thm
val Inj_lift_R_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(R : rel(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?!(a2 : mem(A#)). Holds(R#, App(i#, a1#), App(i#, a2#))) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). Holds(R#, App(i#, a#), App(i# o f#, a#)): thm
val Inj_lift_fun_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val asR_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        Holds(asR(f#), a#, b#) <=> App(f#, a#) = b#: thm
val Inj_lift_fun_lemma' =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?!(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val Inj_eq_eq =
   {}, 
   |- !(X : set)  (Y : set)  (i : fun(X#, Y#)).
        Inj(i#) ==>
        !(x1 : mem(X#))  (x2 : mem(X#)).
          App(i#, x1#) = App(i#, x2#) <=> x1# = x2#: thm
val Inj_lift_fun =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?(f : fun(X#, A#)). !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#):
   thm
val Inj_lift_fun_uex =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?!(f : fun(X#, A#)).
            !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#): thm
val o_assoc =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (D : set)  (h : fun(C#, D#)). (h# o g#) o f# = h# o g# o f#: thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val P2fun_uex0 =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val it = (): unit
******

Loading SEAR file SEARsetting.sml

******
val AX0 = {},  |- ?(A : set)  (a : mem(A#)). T: thm
val Tab_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) <=>
        (!(x : mem(A#))  (y : mem(B#)).
            Holds(R#, x#, y#) <=>
            ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val AX2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        ?(TR : set)  (p : fun(TR#, A#))  (q : fun(TR#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              Holds(R#, x#, y#) <=>
              ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
          !(r : mem(TR#))  (s : mem(TR#)).
            App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Empty_unique =
   {}, 
   |- !(E1 : set)  (E2 : set).
        (!(a : mem(E1#)). F) & (!(a : mem(E2#)). F) ==>
        ?(i : fun(E1#, E2#))  (j : fun(E2#, E1#)).
          i# o j# = Id(E2#) & j# o i# = Id(E1#): thm
val Thm_2_2 = {},  |- ?(Empty : set). !(a : mem(Empty#)). F: thm
val Thm_2_3 =
   {},  |- ?(ONE : set)  (x : mem(ONE#)). !(x' : mem(ONE#)). x'# = x#: thm
val unique_fun_to_ONE =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#)).
        (!(a : mem(ONE#)). a# = x#) ==> !(A : set). ?!(f : fun(A#, ONE#)). T:
   thm
val ONE_unique =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#))  (ONE' : set)  (x' : mem(ONE'#)).
        (!(a : mem(ONE#)). a# = x#) & (!(a : mem(ONE'#)). a# = x'#) ==>
        ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
          i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso0_REFL =
   {}, 
   |- !(A : set).
        ?(i : fun(A#, A#))  (j : fun(A#, A#)).
          i# o j# = Id(A#) & j# o i# = Id(A#): thm
val iso0_SYM =
   {}, 
   |- !(A : set)  (A' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
        ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
          i# o j# = Id(A#) & j# o i# = Id(A'#): thm
val iso0_TRANS =
   {}, 
   |- !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_uex =
   {}, 
   |- ?(ONE : set).
        (?(x : mem(ONE#)). !(a : mem(ONE#)). a# = x#) &
        !(ONE' : set).
          (?(x : mem(ONE'#)). !(a : mem(ONE'#)). a# = x#) ==>
          ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
            i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso_Reqv =
   {}, 
   |- (!(A : set).
          ?(i : fun(A#, A#))  (j : fun(A#, A#)).
            i# o j# = Id(A#) & j# o i# = Id(A#)) &
      (!(A : set)  (A' : set).
          (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
              i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
          ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
            i# o j# = Id(A#) & j# o i# = Id(A'#)) &
      !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_def = {},  |- ?(x : mem(1)). !(a : mem(1)). a# = x#: thm
val dot_uex = {},  |- ?!(x : mem(1)). x# = x#: thm
val dot_def = {},  |- !(a : mem(1)). a# = dot: thm
val dot_def0 = {},  |- dot = dot: thm
val ONE = 1: term
val Thm_2_3_5 = {},  |- !(A : set). ?!(f : rel(A#, 1)). isFun(f#): thm
val To1_ex = {},  |- !(A : set). ?!(f : fun(A#, 1)). T: thm
val dot = dot: term
val To1_uex = {},  |- !(A : set). ?!(f : fun(A#, 1)). f# = f#: thm
val To1_def = {},  |- !(A : set)  (f' : fun(A#, 1)). f'# = To1(A#): thm
val To1_def0 = {(A : set)},  |- To1(A) = To1(A): thm
val Thm_2_4_R_ver =
   {}, 
   |- !(A : set)  (R : rel(1, A#)).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)).
            Holds(R#, dot, a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Rel_Pred1 =
   {}, 
   |- !(A : set).
        ?!(R : rel(1, A#)). !(a : mem(A#)). Holds(R#, dot, a#) <=> P(a#): thm
val Tab_App_Rel =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (x : mem(A#))  (y : mem(B#)).
          App(p#, r#) = x# & App(q#, r#) = y# ==> Holds(R#, x#, y#): thm
val Thm_2_4 =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Tab_mem_R =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#)). Holds(R#, App(p#, r#), App(q#, r#)): thm
val Tab_prop1 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(x : mem(A#))  (y : mem(B#)).
          Holds(R#, x#, y#) <=>
          ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#: thm
val T_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(T0 : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(T0#, a#, b#): thm
val T_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          (!(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#)) &
          !(R' : rel(A#, B#)).
            (!(a : mem(A#))  (b : mem(B#)). Holds(R'#, a#, b#)) ==> R'# = R#:
   thm
val Tab_prop2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Thm_2_5 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (T1 : set)
      (p1 : fun(T1#, A#))  (q1 : fun(T1#, B#))  (T2 : set)
      (p2 : fun(T2#, A#))  (q2 : fun(T2#, B#)).
        isTab(R#, p1#, q1#) & isTab(R#, p2#, q2#) ==>
        ?(b : fun(T1#, T2#)). Bij(b#): thm
val isPair_def =
   {(A : set), (AxB : set), (B : set), (p1 : fun(AxB, A)), (p2 : fun(AxB, B))},
   
   |- isPair(p1, p2) <=>
      !(x : mem(A))  (y : mem(B)).
        ?!(r : mem(AxB)). App(p1, r#) = x# & App(p2, r#) = y#: thm
val isPair_uex =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (p1 : fun(AB#, A#))
      (p2 : fun(AB#, B#))  (AB' : set)  (p1' : fun(AB'#, A#))
      (p2' : fun(AB'#, B#)).
        isPair(p1#, p2#) & isPair(p1'#, p2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          p1'# o i# = p1# &
          p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AxB : set)  (p1 : fun(AxB#, A#))  (p2 : fun(AxB#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              ?(r : mem(AxB#)). App(p1#, r#) = x# & App(p2#, r#) = y#) &
          !(r : mem(AxB#))  (s : mem(AxB#)).
            App(p1#, r#) = App(p1#, s#) & App(p2#, r#) = App(p2#, s#) ==>
            r# = s#: thm
val Pr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)).
          isPair(p1#, p2#) &
          !(AB' : set)  (p1' : fun(AB'#, A#))  (p2' : fun(AB'#, B#)).
            isPair(p1'#, p2'#) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_p12_def =
   {},  |- !(A : set)  (B : set). isPair(p1(A#, B#), p2(A#, B#)): thm
val Pr_ts_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)). T: thm
val isPair_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            p1# o i# = p1# & p2# o i# = p2# & p1# o j# = p1# & p2# o j# = p2#) &
      (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
        (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            p1# o i# = p1'# &
            p2# o i# = p2'# & p1'# o j# = p1# & p2'# o j# = p2#) &
      !(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
      (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B))  (AB'' : set)
      (p1'' : fun(AB''#, A))  (p2'' : fun(AB''#, B)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            p1'# o i# = p1# &
            p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            p1''# o i# = p1'# &
            p2''# o i# = p2'# & p1'# o j# = p1''# & p2'# o j# = p2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          p1''# o i# = p1# &
          p2''# o i# = p2# & p1# o j# = p1''# & p2# o j# = p2''#: thm
val p2_def =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#))  (y : mem(B#)).
            ?(r : mem(A# * B#)).
              App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#) &
        !(r : mem(A# * B#))  (s : mem(A# * B#)).
          App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
          App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val SetPr_def =
   {}, 
   |- !(A : set)  (AB : set)  (p1 : fun(AB#, A#))  (B : set)
      (p2 : fun(AB#, B#)).
        SetPr(p1#, p2#) <=>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
          ?!(fg : fun(X#, AB#)). p1# o fg# = f# & p2# o fg# = g#: thm
val Cross = fn: term -> term -> term
val Pa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        (p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#) &
        !(fg' : fun(X#, A# * B#)).
          p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==>
          fg'# = Pa(f#, g#): thm
val Pa_def0 =
   {(A : set), (B : set), (X : set), (f : fun(X, A)), (g : fun(X, B))}, 
   |- p1(A, B) o Pa(f, g) = f & p2(A, B) o Pa(f, g) = g: thm
val Thm_2_8_SetPr =
   {},  |- !(A : set)  (B : set). SetPr(p1(A#, B#), p2(A#, B#)): thm
val p12_of_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#: thm
val p1_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f#: thm
val p2_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p2(A#, B#) o Pa(f#, g#) = g#: thm
val is_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (fg' : fun(X#, A# * B#)).
        p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==> fg'# = Pa(f#, g#):
   thm
val AX3 =
   {}, 
   |- !(A : set).
        ?(PA : set)  (e : rel(A#, PA#)).
          !(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#): thm
val Pow_uex =
   {(A : set)}, 
   |- ?(PA : set)  (e : rel(A, PA#)).
        (!(S0 : rel(1, A)).
            ?!(s : mem(PA#)).
              !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        !(PA' : set)  (e' : rel(A, PA'#)).
          (!(S0 : rel(1, A)).
              ?!(s : mem(PA'#)).
                !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
          ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val Pow_unique =
   {}, 
   |- !(A : set)  (PA : set)  (e : rel(A#, PA#))  (PA' : set)
      (e' : rel(A#, PA'#)).
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA'#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
        ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
          i# o j# = Id(PA'#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val SetEz_def =
   {(A : set), (B : set), (E : set), (e : fun(E, A)), (f : fun(A, B)),
    (g : fun(A, B))}, 
   |- SetEz(f, g, e) <=>
      !(X : set)  (x : fun(X#, A)).
        f o x# = g o x# ==> ?!(x0 : fun(X#, E)). x# = e o x0#: thm
val Thm_2_10 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(M : set)  (e : fun(A#, M#))  (m : fun(M#, B#)).
          f# = m# o e# & Surj(e#) & Inj(m#): thm
val Thm_2_9_Eqlz =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
        ?(E : set)  (e : fun(E#, A#)). SetEz(f#, g#, e#): thm
val BC0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))).
        Holds(BC0(f#), a#, b#) <=>
        !(z : mem(Z#)).
          Holds(In(Z#), z#, b#) <=> Holds(In(Y#), App(f#, z#), a#): thm
val Pow = fn: term -> term
val Pow_REFL =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#)).
        ?(i : fun(PA#, PA#))  (j : fun(PA#, PA#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e# & asR(j#) @ e# = e#: thm
val Pow_SYM =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) ==>
        ?(i : fun(PA'#, PA#))  (j : fun(PA#, PA'#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA'#) & asR(i#) @ e'# = e# & asR(j#) @ e# = e'#: thm
val Pow_TRANS =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#))
      (PA'' : set)  (e'' : rel(A, PA''#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) &
        (?(i : fun(PA'#, PA''#))  (j : fun(PA''#, PA'#)).
            i# o j# = Id(PA''#) &
            j# o i# = Id(PA'#) & asR(i#) @ e'# = e''# & asR(j#) @ e''# = e'#) ==>
        ?(i : fun(PA#, PA''#))  (j : fun(PA''#, PA#)).
          i# o j# = Id(PA''#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e''# & asR(j#) @ e''# = e#: thm
val Pow_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val All0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(All0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, a#): thm
val All0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(All0(f#)): thm
val BC0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(BC0(f#)): thm
val Ex0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(Ex0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          ?(z : mem(Z#)). Holds(In(Z#), z#, a#) & App(f#, z#) = y#: thm
val Ex0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(Ex0(f#)): thm
val In_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). Holds(In(A#), x#, s1#) <=> Holds(In(A#), x#, s2#)) ==>
        s1# = s2#: thm
val In_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val In_def_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (s0 : fun(A0#, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)).
            (?(a0 : mem(A0#)). x# = App(s0#, a0#)) <=> Holds(In(A#), x#, s#):
   thm
val In_def_P =
   {}, 
   |- !(A : set).
        ?!(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> Holds(In(A#), a#, s#):
   thm
val PO_def =
   {}, 
   |- !(A : set)  (S1 : mem(Pow(A#)))  (S2 : mem(Pow(A#))).
        PO(S1#, S2#) <=>
        !(a : mem(A#)). Holds(In(A#), a#, S1#) ==> Holds(In(A#), a#, S2#):
   thm
val BC_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))). App(BC(f#), a#) = b# <=> Holds(BC0(f#), a#, b#):
   thm
val In_App_BC =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (z : mem(Z#))
      (ys : mem(Pow(Y#))).
        Holds(In(Z#), z#, App(BC(f#), ys#)) <=>
        Holds(In(Y#), App(f#, z#), ys#): thm
val Ex_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(Ex(f#), a#) = b# <=> Holds(Ex0(f#), a#, b#):
   thm
val In_App_Ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(Ex(f#), zs#)) <=>
        ?(z : mem(Z#)). Holds(In(Z#), z#, zs#) & App(f#, z#) = y#: thm
val All_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(All(f#), a#) = b# <=> Holds(All0(f#), a#, b#):
   thm
val In_App_All =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(All(f#), zs#)) <=>
        !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, zs#): thm
val Thm_2_11_SEx_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (zs : mem(Pow(Z#)))
      (ys : mem(Pow(Y#))).
        PO(App(Ex(f#), zs#), ys#) <=> PO(zs#, App(BC(f#), ys#)): thm
val Thm_2_11_SAll_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (ys : mem(Pow(Y#)))
      (zs : mem(Pow(Z#))).
        PO(App(BC(f#), ys#), zs#) <=> PO(ys#, App(All(f#), zs#)): thm
val Sub_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, R2#) <=>
        !(a : mem(A#))  (b : mem(B#)).
          Holds(R1#, a#, b#) ==> Holds(R2#, a#, b#): thm
val Meet_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Meet(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) & Holds(R2#, a#, b#): thm
val Sub_Meet =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(Meet(R1#, R2#), R1#) &
        Sub(Meet(R1#, R2#), R2#) &
        !(R0 : rel(A#, B#)).
          Sub(R0#, R1#) & Sub(R0#, R2#) ==> Sub(R0#, Meet(R1#, R2#)): thm
val Join_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Join(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) | Holds(R2#, a#, b#): thm
val Sub_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, Join(R1#, R2#)) &
        Sub(R2#, Join(R1#, R2#)) &
        !(R0 : rel(A#, B#)).
          Sub(R1#, R0#) & Sub(R2#, R0#) ==> Sub(Join(R1#, R2#), R0#): thm
val MODULAR_LAW =
   {}, 
   |- !(x : set)  (y : set)  (phi : rel(x#, y#))  (z : set)
      (psi : rel(y#, z#))  (chi : rel(x#, z#)).
        Sub(Meet(psi# @ phi#, chi#), psi# @ Meet(phi#, op(psi#) @ chi#)): thm
val left_o_pres_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (C : set)  (R : rel(B#, C#)).
        R# @ Join(R1#, R2#) = Join(R# @ R1#, R# @ R2#): thm
val right_o_pres_Join =
   {(C : set)}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (R : rel(C, A#)). Join(R1#, R2#) @ R# = Join(R1# @ R#, R2# @ R#): thm
val Div_ex =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (C : set)  (s : rel(A#, C#)).
        ?(sdr : rel(B#, C#)).
          !(t : rel(B#, C#)). Sub(t#, sdr#) <=> Sub(t# @ r#, s#): thm
val MF_def = {},  |- !(A : set)  (a : mem(A#)). App(MF(a#), dot) = a#: thm
val Pair_uex =
   {}, 
   |- !(A : set)  (B : set)  (x : mem(A#))  (y : mem(B#)).
        ?!(r : mem(A# * B#)).
          App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#: thm
val Thm_2_12 =
   {}, 
   |- !(B : set)  (A : set)  (R : rel(B#, A#)).
        ?!(fR : fun(B#, Pow(A#))).
          !(y : mem(B#))  (x : mem(A#)).
            Holds(R#, y#, x#) <=> Holds(In(A#), x#, App(fR#, y#)): thm
val Thm_2_3_5_el =
   {},  |- !(A : set)  (a : mem(A#)). ?!(R : fun(1, A#)). App(R#, dot) = a#:
   thm
val Pair_App_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val Pair_def =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val Pair_component =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)).
        Pair(App(p1(A#, B#), r#), App(p2(A#, B#), r#)) = r#: thm
val Pair_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
      (b2 : mem(B#)).
        Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#: thm
val Pair_p12 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        Pair(App(p1(A#, B#), ab#), App(p2(A#, B#), ab#)) = ab#: thm
val Ap1_def =
   {}, 
   |- !(A : set)  (X : set)  (x : mem(X#))  (B : set)  (f : fun(A# * X#, B#))
      (a : mem(A#)). App(Ap1(f#, x#), a#) = App(f#, Pair(a#, x#)): thm
val Ap1_uex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#))
      (x : mem(X#)).
        ?!(fx : fun(A#, B#)).
          !(a : mem(A#)). App(fx#, a#) = App(f#, Pair(a#, x#)): thm
val Cross_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val App_Pa =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (D : set)
      (g : fun(B#, D#))  (ab : mem(A# * B#)).
        App(Pa(f# o p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(f# o p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_o_p2 =
   {}, 
   |- !(B : set)  (C : set)  (f : fun(B#, C#))  (A : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p2(A#, B#), Pair(a#, b#)) = App(f#, b#): thm
val App_o_p1 =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p1(A#, B#), Pair(a#, b#)) = App(f#, a#): thm
val Fst_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p1(A, B), x) = Fst(x):
   thm
val Pair_def' =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#: thm
val Snd_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p2(A, B), x) = Snd(x):
   thm
val Pair_Fst_Snd =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)). Pair(Fst(r#), Snd(r#)) = r#:
   thm
val Pair_has_comp =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#): thm
val p12_of_Pair =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val dest_cross = fn: term -> term * term
val basic_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_fconv = fn: form -> thm
val mk_Pair = fn: term -> term -> term
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val Prla_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (D : set)
      (g : fun(C#, D#)). Prla(f#, g#) = Pa(f# o p1(A#, C#), g# o p2(A#, C#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Exp_ev_unique =
   {}, 
   |- !(A : set)  (B : set)  (A2B : set)  (ev : fun(A# * A2B#, B#))
      (A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B'#)).
              !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
        ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
          i# o j# = Id(A2B'#) &
          j# o i# = Id(A2B#) &
          ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#: thm
val Exp_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#): thm
val Exp_ex_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          (!(f : fun(A#, B#)).
              ?!(sf : mem(A2B#)).
                !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
          !(A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
            (!(f : fun(A#, B#)).
                ?!(sf : mem(A2B'#)).
                  !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
            ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
              i# o j# = Id(A2B'#) &
              j# o i# = Id(A2B#) &
              ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#:
   thm
val Thm_2_13 =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A2B# * A#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(sf#, a#)) = App(f#, a#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Ev_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_uex_refl =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B)).
        ?(i : fun(A2B#, A2B#))  (j : fun(A2B#, A2B#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B#) &
          ev# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_sym =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) ==>
        ?(i : fun(A2B'#, A2B#))  (j : fun(A2B#, A2B'#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B'#) &
          ev# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_trans =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B))  (A2B'' : set)  (ev'' : fun(A * A2B''#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) &
        (?(i : fun(A2B'#, A2B''#))  (j : fun(A2B''#, A2B'#)).
            i# o j# = Id(A2B''#) &
            j# o i# = Id(A2B'#) &
            ev''# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev''#) ==>
        ?(i : fun(A2B#, A2B''#))  (j : fun(A2B''#, A2B#)).
          i# o j# = Id(A2B''#) &
          j# o i# = Id(A2B#) &
          ev''# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev''#: thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val Tpm_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
        !(sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#): thm
val Tpm_def0 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#): thm
val is_Tpm =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sf' : mem(Exp(A#, B#))).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
        sf'# = Tpm(f#): thm
val Tp_def0 =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f: thm
val Tp_ex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#)).
        ?!(h : fun(X#, Exp(A#, B#))).
          Ev(A#, B#) o Pa(p1(A#, X#), h# o p2(A#, X#)) = f#: thm
val Tp_def =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f &
      !(h' : fun(X, Exp(A, B))).
        Ev(A, B) o Pa(p1(A, X), h'# o p2(A, X)) = f ==> h'# = Tp(f): thm
val is_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (h' : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), h'# o p2(A#, X#)) = f# ==> h'# = Tp(f#):
   thm
val Thm_2_14 =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        ?(B : set)  (q : fun(A#, B#)).
          Surj(q#) &
          !(x : mem(A#))  (y : mem(A#)).
            Holds(R#, x#, y#) <=> App(q#, x#) = App(q#, y#): thm
val IN_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#))).
        IN(a#, ss#) <=> Holds(In(A#), a#, ss#): thm
val IN_def_P_expand =
   {}, 
   |- !(A : set).
        ?(s : mem(Pow(A#))).
          (!(a : mem(A#)). P(a#) <=> IN(a#, s#)) &
          !(s' : mem(Pow(A#))).
            (!(a : mem(A#)). P(a#) <=> IN(a#, s'#)) ==> s'# = s#: thm
val IN_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) ==> s1# = s2#: thm
val SS_def =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) <=> !(a : mem(A#)). IN(a#, P1#) ==> IN(a#, P2#): thm
val SS_Trans =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) ==> !(P3 : mem(Pow(A#))). SS(P2#, P3#) ==> SS(P1#, P3#):
   thm
val SS_SS_eq =
   {}, 
   |- !(A : set)  (p1 : mem(Pow(A#)))  (p2 : mem(Pow(A#))).
        SS(p1#, p2#) & SS(p2#, p1#) ==> p1# = p2#: thm
val IN_def_P_ex =
   {}, 
   |- !(A : set). ?(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> IN(a#, s#):
   thm
val IN_def_P =
   {}, 
   |- !(A : set). ?!(s : mem(Pow(A#))). !(a : mem(A#)). IN(a#, s#) <=> P(a#):
   thm
val AX4 =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set).
        ?!(BI : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BI#, sss#)) <=>
            !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val BI_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BI(A#), sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val N0 = N0: term
val N0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val O0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val S0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_def =
   {(A : set), (sss : mem(Pow(Pow(A))))},  |- App(BI(A), sss) = BIGINTER(sss):
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        ?(isss : mem(Pow(A#))). App(BI(A#), sss#) = isss#: thm
val IN_BIGINTER =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGINTER(sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
******

Loading SEAR file SEARreln.sml

******
val mk_App = fn: term -> term -> term
SEARreln.sml:75: warning: Matches are not exhaustive.
Found near
  case (view_form ante, view_form conseq) of
     (vConn ("&", ...), vConn (...)) =>
     let val ip1 = ... ...; val ... = ... in conj_monotone ip1 ip2 end |
     (vConn (...), ... ...) => let val ... = ...; val ... in ... ... ip2 end
     |
     (... ..., ...) => let val ... in ... ... end |
     (...) => let ... in ... end
SEARreln.sml:247: warning: Pattern is not exhaustive.
Found near
  val [fnterm, LFP] = fLFP |> #3 o dest_fun handle _ => raise ... ...
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
val conj_monotone = fn: thm -> thm -> thm
val disj_monotone = fn: thm -> thm -> thm
val exists_monotone = fn: thm -> thm
val forall_monotone = fn: thm -> thm
val imp_induce = fn: thm -> form -> thm
val mk_LFP = fn: term -> thm
val mk_Pow = fn: term -> term
val mk_SS = fn: thm -> thm -> thm
val mk_cases = fn: thm -> thm -> thm -> thm
val mk_cond = fn: thm -> thm -> thm
val mk_fdef = fn: string -> thm -> thm
val mk_fex = fn: form -> string -> thm
val mk_ind = fn: thm -> thm
val mk_ind1 = fn: thm -> thm -> thm
val mk_monotone = fn: thm -> thm
val mk_prim = fn: thm -> thm
val mk_rules = fn: thm -> thm -> thm -> thm
val trivial_imp = fn: form -> thm
val PULL_CONJ = fn: (form -> bool) -> form -> thm option
val conj_assoc_fconv = fn: form -> thm
val conj_cossa_fconv = fn: form -> thm
val conj_swap_fconv = fn: form -> thm
val disj_imp_distr_fconv = fn: form -> thm
val exists_eq_fconv = fn: form -> thm
val forall_conj_split_fconv = fn: form -> thm
val forall_eq_fconv = fn: form -> thm
val mk_case1 = fn: thm -> thm -> thm
val mk_rules1 = fn: thm -> thm -> thm
val mk_rules2 = fn: thm -> thm
val pull_conj_fconv = fn: (form -> bool) -> form -> thm
val pull_exists_fconv1 = fn: form -> thm
SEARreln.sml:599: warning: Pattern is not exhaustive.
Found near val [qv, newtm] = conc |> dest_pred |> #2
val conj_imp_fconv = fn: form -> thm
val disj_imp_undistr_fconv = fn: form -> thm
val forall_in_eq_fconv = fn: form -> thm
val mk_incond = fn: form -> form * string
val mk_ind2 = fn: thm -> thm
val mk_rules3 = fn: thm -> thm
val remove_list_item = fn: ''a -> ''a list -> ''a list
val unpull_exists_fconv1 = fn: form -> thm
val it = (): unit
val inN's_def =
   {},  |- !(a : mem(Pow(N0))). IN(a#, inN's) <=> SS(App(inNf, a#), a#): thm
val inN_cases0 = {},  |- App(inNf, inNs) = inNs: thm
val inN_cases1 =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_incond =
   !(n : mem(N0)).
     IN(n#, inN1) <=>
     n# = O0 | ?(n0 : mem(N0)). IN(n0#, inN0) & n# = App(S0, n0#): form
val inN_ind =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_ind0 =
   {},  |- !(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> SS(inNs, ss#):
   thm
val inN_ind1 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        (!(a : mem(N0)).
            a# = O0 | (?(n0 : mem(N0)). IN(n0#, ss#) & a# = App(S0, n0#)) ==>
            IN(a#, ss#)) ==> !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#):
   thm
val inN_ind2 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_rules0 = {},  |- SS(App(inNf, inNs), inNs): thm
val inN_rules1 =
   {}, 
   |- !(a : mem(N0)).
        a# = O0 | (?(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#)) ==>
        IN(a#, inNs): thm
val inN_rules2 =
   {}, 
   |- !(a : mem(N0)).
        (a# = O0 ==> IN(a#, inNs)) &
        !(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#) ==> IN(a#, inNs):
   thm
val inN_rules3 =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val inNf_def =
   {}, 
   |- !(a : mem(Pow(N0)))  (n : mem(N0)).
        IN(n#, App(inNf, a#)) <=>
        n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_ex =
   {}, 
   |- ?!(f : fun(Pow(N0), Pow(N0))).
        !(a : mem(Pow(N0)))  (n : mem(N0)).
          IN(n#, App(f#, a#)) <=>
          n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_monotone =
   {}, 
   |- !(s1 : mem(Pow(N0)))  (s2 : mem(Pow(N0))).
        SS(s1#, s2#) ==> SS(App(inNf, s1#), App(inNf, s2#)): thm
val inNs_SS =
   {},  |- !(a : mem(Pow(N0))). SS(App(inNf, a#), a#) ==> SS(inNs, a#): thm
val inNs_cond =
   {}, 
   |- !(a : mem(N0)).
        (!(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, inNs): thm
val inNs_def = {},  |- inNs = BIGINTER(inN's): thm
val x1 = "inN0": string
val inN_cases =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_rules =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val N_def =
   {}, 
   |- Inj(iN) &
      !(a : mem(N0)). IN(a#, inNs) <=> ?(b : mem(N)). a# = App(iN, b#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val iN_Inj = {},  |- Inj(iN): thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val iN_inNs = {},  |- !(n : mem(N)). IN(App(iN, n#), inNs): thm
val SUC_ex_lemma =
   {},  |- !(n1 : mem(N)). ?(b : mem(N)). App(S0 o iN, n1#) = App(iN, b#):
   thm
val SUC_def = {},  |- !(a : mem(N)). App(iN o SUC, a#) = App(S0 o iN, a#):
   thm
val iN_eq_eq =
   {}, 
   |- !(x1 : mem(N))  (x2 : mem(N)).
        App(iN, x1#) = App(iN, x2#) ==> x1# = x2#: thm
val O_def = {},  |- O0 = App(iN, O): thm
val iN_ex_uex =
   {}, 
   |- !(b : mem(N0)).
        (?(a : mem(N)). App(iN, a#) = b#) <=>
        ?!(a : mem(N)). App(iN, a#) = b#: thm
val S0_eq_eq =
   {}, 
   |- !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) ==> n# = m#:
   thm
val SUC_Inj = {},  |- Inj(SUC): thm
val iN_O = {},  |- !(n : mem(N)). App(iN, n#) = O0 <=> n# = O: thm
val SUC_NONZERO = {},  |- !(n : mem(N)). ~App(SUC, n#) = O: thm
val Image_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(im : fun(Pow(A#), Pow(B#))).
          !(sa : mem(Pow(A#)))  (b : mem(B#)).
            IN(b#, App(im#, sa#)) <=>
            ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val Image_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sa : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Image(f#), sa#)) <=>
        ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val IMAGE_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (b : mem(B#)).
        IN(b#, IMAGE(f#, s0#)) <=>
        ?(a : mem(A#)). IN(a#, s0#) & b# = App(f#, a#): thm
val IMAGE_def0 =
   {(A : set), (B : set), (f : fun(A, B)), (s0 : mem(Pow(A)))}, 
   |- IMAGE(f, s0) = App(Image(f), s0): thm
val Whole_def = {},  |- !(A : set)  (a : mem(A#)). IN(a#, Whole(A#)): thm
val IN_IMAGE_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(s : mem(Pow(A#)))  (a : mem(A#)).
          IN(a#, s#) <=> IN(App(i#, a#), IMAGE(i#, s#)): thm
val N_ind_P =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(App(SUC, n#))) ==>
      !(n : mem(N)). P(n#): thm
val O_xor_SUC =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = App(SUC, pn#): thm
val SUC_eq_eq =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)).
        App(SUC, n1#) = App(SUC, n2#) <=> n1# = n2#: thm
val Suc_def = {},  |- !(n : mem(N)). Suc(n#) = App(SUC, n#): thm
val O_xor_Suc =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = Suc(pn#): thm
val Suc_eq_eq =
   {},  |- !(n1 : mem(N))  (n2 : mem(N)). Suc(n1#) = Suc(n2#) <=> n1# = n2#:
   thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val N_induct =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Eqv_def =
   {},  |- !(A : set)  (B : set). Eqv(A#, B#) <=> ?(f : fun(A#, B#)). Bij(f#):
   thm
val Asset_def =
   {}, 
   |- !(B : set)  (bs : mem(Pow(B#)))  (B0 : set).
        Asset(bs#, B0#) <=>
        !(B1 : set)  (i : fun(B1#, B#)).
          Inj(i#) &
          (!(b : mem(B#)).
              (?(b0 : mem(B1#)). App(i#, b0#) = b#) <=> IN(b#, bs#)) ==>
          Eqv(B0#, B1#): thm
val Sg_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (a0 : mem(A#)).
        IN(a0#, App(Sg(A#), a#)) <=> a0# = a#: thm
val Sing_def = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Empty_def = {},  |- !(X : set)  (a : mem(X#)). ~IN(a#, Empty(X#)): thm
val Sing_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Sing(a1#) = Sing(a2#) <=> a1# = a2#: thm
val Sing_NONEMPTY = {},  |- !(A : set)  (a : mem(A#)). ~Sing(a#) = Empty(A#):
   thm
val iscoPr_def =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (i1 : fun(A#, AB#))
      (i2 : fun(B#, AB#)).
        iscoPr(i1#, i2#) <=>
        !(X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
          ?!(fg : fun(AB#, X#)). fg# o i1# = f# & fg# o i2# = g#: thm
val tof_def =
   {(A : set), (B : set), (f0 : mem(Exp(A, B)))}, 
   |- !(a : mem(A)). App(Ev(A, B), Pair(a#, f0)) = App(tof(f0), a#): thm
val coPr_unique =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        iscoPr(i1#, i2#) & iscoPr(i1'#, i2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          j# o i1'# = i1# &
          j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val iscoPr_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          iscoPr(i1#, i2#) &
          Inj(i1#) &
          Inj(i2#) &
          (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
          !(ab : mem(AB#)).
            (?(a : mem(A#)). ab# = App(i1#, a#)) |
            ?(b : mem(B#)). ab# = App(i2#, b#): thm
val coPr_REFL =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
        ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB#) &
          j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#:
   thm
val coPr_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#) &
      (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
        (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            j# o i1# = i1'# &
            j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#) &
      !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_SYM =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
        ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB'#) &
          j# o i1# = i1'# &
          j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#: thm
val coPr_TRANS =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          (iscoPr(i1#, i2#) &
            Inj(i1#) &
            Inj(i2#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
            !(ab : mem(AB#)).
              (?(a : mem(A#)). ab# = App(i1#, a#)) |
              ?(b : mem(B#)). ab# = App(i2#, b#)) &
          !(AB' : set)  (i1' : fun(A#, AB'#))  (i2' : fun(B#, AB'#)).
            iscoPr(i1'#, i2'#) &
            Inj(i1'#) &
            Inj(i2'#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1'#, a#) = App(i2'#, b#)) &
            (!(ab : mem(AB'#)).
                (?(a : mem(A#)). ab# = App(i1'#, a#)) |
                ?(b : mem(B#)). ab# = App(i2'#, b#)) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val coPo_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i2_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val coPa_def0 =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#: thm
val coPa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        (coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#) &
        !(fg' : fun(A# + B#, X#)).
          fg'# o i1(A#, B#) = f# & fg'# o i2(A#, B#) = g# ==>
          fg'# = coPa(f#, g#): thm
val i1_Inj = {},  |- !(A : set)  (B : set). Inj(i1(A#, B#)): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val i1_or_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
        ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_xor_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) <=>
        ?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#): thm
val i2_xor_i1 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#)) <=>
        ?(a : mem(A#)). ab# = App(i1(A#, B#), a#): thm
val it = (): unit
******

Loading SEAR file SEARpred_set.sml

******
val tof_Tpm_inv =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). tof(Tpm(f#)) = f#: thm
val Tpm_tof_inv =
   {},  |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#))). Tpm(tof(f#)) = f#:
   thm
val Tpm_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        Tpm(f1#) = Tpm(f2#) <=> f1# = f2#: thm
val tof_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (g : mem(Exp(A#, B#))).
        tof(f#) = tof(g#) <=> f# = g#: thm
val IN_Sing =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)).
        IN(a#, Sing(a0#)) <=> a# = a0#: thm
val BU_ex =
   {}, 
   |- !(A : set).
        ?!(BU : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BU#, sss#)) <=>
            ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val EMPTY_def = {(A : set)},  |- EMPTY(A) <=> !(x : mem(A)). F: thm
val BU_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BU(A#), sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val BIGUNION_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        BIGUNION(sss#) = App(BU(A#), sss#): thm
val IN_BIGUNION =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGUNION(sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val IMAGE_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (s : mem(Pow(A#))). IMAGE(g# o f#, s#) = IMAGE(g#, IMAGE(f#, s#)): thm
val ex_eq_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#))).
        (!(b : mem(B#)). IN(b#, s#) ==> ?(a : mem(A#)). b# = App(f#, a#)) ==>
        ?(s0 : mem(Pow(A#))). s# = IMAGE(f#, s0#): thm
val App_IN_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))
      (a : mem(A#)). IN(a#, s#) ==> IN(App(f#, a#), IMAGE(f#, s#)): thm
val IMAGE_BIGUNION =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(Pow(A#)))).
        IMAGE(f#, BIGUNION(ss#)) = BIGUNION(IMAGE(Image(f#), ss#)): thm
val Prla_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(C : set)  (D : set)  (g : fun(C#, D#)).
          Inj(g#) ==> Inj(Prla(f#, g#)): thm
val Id_Inj = {},  |- !(X : set). Inj(Id(X#)): thm
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Pa_distr =
   {}, 
   |- !(A : set)  (X : set)  (a1 : fun(X#, A#))  (B : set)
      (a2 : fun(X#, B#))  (X0 : set)  (x : fun(X0#, X#)).
        Pa(a1#, a2#) o x# = Pa(a1# o x#, a2# o x#): thm
val Pa_eq_eq =
   {}, 
   |- !(A : set)  (X : set)  (f1 : fun(X#, A#))  (f2 : fun(X#, A#))
      (B : set)  (g1 : fun(X#, B#))  (g2 : fun(X#, B#)).
        Pa(f1#, g1#) = Pa(f2#, g2#) <=> f1# = f2# & g1# = g2#: thm
val p2_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(B#, C#)).
        f# o p2(A#, B#) = p2(A#, C#) o Prla(Id(A#), f#): thm
val p1_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(A#, C#)).
        f# o p1(A#, B#) = p1(C#, B#) o Prla(f#, Id(B#)): thm
val p1_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#)). p1(X#, Y#) o Prla(f#, g#) = f# o p1(A#, B#): thm
val IMAGE_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#))  (x : mem(X#))  (y : mem(Y#))
      (s : mem(Pow(A# * B#))).
        IN(Pair(x#, y#), IMAGE(Prla(f#, g#), s#)) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          IN(Pair(a#, b#), s#) & x# = App(f#, a#) & y# = App(g#, b#): thm
val exists_cross_fconv = fn: form -> thm
val Image_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        App(Image(f#), s#) = IMAGE(f#, s#): thm
val IMAGE_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        IMAGE(f#, Empty(A#)) = Empty(B#): thm
val IN_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        (?(a : mem(A#)). IN(a#, s#)) <=> ~s# = Empty(A#): thm
val IMAGE_Empty_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val BIGUNION_Empty_Empty =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        BIGUNION(ss#) = Empty(A#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val BIGUNION_NONEMPTY =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        ~BIGUNION(ss#) = Empty(A#) <=>
        ?(s : mem(Pow(A#))). IN(s#, ss#) & ~s# = Empty(A#): thm
val BIGUNION_Empty_Empty' =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        Empty(A#) = BIGUNION(ss#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val INTER_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(INTER(A), Pair(a'#, b#))) <=> IN(a#, a'#) & IN(a#, b#):
   thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Inter_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Inter(s1, s2) = App(INTER(A), Pair(s1, s2)): thm
val UNION_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(UNION(A), Pair(a'#, b#))) <=> IN(a#, a'#) | IN(a#, b#):
   thm
val COMPL_def =
   {(A : set)}, 
   |- !(a : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(COMPL(A), a#)) <=> ~IN(a#, a#): thm
val Compl_def =
   {(A : set), (s : mem(Pow(A)))},  |- Compl(s) = App(COMPL(A), s): thm
val IN_Compl =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Compl(s#)) <=> ~IN(a#, s#): thm
val IN_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Union(s1#, s2#)) <=> IN(a#, s1#) | IN(a#, s2#): thm
val Union_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Union(s1, s2) = App(UNION(A), Pair(s1, s2)): thm
val m2r_def =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (od : mem(Pow(A# * A#))).
        Holds(m2r(od#), a1#, a2#) <=> IN(Pair(a1#, a2#), od#): thm
val r2m_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(Pair(a1#, a2#), r2m(R#)) <=> Holds(R#, a1#, a2#): thm
val Union_Empty_Empty =
   {},  |- !(A : set). Union(Empty(A#), Empty(A#)) = Empty(A#): thm
val SS_Refl = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(s#, s#): thm
val NONE_def = {(X : set)},  |- NONE(X) = App(i2(X, 1), dot): thm
val Null_def =
   {},  |- !(X : set)  (n : mem(N)). App(Null(X#), n#) = App(i2(X#, 1), dot):
   thm
val PREIM_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#)))
      (a : mem(A#)).
        IN(a#, PREIM(f#, s#)) <=>
        ?(b : mem(B#)). IN(b#, s#) & App(f#, a#) = b#: thm
val SOME_def =
   {},  |- !(A : set)  (a : mem(A#)). SOME(a#) = App(i1(A#, 1), a#): thm
val Surj_Epi =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) ==>
        !(C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
          g1# o f# = g2# o f# ==> g1# = g2#: thm
val false_def = {},  |- false = App(i1(1, 1), dot): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val true_def = {},  |- true = App(i2(1, 1), dot): thm
val true_ne_false = {},  |- ~true = false: thm
val true_or_false = {},  |- !(tv : mem(1 + 1)). tv# = true | tv# = false: thm
val true_xor_false = {},  |- !(tv : mem(1 + 1)). ~tv# = true <=> tv# = false:
   thm
val false_xor_true = {},  |- !(tv : mem(1 + 1)). ~tv# = false <=> tv# = true:
   thm
val tv_eq_true =
   {}, 
   |- !(tv1 : mem(1 + 1))  (tv2 : mem(1 + 1)).
        tv1# = tv2# <=> tv1# = true <=> tv2# = true: thm
val tf_eq_true =
   {}, 
   |- !(A : set)  (tf1 : fun(A#, 1 + 1))  (tf2 : fun(A#, 1 + 1)).
        tf1# = tf2# <=>
        !(a : mem(A#)). App(tf1#, a#) = true <=> App(tf2#, a#) = true: thm
val basic_fconv_tac = fn: conv -> fconv -> tactic
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
******

Loading SEAR file lambda.sml

******
val TAUT = {},  |- A | ~A: thm
val cond_unique_lemma =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b# = b'#: thm
val cond_unique_lemma' =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b'# = b#: thm
val conj1 = fn: form -> form
val conj2 = fn: form -> form
val conjIs = fn: thm list -> thm
val disj1 = fn: form -> form
val disj2 = fn: form -> form
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val disj_neg_absorb = {},  |- A | ~A & B <=> A | B: thm
val disj_of_negconj = {},  |- ~A & ~B <=> ~(A | B): thm
val djE = fn: form * thm -> form * thm -> form * thm
val djEs = fn: (form * thm) list -> form * thm
val drop_last_cj = fn: form -> form * form
val iant = fn: form -> form
val iconc = fn: form -> form
val imp_dimp_distr = {},  |- A ==> (B <=> C) <=> A ==> B <=> A ==> C: thm
val strip_conj = fn: form -> form list
val strip_disj = fn: form -> form list
val cond_rw_fconv = fn: form -> thm
val conj_assoc_fm = fn: form -> form
val define_lambda = fn: form -> thm
val define_lambda_fun = fn: form -> thm
val nlist = fn: int -> int list
val normalise_lambda_input = fn: form -> form
val it = (): unit
val NOT_def = {},  |- App(NOT, true) = false & App(NOT, false) = true: thm
val OR_def =
   {}, 
   |- App(OR, Pair(true, true)) = true &
      App(OR, Pair(true, false)) = true &
      App(OR, Pair(false, true)) = true & App(OR, Pair(false, false)) = false:
   thm
val constf_def =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#))  (a : mem(A#)).
        App(constf(A#, b#), a#) = b#: thm
val f2r_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * B#, 1 + 1))  (a : mem(A#))
      (b : mem(B#)). Holds(f2r(f#), a#, b#) <=> App(f#, Pair(a#, b#)) = true:
   thm
val r2f_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = App(i2(1, 1), dot) <=> Holds(R#, a#, b#):
   thm
val r2f_def' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = true <=> Holds(R#, a#, b#): thm
val ss2f =
   {(A : set), (s : mem(Pow(A)))}, 
   |- !(a : mem(A)). App(ss2f(s), a#) = true <=> IN(a#, s): thm
val FIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : fun(A, B))}, 
   |- FIB(f, b) = PREIM(f, Sing(b)): thm
val Inj_Image_Inj =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(A#, B#)). Inj(i#) ==> Inj(Image(i#)):
   thm
val mApp_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (f : mem(Exp(A#, B#))).
        mApp(f#, a#) = App(tof(f#), a#): thm
val mFIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : mem(Exp(A, B)))}, 
   |- mFIB(f, b) = PREIM(tof(f), Sing(b)): thm
val Compl_Whole = {},  |- !(A : set). Compl(Whole(A#)) = Empty(A#): thm
val Compl_Empty = {},  |- !(A : set). Compl(Empty(A#)) = Whole(A#): thm
val Inter_Compl_Compl =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J)))}, 
   |- Inter(Compl(s1), Compl(s2)) = Compl(Union(s1, s2)): thm
val neg_or_distr = {},  |- ~(A | B) <=> ~A & ~B: thm
val SS_Union =
   {}, 
   |- (!(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
          SS(a#, Union(a#, b#))) &
      !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val SS_Union1 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(a#, b#)): thm
val SS_Union2 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val Ins_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (s0 : mem(Pow(X#)))  (a : mem(X#)).
        IN(a#, Ins(x0#, s0#)) <=> a# = x0# | IN(a#, s0#): thm
val Union_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Union(Sing(a#), s#) = Ins(a#, s#): thm
val SS_Ins =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(s#, Ins(a#, s#)):
   thm
val BIGINTER_Sing =
   {},  |- !(A : set)  (s : mem(Pow(A#))). BIGINTER(Sing(s#)) = s#: thm
val Whole_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Whole(A#), s#) = s#: thm
val Inter_Whole =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Whole(A#)) = s#: thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Empty_SS = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(Empty(A#), s#): thm
val BIGINTER_Empty = {(A : set)},  |- BIGINTER(Empty(Pow(A))) = Whole(A): thm
val BIGINTER_Ins_Empty =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#))). BIGINTER(Ins(x#, Empty(Pow(A#)))) = x#:
   thm
val Inter_same = {},  |- !(A : set)  (x : mem(Pow(A#))). Inter(x#, x#) = x#:
   thm
val BIGINTER_Ins =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#)))  (xs0 : mem(Pow(Pow(A#)))).
        BIGINTER(Ins(x#, xs0#)) = Inter(x#, BIGINTER(xs0#)): thm
val imp_or_distr = {},  |- A | B ==> C <=> (A ==> C) & (B ==> C): thm
val BIGINTER_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(Pow(A#))))  (s2 : mem(Pow(Pow(A#)))).
        BIGINTER(Union(s1#, s2#)) = Inter(BIGINTER(s1#), BIGINTER(s2#)): thm
val Empty_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Empty(A#), s#) = Empty(A#):
   thm
val Union_EMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val neg_and_distr = {},  |- ~(A & B) <=> ~A | ~B: thm
val SS_Union_split =
   {}, 
   |- !(W : set)  (A : mem(Pow(W#)))  (B : mem(Pow(W#)))  (s : mem(Pow(W#))).
        SS(s#, Union(A#, B#)) <=>
        ?(s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
          SS(s1#, A#) & SS(s2#, B#) & s# = Union(s1#, s2#): thm
val Inter_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Empty(A#)) = Empty(A#):
   thm
val SS_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        SS(s#, Sing(a#)) <=> s# = Sing(a#) | s# = Empty(A#): thm
val Empty_Union =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(Empty(A#), s#) = s#: thm
val SS_Empty =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))). SS(s#, Empty(A#)) <=> s# = Empty(A#):
   thm
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val Union_assoc =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Union(Union(s1#, s2#), s3#) = Union(s1#, Union(s2#, s3#)): thm
val Inter_Whole_Whole =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Whole(A#) <=> s1# = Whole(A#) & s2# = Whole(A#):
   thm
val Union_SS1 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(Union(s1#, s2#), s#) <=> SS(s1#, s#) & SS(s2#, s#): thm
val SS_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s#, Inter(s1#, s2#)) <=> SS(s#, s1#) & SS(s#, s2#): thm
val Union_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        SS(Inter(s1#, s2#), s1#) & SS(Inter(s1#, s2#), s2#): thm
val Whole_SS =
   {}, 
   |- !(A : set)  (X : mem(Pow(A#))). SS(Whole(A#), X#) ==> X# = Whole(A#):
   thm
val SS_Whole = {},  |- !(A : set)  (X : mem(Pow(A#))). SS(X#, Whole(A#)): thm
val Sing_Ins_Empty =
   {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = Ins(a#, Empty(A#)): thm
val EMPTY_Empty_Whole =
   {},  |- !(A : set). EMPTY(A#) <=> Empty(A#) = Whole(A#): thm
val NOT_EMPTY = {},  |- !(A : set). ~EMPTY(A#) <=> ?(a : mem(A#)). T: thm
val NEQ_IN =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val PSS_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- PSS(s1, s2) <=> SS(s1, s2) & ~s1 = s2: thm
val PSS_alt =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) <=>
        SS(s1#, s2#) & ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val Inter_Compl =
   {},  |- !(A : set)  (a : mem(Pow(A#))). Inter(a#, Compl(a#)) = Empty(A#):
   thm
val neg_iff = {},  |- ~(A <=> B) <=> A & ~B | B & ~A: thm
val Union_Empty2 =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(s#, Empty(A#)) = s#: thm
val Inter_eq_Empty =
   {}, 
   |- !(W : set)  (s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
        Inter(s1#, s2#) = Empty(W#) <=> SS(s2#, Compl(s1#)): thm
val PSS_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) ==> SS(s1#, s2#): thm
val SS_BIGUNION =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(Pow(A#)))))
      (s0 : mem(Pow(Pow(A#)))).
        IN(s0#, ss#) & SS(s#, s0#) ==> SS(s#, BIGUNION(ss#)): thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val Del_def =
   {}, 
   |- !(X : set)  (s0 : mem(Pow(X#)))  (x0 : mem(X#))  (a : mem(X#)).
        IN(a#, Del(s0#, x0#)) <=> IN(a#, s0#) & ~a# = x0#: thm
val c31_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c31(abc) = Fst(abc): thm
val c32_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c32(abc) = Fst(Snd(abc)): thm
val c33_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c33(abc) = Snd(Snd(abc)): thm
val Del_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        ~IN(x0#, xs0#) ==> Del(Ins(x0#, xs0#), x0#) = xs0#: thm
val Ins_absorb =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        IN(x0#, xs0#) ==> Ins(x0#, xs0#) = xs0#: thm
val Ins_Del =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, s#) ==> Ins(a#, Del(s#, a#)) = s#: thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
        IMAGE(f#, ss#) = Empty(B#) <=> ss# = Empty(A#): thm
val NOTIN_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        ~IN(a#, s#) ==> Del(s#, a#) = s#: thm
val Inj_IMAGE_Del =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#)))
      (a : mem(A#)).
        Inj(f#) ==>
        IMAGE(f#, Del(ss#, a#)) = Del(IMAGE(f#, ss#), App(f#, a#)): thm
val disj_not_imp = {},  |- A | ~B <=> B ==> A: thm
val exists_forall = fn: string * sort -> thm
val exists_forall_th =
   {(A : set)},  |- (?(a : mem(A)). f0(a#)) <=> ~!(a : mem(A)). ~f0(a#): thm
val not_disj_imp = {},  |- ~B | A <=> B ==> A: thm
val set_NEQ =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). ~IN(a#, s1#) & IN(a#, s2#): thm
val Pa_Inj =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#)).
        Inj(f#) ==> !(B : set)  (g : fun(X#, B#)). Inj(Pa(g#, f#)): thm
val o_Inj_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_restrict =
   {}, 
   |- !(D : set)  (D0 : set)  (i1 : fun(D#, D0#)).
        Inj(i1#) ==>
        !(C : set)  (C0 : set)  (i2 : fun(C#, C0#)).
          Inj(i2#) ==>
          !(f0 : fun(D0#, C0#)).
            (!(d : mem(D#)).
                ?!(c : mem(C#)). App(f0# o i1#, d#) = App(i2#, c#)) ==>
            ?!(f : fun(D#, C#)). i2# o f# = f0# o i1#: thm
val SS_Del =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(Del(s#, a#), s#):
   thm
val Inj_o_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        Inj(g# o f#) ==> Inj(f#): thm
val SS_Ins_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#)))  (G : mem(Pow(A#))).
        SS(ss#, Ins(a#, G#)) ==> SS(Del(ss#, a#), G#): thm
val SOME_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (x2 : mem(X#)).
        SOME(x1#) = SOME(x2#) <=> x1# = x2#: thm
val option_xor =
   {}, 
   |- !(A : set)  (a1 : mem(A# + 1)).
        ~a1# = NONE(A#) <=> ?!(a0 : mem(A#)). a1# = SOME(a0#): thm
val NOT_true_iff_false =
   {},  |- !(tv : mem(1 + 1)). App(NOT, tv#) = true <=> tv# = false: thm
val SOME_NOTNONE = {},  |- !(X : set)  (x : mem(X#)). ~SOME(x#) = NONE(X#):
   thm
val OM_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- App(OM(f), NONE(A)) = NONE(B) &
      !(a : mem(A)). App(OM(f), SOME(a#)) = SOME(App(f, a#)): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val Diff_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Diff(s1#, s2#)) <=> IN(a#, s1#) & ~IN(a#, s2#): thm
val Inter_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        ~Inter(s#, Sing(a#)) = Empty(A#) <=> IN(a#, s#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val Diff_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Diff(s#, Empty(A#)) = s#: thm
val Diff_Empty_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Diff(s1#, s2#) = Empty(A#) <=> SS(s1#, s2#): thm
val Ins_Union =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Ins(a#, s#) = Union(Sing(a#), s#): thm
val Union_Empty_both_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Inter(s1#, Union(s2#, s3#)) = Union(Inter(s1#, s2#), Inter(s1#, s3#)):
   thm
val Inter_Diff_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Sing(x#)) = Empty(A#) <=>
        IN(x#, Diff(s1#, s2#)): thm
val Diff_Ins_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Ins(x#, s3#)) = Empty(A#) <=>
        ~Inter(Diff(s1#, s2#), s3#) = Empty(A#) | IN(x#, Diff(s1#, s2#)): thm
val Inter_Empty2 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Empty(A#) ==>
        !(a : mem(A#)). IN(a#, s2#) ==> ~IN(a#, s1#): thm
val Inter_both_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~Inter(s1#, s2#) = Empty(A#) ==> ~s1# = Empty(A#) & ~s2# = Empty(A#):
   thm
val neg_imp_conj = {},  |- ~(A ==> B) <=> A & ~B: thm
val forall_exists_dual =
   {},  |- !(A : set). (!(a : mem(A#)). P(a#)) <=> ~?(a : mem(A#)). ~P(a#):
   thm
val neg_conj_imp = {},  |- ~(A & B) <=> A ==> ~B: thm
val it = (): unit
******

Loading SEAR file SEARNarith.sml

******
val Nind's_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        IN(a#, Nind's(f0, x0)) <=> SS(App(Nindf(f0, x0), a#), a#): thm
val Nind_cases0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- App(Nindf(f0, x0), Ninds(f0, x0)) = Ninds(f0, x0): thm
val Nind_cases1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_incond =
   !(nx : mem(N * X)).
     IN(nx#, Nind1) <=>
     nx# = Pair(O, x0) |
     ?(nx0 : mem(N * X)).
       IN(nx0#, Nind0) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): form
val Nind_ind =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), ss#), ss#) ==> SS(Ninds(f0, x0), ss#): thm
val Nind_ind1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        (!(a : mem(N * X)).
            a# = Pair(O, x0) |
            (?(nx0 : mem(N * X)).
                IN(nx0#, ss#) & a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_rules0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- SS(App(Nindf(f0, x0), Ninds(f0, x0)), Ninds(f0, x0)): thm
val Nind_rules1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        a# = Pair(O, x0) |
        (?(nx0 : mem(N * X)).
            IN(nx0#, Ninds(f0, x0)) &
            a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
        IN(a#, Ninds(f0, x0)): thm
val Nind_rules2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (a# = Pair(O, x0) ==> IN(a#, Ninds(f0, x0))) &
        !(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))) ==>
          IN(a#, Ninds(f0, x0)): thm
val Nind_rules3 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nindf_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
        IN(nx#, App(Nindf(f0, x0), a#)) <=>
        nx# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nindf_ex =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(N * X), Pow(N * X))).
        !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
          IN(nx#, App(f#, a#)) <=>
          nx# = Pair(O, x0) |
          ?(nx0 : mem(N * X)).
            IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))):
   thm
val Nindf_monotone =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(N * X)))  (s2 : mem(Pow(N * X))).
        SS(s1#, s2#) ==> SS(App(Nindf(f0, x0), s1#), App(Nindf(f0, x0), s2#)):
   thm
val Ninds_SS =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), a#), a#) ==> SS(Ninds(f0, x0), a#): thm
val Ninds_cond =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (!(ss : mem(Pow(N * X))).
            SS(App(Nindf(f0, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Ninds(f0, x0)): thm
val Ninds_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- Ninds(f0, x0) = BIGINTER(Nind's(f0, x0)): thm
val x1 = "Nind0": string
val Nind_cases =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_rules =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nind_uex =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        ?!(x : mem(X#)). IN(Pair(n#, x#), Ninds(f0#, x0#)): thm
val Nrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (a : mem(N)).
        IN(Pair(a#, App(Nrec(x0#, f0#), a#)), Ninds(f0#, x0#)): thm
val Nrec_O =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        App(Nrec(x0#, f0#), O) = x0#: thm
val App_Nrec_Ninds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N))
      (x : mem(X#)).
        App(Nrec(x0#, f0#), n#) = x# <=> IN(Pair(n#, x#), Ninds(f0#, x0#)):
   thm
val Nrec_Suc =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        App(Nrec(x0#, f0#), Suc(n#)) = App(f0#, App(Nrec(x0#, f0#), n#)): thm
val Nrec_unique =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Nrec_Suc_eqn =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        Nrec(x0#, f0#) o SUC = f0# o Nrec(x0#, f0#): thm
val El_def = {},  |- !(A : set)  (a : mem(A#)). App(El(a#), dot) = a#: thm
val El_eq_eq =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). El(a#) = El(b#) <=> a# = b#:
   thm
val App_o_El =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(f#, a#) = App(f# o El(a#), dot): thm
val Nrec_El =
   {}, 
   |- !(X : set)  (a : mem(X#))  (f : fun(X#, X#)).
        Nrec(a#, f#) o El(O) = El(a#) &
        Nrec(a#, f#) o SUC = f# o Nrec(a#, f#) &
        !(u : fun(N, X#)).
          u# o El(O) = El(a#) & u# o SUC = f# o u# ==> u# = Nrec(a#, f#): thm
val App_El_mem =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(f#, a#) = b# <=> f# o El(a#) = El(b#): thm
val Nrec_O_SUC = {},  |- Nrec(O, SUC) = Id(N): thm
val comm_with_SUC_id0 =
   {}, 
   |- !(f : fun(N, N)). App(f#, O) = O & f# o SUC = SUC o f# ==> f# = Id(N):
   thm
val comm_with_SUC_id =
   {}, 
   |- !(f : fun(N, N)).
        f# o El(O) = El(O) & f# o SUC = SUC o f# ==> f# = Id(N): thm
val Thm1_case1_comm_condition =
   {}, 
   |- !(B : set)  (f0 : fun(N, B#))  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        f0# o El(O) = g# & f0# o SUC = h# o Pa(Id(N), f0#) <=>
        Pa(Id(N), f0#) o El(O) = Pa(El(O), g#) &
        Pa((SUC o p1(N, B#)), h#) o Pa(Id(N), f0#) = Pa(Id(N), f0#) o SUC:
   thm
val Dot_def = {},  |- !(A : set)  (f : fun(1, A#)). Dot(f#) = App(f#, dot):
   thm
val Dot_of_El = {},  |- !(A : set)  (a : mem(A#)). Dot(El(a#)) = a#: thm
val El_of_Dot = {},  |- !(X : set)  (f : fun(1, X#)). El(Dot(f#)) = f#: thm
val to_P_component =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#)).
        Pa(p1(A#, B#) o f#, p2(A#, B#) o f#) = f#: thm
val Thm1_case_1 =
   {}, 
   |- !(B : set)  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        ?!(f : fun(N, B#)). f# o El(O) = g# & f# o SUC = h# o Pa(Id(N), f#):
   thm
val is_Nrec =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Tp1_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(tpf : fun(1, Exp(A#, B#))). Tp(f# o p1(A#, 1)) = tpf#: thm
val Ev_of_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#)).
        Ev(A#, B#) o Pa(p1(A#, X#), Tp(f#) o p2(A#, X#)) = f#: thm
val Tp1_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Tp(f# o p1(A#, 1)) = Tp1(f#):
   thm
val Tp_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (g : fun(A# * X#, B#)). Tp(f#) = Tp(g#) <=> f# = g#: thm
val Ev_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, Exp(A#, B#)))
      (g : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), f# o p2(A#, X#)) = Ev(A#, B#) o
          Pa(p1(A#, X#), g# o p2(A#, X#)) ==> f# = g#: thm
val to_P_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#))
      (g : fun(X#, A# * B#)).
        p1(A#, B#) o f# = p1(A#, B#) o g# & p2(A#, B#) o f# = p2(A#, B#) o g# ==>
        f# = g#: thm
val Pa_o_split =
   {}, 
   |- !(B : set)  (X : set)  (f : fun(B#, X#))  (Y : set)  (g : fun(X#, Y#))
      (A : set).
        Pa(p1(A#, B#), g# o f# o p2(A#, B#)) =
          Pa(p1(A#, X#), (g# o p2(A#, X#))) o Pa(p1(A#, B#), f# o p2(A#, B#)):
   thm
val Thm1_comm_eq_left =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))  (g : fun(A#, B#)).
        Tp(f#) o El(O) = Tp1(g#) <=>
        f# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1): thm
val Pa_p1_p2 =
   {},  |- !(A : set)  (B : set). Pa(p1(A#, B#), p2(A#, B#)) = Id(A# * B#):
   thm
val Thm1_comm_eq_right =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))
      (h : fun((A# * N) * B#, B#))
      (l : fun(A# * N * Exp(A#, B#), (A# * N) * B#)).
        Pa(Pa(p1(A#, N * Exp(A#, B#)), p1(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#))), Ev(A#, B#) o
           Pa(p1(A#, N * Exp(A#, B#)), p2(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#)))) = l# ==>
        (h# o Pa(Id(A# * N), f#) = f# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
          Tp((h# o l#)) o Pa(Id(N), Tp(f#)) = Tp(f#) o SUC): thm
val Ev_of_Tp_el =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))  (P : set)
      (a : fun(P#, A#))  (x : fun(P#, X#)).
        Ev(A#, B#) o Pa(a#, Tp(f#) o x#) = f# o Pa(a#, x#): thm
val Ev_of_Tp_el' =
   {}, 
   |- !(A : set)  (B : set)  (P : set)  (f : fun(A# * P#, B#))
      (a : fun(P#, A#)). Ev(A#, B#) o Pa(a#, Tp(f#)) = f# o Pa(a#, Id(P#)):
   thm
val Tp_of_Ev =
   {(A : set), (B : set), (X : set), (f : fun(X, Exp(A, B)))}, 
   |- Tp(Ev(A, B) o Pa(p1(A, X), f o p2(A, X))) = f: thm
val Thm1 =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val Thm1_uex =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?!(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val PRE_def = {},  |- PRE o El(O) = El(O) & PRE o SUC = Id(N): thm
val Pre_def = {},  |- !(n : mem(N)). Pre(n#) = App(PRE, n#): thm
val Pre_eqn = {},  |- Pre(O) = O & !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val ADD_def =
   {}, 
   |- ADD o Pa(p1(N, 1), El(O) o To1(N * 1)) = p1(N, 1) &
      SUC o ADD = ADD o Pa(p1(N, N), SUC o p2(N, N)): thm
val Add_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Add(n1#, n2#) = App(ADD, Pair(n1#, n2#)):
   thm
val Add_O = {},  |- !(n : mem(N)). Add(n#, O) = n#: thm
val App_input_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a1 : mem(A#))
      (a2 : mem(A#)). a1# = a2# ==> App(f#, a1#) = App(f#, a2#): thm
val Add_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, Suc(n#)) = Suc(Add(m#, n#)):
   thm
val Pre_O = {},  |- Pre(O) = O: thm
val Pre_Suc = {},  |- !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val SUB_def =
   {}, 
   |- SUB o Pa(p1(N, 1), El(O) o p2(N, 1)) = p1(N, 1) &
      PRE o SUB = SUB o Pa(p1(N, N), SUC o p2(N, N)): thm
val o_eq_r =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        f1# = f2# ==> !(C : set)  (g : fun(B#, C#)). g# o f1# = g# o f2#: thm
val Sub_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Sub(n1#, n2#) = App(SUB, Pair(n1#, n2#)):
   thm
val Sub_O = {},  |- !(n : mem(N)). Sub(n#, O) = n#: thm
val Sub_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, Suc(n#)) = Pre(Sub(m#, n#)):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Le_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Pre_eq_O = {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O):
   thm
val Lt_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val Le_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val Lt_Le = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> Le(m#, n#):
   thm
val Lt_NE = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> ~m# = n#: thm
val Le_NE_Lt =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) & ~m# = n# ==> Lt(m#, n#):
   thm
val Lt_Le_NE =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val Sub_mono_eq =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(Suc(m#), Suc(n#)) = Sub(m#, n#):
   thm
val Add_Sub = {},  |- !(c : mem(N))  (a : mem(N)). Sub(Add(a#, c#), c#) = a#:
   thm
val Add_O2 = {},  |- !(n : mem(N)). Add(O, n#) = n#: thm
val Sub_EQ_O = {},  |- !(n : mem(N)). Sub(n#, n#) = O: thm
val Le_refl = {},  |- !(n : mem(N)). Le(n#, n#): thm
val Le_O_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val o_eq_l =
   {}, 
   |- !(B : set)  (C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
        g1# = g2# ==> !(A : set)  (f : fun(A#, B#)). g1# o f# = g2# o f#: thm
val Le_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) ==> Lt(m#, n#) | m# = n#:
   thm
val Le_Sub =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val cancel_Sub =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Le(a#, c#) ==> (Sub(b#, a#) = Sub(c#, a#) <=> b# = c#):
   thm
val th =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Sub_of_O = {},  |- !(n : mem(N)). Sub(O, n#) = O: thm
val O_LESS_EQ = {},  |- !(x : mem(N)). Le(O, x#): thm
val LESS_EQ_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val LESS_O = {},  |- !(n : mem(N)). Lt(O, Suc(n#)): thm
val LESS_MONO_EQ =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val LE_O_iff = {},  |- !(n : mem(N)). Le(n#, O) <=> n# = O: thm
val LESS_cases =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | Le(b#, a#): thm
val LESS_EQ_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) | Le(n#, m#): thm
val Add_Suc1 =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(Suc(a#), b#) = Suc(Add(a#, b#)):
   thm
val Add_comm =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(a#, b#) = Add(b#, a#): thm
val Suc_Sub = {},  |- !(n : mem(N)). Sub(Suc(n#), n#) = Suc(O): thm
val Sub_DIFF_1 =
   {},  |- !(a : mem(N))  (b : mem(N)). Sub(a#, b#) = Suc(O) <=> a# = Suc(b#):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Sub_Suc_O_cases =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, Suc(b#)) = O ==> a# = Suc(b#) | Sub(a#, b#) = O: thm
val Le_cases_iff =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) <=> Lt(a#, b#) | a# = b#:
   thm
val Lt_Suc_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Suc(b#)) <=> Le(a#, b#): thm
val Sub_EQ_O1 =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, n#) = O <=> Le(m#, n#): thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val strong_ind =
   {}, 
   |- (!(a : mem(N)). (!(a0 : mem(N)). Lt(a0#, a#) ==> P(a0#)) ==> P(a#)) ==>
      !(a : mem(N)). P(a#): thm
val WOP =
   {}, 
   |- !(a : mem(N)).
        P(a#) ==>
        ?(a0 : mem(N)). P(a0#) & !(a1 : mem(N)). P(a1#) ==> Le(a0#, a1#): thm
val MUL_def0 =
   {}, 
   |- MUL o Pa(p1(N, 1), El(O) o To1(N * 1)) = El(O) o To1(N * 1) &
      ADD o Pa(MUL, p1(N, N)) = MUL o Pa(p1(N, N), SUC o p2(N, N)): thm
val Mul_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Mul(n1#, n2#) = App(MUL, Pair(n1#, n2#)):
   thm
val App_Pa2 =
   {}, 
   |- !(A : set)  (B : set)  (D : set)  (g : fun(B#, D#))
      (ab : mem(A# * B#)).
        App(Pa(p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_p1_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p1(A#, B#), Pair(a#, b#)) = a#: thm
val App_p2_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p2(A#, B#), Pair(a#, b#)) = b#: thm
val Mul_O = {},  |- !(n : mem(N)). Mul(n#, O) = O: thm
val Mul_Suc =
   {}, 
   |- !(n : mem(N))  (n0 : mem(N)). Mul(n#, Suc(n0#)) = Add(Mul(n#, n0#), n#):
   thm
val Mul_LEFT_O = {},  |- !(m : mem(N)). Mul(O, m#) = O: thm
val Mul_LEFT_1 = {},  |- !(m : mem(N)). Mul(Suc(O), m#) = m#: thm
val Mul_RIGHT_1 = {},  |- !(m : mem(N)). Mul(m#, Suc(O)) = m#: thm
val Add_comm' =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(b#, a#) = Add(a#, b#): thm
val Add_assoc =
   {}, 
   |- !(m : mem(N))  (n0 : mem(N))  (p : mem(N)).
        Add(m#, Add(n0#, p#)) = Add(Add(m#, n0#), p#): thm
val Add_eq_eq =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (a : mem(N)).
        Add(m#, a#) = Add(n#, a#) ==> m# = n#: thm
val Mul_Suc1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Mul(Suc(n#), m#) = Add(m#, Mul(n#, m#)):
   thm
val Mul_clauses =
   {}, 
   |- (!(m : mem(N)).
          Mul(O, m#) = O &
          Mul(m#, O) = O & Mul(Suc(O), m#) = m# & Mul(m#, Suc(O)) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Mul(Suc(m#), n#) = Add(Mul(m#, n#), n#) &
        Mul(m#, Suc(n#)) = Add(m#, Mul(m#, n#)): thm
val Mul_comm =
   {},  |- !(m : mem(N))  (n : mem(N)). Mul(m#, n#) = Mul(n#, m#): thm
val Add_clauses =
   {}, 
   |- (!(m : mem(N)). Add(O, m#) = m# & Add(m#, O) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Add(Suc(m#), n#) = Suc(Add(m#, n#)) &
        Add(m#, Suc(n#)) = Suc(Add(m#, n#)): thm
val Nind_tac = fn: tactic
val RIGHT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Add(m#, n#), p#) = Add(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Add(m#, n#)) = Add(Mul(p#, m#), Mul(p#, n#)): thm
val Mul_assoc =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(m#, Mul(n#, p#)) = Mul(Mul(m#, n#), p#): thm
val Sub_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Sub(a#, Add(b#, c#)) = Sub(Sub(a#, b#), c#): thm
val Le_O_iff = {},  |- !(a : mem(N)). Le(a#, O) <=> a# = O: thm
val Le_Suc =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, Suc(b#)) ==> Le(a#, b#) | a# = Suc(b#): thm
val Le_Add_ex =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(n#, m#) ==> ?(p : mem(N)). Add(p#, n#) = m#: thm
val LE_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Sub(a#, b#) = O:
   thm
val LT_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Holds(LT, a#, b#) <=> Holds(LE, a#, b#) & ~a# = b#: thm
val LE_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Le(a#, b#): thm
val LT_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LT, a#, b#) <=> Lt(a#, b#): thm
val LE_Trans = {},  |- Trans(LE): thm
val LESS_MONO_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(m#, n#) <=> Lt(Add(m#, p#), Add(n#, p#)): thm
val EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val LESS_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(Add(m#, p#), Add(n#, p#)) <=> Lt(m#, n#): thm
val LESS_OR_EQ =
   {(m : mem(N)), (n : mem(N))},  |- Le(m, n) <=> Lt(m, n) | m = n: thm
val LESS_EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(Add(m#, p#), Add(n#, p#)) <=> Le(m#, n#): thm
val Le_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, c#) & Le(b#, d#) ==> Le(Add(a#, b#), Add(c#, d#)): thm
val Le_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Le(a1#, a2#) & Le(a2#, a3#) ==> Le(a1#, a3#): thm
val Asym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Asym(R#) <=>
        !(a : mem(A#))  (b : mem(A#)).
          Holds(R#, a#, b#) & Holds(R#, b#, a#) ==> a# = b#: thm
val Lt_Suc = {},  |- !(a : mem(N)). Lt(a#, Suc(a#)): thm
val Suc_NEQ = {},  |- !(a : mem(N)). ~a# = Suc(a#): thm
val Add_Suc_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Add(a#, Suc(b#))): thm
val LT_Trans = {},  |- Trans(LT): thm
val Lt_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Lt(a1#, a2#) & Lt(a2#, a3#) ==> Lt(a1#, a3#): thm
val LE_Asym = {},  |- Asym(LE): thm
val Le_Asym =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) ==> a# = b#:
   thm
val LESS_EQ_LESS_EQ_MONO =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N))  (q : mem(N)).
        Le(m#, p#) & Le(n#, q#) ==> Le(Add(m#, n#), Add(p#, q#)): thm
val Le_MONO_Mul =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(m#, n#) ==> Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul' =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(m#, n#) ==> !(p : mem(N)). Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Le(m#, i#) & Le(n#, j#) ==> Le(Mul(m#, n#), Mul(i#, j#)): thm
val Le_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val Le_O' = {},  |- !(x : mem(N)). Le(O, x#): thm
val Sub_Suc1 =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(b#, a#) ==> Sub(Suc(a#), b#) = Suc(Sub(a#, b#)): thm
val SUB_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Le(n#, m#) ==> Add(Sub(m#, n#), n#) = m#:
   thm
val ADD_EQ_SUB =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(n#, p#) ==> (Add(m#, n#) = p# <=> m# = Sub(p#, n#)): thm
val NOT_SUC_LESS_EQ_O = {},  |- !(n : mem(N)). ~Le(Suc(n#), O): thm
val NOT_SUC_LT_O = {},  |- !(n : mem(N)). ~Lt(Suc(n#), O): thm
val Lt_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val Lt_trichotomy =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | a# = b# | Lt(b#, a#):
   thm
val NEQ_O_Lt = {},  |- !(a : mem(N)). ~a# = O <=> Lt(O, a#): thm
val Add_eq_O =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, n#) = O <=> m# = O & n# = O:
   thm
val Mul_eq_O =
   {}, 
   |- !(a : mem(N)). ~a# = O ==> !(b : mem(N)). Mul(a#, b#) = O <=> b# = O:
   thm
val Sub_Sub_O_eq =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, b#) = O & Sub(b#, a#) = O ==> a# = b#: thm
val NOT_LESS =
   {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#): thm
val RIGHT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Sub(m#, n#), p#) = Sub(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Sub(m#, n#)) = Sub(Mul(p#, m#), Mul(p#, n#)): thm
val MULT_MONO_EQ =
   {}, 
   |- !(n : mem(N))  (m : mem(N))  (i : mem(N)).
        Mul(Suc(n#), m#) = Mul(Suc(n#), i#) <=> m# = i#: thm
val Mul_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        ~p# = O ==> (Mul(m#, p#) = Mul(n#, p#) <=> m# = n#): thm
val Lt_MONO_Mul =
   {}, 
   |- !(p : mem(N)).
        Lt(O, p#) ==>
        !(m : mem(N))  (n : mem(N)).
          Lt(m#, n#) ==> Lt(Mul(m#, p#), Mul(n#, p#)): thm
val Le_Lt_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Lt(a#, c#): thm
val Lt_O_Lt = {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) ==> Lt(O, b#):
   thm
val Lt_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Lt(m#, i#) & Lt(n#, j#) ==> Lt(Mul(m#, n#), Mul(i#, j#)): thm
val LESS_ADD_NONZERO =
   {},  |- !(m : mem(N))  (n : mem(N)). ~n# = O ==> Lt(m#, Add(m#, n#)): thm
val SUB_LESS =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Lt(O, n#) & Le(n#, m#) ==> Lt(Sub(m#, n#), m#): thm
val Add_leq =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (b : mem(N)).
        a1# = a2# ==> Add(a1#, b#) = Add(a2#, b#): thm
val Add_req =
   {}, 
   |- !(a : mem(N))  (b1 : mem(N))  (b2 : mem(N)).
        b1# = b2# ==> Add(a#, b1#) = Add(a#, b2#): thm
val Add_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, b#), Add(c#, d#)): thm
val Add_split_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(a#, Add(Add(b#, c#), d#)): thm
val Add_last_middle_split =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, d#), Add(b#, c#)): thm
val Add_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val Add_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (m : mem(N))  (n : mem(N)).
        Add(a#, m#) = Add(a#, n#) <=> m# = n#: thm
val Lt_Sub_O =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) <=> Lt(O, Sub(b#, a#)):
   thm
val Lt_Le_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(a#, b#) & Le(b#, c#) ==> Lt(a#, c#): thm
val LESS_EQ_SUC = {},  |- !(n : mem(N)). Le(n#, Suc(n#)): thm
val Le_Lt_Le =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Le(a#, c#): thm
val Add_Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(Add(a#, b#), Add(c#, d#)) = Add(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_Lt_Lt_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Lt(c#, d#) ==> Lt(Add(a#, c#), Add(b#, d#)): thm
val Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Add(a#, Add(b#, c#)) = Add(b#, Add(a#, c#)): thm
val NOT_LESS_EQ =
   {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
val SUC_NOT_LESS_EQ = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
val Lt_Le_Suc =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(b#, a#) <=> Le(Suc(b#), a#): thm
val Le_Le_iff_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) <=> a# = b#:
   thm
val Le_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Le(a#, b#) ==> Le(Sub(a#, c#), Sub(b#, c#)): thm
val Lt_imp_Sub_O =
   {(a : mem(N)), (b : mem(N))},  |- Lt(a, b) ==> Sub(a, b) = O: thm
val Lt_Sub_imp_Le =
   {(a : mem(N)), (b : mem(N)), (c : mem(N))}, 
   |- Lt(a, Sub(b, c)) ==> Le(c, b): thm
val Lt_MONO_Sub_hard_direction =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(Sub(a#, c#), Sub(b#, c#)) & Le(c#, a#) ==> Lt(a#, b#): thm
val Lt_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Lt(a#, b#) <=> Lt(Sub(a#, c#), Sub(b#, c#)): thm
val Add_Le = {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, Add(a#, b#)): thm
val Add_pos_Lt =
   {}, 
   |- !(a : mem(N)).
        Lt(O, a#) ==>
        !(b : mem(N))  (c : mem(N)). Add(a#, b#) = c# ==> Lt(b#, c#): thm
val Le_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Le(c#, d#) ==>
          Le(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val Lt_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Lt(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Lt(c#, d#) ==>
          Lt(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val num1_def = {},  |- num1 = Suc(O): thm
val num2_def = {},  |- num2 = Suc(num1): thm
val num3_def = {},  |- num3 = Suc(num2): thm
val num4_def = {},  |- num4 = Suc(num3): thm
val WOP' =
   {}, 
   |- !(s : mem(Pow(N))).
        ~s# = Empty(N) ==>
        ?(a0 : mem(N)).
          IN(a0#, s#) & !(a1 : mem(N)). IN(a1#, s#) ==> Le(a0#, a1#): thm
val division_theorem_N_ex0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Lt(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val division_theorem_N_ex =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Le(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val NOT_Lt_O_O = {},  |- ~Lt(O, O): thm
val it = (): unit
******

Loading SEAR file SEARZarith.sml

******
val ZR_def =
   {}, 
   |- !(x : mem(N))  (y : mem(N))  (u : mem(N))  (v : mem(N)).
        Holds(ZR, Pair(x#, y#), Pair(u#, v#)) <=> Add(x#, v#) = Add(u#, y#):
   thm
val ZR_Refl = {},  |- Refl(ZR): thm
val ZR_Trans = {},  |- Trans(ZR): thm
val ZR_Sym = {},  |- Sym(ZR): thm
val ZR_ER = {},  |- ER(ZR): thm
val Ri_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (s : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Ri(r#), s#)) <=>
        ?(a : mem(A#)). IN(a#, s#) & Holds(r#, a#, b#): thm
val Rsi_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#)). Rsi(r#) = Ri(r#) o Sg(A#):
   thm
val rsi_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (r : rel(A#, B#)).
        rsi(r#, a#) = App(Rsi(r#), a#): thm
val IN_rsi =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
val ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          (!(x : mem(A#)). Holds(r#, a1#, x#) <=> Holds(r#, a2#, x#)) <=>
          Holds(r#, a1#, a2#): thm
val rsi_eq_ER =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          rsi(r#, a1#) = rsi(r#, a2#) <=> Holds(r#, a1#, a2#): thm
val Z_def =
   {}, 
   |- Inj(iZ) &
      !(a : mem(Pow(N * N))).
        (?(n : mem(N * N)). a# = rsi(ZR, n#)) <=>
        ?(b : mem(Z)). a# = App(iZ, b#): thm
val iZ_Inj = {},  |- Inj(iZ): thm
val iZ_eq_eq =
   {}, 
   |- !(x1 : mem(Z))  (x2 : mem(Z)).
        App(iZ, x1#) = App(iZ, x2#) ==> x1# = x2#: thm
val iZ_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(m : mem(N))  (n : mem(N)). App(iZ, z#) = rsi(ZR, Pair(m#, n#)): thm
val rsi_iZ =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        ?(b : mem(Z)). rsi(ZR, Pair(m#, n#)) = App(iZ, b#): thm
val resp_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#)).
        resp(f#, r1#, r2#) <=>
        !(y : mem(A#))  (z : mem(A#)).
          Holds(r1#, y#, z#) ==> Holds(r2#, App(f#, y#), App(f#, z#)): thm
val rext_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a0 : mem(Pow(A#)))  (b0 : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a0#, b0#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a0# = rsi(r1#, a#) & b0# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val rext_def0 =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a : mem(Pow(A#)))  (b : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a#, b#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a# = rsi(r1#, a#) & b# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val prrel_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#))
      (a1 : mem(A#))  (b1 : mem(B#))  (a2 : mem(A#))  (b2 : mem(B#)).
        Holds(prrel(r1#, r2#), Pair(a1#, b1#), Pair(a2#, b2#)) <=>
        Holds(r1#, a1#, a2#) & Holds(r2#, b1#, b2#): thm
val main =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val ipow2_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (b : mem(B#))  (Q1 : set)
      (aq : mem(Q1#))  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (bq : mem(Q2#))
      (i2 : fun(Q2#, Pow(B#))).
        IN(Pair(a#, b#), App(ipow2(i1#, i2#), Pair(aq#, bq#))) <=>
        IN(a#, App(i1#, aq#)) & IN(b#, App(i2#, bq#)): thm
val addf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(addf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(a#, a'#), Add(b#, b''#)): thm
val prrel_ER_ER =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#)).
        ER(r1#) & ER(r2#) ==> ER(prrel(r1#, r2#)): thm
val Pow_conj_eq0 =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3#: thm
val Pow_conj_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3# & s2# = s4#: thm
val ipow2_Inj_Inj =
   {}, 
   |- !(Q1 : set)  (A : set)  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (B : set)
      (i2 : fun(Q2#, Pow(B#))).
        (!(q1 : mem(Q1#)). ?(a : mem(A#)). IN(a#, App(i1#, q1#))) &
        (!(q2 : mem(Q2#)). ?(b : mem(B#)). IN(b#, App(i2#, q2#))) &
        Inj(i1#) & Inj(i2#) ==> Inj(ipow2(i1#, i2#)): thm
val Quo_def =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quo(r#, i#) <=>
        !(s : mem(Pow(A#))).
          (?!(q : mem(Q#)). s# = App(i#, q#)) <=>
          ?(a : mem(A#)). s# = rsi(r#, a#): thm
val Inj_Quo =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Inj(i) &
      (!(s : mem(Pow(A))).
          (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#)) <=>
      Inj(i) & Quo(r, i): thm
val ER_rsi_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a : mem(A#)).
        ER(r#) ==> IN(a#, rsi(r#, a#)): thm
val Quo_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) & Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        Quo(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val Quo_fun =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val main_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val Inj_Quo_Z = {},  |- Inj(iZ) & Quo(ZR, iZ): thm
val Quo_fun_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val iZ_nonempty =
   {},  |- !(z : mem(Z)). ?(ab : mem(N * N)). IN(ab#, App(iZ, z#)): thm
val addf0_resp = {},  |- resp(addf0, prrel(ZR, ZR), ZR): thm
val addz_conds =
   {}, 
   |- ER(prrel(ZR, ZR)) &
      ER(ZR) &
      resp(addf0, prrel(ZR, ZR), ZR) &
      Inj(ipow2(iZ, iZ)) &
      Inj(iZ) & Quo(prrel(ZR, ZR), ipow2(iZ, iZ)) & Quo(ZR, iZ): thm
val main_addz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(addz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(addf0, a#) = b#: thm
val main_addz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(addz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val Inj_Quo_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Inj(i#) & Quo(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). App(i#, q#) = rsi(r#, a#): thm
val Z_has_rep =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). App(iZ, z#) = rsi(ZR, Pair(a'#, b#)):
   thm
val Addz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Addz(z1#, z2#) = App(addz, Pair(z1#, z2#)): thm
val Repz_def = {},  |- !(z : mem(Z)). Repz(z#) = App(iZ, z#): thm
val Repz_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = rsi(ZR, Pair(a'#, b#)): thm
val ZC_def = {},  |- !(ab : mem(N * N)). ZC(ab#) = rsi(ZR, ab#): thm
val Repz_ZC =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = ZC(Pair(a'#, b#)): thm
val Addz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Addz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val ZC_ZR =
   {}, 
   |- !(ab : mem(N * N))  (cd : mem(N * N)).
        ZC(ab#) = ZC(cd#) <=> Holds(ZR, ab#, cd#): thm
val Addz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Addz(z1#, z2#)) = ZC(Pair(Add(a1#, a3#), Add(a2#, a4#))): thm
val Repz_eq_eq =
   {},  |- !(x1 : mem(Z))  (x2 : mem(Z)). Repz(x1#) = Repz(x2#) ==> x1# = x2#:
   thm
val Repz_eq_ZR =
   {}, 
   |- !(a1 : mem(N * N))  (a2 : mem(N * N)).
        ZC(a1#) = ZC(a2#) <=> Holds(ZR, a1#, a2#): thm
val eq_ZR =
   {},  |- !(a : mem(N * N))  (b : mem(N * N)). a# = b# ==> Holds(ZR, a#, b#):
   thm
val Addz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Addz(z1#, z2#) = Addz(z2#, z1#):
   thm
val negf0_def =
   {},  |- !(a : mem(N * N)). App(negf0, a#) = Pair(Snd(a#), Fst(a#)): thm
val negf0_def1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). App(negf0, Pair(m#, n#)) = Pair(n#, m#):
   thm
val negf0_resp = {},  |- resp(negf0, ZR, ZR): thm
val Negz_def = {},  |- !(z : mem(Z)). Negz(z#) = App(negz, z#): thm
val main_negz =
   {(z : mem(Z))}, 
   |- ?(a : mem(N * N))  (b : mem(N * N)).
        Repz(z) = ZC(a#) & Repz(App(negz, z)) = ZC(b#) & App(negf0, a#) = b#:
   thm
val Negz_char =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = ZC(Pair(a#, b#)) ==> Repz(Negz(z#)) = ZC(Pair(b#, a#)):
   thm
val main_negz1 =
   {(z : mem(Z))}, 
   |- ?(a1' : mem(N))  (a2' : mem(N)).
        Repz(z) = ZC(Pair(a1'#, a2'#)) & Repz(Negz(z)) = ZC(Pair(a2'#, a1'#)):
   thm
val mulf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(mulf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(Mul(a#, a'#), Mul(b#, b''#)),
           Add(Mul(a#, b''#), Mul(b#, a'#))): thm
val mulf0_resp = {},  |- resp(mulf0, prrel(ZR, ZR), ZR): thm
val main_mulz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(mulz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(mulf0, a#) = b#: thm
val main_mulz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(mulz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
           Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Mulz(z1#, z2#) = App(mulz, Pair(z1#, z2#)): thm
val Mulz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Mulz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Mulz(z1#, z2#)) =
            ZC(Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
              Add(Mul(a1#, a4#), Mul(a2#, a3#)))): thm
val ZC_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        ?!(z : mem(Z)). Repz(z#) = ZC(Pair(a#, b#)): thm
val ZC_Repz' =
   {},  |- !(ab : mem(N * N)). ?!(z : mem(Z)). Repz(z#) = ZC(ab#): thm
val absz_def =
   {}, 
   |- !(a' : mem(N))  (b : mem(N))  (b : mem(Z)).
        App(absz, Pair(a'#, b#)) = b# <=> Repz(b#) = ZC(Pair(a'#, b#)): thm
val Absz_def = {},  |- !(ab : mem(N * N)). Absz(ab#) = App(absz, ab#): thm
val Asz_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Asz(a#, b#) = Absz(Pair(a#, b#)): thm
val Zc_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Zc(a#, b#) = ZC(Pair(a#, b#)): thm
val Absz_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Repz(Absz(Pair(a#, b#))) = ZC(Pair(a#, b#)): thm
val Asz_Repz =
   {},  |- !(a : mem(N))  (b : mem(N)). Repz(Asz(a#, b#)) = Zc(a#, b#): thm
val Oz_def = {},  |- Oz = Asz(O, O): thm
val En_def = {},  |- En = Suc(O): thm
val Ez_def = {},  |- Ez = Asz(En, O): thm
val Addz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Addz(z1#, z2#)) = Zc(Add(a1#, a3#), Add(a2#, a4#)): thm
val Addz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Addz(Asz(a#, b#), Asz(c#, d#)) = Asz(Add(a#, c#), Add(b#, d#)): thm
val Mulz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Mulz(z1#, z2#)) =
            Zc(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))): thm
val Mulz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Mulz(Asz(a#, b#), Asz(c#, d#)) =
          Asz(Add(Mul(a#, c#), Mul(b#, d#)), Add(Mul(a#, d#), Mul(b#, c#))):
   thm
val Negz_th0 =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) ==> Repz(Negz(z#)) = Zc(b#, a#): thm
val Negz_Asz =
   {},  |- !(a : mem(N))  (b : mem(N)). Negz(Asz(a#, b#)) = Asz(b#, a#): thm
val cases_z =
   {},  |- !(z : mem(Z)). ?(a : mem(N))  (b : mem(N)). z# = Asz(a#, b#): thm
val Addz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Addz(Addz(z1#, z2#), z3#) = Addz(z1#, Addz(z2#, z3#)): thm
val casesz =
   {}, 
   |- (!(a : mem(N))  (b : mem(N)). P(Asz(a#, b#))) <=> !(z : mem(Z)). P(z#):
   thm
SEARZarith.sml:1213: warning: Matches are not exhaustive. Found near fn [th0] => dimp_mp_l2r th0 th
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val casez_tac = fn: cont * form list * form -> goal list * validation
val Asz_eq_ZR =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Asz(a#, b#) = Asz(c#, d#) <=> Holds(ZR, Pair(a#, b#), Pair(c#, d#)):
   thm
val Addz_Negz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Negz(z#)) = Oz: thm
val Mulz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Mulz(z1#, z2#), z3#) = Mulz(z1#, Mulz(z2#, z3#)): thm
val LDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(z1#, Addz(z2#, z3#)) = Addz(Mulz(z1#, z2#), Mulz(z1#, z3#)): thm
val Mulz_Ez = {},  |- !(z : mem(Z)). Mulz(z#, Ez) = z#: thm
val Mulz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Mulz(z1#, z2#) = Mulz(z2#, z1#):
   thm
val RDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Addz(z2#, z3#), z1#) = Addz(Mulz(z2#, z1#), Mulz(z3#, z1#)): thm
val le0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b' : mem(N)).
        le0(Pair(a#, b#), Pair(a'#, b'#)) <=> Le(Add(a#, b'#), Add(b#, a'#)):
   thm
val Lez_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) <=>
        !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
          Repz(z1#) = Zc(a#, b#) & Repz(z2#) = Zc(c#, d#) ==>
          Le(Add(a#, d#), Add(b#, c#)): thm
val LEz_def =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Holds(LEz, a#, b#) <=> Lez(a#, b#):
   thm
val LEz_Refl = {},  |- Refl(LEz): thm
val Repz_Zc =
   {}, 
   |- !(z : mem(Z)). ?(a' : mem(N))  (b : mem(N)). Repz(z#) = Zc(a'#, b#):
   thm
val LEz_Trans = {},  |- Trans(LEz): thm
val LEz_Asym = {},  |- Asym(LEz): thm
val Total_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Total(R#) <=>
        !(a : mem(A#))  (b : mem(A#)). Holds(R#, a#, b#) | Holds(R#, b#, a#):
   thm
val Lez_resp0 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N))  (e : mem(N))
      (f : mem(N))  (g : mem(N))  (h : mem(N)).
        Holds(ZR, Pair(a#, b#), Pair(c#, d#)) &
        Holds(ZR, Pair(e#, f#), Pair(g#, h#)) ==>
        (Le(Add(a#, f#), Add(b#, e#)) <=> Le(Add(c#, h#), Add(d#, g#))): thm
val LEz_Total = {},  |- Total(LEz): thm
val Lez_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Lez(Asz(a#, b#), Asz(c#, d#)) <=> Le(Add(a#, d#), Add(b#, c#)): thm
val Lez_Addz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) ==> !(z3 : mem(Z)). Lez(Addz(z1#, z3#), Addz(z2#, z3#)):
   thm
val Lez_Mulz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Lez(z1#, z2#) & Lez(Oz, z3#) ==> Lez(Mulz(z1#, z3#), Mulz(z2#, z3#)):
   thm
val EVEN_def =
   {}, 
   |- (!(a : mem(1)). App(EVEN, O) = true) &
      !(a : mem(N)). App(EVEN, Suc(a#)) = App(NOT, App(EVEN, a#)): thm
val Even_def = {(n : mem(N))},  |- Even(n) <=> App(EVEN, n) = true: thm
val O_Even = {},  |- Even(O): thm
val Suc_Even = {},  |- !(n : mem(N)). Even(Suc(n#)) <=> ~Even(n#): thm
val Even_not_Odd = {},  |- !(n : mem(N)). Even(n#) <=> ~Odd(n#): thm
val Odd_def = {(n : mem(N))},  |- Odd(n) <=> ~Even(n): thm
val Odd_not_Even = {},  |- !(n : mem(N)). Odd(n#) <=> ~Even(n#): thm
val id_ER = {},  |- !(A : set). ER(id(A#)): thm
val Sg_Inj = {},  |- !(A : set). Inj(Sg(A#)): thm
val Quo_id_Sg = {},  |- !(A : set). Quo(id(A#), Sg(A#)): thm
val Pow_conj_eq' =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (s1 : mem(Pow(A#)))  (B : set)
      (b0 : mem(B#))  (s2 : mem(Pow(B#))).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        !(s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#))).
          (!(a : mem(A#))  (b : mem(B#)).
              IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) <=>
          s1# = s3# & s2# = s4#: thm
val Repz_iff_Asz =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) <=> Asz(a#, b#) = z#: thm
val ipow2_prrel_ZR =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N)), (z1 : mem(Z)),
    (z2 : mem(Z))}, 
   |- App(ipow2(iZ, iZ), Pair(z1, z2)) =
        rsi(prrel(ZR, ZR), Pair(Pair(a, b), Pair(c, d))) <=>
      Asz(a, b) = z1 & Asz(c, d) = z2: thm
val Asz_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, b#) = Asz(a#, c#) <=> b# = c#: thm
val Ltz_def =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Lez(a#, b#) & ~a# = b#:
   thm
val N2Z_def = {},  |- !(a : mem(N)). App(N2Z, a#) = Asz(a#, O): thm
val n2z_def = {},  |- !(n : mem(N)). n2z(n#) = App(N2Z, n#): thm
val Asz_eq_eq_l =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, c#) = Asz(b#, c#) <=> a# = b#: thm
val N2Z_Inj = {},  |- Inj(N2Z): thm
val Repz_eq_eq_iff =
   {(x1 : mem(Z)), (x2 : mem(Z))},  |- Repz(x1) = Repz(x2) <=> x1 = x2: thm
val prove_dimp_th = fn: thm -> thm
val Abv_positive_ex0 =
   {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> ?(n : mem(N)). Asz(n#, O) = z#: thm
val Lez_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Lez(Negz(z#), Negz(b#)) <=> Lez(b#, z#):
   thm
val Negz_eq_eq =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Negz(z#) = Negz(b#) <=> z# = b#: thm
val Negz_Oz = {},  |- Negz(Oz) = Oz: thm
val Abv_negative_ex0 =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> ?(n : mem(N)). Asz(O, n#) = z#: thm
val Lez_dichotomy =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Lez(z#, b#) | Lez(b#, z#): thm
val Ltz_Asz =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N))}, 
   |- Ltz(Asz(a, b), Asz(c, d)) <=> Lt(Add(a, d), Add(b, c)): thm
val NOT_Lez_Ltz =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Lez(z#, b#) <=> Ltz(b#, z#): thm
val Abv_def =
   {}, 
   |- !(z : mem(Z)).
        Lez(Oz, z#) & Asz(Abv(z#), O) = z# |
        Ltz(z#, Oz) & Asz(O, Abv(z#)) = z#: thm
val Abv_nonneg = {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> Asz(Abv(z#), O) = z#:
   thm
val Abv_uex =
   {}, 
   |- !(z : mem(Z)).
        ?!(n : mem(N)).
          Lez(Oz, z#) & Asz(n#, O) = z# | Ltz(z#, Oz) & Asz(O, n#) = z#: thm
val n2z_Abv = {},  |- !(a : mem(Z)). Lez(Oz, a#) ==> n2z(Abv(a#)) = a#: thm
val Oz_Mulz = {},  |- !(z : mem(Z)). Mulz(Oz, z#) = Oz: thm
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val Oz_Ltz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, Oz) & Ltz(b#, Oz) ==> Ltz(Oz, Mulz(z#, b#)): thm
val int1_NONZERO = {},  |- ~int1 = Oz: thm
val int1_def = {},  |- int1 = n2z(Suc(O)): thm
val Negz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Negz(Mulz(z#, b#)):
   thm
val Ltz_Addz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, b#) <=> Ltz(Addz(z#, Negz(b#)), Oz): thm
val Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(z#, Negz(b#)) = Negz(Mulz(z#, b#)):
   thm
val Mulz_int1 = {},  |- !(z : mem(Z)). Mulz(z#, int1) = z#: thm
val Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) ==> Lez(z#, b#): thm
val n2z_Oz_Lez = {},  |- !(a : mem(N)). Lez(Oz, n2z(a#)): thm
val Negz_Addz_Oz = {},  |- !(z : mem(Z)). Addz(Negz(z#), z#) = Oz: thm
val Lez_Addz_ex =
   {}, 
   |- !(z : mem(Z))  (m : mem(Z)).
        Lez(z#, m#) ==> ?(p : mem(Z)). Lez(Oz, p#) & Addz(p#, z#) = m#: thm
val Lez_Addz_2 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Lez(z#, c#) & Lez(b#, d#) ==> Lez(Addz(z#, b#), Addz(c#, d#)): thm
val Oz_Lez_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(Oz, z#) & Lez(Oz, b#) ==>
        Lez(z#, Addz(z#, b#)) & Lez(b#, Addz(z#, b#)): thm
val Oz_Ltz_Addz =
   {}, 
   |- !(z : mem(Z)). Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(b#, Addz(z#, b#)):
   thm
val int1_Asz = {},  |- int1 = Asz(Suc(O), O): thm
val Ltz_int1_Lez_Oz = {},  |- !(z : mem(Z)). Ltz(int1, z#) ==> Lez(Oz, z#):
   thm
val Lez_Oz_Addz_Lez =
   {}, 
   |- !(z : mem(Z)). Lez(z#, Oz) ==> !(a : mem(Z)). Lez(Addz(a#, z#), a#):
   thm
val Lez_Ltz_TRANS_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(z#, c#): thm
val Ltz_trans =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(a#, c#): thm
val NOT_Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Ltz(z#, b#) <=> Lez(b#, z#): thm
val Addz_Rarr =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = c# <=> z# = Addz(c#, Negz(b#)): thm
val Addz_eq_eq =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = Addz(z#, c#) <=> b# = c#: thm
val Negz_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Negz(Addz(z#, b#)) = Addz(Negz(z#), Negz(b#)): thm
val Lez_cases =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) <=> Ltz(a#, b#) | a# = b#:
   thm
val Lez_refl = {},  |- !(a : mem(Z)). Lez(a#, a#): thm
val Lez_REFL = {},  |- !(z : mem(Z)). Lez(z#, z#): thm
val Oz_Lez_int1 = {},  |- Lez(Oz, int1): thm
val Oz_Ltz_int1 = {},  |- Ltz(Oz, int1): thm
val Ltz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(Negz(z#), Negz(b#)) <=> Ltz(b#, z#):
   thm
val NEQ_Ltz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). ~a# = b# <=> Ltz(a#, b#) | Ltz(b#, a#):
   thm
val Ltz_iff_Lez_int1 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) <=> Lez(Addz(z#, int1), b#):
   thm
val Negz_Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Mulz(z#, Negz(b#)):
   thm
val Oz_Addz = {},  |- !(z : mem(Z)). Addz(Oz, z#) = z#: thm
val Addz_eq_eq' =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(a#, c#) = Addz(b#, c#) <=> a# = b#: thm
val between_int1_Oz =
   {},  |- !(z : mem(Z)). Ltz(Negz(int1), z#) & Ltz(z#, int1) <=> z# = Oz:
   thm
val Addz_Negz_Oz_eq =
   {}, 
   |- !(z : mem(Z))  (z2 : mem(Z)). Addz(z#, Negz(z2#)) = Oz <=> z# = z2#:
   thm
val Negz_Negz = {},  |- !(z : mem(Z)). Negz(Negz(z#)) = z#: thm
val Ltz_iff_O_Ltz_Sub =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) <=> Ltz(Oz, Addz(b#, Negz(a#))): thm
val Ltz_Ltz_Mulz_Ltz =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, Mulz(z#, b#)) ==> Ltz(Oz, b#):
   thm
val Ltz_Ltz_Mulz_pos =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, b#) ==> Ltz(Oz, Mulz(z#, b#)):
   thm
val Mulz_Ltz_Ltz =
   {}, 
   |- !(a : mem(Z)).
        Ltz(Oz, a#) ==>
        !(b : mem(Z))  (c : mem(Z)).
          Ltz(Mulz(a#, b#), Mulz(a#, c#)) <=> Ltz(b#, c#): thm
val Ltz_Oz_Lez_int1 = {},  |- !(z : mem(Z)). Ltz(Oz, z#) <=> Lez(int1, z#):
   thm
val Addz_Rarr_both_sides =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Addz(z#, b#) = Addz(c#, d#) <=>
        Addz(d#, Negz(b#)) = Addz(z#, Negz(c#)): thm
val Lez_Ltz_Addz_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==>
        !(c : mem(Z))  (d : mem(Z)).
          Ltz(c#, d#) ==> Ltz(Addz(z#, c#), Addz(b#, d#)): thm
val Mulz_Negz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), Negz(b#)) = Mulz(z#, b#):
   thm
val Lez_asym =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) & Lez(b#, a#) ==> a# = b#:
   thm
val Ltz_NOT_Ltz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) ==> ~Ltz(b#, a#): thm
val Abv_Negz = {},  |- !(z : mem(Z)). Abv(Negz(z#)) = Abv(z#): thm
val Abv_Oz = {},  |- Abv(Oz) = O: thm
val n2z_Abv_Negz =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> n2z(Abv(z#)) = Negz(z#): thm
val n2z_is_Abv =
   {},  |- !(n : mem(N))  (z : mem(Z)). n2z(n#) = z# ==> n# = Abv(z#): thm
val Le_Abv_Abv =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Lez(Oz, a#) & Lez(Oz, b#) ==> (Le(Abv(a#), Abv(b#)) <=> Lez(a#, b#)):
   thm
val division_theorem_ex0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_ex1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val Lez_trans =
   {}, 
   |- !(a1 : mem(Z))  (a2 : mem(Z))  (a3 : mem(Z)).
        Lez(a1#, a2#) & Lez(a2#, a3#) ==> Lez(a1#, a3#): thm
val division_theorem_ex =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?(q : mem(Z))  (r : mem(Z)).
            a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_unique0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem_unique1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        ?!(qr : mem(Z * Z)).
          a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
          Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val DIVRz_def =
   {}, 
   |- !(a : mem(Z * Z)).
        Snd(a#) = Oz & App(DIVRz, a#) = Pair(Oz, Oz) |
        ~Snd(a#) = Oz &
        Fst(a#) =
          Addz(Mulz(Fst(App(DIVRz, a#)), Snd(a#)), Snd(App(DIVRz, a#))) &
        Lez(Oz, Snd(App(DIVRz, a#))) &
        Ltz(Snd(App(DIVRz, a#)), n2z(Abv(Snd(a#)))): thm
val Divrz_Oz =
   {}, 
   |- !(d : mem(Z)). d# = Oz ==> !(a : mem(Z)). Divrz(a#, d#) = Pair(Oz, Oz):
   thm
val Divrz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divrz(a, d) = App(DIVRz, Pair(a, d)):
   thm
val Divrz_property0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        d# = Oz & Divrz(a#, d#) = Pair(Oz, Oz) |
        ~d# = Oz &
        a# = Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) &
        Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divrz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) = a# &
          Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divz_Remz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Divz(a#, d#), d#), Remz(a#, d#)) = a# &
          Lez(Oz, Remz(a#, d#)) & Ltz(Remz(a#, d#), n2z(Abv(d#))): thm
val Divz_Remz_Oz =
   {},  |- !(a : mem(Z)). Divz(a#, Oz) = Oz & Remz(a#, Oz) = Oz: thm
val Divz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divz(a, d) = Fst(Divrz(a, d)): thm
val Remz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Remz(a, d) = Snd(Divrz(a, d)): thm
val Subz_Addz =
   {},  |- !(m : mem(Z))  (n : mem(Z)). Addz(Subz(m#, n#), n#) = m#: thm
val Subz_def =
   {(a : mem(Z)), (b : mem(Z))},  |- Subz(a, b) = Addz(a, Negz(b)): thm
val Mulz_Oz = {},  |- !(z : mem(Z)). Mulz(z#, Oz) = Oz: thm
val Oz_Ltz_Negz = {},  |- !(a : mem(Z)). Ltz(Oz, a#) <=> Ltz(Negz(a#), Oz):
   thm
val Ltz_Oz_Negz = {},  |- !(a : mem(Z)). Ltz(a#, Oz) <=> Ltz(Oz, Negz(a#)):
   thm
val Mulz_Ltz_Ltz_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(Mulz(a#, b#), Oz) <=>
        Ltz(Oz, a#) & Ltz(b#, Oz) | Ltz(Oz, b#) & Ltz(a#, Oz): thm
val Mulz_Oz_iff_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Mulz(a#, b#) = Oz <=> a# = Oz | b# = Oz:
   thm
val Divz_Remz_unique =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z))  (q : mem(Z))  (r : mem(Z)).
          Addz(Mulz(q#, d#), r#) = a# & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))) ==>
          q# = Divz(a#, d#) & r# = Remz(a#, d#): thm
val division_theorem' =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?!(qr : mem(Z * Z)).
            a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
            Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val Ltz_Subz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Ltz(Oz, Subz(b#, a#)):
   thm
val Subz_Ltz =
   {}, 
   |- !(a : mem(Z)). Ltz(Oz, a#) ==> !(b : mem(Z)). Ltz(Subz(b#, a#), b#):
   thm
val int1_Mulz = {},  |- !(z : mem(Z)). Mulz(int1, z#) = z#: thm
val Addz_Subz_Rarr =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(Addz(a#, b#), Subz(c#, b#)) = Addz(a#, c#): thm
val Divz_pos_Remz =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(Oz, a#) & Ltz(Oz, d#) ==> Ltz(Remz(a#, d#), d#): thm
val n2z_eq_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). n2z(a#) = n2z(b#) <=> a# = b#: thm
val n2z_Asz = {},  |- !(n : mem(N)). n2z(n#) = Asz(n#, O): thm
val n2z_Oz = {},  |- n2z(O) = Oz: thm
val Lez_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Lez(n2z(a#), n2z(b#)) <=> Le(a#, b#):
   thm
val Ltz_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Ltz(n2z(a#), n2z(b#)) <=> Lt(a#, b#):
   thm
val Oz_Lez_n2z = {},  |- !(n : mem(N)). Lez(Oz, n2z(n#)): thm
val Mulz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Mulz(n2z(a#), n2z(b#)) = n2z(Mul(a#, b#)):
   thm
val Addz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Addz(n2z(a#), n2z(b#)) = n2z(Add(a#, b#)):
   thm
val n2z_Oz_O = {},  |- !(n : mem(N)). n2z(n#) = Oz <=> n# = O: thm
val Le_num1_Lt_O = {},  |- !(a : mem(N)). Le(num1, a#) <=> Lt(O, a#): thm
val division_theorem_N_uex =
   {}, 
   |- !(d : mem(N)).
        Le(num1, d#) ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val qfun_compr = fn: term frag list -> term frag list -> thm
******

Loading SEAR file quo.sml

******
val resp1_def =
   {(A : set), (B : set), (R : rel(A, A)), (f : fun(A, B))}, 
   |- resp1(f, R) <=> resp(f, R, id(B)): thm
val resp1_property =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (R : rel(A#, A#)).
        resp1(f#, R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> App(f#, a1#) = App(f#, a2#): thm
val Inj_INV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          ?!(ivf : fun(B#, A#)).
            ivf# o f# = Id(A#) &
            !(b : mem(B#)).
              (!(a : mem(A#)). ~App(f#, a#) = b#) ==> App(ivf#, b#) = a0#:
   thm
val Abs_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- Abs(r, i, q0) = LINV(i, q0) o Rsi(r): thm
val Inj_LINV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(a : mem(A#)). LINV(f#, a#) o f# = Id(A#): thm
val LINV_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          LINV(f#, a0#) o f# = Id(A#) &
          !(b : mem(B#)).
            (!(a : mem(A#)). ~App(f#, a#) = b#) ==>
            App(LINV(f#, a0#), b#) = a0#: thm
val Quot_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Quot(r, i) <=>
      Inj(i) &
      !(s : mem(Pow(A))).
        (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#):
   thm
val abs_def =
   {(A : set), (Q : set), (a : mem(A)), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- abs(r, i, q0, a) = App(Abs(r, i, q0), a): thm
val eth = {(A : set), (B : set), (a0 : mem(A))},  |- ?(f : fun(B, A)). T: thm
val fname = "LINV": string
val fun_mem_ex =
   {},  |- !(A : set)  (a0 : mem(A#))  (B : set). ?(f : fun(B#, A#)). T: thm
val qvl =
   [[QUOTE " (*#loc 80 35*)f:A->B"], [QUOTE " (*#loc 80 48*)a0:mem(A)"]]:
   term frag list list
val uexth0 =
   {(A : set), (B : set), (a0 : mem(A)), (f : fun(A, B))}, Inj(f)
   |- ?!(ivf : fun(B, A)).
        ivf# o f = Id(A) &
        !(b : mem(B)).
          (!(a : mem(A)). ~App(f, a#) = b#) ==> App(ivf#, b#) = a0: thm
val Abs_Surj =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==> !(q0 : mem(Q#)). Surj(Abs(r#, i#, q0#)): thm
val Quot_ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            App(i#, q1#) = rsi(r#, a1#) & App(i#, q2#) = rsi(r#, a2#) ==>
            (Holds(r#, a1#, a2#) <=> q1# = q2#): thm
val Quot_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            abs(r#, i#, q0#, a1#) = abs(r#, i#, q0#, a2#) <=>
            Holds(r#, a1#, a2#): thm
val Quot_UMP =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        !(B : set)  (f : fun(A#, B#)).
          resp1(f#, R#) ==>
          !(Q : set)  (i : fun(Q#, Pow(A#))).
            Quot(R#, i#) ==>
            !(q0 : mem(Q#)).
              ?!(fb : fun(Q#, B#)).
                !(a : mem(A#)). App(fb#, abs(R#, i#, q0#, a#)) = App(f#, a#):
   thm
val Quot_Quo =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) <=> Inj(i#) & Quo(r#, i#): thm
val ER_Quot_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). IN(a#, App(i#, q#)): thm
val Quot_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        Quot(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val abs_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        !(q1 : mem(Q1#))  (q2 : mem(Q2#))  (a : mem(A#))  (b : mem(B#)).
          abs(prrel(r1#, r2#), ipow2(i1#, i2#), Pair(q1#, q2#), Pair(a#, b#)) =
            Pair(abs(r1#, i1#, q1#, a#), abs(r2#, i2#, q2#, b#)): thm
val Rep_of_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(q0 : mem(Q#))  (a : mem(A#)).
          App(i#, abs(r#, i#, q0#, a#)) = rsi(r#, a#): thm
val Quot_rsi_uex =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). App(i#, q#) = rsi(r#, a#): thm
val ER_Quot_rsi_char =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q : mem(Q#))  (a : mem(A#)).
            IN(a#, App(i#, q#)) <=> App(i#, q#) = rsi(r#, a#): thm
val Quot_IN_BIGUNION_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            ?(a : mem(Q#)). IN(a#, s#) & abs(r#, i#, q0#, ra#) = a#: thm
val Quot_IN_BIGUNION_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            IN(abs(r#, i#, q0#, ra#), s#): thm
val Quot_el_same =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#)).
            q1# = q2# <=>
            ?(a1 : mem(A#))  (a2 : mem(A#)).
              IN(a1#, App(i#, q1#)) &
              IN(a2#, App(i#, q2#)) & Holds(r#, a1#, a2#): thm
val ER_Quot_has_mem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val ER_Quot_has_umem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val it = (): unit
val NONZERO_O_Lt = {},  |- !(n : mem(N)). ~n# = O <=> Lt(O, n#): thm
val DIVR_def =
   {}, 
   |- !(a : mem(N * N)).
        Snd(a#) = O & App(DIVR, a#) = Pair(O, O) |
        ~Snd(a#) = O &
        Fst(a#) = Add(Mul(Fst(App(DIVR, a#)), Snd(a#)), Snd(App(DIVR, a#))) &
        Lt(Snd(App(DIVR, a#)), Snd(a#)): thm
val Divr_O =
   {},  |- !(d : mem(N)). d# = O ==> !(a : mem(N)). Divr(a#, d#) = Pair(O, O):
   thm
val Divr_def =
   {(a : mem(N)), (d : mem(N))},  |- Divr(a, d) = App(DIVR, Pair(a, d)): thm
val Divr_property0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        d# = O & Divr(a#, d#) = Pair(O, O) |
        ~d# = O &
        a# = Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) &
        Lt(Snd(Divr(a#, d#)), d#): thm
val Z2N_def = {},  |- Z2N = LINV(N2Z, O): thm
val Divr_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) = a# &
          Lt(Snd(Divr(a#, d#)), d#): thm
val Div2_def = {(n : mem(N))},  |- Div2(n) = Div(n, num2): thm
val Div_Rem_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Div(a#, d#), d#), Rem(a#, d#)) = a# & Lt(Rem(a#, d#), d#):
   thm
val Div_def = {(a : mem(N)), (d : mem(N))},  |- Div(a, d) = Fst(Divr(a, d)):
   thm
val Rem_def = {(a : mem(N)), (d : mem(N))},  |- Rem(a, d) = Snd(Divr(a, d)):
   thm
val num2_NONZERO = {},  |- ~num2 = O: thm
val Mul_num2 = {},  |- !(a : mem(N)). Mul(num2, a#) = Add(a#, a#): thm
val Div_Rem_num2 =
   {}, 
   |- !(a : mem(N)).
        Add(Mul(Div2(a#), num2), Rem(a#, num2)) = a# &
        Lt(Rem(a#, num2), num2): thm
val Div_Rem_unique =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N))  (q : mem(N))  (r : mem(N)).
          Add(Mul(q#, d#), r#) = a# & Lt(r#, d#) ==>
          q# = Div(a#, d#) & r# = Rem(a#, d#): thm
val division_theorem_N_uex' =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val Div_Rem_Mul =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)). Div(Mul(d#, a#), d#) = a# & Rem(Mul(d#, a#), d#) = O:
   thm
val Div2_Mul = {},  |- !(n : mem(N)). Div2(Mul(num2, n#)) = n#: thm
val num1_Lt_num2 = {},  |- Lt(num1, num2): thm
val Div2_Suc_Mul_num2 =
   {}, 
   |- !(n : mem(N)).
        Div2(Suc(Mul(num2, n#))) = n# & Rem(Suc(Mul(num2, n#)), num2) = num1:
   thm
val Even_Suc = {},  |- !(a : mem(N)). Even(Suc(a#)) <=> ~Even(a#): thm
val num2_Mul_Even = {},  |- !(a : mem(N)). Even(Mul(num2, a#)): thm
val Suc_num2_Mul_Odd = {},  |- !(a : mem(N)). Odd(Suc(Mul(num2, a#))): thm
val O_Even = {},  |- Even(O): thm
val O_NEQ_num1 = {},  |- ~O = num1: thm
val O_NEQ_num2 = {},  |- ~O = num2: thm
val O_NEQ_num3 = {},  |- ~O = num3: thm
val O_NEQ_num4 = {},  |- ~O = num4: thm
val num1_NEQ_num4 = {},  |- ~num1 = num4: thm
val num1_NEQ_num3 = {},  |- ~num1 = num3: thm
val num1_NEQ_num2 = {},  |- ~num1 = num2: thm
val num2_NEQ_num3 = {},  |- ~num2 = num3: thm
val num2_NEQ_num4 = {},  |- ~num2 = num4: thm
val num4_NEQ_num3 = {},  |- ~num4 = num3: thm
val Div_of_O = {},  |- !(n : mem(N)). Div(O, n#) = O & Rem(O, n#) = O: thm
val Even_Sub_num2 = {},  |- !(a : mem(N)). Even(a#) ==> Even(Sub(a#, num2)):
   thm
val Odd_num1 = {},  |- Odd(num1): thm
val Lt_num2 = {},  |- !(a : mem(N)). Lt(a#, num2) <=> a# = O | a# = num1: thm
val Even_Div2 =
   {}, 
   |- !(a : mem(N)).
        Even(a#) <=> Mul(Div2(a#), num2) = a# & Rem(a#, num2) = O: thm
val Odd_Div2 =
   {}, 
   |- !(a : mem(N)).
        Odd(a#) <=> Suc(Mul(Div2(a#), num2)) = a# & Rem(a#, num2) = num1: thm
val it = (): unit
******

Loading SEAR file SEARFiniteness.sml

******
val FI's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). IN(a#, FI's(X)) <=> SS(App(FIf(X), a#), a#):
   thm
val FI_cases0 = {(X : set)},  |- App(FIf(X), FIs(X)) = FIs(X): thm
val FI_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_incond =
   !(xs : mem(Pow(X))).
     IN(xs#, FIs1) <=>
     xs# = Empty(X) |
     ?(xs0 : mem(Pow(X)))  (x : mem(X)). IN(xs0#, FIs0) & xs# = Ins(x#, xs0#):
   form
val FI_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> SS(FIs(X), ss#):
   thm
val FI_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        (!(a : mem(Pow(X))).
            a# = Empty(X) |
            (?(xs0 : mem(Pow(X)))  (x : mem(X)).
                IN(xs0#, ss#) & a# = Ins(x#, xs0#)) ==> IN(a#, ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_rules0 = {(X : set)},  |- SS(App(FIf(X), FIs(X)), FIs(X)): thm
val FI_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        a# = Empty(X) |
        (?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#)) ==> IN(a#, FIs(X)): thm
val FI_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (a# = Empty(X) ==> IN(a#, FIs(X))) &
        !(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#) ==> IN(a#, FIs(X)): thm
val FI_rules3 =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val FIf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
        IN(xs#, App(FIf(X), a#)) <=>
        xs# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X)), Pow(Pow(X)))).
        !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
          IN(xs#, App(f#, a#)) <=>
          xs# = Empty(X) |
          ?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X))))  (s2 : mem(Pow(Pow(X)))).
        SS(s1#, s2#) ==> SS(App(FIf(X), s1#), App(FIf(X), s2#)): thm
val FIs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). SS(App(FIf(X), a#), a#) ==> SS(FIs(X), a#):
   thm
val FIs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (!(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, FIs(X)): thm
val FIs_def = {(X : set)},  |- FIs(X) = BIGINTER(FI's(X)): thm
val x1 = "FIs0": string
val FI_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_rules =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val Fin_def =
   {},  |- !(X : set)  (A : mem(Pow(X#))). Fin(A#) <=> IN(A#, FIs(X#)): thm
val Cd's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))).
        IN(a#, Cd's(X)) <=> SS(App(Cdf(X), a#), a#): thm
val Cd_cases0 = {(X : set)},  |- App(Cdf(X), Cds(X)) = Cds(X): thm
val Cd_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_incond =
   !(xsn : mem(Pow(X) * N)).
     IN(xsn#, Cds1) <=>
     xsn# = Pair(Empty(X), O) |
     ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
       IN(xsn0#, Cds0) &
       ~IN(x#, Fst(xsn0#)) &
       xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): form
val Cd_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        SS(App(Cdf(X), ss#), ss#) ==> SS(Cds(X), ss#): thm
val Cd_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        (!(a : mem(Pow(X) * N)).
            a# = Pair(Empty(X), O) |
            (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
                IN(xsn0#, ss#) &
                ~IN(x#, Fst(xsn0#)) &
                a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_rules0 = {(X : set)},  |- SS(App(Cdf(X), Cds(X)), Cds(X)): thm
val Cd_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        a# = Pair(Empty(X), O) |
        (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, Cds(X)) &
            ~IN(x#, Fst(xsn0#)) &
            a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
        IN(a#, Cds(X)): thm
val Cd_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (a# = Pair(Empty(X), O) ==> IN(a#, Cds(X))) &
        !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))) ==> IN(a#, Cds(X)):
   thm
val Cd_rules3 =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cdf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
        IN(xsn#, App(Cdf(X), a#)) <=>
        xsn# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, a#) &
          ~IN(x#, Fst(xsn0#)) &
          xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X) * N), Pow(Pow(X) * N))).
        !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
          IN(xsn#, App(f#, a#)) <=>
          xsn# = Pair(Empty(X), O) |
          ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, a#) &
            ~IN(x#, Fst(xsn0#)) &
            xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X) * N)))  (s2 : mem(Pow(Pow(X) * N))).
        SS(s1#, s2#) ==> SS(App(Cdf(X), s1#), App(Cdf(X), s2#)): thm
val Cds_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))). SS(App(Cdf(X), a#), a#) ==> SS(Cds(X), a#):
   thm
val Cds_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (!(ss : mem(Pow(Pow(X) * N))).
            SS(App(Cdf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, Cds(X)):
   thm
val Cds_def = {(X : set)},  |- Cds(X) = BIGINTER(Cd's(X)): thm
val x1 = "Cds0": string
val Cd_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_rules =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cds_ind =
   {}, 
   |- !(X : set)  (ss : mem(Pow(Pow(X#) * N))).
        IN(Pair(Empty(X#), O), ss#) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            IN(Pair(xs0#, n0#), ss#) & ~IN(x#, xs0#) ==>
            IN(Pair(Ins(x#, xs0#), Suc(n0#)), ss#)) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> IN(Pair(xs#, n#), ss#): thm
val Cd_induct0 =
   {}, 
   |- !(X : set).
        P(Pair(Empty(X#), O)) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(Pair(xs0#, n0#)) & ~IN(x#, xs0#) ==>
            P(Pair(Ins(x#, xs0#), Suc(n0#)))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(Pair(xs#, n#)): thm
val Cd_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(xs#, n#): thm
val Fin_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#)) &
        (!(xs0 : mem(Pow(X#)))  (x : mem(X#)). P(xs0#) ==> P(Ins(x#, xs0#))) ==>
        !(xs : mem(Pow(X#))). Fin(xs#) ==> P(xs#): thm
val Cdr_def =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) <=> IN(Pair(xs#, n#), Cds(X#)): thm
val Cdr_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)). Cdr(xs#, n#) ==> P(xs#, n#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs0#, n#) ==>
        !(x : mem(X#)). ~IN(x#, xs0#) ==> Cdr(Ins(x#, xs0#), Suc(n#)): thm
val Ins_NONEMPTY =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs : mem(Pow(X#))).
        ~Ins(x0#, xs#) = Empty(X#): thm
val IN_Ins_SND =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (x : mem(X#)).
        IN(x#, Ins(x0#, xs0#)) & ~x# = x0# ==> IN(x#, xs0#): thm
val Cdr_Empty_unique =
   {},  |- !(X : set)  (n : mem(N)). Cdr(Empty(X#), n#) ==> n# = O: thm
val Del_Ins_SWAP =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        ~x0# = x# ==>
        !(xs : mem(Pow(X#))). Del(Ins(x0#, xs#), x#) = Ins(x0#, Del(xs#, x#)):
   thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(Ins(x0#, xs0#), n#) <=>
        ?(a : mem(Pow(X#)))  (b : mem(N))  (x : mem(X#)).
          Cdr(a#, b#) &
          ~IN(x#, a#) & Ins(x0#, xs0#) = Ins(x#, a#) & n# = Suc(b#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) ==>
        Cdr(xs#, n#) &
        !(x : mem(X#)). IN(x#, xs#) ==> Cdr(Del(xs#, x#), Pre(n#)): thm
val Fin_Card =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> ?!(n : mem(N)). Cdr(xs#, n#): thm
val CARD_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        Holds(CARD(X#), a#, b#) <=> Fin(a#) & Cdr(a#, b#) | ~Fin(a#) & b# = O:
   thm
val CARD_unique =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        ?!(n : mem(N)). Holds(CARD(X#), xs#, n#): thm
val Cd0_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        App(Cd0(X#), a#) = b# <=> Holds(CARD(X#), a#, b#): thm
val Card_def =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Card(xs#) = App(Cd0(X#), xs#):
   thm
val Del_Empty =
   {},  |- !(X : set)  (x : mem(X#)). Del(Empty(X#), x#) = Empty(X#): thm
val Ins_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (s1 : mem(Pow(A#)))  (a2 : mem(A#))
      (s2 : mem(Pow(A#))).
        ~IN(a1#, s1#) &
        ~IN(a2#, s2#) &
        ~IN(a1#, s2#) & ~IN(a2#, s1#) & Ins(a1#, s1#) = Ins(a2#, s2#) ==>
        a1# = a2# & s1# = s2#: thm
val Fin_Empty = {},  |- !(X : set). Fin(Empty(X#)): thm
val Fin_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#))).
        Fin(xs0#) ==> !(x : mem(X#)). Fin(Ins(x#, xs0#)): thm
val Fin_Ins_Ins =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Fin(Ins(a1#, Ins(a2#, Empty(A#)))): thm
val Fin_Del0 =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> Fin(xs#) & !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Fin_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Card_Fin =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(n : mem(N)). Card(xs#) = n# <=> Cdr(xs#, n#): thm
val Card_Empty = {},  |- !(X : set). Card(Empty(X#)) = O: thm
val Cdr_Card =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Fin(xs#) ==> Cdr(xs#, Card(xs#)):
   thm
val Card_Ins =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). ~IN(x#, xs#) ==> Card(Ins(x#, xs#)) = Suc(Card(xs#)):
   thm
val Card_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). IN(x#, xs#) ==> Card(Del(xs#, x#)) = Pre(Card(xs#)):
   thm
val IN_App_IMAGE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        IN(a#, s#) ==>
        !(B : set)  (f : fun(A#, B#)). IN(App(f#, a#), IMAGE(f#, s#)): thm
val Fin_SS =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Fin(s#) ==> !(t : mem(Pow(A#))). SS(t#, s#) ==> Fin(t#): thm
val Fin_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(Union(s1#, s2#)) <=> Fin(s1#) & Fin(s2#): thm
val Ins_Ins_Fin =
   {(A : set), (s1 : mem(A)), (s2 : mem(A))}, 
   |- Fin(Ins(s1, Ins(s2, Empty(A)))): thm
val Fin_Sing = {},  |- !(A : set)  (a : mem(A#)). Fin(Sing(a#)): thm
val it = (): unit
******

Loading SEAR file SEARList.sml

******
val isL's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        IN(a#, isL's(X)) <=> SS(App(isLf(X), a#), a#): thm
val isL_cases0 = {(X : set)},  |- App(isLf(X), isLs(X)) = isLs(X): thm
val isL_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_incond =
   !(ls : mem(Pow(N * X))).
     IN(ls#, isLs1) <=>
     ls# = Empty(N * X) |
     ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
       IN(ls0#, isLs0) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): form
val isL_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), ss#), ss#) ==> SS(isLs(X), ss#): thm
val isL_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        (!(a : mem(Pow(N * X))).
            a# = Empty(N * X) |
            (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
                IN(ls0#, ss#) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_rules0 = {(X : set)},  |- SS(App(isLf(X), isLs(X)), isLs(X)): thm
val isL_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        a# = Empty(N * X) |
        (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
        IN(a#, isLs(X)): thm
val isL_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (a# = Empty(N * X) ==> IN(a#, isLs(X))) &
        !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#) ==>
          IN(a#, isLs(X)): thm
val isL_rules3 =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val isLf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
        IN(ls#, App(isLf(X), a#)) <=>
        ls# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(N * X)), Pow(Pow(N * X)))).
        !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
          IN(ls#, App(f#, a#)) <=>
          ls# = Empty(N * X) |
          ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(N * X))))  (s2 : mem(Pow(Pow(N * X)))).
        SS(s1#, s2#) ==> SS(App(isLf(X), s1#), App(isLf(X), s2#)): thm
val isLs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), a#), a#) ==> SS(isLs(X), a#): thm
val isLs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (!(ss : mem(Pow(Pow(N * X)))).
            SS(App(isLf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isLs(X)):
   thm
val isLs_def = {(X : set)},  |- isLs(X) = BIGINTER(isL's(X)): thm
val x1 = "isLs0": string
val isL_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_rules =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val List_def =
   {}, 
   |- !(X : set).
        Inj(iL(X#)) &
        !(a : mem(Pow(N * X#))).
          IN(a#, isLs(X#)) <=> ?(b : mem(List(X#))). a# = App(iL(X#), b#):
   thm
val iL_Inj = {},  |- !(X : set). Inj(iL(X#)): thm
val isL_def =
   {},  |- !(X : set)  (l : mem(Pow(N * X#))). isL(l#) <=> IN(l#, isLs(X#)):
   thm
val isL_induct =
   {}, 
   |- !(X : set).
        P(Empty(N * X#)) &
        (!(ls0 : mem(Pow(N * X#)))  (x : mem(X#)).
            P(ls0#) ==> P(Ins(Pair(Card(ls0#), x#), ls0#))) ==>
        !(l : mem(Pow(N * X#))). isL(l#) ==> P(l#): thm
val isL_Empty = {},  |- !(X : set). isL(Empty(N * X#)): thm
val isL_Ins =
   {}, 
   |- !(X : set)  (ls0 : mem(Pow(N * X#))).
        isL(ls0#) ==> !(x : mem(X#)). isL(Ins(Pair(Card(ls0#), x#), ls0#)):
   thm
val Repl_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Repl(l#) = App(iL(X#), l#): thm
val Nil_def = {},  |- !(X : set). Repl(Nil(X#)) = Empty(N * X#): thm
val cons0_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- cons0(x, l) = Ins(Pair(Card(l), x), l): thm
val cons1_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- App(cons1(X), Pair(x, l)) = Ins(Pair(Card(l), x), l): thm
val iL_isL = {},  |- !(X : set)  (l : mem(List(X#))). isL(App(iL(X#), l#)):
   thm
val isL_Repl =
   {}, 
   |- !(X : set)  (a : mem(Pow(N * X#))).
        isL(a#) <=> ?(b : mem(List(X#))). a# = Repl(b#): thm
val CONS_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Ins(Pair(Card(Repl(l#)), x#), Repl(l#)) =
          Repl(App(CONS(X#), Pair(x#, l#))): thm
val lift_cond2 =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val lift_cond2' =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?!(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val Cons_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Cons(x#, l#) = App(CONS(X#), Pair(x#, l#)): thm
val Repl_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Repl(Cons(x#, l#)) = Ins(Pair(Card(Repl(l#)), x#), Repl(l#)): thm
val Repl_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(List(X#)))  (l2 : mem(List(X#))).
        Repl(l1#) = Repl(l2#) <=> l1# = l2#: thm
val Cons_NONNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(List(X#))). ~Cons(x#, l#) = Nil(X#):
   thm
val Repl_Empty_uex =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        Repl(l#) = Empty(N * X#) <=> l# = Nil(X#): thm
val List_induct =
   {}, 
   |- !(X : set).
        P(Nil(X#)) &
        (!(l : mem(List(X#))). P(l#) ==> !(x : mem(X#)). P(Cons(x#, l#))) ==>
        !(l : mem(List(X#))). P(l#): thm
val Fin_Repl = {},  |- !(X : set)  (l : mem(List(X#))). Fin(Repl(l#)): thm
val isL_Card_NOTIN0 =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (n : mem(N))  (x : mem(X#)).
        IN(Pair(n#, x#), Repl(l#)) ==> Lt(n#, Card(Repl(l#))): thm
val CONS_Inj = {},  |- !(X : set). Inj(CONS(X#)): thm
val Cons_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (l1 : mem(List(X#)))  (x2 : mem(X#))
      (l2 : mem(List(X#))).
        Cons(x1#, l1#) = Cons(x2#, l2#) <=> x1# = x2# & l1# = l2#: thm
val Cons_or_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        l# = Nil(X#) |
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Cons_xor_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        ~l# = Nil(X#) <=>
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Lind's_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        IN(a#, Lind's(a0, f0)) <=> SS(App(Lindf(a0, f0), a#), a#): thm
val Lind_cases0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- App(Lindf(a0, f0), Linds(a0, f0)) = Linds(a0, f0): thm
val Lind_cases1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_incond =
   !(p : mem(List(X) * A)).
     IN(p#, Lind1) <=>
     p# = Pair(Nil(X), a0) |
     ?(p0 : mem(List(X) * A))  (x : mem(X)).
       IN(p0#, Lind0) &
       p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): form
val Lind_ind =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), ss#), ss#) ==> SS(Linds(a0, f0), ss#): thm
val Lind_ind1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        (!(a : mem(List(X) * A)).
            a# = Pair(Nil(X), a0) |
            (?(p0 : mem(List(X) * A))  (x : mem(X)).
                IN(p0#, ss#) &
                a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_rules0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- SS(App(Lindf(a0, f0), Linds(a0, f0)), Linds(a0, f0)): thm
val Lind_rules1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        a# = Pair(Nil(X), a0) |
        (?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, Linds(a0, f0)) &
            a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
        IN(a#, Linds(a0, f0)): thm
val Lind_rules2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (a# = Pair(Nil(X), a0) ==> IN(a#, Linds(a0, f0))) &
        !(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))) ==>
          IN(a#, Linds(a0, f0)): thm
val Lind_rules3 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lindf_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
        IN(p#, App(Lindf(a0, f0), a#)) <=>
        p# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, a#) &
          p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_ex =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- ?!(f : fun(Pow(List(X) * A), Pow(List(X) * A))).
        !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Nil(X), a0) |
          ?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, a#) &
            p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_monotone =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(s1 : mem(Pow(List(X) * A)))  (s2 : mem(Pow(List(X) * A))).
        SS(s1#, s2#) ==> SS(App(Lindf(a0, f0), s1#), App(Lindf(a0, f0), s2#)):
   thm
val Linds_SS =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), a#), a#) ==> SS(Linds(a0, f0), a#): thm
val Linds_cond =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (!(ss : mem(Pow(List(X) * A))).
            SS(App(Lindf(a0, f0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Linds(a0, f0)): thm
val Linds_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- Linds(a0, f0) = BIGINTER(Lind's(a0, f0)): thm
val x1 = "Lind0": string
val Lind_cases =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_rules =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lind_uex =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#))). ?!(a : mem(A#)). IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_def =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (a : mem(List(X#))).
        IN(Pair(a#, App(Lrec(a0#, f0#), a#)), Linds(a0#, f0#)): thm
val Lrec_Nil =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        App(Lrec(a0#, f0#), Nil(X#)) = a0#: thm
val App_Lrec_Linds =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (a : mem(A#)).
        App(Lrec(a0#, f0#), l#) = a# <=> IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_Cons =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (x : mem(X#)).
        App(Lrec(a0#, f0#), Cons(x#, l#)) =
          App(f0#, Pair(x#, App(Lrec(a0#, f0#), l#))): thm
val Lrec_unique =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f : fun(X# * A#, A#))
      (r : fun(List(X#), A#)).
        App(r#, Nil(X#)) = a0# & r# o CONS(X#) = f# o Prla(Id(X#), r#) ==>
        r# = Lrec(a0#, f#): thm
val Lrec_Cons_eqn =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        Lrec(a0#, f0#) o CONS(X#) = f0# o Prla(Id(X#), Lrec(a0#, f0#)): thm
val LENGTH_def = {},  |- !(X : set). LENGTH(X#) = Lrec(O, SUC o p2(X#, N)):
   thm
val Length_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Length(l#) = App(LENGTH(X#), l#):
   thm
val Length_Nil = {},  |- !(X : set). Length(Nil(X#)) = O: thm
val Length_Cons =
   {}, 
   |- !(A : set)  (a : mem(A#))  (l : mem(List(A#))).
        Length(Cons(a#, l#)) = Suc(Length(l#)): thm
val HD_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        App(HD(X#), Cons(x#, l#)) = SOME(x#): thm
val HD_Nil = {(X : set)},  |- App(HD(X), Nil(X)) = NONE(X): thm
val HD_def =
   {},  |- !(X : set). HD(X#) = Lrec(NONE(X#), i1(X#, 1) o p1(X#, X# + 1)):
   thm
val Hd_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Hd(Cons(x#, l#)) = SOME(x#): thm
val Hd_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Hd(l#) = App(HD(X#), l#): thm
val TL_Nil = {(X : set)},  |- App(TL(X), Nil(X)) = Nil(X): thm
val TL_def =
   {}, 
   |- !(X : set)  (a : mem(List(X#))).
        a# = Nil(X#) & App(TL(X#), a#) = Nil(X#) |
        ~a# = Nil(X#) & ?(x : mem(X#)). a# = Cons(x#, App(TL(X#), a#)): thm
val TL_ex =
   {(X : set)}, 
   |- !(l : mem(List(X))).
        ?!(tl : mem(List(X))).
          l# = Nil(X) & tl# = Nil(X) |
          ~l# = Nil(X) & ?(x : mem(X)). l# = Cons(x#, tl#): thm
val TL_Cons =
   {(X : set)}, 
   |- !(x : mem(X))  (tl : mem(List(X))). App(TL(X), Cons(x#, tl#)) = tl#:
   thm
val ELn_Nil = {(X : set)},  |- App(ELn(X), O) = Tpm(HD(X)): thm
val ELn_def =
   {(X : set)}, 
   |- ELn(X) = Nrec(Tpm(HD(X)), Ap1(MO(List(X), List(X), X + 1), Tpm(TL(X)))):
   thm
val Eln_Map =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(n : mem(N))  (l : mem(List(X))).
        Lt(n#, Length(l#)) ==> Eln(n#, Map(f, l#)) = App(OM(f), Eln(n#, l#)):
   thm
val Eln_O = {(X : set)},  |- !(a : mem(List(X))). Eln(O, a#) = Hd(a#): thm
val Eln_Suc =
   {(X : set)}, 
   |- !(n : mem(N))  (a : mem(List(X))). Eln(Suc(n#), a#) = Eln(n#, Tl(a#)):
   thm
val Eln_def =
   {(X : set), (l : mem(List(X))), (n : mem(N))}, 
   |- Eln(n, l) = App(tof(App(ELn(X), n)), l): thm
val MAP_Cons =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(l : mem(List(X)))  (x : mem(X)).
        App(MAP(f), Cons(x#, l#)) = Cons(App(f, x#), App(MAP(f), l#)): thm
val MAP_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        App(MAP(f#), Nil(X#)) = Nil(Y#): thm
val MAP_def =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        MAP(f#) = Lrec(Nil(Y#), CONS(Y#) o Prla(f#, Id(List(Y#)))): thm
val MO_def =
   {(A : set), (B : set), (C : set), (fm : mem(Exp(A, B))),
    (gm : mem(Exp(B, C)))},  |- App(MO(A, B, C), Pair(gm, fm)) = mo(gm, fm):
   thm
val Map_Cons =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#))  (l : mem(List(X#)))
      (x : mem(X#)). Map(f#, Cons(x#, l#)) = Cons(App(f#, x#), Map(f#, l#)):
   thm
val Map_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)). Map(f#, Nil(X#)) = Nil(Y#):
   thm
val Map_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (Y : set)  (f : fun(X#, Y#)).
        Map(f#, l#) = App(MAP(f#), l#): thm
val Tl_Cons =
   {}, 
   |- !(X : set)  (x : mem(X#))  (tl : mem(List(X#))).
        Tl(Cons(x#, tl#)) = tl#: thm
val Tl_Nil = {},  |- !(X : set). Tl(Nil(X#)) = Nil(X#): thm
val Tl_def = {(X : set), (l : mem(List(X)))},  |- Tl(l) = App(TL(X), l): thm
val mo_def =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (C : set)
      (g : mem(Exp(B#, C#))). mo(g#, f#) = Tpm(tof(g#) o tof(f#)): thm
val it = (): unit
******

Loading SEAR file SEARfm.sml

******
val InjA_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjA(A#), a#)) <=> a# = SOME(a#): thm
val InjN_def =
   {}, 
   |- !(A : set)  (a : mem(N))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjN(A#), a#)) <=> n# = a#: thm
val InjUU0_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * A)))  (b : mem(Pow(N * A)))  (n : mem(N))
      (a : mem(A)).
        IN(Pair(n#, a#), App(InjUU0(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val injUU0_char =
   {}, 
   |- (!(n : mem(N)).
          Even(n#) ==>
          !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
          (a : mem(A#)).
            IN(Pair(n#, a#), injUU0(u1#, u2#)) <=>
            IN(Pair(Div2(n#), a#), u1#)) &
      !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val injUU0_def =
   {(A : set), (u1 : mem(Pow(N * A))), (u2 : mem(Pow(N * A)))}, 
   |- injUU0(u1, u2) = App(InjUU0(A), Pair(u1, u2)): thm
val InjUU0_Inj = {},  |- !(A : set). Inj(InjUU0(A#)): thm
val injUU0_Even =
   {}, 
   |- !(n : mem(N)).
        Even(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u1#):
   thm
val injUU0_Odd =
   {}, 
   |- !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val F0_def = {(A : set)},  |- F0(A) = injN(A, O): thm
val InjA_Inj = {},  |- !(A : set). Inj(InjA(A#)): thm
val InjUU_Inj = {},  |- !(A : set). Inj(InjUU(A#)): thm
val InjUU_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * (A + 1))))  (b : mem(Pow(N * (A + 1))))
      (n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), App(InjUU(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val InjUU_def0 = {},  |- !(A : set). InjUU(A#) = InjUU0(A# + 1): thm
val injA_def = {(A : set), (a : mem(A))},  |- injA(a) = App(InjA(A), a): thm
val injN_def = {(A : set), (n : mem(N))},  |- injN(A, n) = App(InjN(A), n):
   thm
val VAR0_Inj = {},  |- !(A : set). Inj(VAR0(A#)): thm
val VAR0_def =
   {(A : set)}, 
   |- VAR0(A) = InjUU(A) o Pa(El(injN(A, num1)) o To1(A), InjA(A)): thm
val NEG0_Inj = {},  |- !(A : set). Inj(NEG0(A#)): thm
val NEG0_def =
   {(A : set)}, 
   |- NEG0(A) = InjUU(A) o
        Pa(El(injN(A, num2)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Var0_def = {(A : set), (a : mem(A))},  |- Var0(a) = App(VAR0(A), a): thm
val DISJ0_Inj = {},  |- !(A : set). Inj(DISJ0(A#)): thm
val DISJ0_def =
   {(A : set)}, 
   |- DISJ0(A) = InjUU(A) o
        Pa(El(injN(A, num3)) o To1(Pow((N * (A + 1))) * Pow(N * (A + 1))),
         InjUU(A)): thm
val Neg0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- Neg0(f0) = App(NEG0(A), f0):
   thm
val DIAM0_Inj = {},  |- !(A : set). Inj(DIAM0(A#)): thm
val DIAM0_def =
   {(A : set)}, 
   |- DIAM0(A) = InjUU(A) o
        Pa(El(injN(A, num4)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Disj0_def =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- Disj0(f1, f2) = App(DISJ0(A), Pair(f1, f2)): thm
val Diam0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- Diam0(f0) = App(DIAM0(A), f0): thm
val f =
   (nas = F0 ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_cl =
   (nas = F0(A) ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_incond =
   !(nas : mem(Pow(N * (A + 1)))).
     IN(nas#, isfms1) <=>
     nas# = F0(A) |
     (?(p : mem(A)). nas# = Var0(p#)) |
     (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Neg0(f0#)) |
     (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
         IN(f1#, isfms0) & IN(f2#, isfms0) & nas# = Disj0(f1#, f2#)) |
     ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Diam0(f0#): form
val x1 = "isfms0": string
val isfmf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(Pow(N * (A + 1))), Pow(Pow(N * (A + 1))))).
        !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
          IN(nas#, App(f#, a#)) <=>
          nas# = F0(A) |
          (?(p : mem(A)). nas# = Var0(p#)) |
          (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
          (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
              IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
          ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
        IN(nas#, App(isfmf(A), a#)) <=>
        nas# = F0(A) |
        (?(p : mem(A)). nas# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(Pow(N * (A + 1)))))  (s2 : mem(Pow(Pow(N * (A + 1))))).
        SS(s1#, s2#) ==> SS(App(isfmf(A), s1#), App(isfmf(A), s2#)): thm
val isfm's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        IN(a#, isfm's(A)) <=> SS(App(isfmf(A), a#), a#): thm
val isfms_def = {(A : set)},  |- isfms(A) = BIGINTER(isfm's(A)): thm
val isfms_cond =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (!(ss : mem(Pow(Pow(N * (A + 1))))).
            SS(App(isfmf(A), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isfms(A)):
   thm
val isfms_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), a#), a#) ==> SS(isfms(A), a#): thm
val isfm_rules0 = {(A : set)},  |- SS(App(isfmf(A), isfms(A)), isfms(A)): thm
val isfm_cases0 = {(A : set)},  |- App(isfmf(A), isfms(A)) = isfms(A): thm
val isfm_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), ss#), ss#) ==> SS(isfms(A), ss#): thm
val isfm_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (!(a : mem(Pow(N * (A + 1)))).
            a# = F0(A) |
            (?(p : mem(A)). a# = Var0(p#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Neg0(f0#)) |
            (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj0(f1#, f2#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Diam0(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases1 =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules1 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        a# = F0(A) |
        (?(p : mem(A)). a# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Diam0(f0#)) ==>
        IN(a#, isfms(A)): thm
val isfm_rules2 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (a# = F0(A) ==> IN(a#, isfms(A))) &
        (!(p : mem(A)). a# = Var0(p#) ==> IN(a#, isfms(A))) &
        (!(f0 : mem(Pow(N * (A + 1)))).
            IN(f0#, isfms(A)) & a# = Neg0(f0#) ==> IN(a#, isfms(A))) &
        (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#) ==>
            IN(a#, isfms(A))) &
        !(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) & a# = Diam0(f0#) ==> IN(a#, isfms(A)): thm
val isfm_rules3 =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_def =
   {}, 
   |- !(A : set)  (f : mem(Pow(N * (A# + 1)))).
        isfm(f#) <=> IN(f#, isfms(A#)): thm
val isfm_induct =
   {}, 
   |- !(A : set).
        P(F0(A#)) &
        (!(p : mem(A#)). P(Var0(p#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Neg0(f0#))) &
        (!(f1 : mem(Pow(N * (A# + 1))))  (f2 : mem(Pow(N * (A# + 1)))).
            P(f1#) & P(f2#) ==> P(Disj0(f1#, f2#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Diam0(f0#))) ==>
        !(f0 : mem(Pow(N * (A# + 1)))). isfm(f0#) ==> P(f0#): thm
val isfm_F0 = {},  |- !(A : set). isfm(F0(A#)): thm
val isfm_Diam0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val isfm_Neg0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#)): thm
val isfm_Var0 = {},  |- !(A : set)  (p : mem(A#)). isfm(Var0(p#)): thm
val isfm_clauses =
   {(A : set)}, 
   |- isfm(F0(A)) &
      (!(p : mem(A)). isfm(Var0(p#))) &
      (!(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#))) &
      !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val form_def =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). a# = App(repf(A), b#): thm
val isfm_Disj0 =
   {(A : set)}, 
   |- !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
        isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#)): thm
val repf_Inj = {(A : set)},  |- Inj(repf(A)): thm
val Bot_def = {(A : set)},  |- Repf(Bot(A)) = F0(A): thm
val Repf_def =
   {},  |- !(A : set)  (f : mem(form(A#))). Repf(f#) = App(repf(A#), f#): thm
val VAR_def =
   {(A : set)},  |- !(a : mem(A)). App(repf(A) o VAR(A), a#) = Var0(a#): thm
val flip_fconv = fn: form -> thm
val form_def' =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). App(repf(A), b#) = a#: thm
val repf_isfm = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Repf(f0#)): thm
val VAR_VAR0 = {},  |- !(A : set). repf(A#) o VAR(A#) = VAR0(A#): thm
val VAR_Inj = {},  |- !(A : set). Inj(VAR(A#)): thm
val NEG_NEG0 = {},  |- !(A : set). repf(A#) o NEG(A#) = NEG0(A#) o repf(A#):
   thm
val NEG_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(NEG(A), a#)) = Neg0(Repf(a#)): thm
val Neg0_Repf = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Neg0(Repf(f0#))):
   thm
val NEG_Inj = {},  |- !(A : set). Inj(NEG(A#)): thm
val DIAM_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(DIAM(A), a#)) = Diam0(Repf(a#)): thm
val Diam0_Repf =
   {(A : set)},  |- !(f0 : mem(form(A))). isfm(Diam0(Repf(f0#))): thm
val form_def_uex =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (?!(b : mem(form(A))). a# = Repf(b#)) <=> isfm(a#): thm
val DISJ_DISJ0 =
   {}, 
   |- !(A : set). repf(A#) o DISJ(A#) = DISJ0(A#) o Prla(repf(A#), repf(A#)):
   thm
val DISJ_def =
   {(A : set)}, 
   |- !(a' : mem(form(A)))  (b : mem(form(A))).
        Repf(App(DISJ(A), Pair(a'#, b#))) = Disj0(Repf(a'#), Repf(b#)): thm
val DISJ_Inj = {},  |- !(A : set). Inj(DISJ(A#)): thm
val DIAM_DIAM0 =
   {},  |- !(A : set). repf(A#) o DIAM(A#) = DIAM0(A#) o repf(A#): thm
val DIAM_Inj = {},  |- !(A : set). Inj(DIAM(A#)): thm
val Diam_def =
   {(A : set), (f : mem(form(A)))},  |- Diam(f) = App(DIAM(A), f): thm
val Disj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Disj(f1, f2) = App(DISJ(A), Pair(f1, f2)): thm
val Neg_def = {(A : set), (f : mem(form(A)))},  |- Neg(f) = App(NEG(A), f):
   thm
val Var_def = {(A : set), (a : mem(A))},  |- Var(a) = App(VAR(A), a): thm
val Var_eq_eq =
   {(A : set)}, 
   |- !(p1 : mem(A))  (p2 : mem(A)). Var(p1#) = Var(p2#) <=> p1# = p2#: thm
val Neg_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Neg(f1#) = Neg(f2#) <=> f1# = f2#: thm
val Diam_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Diam(f1#) = Diam(f2#) <=> f1# = f2#: thm
val Disj_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A)))  (g1 : mem(form(A)))
      (g2 : mem(form(A))).
        Disj(f1#, f2#) = Disj(g1#, g2#) <=> f1# = g1# & f2# = g2#: thm
val Repf_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Repf(f1#) = Repf(f2#) <=> f1# = f2#: thm
val form_induct =
   {}, 
   |- !(A : set).
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Neg(f0#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Diam(f0#))) ==>
        !(f0 : mem(form(A#))). P(f0#): thm
val fmind's_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        IN(a#, fmind's(djf, dmf, nf, vf, x0)) <=>
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#): thm
val fmind_cases0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)) =
        fminds(djf, dmf, nf, vf, x0): thm
val fmind_cases1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_incond =
   !(p : mem(form(A) * X)).
     IN(p#, fmind1) <=>
     p# = Pair(Bot(A), x0) |
     (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
     ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
       IN(p1#, fmind0) &
       IN(p2#, fmind0) &
       p# =
         Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))):
   form
val fmind_ind =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), ss#): thm
val fmind_ind1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (!(a : mem(form(A) * X)).
            a# = Pair(Bot(A), x0) |
            (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
            (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
                IN(p1#, ss#) &
                IN(p2#, ss#) &
                a# =
                  Pair(Disj(Fst(p1#), Fst(p2#)),
                   App(djf, Pair(Snd(p1#), Snd(p2#))))) ==> IN(a#, ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_rules0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- SS(App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)),
       fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        a# = Pair(Bot(A), x0) |
        (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
            IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
            a# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#))))) ==>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (a# = Pair(Bot(A), x0) ==> IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(a' : mem(A)).
            a# = Pair(Var(a'#), App(vf, a'#)) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          a# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))) ==>
          IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules3 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val fmindf_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
        IN(p#, App(fmindf(djf, dmf, nf, vf, x0), a#)) <=>
        p# = Pair(Bot(A), x0) |
        (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, a#) &
          IN(p2#, a#) &
          p# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_ex =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(form(A) * X), Pow(form(A) * X))).
        !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Bot(A), x0) |
          (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
          ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, a#) &
            IN(p2#, a#) &
            p# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_monotone =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(form(A) * X)))  (s2 : mem(Pow(form(A) * X))).
        SS(s1#, s2#) ==>
        SS(App(fmindf(djf, dmf, nf, vf, x0), s1#),
         App(fmindf(djf, dmf, nf, vf, x0), s2#)): thm
val fminds_SS =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), a#): thm
val fminds_cond =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (!(ss : mem(Pow(form(A) * X))).
            SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fminds_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- fminds(djf, dmf, nf, vf, x0) = BIGINTER(fmind's(djf, dmf, nf, vf, x0)):
   thm
val x1 = "fmind0": string
val fmind_cases =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_rules =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val IN_F0 =
   {(A : set)}, 
   |- !(n : mem(N))  (a : mem(A + 1)). IN(Pair(n#, a#), F0(A)) <=> n# = O:
   thm
val IN_Var0 =
   {(A : set), (a0 : mem(A))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Var0(a0)) <=>
        Even(n#) & Div2(n#) = num1 | Odd(n#) & a# = SOME(a0): thm
val IN_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Neg0(f0)) <=>
        Even(n#) & Div2(n#) = num2 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Diam0(f0)) <=>
        Even(n#) & Div2(n#) = num4 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Disj0(f1, f2)) <=>
        Even(n#) & Div2(n#) = num3 |
        Odd(n#) &
        (Even(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f1) |
          Odd(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f2)): thm
val F0_NOT_Var0 = {(A : set), (p : mem(A))},  |- ~F0(A) = Var0(p): thm
val Bot_NOT_Var = {(A : set), (p : mem(A))},  |- ~Bot(A) = Var(p): thm
val F0_NOT_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- ~F0(A) = Disj0(f1, f2): thm
val Bot_NOT_Disj =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Bot(A) = Disj(f1, f2): thm
val F0_NOT_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Neg0(f0): thm
val Bot_NOT_Neg = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Neg(f): thm
val F0_NOT_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Diam0(f0): thm
val Bot_NOT_Diam = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Diam(f):
   thm
val Bot_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Bot(A#) = Var(p#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Neg(f#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Diam(f#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Bot(A#) = Disj(f1#, f2#): thm
val InjN_Inj = {},  |- !(A : set). Inj(InjN(A#)): thm
val Var0_NOT_Diam0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Diam0(f0): thm
val VAR_def' =
   {(A : set)},  |- !(a : mem(A)). Repf(App(VAR(A), a#)) = Var0(a#): thm
val Var_NOT_Diam =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Diam(f): thm
val Var0_NOT_Disj0 =
   {(A : set), (a : mem(A)), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Var0(a) = Disj0(f1, f2): thm
val Var_NOT_Disj =
   {(A : set), (a : mem(A)), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Var(a) = Disj(f1, f2): thm
val Var0_NOT_Neg0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Neg0(f0): thm
val Var_NOT_Neg =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Neg(f): thm
val Var_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Var(p#) = Bot(A#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Neg(f#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Diam(f#)) &
        !(p : mem(A#))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Var(p#) = Disj(f1#, f2#): thm
val Neg0_NOT_Diam0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Neg0(f) = Diam0(f0): thm
val Neg_NOT_Diam =
   {(A : set), (f : mem(form(A))), (f0 : mem(form(A)))}, 
   |- ~Neg(f) = Diam(f0): thm
val Neg0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Neg0(f) = Disj0(f1, f2): thm
val Neg_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Neg(f) = Disj(f1, f2): thm
val Neg_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Neg(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Neg(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Neg(f#) = Diam(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Neg(f#) = Disj(f1#, f2#): thm
val Diam0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Diam0(f) = Disj0(f1, f2): thm
val Diam_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Diam(f) = Disj(f1, f2): thm
val Diam_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Diam(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Diam(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Diam(f#) = Neg(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Diam(f#) = Disj(f1#, f2#): thm
val Disj_NOT =
   {}, 
   |- !(A : set).
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            ~Disj(f1#, f2#) = Bot(A#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (p : mem(A#)).
            ~Disj(f1#, f2#) = Var(p#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f0 : mem(form(A#))).
            ~Disj(f1#, f2#) = Diam(f0#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f : mem(form(A#))).
          ~Disj(f1#, f2#) = Neg(f#): thm
val fmind_Neg =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Neg(f), App(nf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_Disj =
   {}, 
   |- !(A : set)  (f1 : mem(form(A#)))  (X : set)  (djf : fun(X# * X#, X#))
      (dmf : fun(X#, X#))  (nf : fun(X#, X#))  (vf : fun(A#, X#))
      (x0 : mem(X#))  (x1 : mem(X#)).
        IN(Pair(f1#, x1#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
        !(f2 : mem(form(A#)))  (x2 : mem(X#)).
          IN(Pair(f2#, x2#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
          IN(Pair(Disj(f1#, f2#), App(djf#, Pair(x1#, x2#))),
           fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmind_Diam =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Diam(f), App(dmf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_uex =
   {(X : set)}, 
   |- !(A : set)  (x0 : mem(X))  (vf : fun(A#, X))  (nf : fun(X, X))
      (djf : fun(X * X, X))  (dmf : fun(X, X))  (f : mem(form(A#))).
        ?!(x : mem(X)). IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)):
   thm
val fmrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (a : mem(form(A#))).
        IN(Pair(a#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), a#)),
       fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val App_fmrec_fminds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (f : mem(form(A#)))  (x : mem(X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#) = x# <=>
        IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmrec_clauses =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), Bot(A#)) = x0# &
        (!(p : mem(A#)).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Var(p#)) = App(vf#, p#)) &
        (!(f : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Neg(f#)) =
              App(nf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Disj(f1#, f2#)) =
              App(djf#,
               Pair(App(fmrec(x0#, vf#, nf#, djf#, dmf#), f1#),
                App(fmrec(x0#, vf#, nf#, djf#, dmf#), f2#)))) &
        !(f : mem(form(A#))).
          App(fmrec(x0#, vf#, nf#, djf#, dmf#), Diam(f#)) =
            App(dmf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#)): thm
val it = (): unit
******

Loading SEAR file SEARUF.sml

******
val Inter_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val Inter_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val filter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- filter(L) <=>
      ~EMPTY(J) &
      IN(Whole(J), L) &
      (!(X : mem(Pow(J)))  (Y : mem(Pow(J))).
          IN(X#, L) & IN(Y#, L) ==> IN(Inter(X#, Y#), L)) &
      !(X : mem(Pow(J))).
        IN(X#, L) ==> !(Y : mem(Pow(J))). SS(X#, Y#) ==> IN(Y#, L): thm
val ufilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). ~IN(Compl(X#), L) <=> IN(X#, L): thm
val ufilter_filter =
   {},  |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> filter(L#):
   thm
val SS_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val SS_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val Whole_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). filter(L#) ==> IN(Whole(J#), L#):
   thm
val Whole_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> IN(Whole(J#), L#):
   thm
val Empty_NOTIN_UF =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> ~IN(Empty(J#), L#):
   thm
val IN_UF_NONEMPTY =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==> !(X : mem(Pow(J#))). IN(X#, L#) ==> ~X# = Empty(J#):
   thm
val Repu_def = {(J : set), (u : mem(UFs(J)))},  |- Repu(u) = App(iUF(J), u):
   thm
val Repu_ufilter = {},  |- !(A : set)  (u : mem(UFs(A#))). ufilter(Repu(u#)):
   thm
val UFs_def =
   {(J : set)}, 
   |- Inj(iUF(J)) &
      !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = App(iUF(J), b#): thm
val from_UFs =
   {(J : set)}, 
   |- !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = Repu(b#): thm
val Empty_NOTIN_UFs =
   {},  |- !(J : set)  (u : mem(UFs(J#))). ~IN(Empty(J#), Repu(u#)): thm
val ufilter_alt =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). IN(Compl(X#), L) <=> ~IN(X#, L): thm
val Compl_Repu =
   {(J : set), (X : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Compl(X), Repu(u)) <=> ~IN(X, Repu(u)): thm
val Union_Repu =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Union(s1, s2), Repu(u)) <=> IN(s1, Repu(u)) | IN(s2, Repu(u)): thm
val CUI_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- CUI(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        IN(BIGINTER(ss0#), ss): thm
val CUI_iff_binary =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#)))).
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) <=>
        !(s : mem(Pow(Pow(W#)))).
          SS(s#, A#) & Fin(s#) & ~s# = Empty(Pow(W#)) ==>
          IN(BIGINTER(s#), A#): thm
val FIP_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- FIP(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        ~BIGINTER(ss0#) = Empty(A): thm
val FIP_CUI_lemma =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        ~IN(Empty(W#), A#) & ~IN(Empty(W#), B#): thm
val FIP_closed_under_Inter =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) &
        (!(b1 : mem(Pow(W#))).
            IN(b1#, B#) ==>
            !(b2 : mem(Pow(W#))). IN(b2#, B#) ==> IN(Inter(b1#, b2#), B#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        FIP(Union(A#, B#)): thm
val IN_gfilter =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(x : mem(Pow(A))).
        IN(x#, gfilter(s)) <=>
        !(ss : mem(Pow(Pow(A)))). SS(s, ss#) & filter(ss#) ==> IN(x#, ss#):
   thm
val gfilter_def =
   {(A : set), (s : mem(Pow(Pow(A))))},  |- gfilter(s) = BIGINTER(gfss(s)):
   thm
val gfilter_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter(s#)): thm
val gfilter_ind =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(A#)))).
        SS(s#, ss#) & filter(ss#) ==>
        !(x : mem(Pow(A#))). IN(x#, gfilter(s#)) ==> IN(x#, ss#): thm
val gfss_def =
   {(A : set), (s0 : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(Pow(A)))). IN(a#, gfss(s0)) <=> SS(s0, a#) & filter(a#):
   thm
val SS_gfilter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter(s#)): thm
val pfilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- pfilter(L) <=> filter(L) & ~L = Whole(Pow(J)): thm
val gfilter1_def =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, gfilter1(s)) <=>
        a# = Whole(A) |
        ?(ss : mem(Pow(Pow(A)))).
          SS(ss#, s) &
          Fin(ss#) & ~ss# = Empty(Pow(A)) & SS(BIGINTER(ss#), a#): thm
val gfilter1_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter1(s#)): thm
val SS_gfilter1 =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter1(s#)): thm
val CUI_filter =
   {},  |- !(A : set)  (L : mem(Pow(Pow(A#)))). filter(L#) ==> CUI(L#): thm
val gfilter_gfilter1 =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) ==> gfilter(s#) = gfilter1(s#): thm
val Empty_NOTIN_pfilter =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) <=> filter(s#) & ~IN(Empty(A#), s#): thm
val FIP_Empty_NOTIN_gfilter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))). FIP(s#) ==> ~IN(Empty(A#), gfilter(s#)):
   thm
val FIP_PSUBSET_proper_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))).
          FIP(s#) ==> ?(v : mem(Pow(Pow(A#)))). pfilter(v#) & SS(s#, v#): thm
val filter_Whole = {},  |- !(J : set). ~EMPTY(J#) ==> filter(Whole(Pow(J#))):
   thm
val filter_Empty_Whole =
   {}, 
   |- !(J : set).
        ~EMPTY(J#) ==>
        !(L : mem(Pow(Pow(J#)))).
          filter(L#) & IN(Empty(J#), L#) <=> L# = Whole(Pow(J#)): thm
val ufilter_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        ufilter(u#) ==>
        !(s : mem(Pow(Pow(J#)))).
          filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#)): thm
val CUI_Empty_NOTIN_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        CUI(s#) & ~IN(Empty(W#), s#) ==> FIP(s#): thm
val pfilter_FIP =
   {},  |- !(W : set)  (s : mem(Pow(Pow(W#)))). pfilter(s#) ==> FIP(s#): thm
val pfilter_filter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). pfilter(s#) ==> filter(s#):
   thm
val pfilter_INSERT_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        pfilter(s#) ==>
        !(b : mem(Pow(W#))).
          ~IN(b#, s#) & ~IN(Compl(b#), s#) ==> FIP(Ins(b#, s#)): thm
val maximal_ufilter =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        (!(s : mem(Pow(Pow(J#)))).
            filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) ==> ufilter(u#):
   thm
val chain_def =
   {(A : set), (R : rel(A, A)), (t : mem(Pow(A)))}, 
   |- chain(t, R) <=>
      !(a1 : mem(A))  (a2 : mem(A)).
        IN(a1#, t) & IN(a2#, t) ==> Holds(R, a1#, a2#) | Holds(R, a2#, a1#):
   thm
val ismax_def =
   {(A : set), (R : rel(A, A)), (m : mem(A))}, 
   |- ismax(R, m) <=> !(x : mem(A)). Holds(R, m, x#) ==> x# = m: thm
val ptorder_def =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> Trans(R) & Refl(R) & Asym(R): thm
val ubound_def =
   {(A : set), (R : rel(A, A)), (s : mem(Pow(A))), (x : mem(A))}, 
   |- ubound(s, R, x) <=> !(y : mem(A)). IN(y#, s) ==> Holds(R, y#, x): thm
******

Loading SEAR file zorns.sml

******
val AC =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). Holds(R#, a#, App(f#, a#)): thm
val antisym_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        antisym(r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, x#), r#) ==> x# = y#: thm
val chain0_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        chain0(s#, r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==>
          IN(Pair(x#, y#), r#) | IN(Pair(y#, x#), r#): thm
val domain_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, domain(r#)) <=> ?(y : mem(A#)). IN(Pair(a#, y#), r#): thm
val ischoice_def =
   {(A : set), (f : fun(Pow(A), A)), (s : mem(Pow(Pow(A))))}, 
   |- ischoice(f, s) <=>
      ~IN(Empty(A), s) &
      !(s0 : mem(Pow(A))). IN(s0#, s) ==> IN(App(f, s0#), s0#): thm
val ischoice_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) & ~IN(Empty(A#), s#) ==>
        ?(f : fun(Pow(A#), A#)). ischoice(f#, s#): thm
val maximal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, maximal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(a#, x'#), r#) ==> a# = x'#:
   thm
val minimal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, minimal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(x'#, a#), r#) ==> a# = x'#:
   thm
val partial_order_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        partial_order(r#, s#) <=>
        SS(domain(r#), s#) &
        SS(range(r#), s#) & transitive(r#) & reflexive(r#, s#) & antisym(r#):
   thm
val range_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, range(r#)) <=> ?(x : mem(A#)). IN(Pair(x#, a#), r#): thm
val reflexive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        reflexive(r#, s#) <=>
        !(x : mem(A#)). IN(x#, s#) ==> IN(Pair(x#, x#), r#): thm
val transitive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        transitive(r#) <=>
        !(x : mem(A#))  (y : mem(A#))  (z : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, z#), r#) ==>
          IN(Pair(x#, z#), r#): thm
val upper_bounds_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, upper_bounds(s#, r#)) <=>
        IN(a#, range(r#)) &
        !(y : mem(A#)). IN(y#, s#) ==> IN(Pair(y#, a#), r#): thm
val fchains_def =
   {(A : set), (f : fun(Pow(A), A)), (r : mem(Pow(A * A)))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, fchains(r, f)) <=>
        chain0(a#, r) &
        ~a# = Empty(A) &
        !(C : mem(Pow(A))).
          chain0(C#, r) &
          SS(C#, a#) & ~Inter(Diff(upper_bounds(C#, r), C#), a#) = Empty(A) ==>
          IN(App(f, Diff(upper_bounds(C#, r), C#)),
           minimal_elements(Inter(Diff(upper_bounds(C#, r), C#), a#), r)):
   thm
val hatclass_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(Pow(A#))).
        IN(a#, hatclass(r#)) <=>
        ~a# = Empty(A#) &
        ?(C : mem(Pow(A#))). a# = Diff(upper_bounds(C#, r#), C#): thm
val lemma1 =
   {(A : set)}, 
   |- !(x : mem(A))  (s : mem(Pow(A)))  (r : mem(Pow(A * A))).
        chain0(s#, r#) & IN(x#, s#) ==>
        IN(x#, domain(r#)) & IN(x#, range(r#)): thm
val lemma2 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A)))  (x : mem(A))  (x' : mem(A)).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        IN(k1#, fchains(r#, f#)) &
        IN(k2#, fchains(r#, f#)) & IN(x#, k1#) & IN(x'#, k2#) & ~IN(x'#, k1#) ==>
        IN(Pair(x#, x'#), r#): thm
val lemma3 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) & IN(k1#, fchains(r#, f#)) & IN(k2#, fchains(r#, f#)) ==>
        SS(k1#, k2#) | SS(k2#, k1#): thm
val lemma4 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A)).
        ischoice(f#, hatclass(r#)) & antisym(r#) & transitive(r#) ==>
        chain0(BIGUNION(fchains(r#, f#)), r#) &
        !(x : mem(A))  (x' : mem(A))  (k : mem(Pow(A))).
          IN(Pair(x'#, x#), r#) &
          IN(x'#, BIGUNION(fchains(r#, f#))) &
          IN(x#, BIGUNION(fchains(r#, f#))) &
          IN(k#, fchains(r#, f#)) & IN(x#, k#) ==> IN(x'#, k#): thm
val lemma5 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) & ~range(r#) = Empty(A) & reflexive(r#, s#) ==>
        IN(Sing(App(f#, range(r#))), fchains(r#, f#)): thm
val lemma6 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (k : mem(Pow(A)))
      (x : mem(A))  (C : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) &
        IN(k#, fchains(r#, f#)) &
        IN(x#, k#) &
        chain0(C#, r#) &
        IN(x#, Diff(upper_bounds(C#, r#), C#)) &
        SS(C#, BIGUNION(fchains(r#, f#))) ==>
        IN(App(f#, Diff(upper_bounds(C#, r#), C#)), k#) &
        IN(Pair(App(f#, Diff(upper_bounds(C#, r#), C#)), x#), r#): thm
val lemma7 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        IN(BIGUNION(fchains(r#, f#)), fchains(r#, f#)): thm
val lemma8 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A)))
      (k : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        reflexive(r#, s#) &
        antisym(r#) &
        transitive(r#) &
        IN(k#, fchains(r#, f#)) & ~Diff(upper_bounds(k#, r#), k#) = Empty(A) ==>
        IN(Ins(App(f#, Diff(upper_bounds(k#, r#), k#)), k#), fchains(r#, f#)):
   thm
val upper_bounds_lem =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A)))  (x1 : mem(A))
      (x2 : mem(A)).
        transitive(r#) &
        IN(x1#, upper_bounds(s#, r#)) & IN(Pair(x1#, x2#), r#) ==>
        IN(x2#, upper_bounds(s#, r#)): thm
val lemma9 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        SS(upper_bounds(BIGUNION(fchains(r#, f#)), r#),
         maximal_elements(s#, r#)): thm
val zorns_lemma0 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A))).
        ~s# = Empty(A) &
        partial_order(r#, s#) &
        (!(t : mem(Pow(A))).
            chain0(t#, r#) ==> ~upper_bounds(t#, r#) = Empty(A)) ==>
        ?(x : mem(A)). IN(x#, maximal_elements(s#, r#)): thm
val Trans_transitive =
   {},  |- !(A : set)  (R : rel(A#, A#)). Trans(R#) <=> transitive(r2m(R#)):
   thm
val Refl_reflexive =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> reflexive(r2m(R#), Whole(A#)): thm
val Asym_antisym =
   {},  |- !(A : set)  (R : rel(A#, A#)). Asym(R#) <=> antisym(r2m(R#)): thm
val ptorder_partial_order =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> partial_order(r2m(R), Whole(A)): thm
val zorns_lemma =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ~EMPTY(A#) & ptorder(R#) ==>
        (!(c : mem(Pow(A#))).
            chain(c#, R#) & ~c# = Empty(A#) ==>
            ?(ub : mem(A#)). ubound(c#, R#, ub#)) ==>
        ?(m : mem(A#)). ismax(R#, m#): thm
val it = (): unit
val ufilter_iff_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        ((!(s : mem(Pow(Pow(J#)))).
              filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) <=>
          ufilter(u#)): thm
val UNION_chain_filter_filter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> filter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          filter(BIGUNION(ss#)): thm
val UNION_chain_pfilter_pfilter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> pfilter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          pfilter(BIGUNION(ss#)): thm
val ufilter_thm =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) ==> ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(s#, u#):
   thm
val ufilter_thm_coro =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==>
        ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(ss#, u#): thm
val Prop_5_3 =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==> ?(u : mem(UFs(A#))). SS(ss#, Repu(u#)): thm
val FIP_Sing =
   {},  |- !(W : set)  (a : mem(Pow(W#))). ~a# = Empty(W#) ==> FIP(Sing(a#)):
   thm
val it = (): unit
******

Loading SEAR file SEARmmmt.sml

******
val Rm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w1 : mem(W)), (w2 : mem(W))}, 
   |- Rm(M, w1, w2) <=> IN(Pair(w1, w2), Rof(M)): thm
val Rof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Rof(M#) = Fst(M#): thm
val Vof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Vof(M#) = tof(Snd(M#)): thm
val HAT_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(A))  (w : mem(W)).
        IN(w#, App(HAT(M), a#)) <=> IN(a#, App(Vof(M), w#)): thm
val satis_def0 =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A))), (w : mem(W))}, 
   |- satis(M, w, f) <=> IN(w, App(satisf(M), f)): thm
val satis_dmf =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(Pow(W)))  (w : mem(W)).
        IN(w#, App(sdmf(M), a#)) <=>
        ?(w0 : mem(W)). IN(w0#, a#) & Rm(M, w#, w0#): thm
val satisf_clause =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- App(satisf(M), Bot(A)) = Empty(W) &
      (!(p : mem(A)). App(satisf(M), Var(p#)) = App(HAT(M), p#)) &
      (!(f : mem(form(A))).
          App(satisf(M), Neg(f#)) = App(COMPL(W), App(satisf(M), f#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          App(satisf(M), Disj(f1#, f2#)) =
            App(UNION(W), Pair(App(satisf(M), f1#), App(satisf(M), f2#)))) &
      !(f : mem(form(A))).
        App(satisf(M), Diam(f#)) = App(sdmf(M), App(satisf(M), f#)): thm
val satisf_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- satisf(M) = fmrec(Empty(W), HAT(M), COMPL(W), UNION(W), sdmf(M)): thm
val satis_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))}, 
   |- ~satis(M, w, Bot(A)) &
      (!(a : mem(A)). satis(M, w, Var(a#)) <=> IN(a#, App(Vof(M), w))) &
      (!(f : mem(form(A))). satis(M, w, Neg(f#)) <=> ~satis(M, w, f#)) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          satis(M, w, Disj(f1#, f2#)) <=> satis(M, w, f1#) | satis(M, w, f2#)) &
      !(f : mem(form(A))).
        satis(M, w, Diam(f#)) <=>
        ?(v : mem(W)). Rm(M, w, v#) & satis(M, v#, f#): thm
val SATIS_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (fs : mem(Pow(form(A)))), (w : mem(W))}, 
   |- SATIS(M, w, fs) <=> !(f : mem(form(A))). IN(f#, fs) ==> satis(M, w, f#):
   thm
val Top_def = {(A : set)},  |- Top(A) = Neg(Bot(A)): thm
val Conj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Conj(f1, f2) = Neg(Disj(Neg(f1), Neg(f2))): thm
val satis_Conj =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f1 : mem(form(A)))  (f2 : mem(form(A))).
        satis(M#, w#, Conj(f1#, f2#)) <=>
        satis(M#, w#, f1#) & satis(M#, w#, f2#): thm
val PE's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). IN(a#, PE's(A)) <=> SS(App(PEf(A), a#), a#):
   thm
val PE_cases0 = {(A : set)},  |- App(PEf(A), PEs(A)) = PEs(A): thm
val PE_cases1 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_incond =
   !(f : mem(form(A))).
     IN(f#, PEs1) <=>
     f# = Top(A) |
     f# = Bot(A) |
     (?(p : mem(A)). f# = Var(p#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Conj(f1#, f2#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Disj(f1#, f2#)) |
     ?(f0 : mem(form(A))). IN(f0#, PEs0) & f# = Diam(f0#): form
val PE_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        (!(a : mem(form(A))).
            a# = Top(A) |
            a# = Bot(A) |
            (?(p : mem(A)). a# = Var(p#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Conj(f1#, f2#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj(f1#, f2#)) |
            (?(f0 : mem(form(A))). IN(f0#, ss#) & a# = Diam(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_rules0 = {(A : set)},  |- SS(App(PEf(A), PEs(A)), PEs(A)): thm
val PE_rules1 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        a# = Top(A) |
        a# = Bot(A) |
        (?(p : mem(A)). a# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#)) |
        (?(f0 : mem(form(A))). IN(f0#, PEs(A)) & a# = Diam(f0#)) ==>
        IN(a#, PEs(A)): thm
val PE_rules2 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (a# = Top(A) ==> IN(a#, PEs(A))) &
        (a# = Bot(A) ==> IN(a#, PEs(A))) &
        (!(p : mem(A)). a# = Var(p#) ==> IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        !(f0 : mem(form(A))).
          IN(f0#, PEs(A)) & a# = Diam(f0#) ==> IN(a#, PEs(A)): thm
val PE_rules3 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PEf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A))))  (f : mem(form(A))).
        IN(f#, App(PEf(A), a#)) <=>
        f# = Top(A) |
        f# = Bot(A) |
        (?(p : mem(A)). f# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(form(A)), Pow(form(A)))).
        !(a : mem(Pow(form(A))))  (f : mem(form(A))).
          IN(f#, App(f#, a#)) <=>
          f# = Top(A) |
          f# = Bot(A) |
          (?(p : mem(A)). f# = Var(p#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
          ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==> SS(App(PEf(A), s1#), App(PEf(A), s2#)): thm
val PEs_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). SS(App(PEf(A), a#), a#) ==> SS(PEs(A), a#):
   thm
val PEs_cond =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (!(ss : mem(Pow(form(A)))). SS(App(PEf(A), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, PEs(A)): thm
val PEs_def = {(A : set)},  |- PEs(A) = BIGINTER(PE's(A)): thm
val x1 = "PEs0": string
val PE_cases0 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_rules0 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PE_def0 = {(A : set), (f : mem(form(A)))},  |- PE(f) <=> IN(f, PEs(A)):
   thm
val PE_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). PE(a#) ==> IN(a#, ss#): thm
val PE_cases =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        PE(x#) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). PE(f0#) & x# = Diam(f0#): thm
val PE_rules =
   {(A : set)}, 
   |- PE(Top(A)) &
      PE(Bot(A)) &
      (!(p : mem(A)). PE(Var(p#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#))) &
      !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val PE_induct =
   {}, 
   |- !(A : set).
        P(Top(A#)) &
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Conj(f1#, f2#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f : mem(form(A#))). P(f#) ==> P(Diam(f#))) ==>
        !(f : mem(form(A#))). PE(f#) ==> P(f#): thm
val satis_Bot =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
      (w : mem(W#)). ~satis(M#, w#, Bot(A#)): thm
val satis_Top =
   {(W : set)}, 
   |- !(A : set)  (M : mem(Pow((W * W)) * Exp(W, Pow(A#))))  (w : mem(W)).
        satis(M#, w#, Top(A#)): thm
val PUS_Var = {},  |- !(A : set)  (p : mem(A#)). PUS(Var(p#)): thm
val PUS_def =
   {(A : set), (f : mem(form(A)))}, 
   |- PUS(f) <=>
      !(W1 : set)  (W2 : set)  (R : rel(W1#, W2#))
      (M1 : mem(Pow((W1# * W1#)) * Exp(W1#, Pow(A))))
      (M2 : mem(Pow((W2# * W2#)) * Exp(W2#, Pow(A)))).
        Sim(R#, M1#, M2#) ==>
        !(w1 : mem(W1#))  (w2 : mem(W2#)).
          Holds(R#, w1#, w2#) ==> satis(M1#, w1#, f) ==> satis(M2#, w2#, f):
   thm
val Sim_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (R : rel(W1, W2)),
    (W1 : set), (W2 : set)}, 
   |- Sim(R, M1, M2) <=>
      !(w1 : mem(W1))  (w2 : mem(W2)).
        Holds(R, w1#, w2#) ==>
        (!(p : mem(A)).
            IN(p#, App(Vof(M1), w1#)) ==> IN(p#, App(Vof(M2), w2#))) &
        !(v : mem(W1)).
          Rm(M1, w1#, v#) ==>
          ?(v' : mem(W2)). Holds(R, v#, v'#) & Rm(M2, w2#, v'#): thm
val PUS_Top = {},  |- !(A : set). PUS(Top(A#)): thm
val PUS_Bot = {},  |- !(A : set). PUS(Bot(A#)): thm
val Thm_6_25_r2l0 =
   {},  |- !(A : set)  (f : mem(form(A#))). PE(f#) ==> PUS(f#): thm
val EQV_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- EQV(f1, f2) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, f1) <=> satis(M#, w#, f2): thm
val Thm_6_25_r2l =
   {}, 
   |- !(A : set)  (f : mem(form(A#)))  (f0 : mem(form(A#))).
        PE(f0#) & EQV(f#, f0#) ==> PUS(f#): thm
val Fsab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Fsab(fs, X, M) <=>
      !(ss : mem(Pow(form(A)))). Fin(ss#) & SS(ss#, fs) ==> Sab(ss#, X, M):
   thm
val Msat_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- Msat(M) <=>
      !(w : mem(W))  (fs : mem(Pow(form(A)))).
        Fsab(fs#, Sucm(M, w#), M) ==> Sab(fs#, Sucm(M, w#), M): thm
val Sab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Sab(fs, X, M) <=> ?(x : mem(W)). IN(x#, X) & SATIS(M, x#, fs): thm
val Sucm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))},  |- !(a : mem(W)). IN(a#, Sucm(M, w)) <=> Rm(M, w, a#):
   thm
val Tat_def =
   {(A : set), (W : set), (a : mem(A)), (f0 : fun(W, Pow(A)))}, 
   |- !(a' : mem(W)). IN(a'#, Tat(f0, a)) <=> IN(a, App(f0, a'#)): thm
val fun_mem_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(f : fun(A#, B#)). P(f#)) <=> ?(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val mem_fun_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(m : mem(Exp(A#, B#))). P(m#)) <=> ?(f : fun(A#, B#)). P(Tpm(f#)):
   thm
val fun_mem_uex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?!(f : fun(A#, B#)). P(f#)) <=> ?!(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val UE_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- UE(M) = Pair(ueR(M), ueV(M)): thm
val csee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, csee(M, X)) <=> ?(v : mem(W)). Rm(M, a#, v#) & IN(v#, X): thm
val osee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, osee(M, X)) <=> !(v : mem(W)). Rm(M, a#, v#) ==> IN(v#, X):
   thm
val ueR_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a' : mem(UFs(W)))  (b : mem(UFs(W))).
        IN(Pair(a'#, b#), ueR(M)) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(b#)) ==> IN(csee(M, X#), Repu(a'#)):
   thm
val ueV_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(u : mem(UFs(W)))  (a : mem(A)).
        IN(a#, App(tof(ueV(M)), u#)) <=> IN(Tat(Vof(M), a#), Repu(u#)): thm
val ufilter_Compl =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))). ~IN(Compl(X#), L#) <=> IN(X#, L#): thm
val exists_forall_dual =
   {},  |- !(A : set). (?(a : mem(A#)). P(a#)) <=> ~!(a : mem(A#)). ~P(a#):
   thm
val Prop_5_4_1 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        csee(M#, X#) = Compl(osee(M#, Compl(X#))): thm
val Prop_5_4_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        osee(M#, X#) = Compl(csee(M#, Compl(X#))): thm
val Prop_5_6 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val MEQ_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (W1 : set), (W2 : set),
    (w1 : mem(W1)), (w2 : mem(W2))}, 
   |- MEQ(M1, w1, M2, w2) <=>
      !(f : mem(form(A))). satis(M1, w1, f#) <=> satis(M2, w2, f#): thm
val pufilter_def =
   {(A : set), (a : mem(A))}, 
   |- !(a' : mem(Pow(A))). IN(a'#, pufilter(a)) <=> IN(a, a'#): thm
val pufilter_filter =
   {},  |- !(A : set)  (a : mem(A#)). filter(pufilter(a#)): thm
val ueR_alt =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val pufilter_ufilter =
   {},  |- !(A : set)  (a : mem(A#)). ufilter(pufilter(a#)): thm
val Repu_eq_eq =
   {}, 
   |- !(W : set)  (u1 : mem(UFs(W#)))  (u2 : mem(UFs(W#))).
        Repu(u1#) = Repu(u2#) ==> u1# = u2#: thm
val Pft_def =
   {(W : set), (w0 : mem(W))}, 
   |- !(ws : mem(Pow(W))). IN(ws#, Repu(Pft(w0))) <=> IN(w0, ws#): thm
val Prop_5_5_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W)))
      (Y : mem(Pow(W))).
        osee(M#, Inter(X#, Y#)) = Inter(osee(M#, X#), osee(M#, Y#)): thm
val SW_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(form(A)))  (w : mem(W)).
        IN(w#, App(SW(M), a#)) <=> satis(M, w#, a#): thm
val Sw_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A)))},  |- Sw(M, f) = App(SW(M), f): thm
val Sw_Bot =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Sw(M#, Bot(A)) = Empty(W):
   thm
val Sw_Var =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        Sw(M#, Var(p#)) = App(HAT(M#), p#): thm
val Vof_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Vof(UE(M#)) = tof(ueV(M#)):
   thm
val HAT_Tat =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        App(HAT(M#), p#) = Tat(Vof(M#), p#): thm
val Sw_Neg =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        Sw(M#, Neg(f#)) = Compl(Sw(M#, f#)): thm
val Sw_Disj =
   {(A : set), (W : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        Sw(M#, Disj(f1, f2)) = Union(Sw(M#, f1), Sw(M#, f2)): thm
val Rm_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (u' : mem(UFs(W))).
        Rm(UE(M#), u#, u'#) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(u'#)) ==> IN(csee(M#, X#), Repu(u#)):
   thm
val csee_Sw_DIAM =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        csee(M#, Sw(M#, f#)) = Sw(M#, Diam(f#)): thm
val Prop_5_8 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
      (phi : mem(form(A)))  (u : mem(UFs(W#))).
        IN(Sw(M#, phi#), Repu(u#)) <=> satis(UE(M#), u#, phi#): thm
val Prop_5_7 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        MEQ(M#, w#, UE(M#), Pft(w#)): thm
val SATIS_Sing =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f : mem(form(A))). SATIS(M#, w#, Sing(f#)) <=> satis(M#, w#, f#): thm
val Fin_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(s1#) | Fin(s2#) ==> Fin(Inter(s1#, s2#)): thm
val SATIS_Union =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SATIS(M#, w#, Union(s1#, s2#)) <=>
        SATIS(M#, w#, s1#) & SATIS(M#, w#, s2#): thm
val only_see_whole_world =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        osee(M#, Whole(W)) = Whole(W): thm
val SATIS_Empty =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        SATIS(M#, w#, Empty(form(A))): thm
val BIGCONJ_EXISTS =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        ?(ff : mem(form(A))).
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val SS_Union_of =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s1#, s#) & SS(s2#, s#) ==> SS(Union(s1#, s2#), s#): thm
val Prop_5_9 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Msat(UE(M#)): thm
val PE_BIGCONJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val PE_Conj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#)): thm
val PE_BIGDISJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)).
            satis(M#, w#, ff#) <=>
            ?(f : mem(form(A))). IN(f#, s#) & satis(M#, w#, f#): thm
val PE_Disj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#)): thm
val PE_Diam =
   {(A : set)},  |- !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val Thm_6_22 =
   {(A : set), (W1 : set), (W2 : set)}, 
   |- !(M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A))))
      (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))).
        Msat(M1#) & Msat(M2#) ==>
        !(w1 : mem(W1))  (w2 : mem(W2)).
          (!(f : mem(form(A))).
              PE(f#) ==> satis(M1#, w1#, f#) ==> satis(M2#, w2#, f#)) ==>
          ?(R : rel(W1, W2)). Sim(R#, M1#, M2#) & Holds(R#, w1#, w2#): thm
val ENT_def =
   {(A : set), (phis : mem(Pow(form(A)))), (psi : mem(form(A)))}, 
   |- ENT(phis, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        SATIS(M#, w#, phis) ==> satis(M#, w#, psi): thm
val MCOMPACT_def =
   {}, 
   |- MCOMPACT <=>
      !(A : set)  (fs : mem(Pow(form(A#)))).
        (!(ffs : mem(Pow(form(A#)))).
            SS(ffs#, fs#) & Fin(ffs#) ==>
            ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
            (w : mem(W#)). SATIS(M#, w#, ffs#)) ==>
        ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
        (w : mem(W#)). SATIS(M#, w#, fs#): thm
val satis_Neg =
   {(A : set), (W : set), (f : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        satis(M#, w#, Neg(f)) <=> ~satis(M#, w#, f): thm
val Ent_def =
   {(A : set), (phi : mem(form(A))), (psi : mem(form(A)))}, 
   |- Ent(phi, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, phi) ==> satis(M#, w#, psi): thm
val SATIS_SS =
   {(A : set), (W : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==>
        !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
          SATIS(M#, w#, s2#) ==> SATIS(M#, w#, s1#): thm
val Thm_6_24 =
   {(A : set)}, 
   |- MCOMPACT ==>
      !(fs : mem(Pow(form(A))))  (phi : mem(form(A))).
        ENT(fs#, phi#) ==>
        ?(ffs : mem(Pow(form(A)))).
          SS(ffs#, fs#) & Fin(ffs#) & ENT(ffs#, phi#): thm
val Fin_ENT_PE =
   {(A : set)}, 
   |- !(fs : mem(Pow(form(A)))).
        Fin(fs#) & (!(f : mem(form(A))). IN(f#, fs#) ==> PE(f#)) ==>
        ?(phi : mem(form(A))).
          PE(phi#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). SATIS(M#, w#, fs#) <=> satis(M#, w#, phi#): thm
val PEC_def =
   {(A : set), (f : mem(form(A)))}, 
   |- !(a : mem(form(A))). IN(a#, PEC(f)) <=> PE(a#) & Ent(f, a#): thm
val SATIS_PEC =
   {(A : set), (W : set)}, 
   |- !(f : mem(form(A)))  (M : mem(Pow((W * W)) * Exp(W, Pow(A))))
      (w : mem(W)). satis(M#, w#, f#) ==> SATIS(M#, w#, PEC(f#)): thm
val Del_Fin =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        Fin(Del(s#, a#)) ==> Fin(s#): thm
val Fin_Inj0 =
   {}, 
   |- !(B : set)  (s : mem(Pow(B#))).
        Fin(s#) ==>
        !(A : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
          s# = IMAGE(f#, ss#) ==> Inj(f#) ==> Fin(ss#): thm
val Fin_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(ss : mem(Pow(A#))). Fin(IMAGE(f#, ss#)) ==> Fin(ss#):
   thm
val Thm_6_25_iff =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) <=> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val Thm_6_25_l2r =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) ==> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val it = (): unit
******

Loading SEAR file SEARllist.sml

******
val IN_gfp =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (a : mem(A)).
        IN(a#, gfp(f#)) <=>
        ?(sa : mem(Pow(A))). SS(sa#, App(f#, sa#)) & IN(a#, sa#): thm
val gfp_def =
   {}, 
   |- !(A : set)  (f : fun(Pow(A#), Pow(A#))). gfp(f#) = BIGUNION(prims(f#)):
   thm
val prims_def =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- !(a : mem(Pow(A))). IN(a#, prims(f)) <=> SS(a#, App(f, a#)): thm
val weak_coind =
   {}, 
   |- !(A : set)  (sa : mem(Pow(A#)))  (a : mem(A#))
      (f : fun(Pow(A#), Pow(A#))).
        IN(a#, sa#) & SS(sa#, App(f#, sa#)) ==> IN(a#, gfp(f#)): thm
val SS_gfp_fgfp =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(gfp(f), App(f, gfp(f))): thm
val monotone_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(Pow(A#), Pow(B#))).
        monotone(f#) <=>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          SS(s1#, s2#) ==> SS(App(f#, s1#), App(f#, s2#)): thm
val rules0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(App(f, gfp(f)), gfp(f)): thm
val cases0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> gfp(f) = App(f, gfp(f)): thm
val coind0 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (sa : mem(Pow(A))).
        SS(sa#, App(f#, sa#)) ==> SS(sa#, gfp(f#)): thm
val lcons0_def =
   {}, 
   |- !(X : set)  (f0 : fun(N, X# + 1))  (x : mem(X#)).
        App(lcons0(x#, f0#), O) = SOME(x#) &
        !(n : mem(N)). App(lcons0(x#, f0#), Suc(n#)) = App(f0#, n#): thm
val llf_uex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Exp(N, X + 1)), Pow(Exp(N, X + 1)))).
        !(gs : mem(Pow(Exp(N, X + 1))))  (g : mem(Exp(N, X + 1))).
          IN(g#, App(f#, gs#)) <=>
          g# = Tpm(Null(X)) |
          ?(h : mem(X))  (t : fun(N, X + 1)).
            g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_def =
   {}, 
   |- !(X : set)  (gs : mem(Pow(Exp(N, X# + 1))))  (g : mem(Exp(N, X# + 1))).
        IN(g#, App(llf(X#), gs#)) <=>
        g# = Tpm(Null(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_monotone = {},  |- !(X : set). monotone(llf(X#)): thm
val islls_def = {(X : set)},  |- islls(X) = gfp(llf(X)): thm
val llist_def1 =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          IN(a#, islls(X#)) <=>
          ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_Inj = {},  |- !(X : set). Inj(repll(X#)): thm
val isll_def =
   {}, 
   |- !(X : set)  (l : mem(Exp(N, X# + 1))). isll(l#) <=> IN(l#, islls(X#)):
   thm
val ll_cases = {},  |- !(X : set). islls(X#) = App(llf(X#), islls(X#)): thm
val ll_coind =
   {}, 
   |- !(X : set)  (sa : mem(Pow(Exp(N, X# + 1)))).
        (!(a : mem(Exp(N, X# + 1))).
            IN(a#, sa#) ==>
            a# = Tpm(Null(X#)) |
            ?(h : mem(X#))  (t : fun(N, X# + 1)).
              a# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), sa#)) ==>
        !(a : mem(Exp(N, X# + 1))). IN(a#, sa#) ==> IN(a#, islls(X#)): thm
val ll_rules =
   {}, 
   |- !(X : set).
        IN(Tpm(Null(X#)), islls(X#)) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          IN(Tpm(t#), islls(X#)) ==> IN(Tpm(lcons0(h#, t#)), islls(X#)): thm
val isll_lnil = {},  |- !(X : set). isll(Tpm(Null(X#))): thm
val isll_shift =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val Repll_def =
   {},  |- !(X : set)  (l : mem(llist(X#))). Repll(l#) = App(repll(X#), l#):
   thm
val LNil_def = {},  |- !(X : set). Repll(LNil(X#)) = Tpm(Null(X#)): thm
val llist_def =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          isll(a#) <=> ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_isll =
   {},  |- !(X : set)  (ll : mem(llist(X#))). isll(App(repll(X#), ll#)): thm
val isll_Repll =
   {}, 
   |- !(X : set)  (a : mem(Exp(N, X# + 1))).
        isll(a#) <=> ?(b : mem(llist(X#))). a# = Repll(b#): thm
val Repll_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(llist(X#)))  (l2 : mem(llist(X#))).
        Repll(l1#) = Repll(l2#) <=> l1# = l2#: thm
val Repll_isll = {},  |- !(X : set)  (ll : mem(llist(X#))). isll(Repll(ll#)):
   thm
val isll_lcons0 =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val isll_rules =
   {}, 
   |- !(X : set).
        isll(Tpm(Null(X#))) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          isll(Tpm(t#)) ==> isll(Tpm(lcons0(h#, t#))): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LCons_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#)))  (x : mem(X#)).
        Repll(LCons(x#, ll#)) = Tpm(lcons0(x#, tof(Repll(ll#)))): thm
val Repll_lnil_uex =
   {}, 
   |- !(X : set)  (l : mem(llist(X#))).
        Repll(l#) = Tpm(Null(X#)) <=> l# = LNil(X#): thm
val FPB_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- App(FPB(f), NONE(B * A)) = NONE(B * A) &
      !(b : mem(B))  (a : mem(A)).
        App(FPB(f), SOME(Pair(b#, a#))) = App(f, b#): thm
val FP_def =
   {(X : set), (f : fun(X, X))}, 
   |- !(x : mem(X)).
        App(FP(f), Pair(O, x#)) = x# &
        !(n : mem(N)).
          App(FP(f), Pair(Suc(n#), x#)) = App(FP(f), Pair(n#, App(f, x#))):
   thm
val OB_def =
   {(A : set), (B : set)}, 
   |- !(f : fun(A, B + 1)).
        App(OB(A, B), Pair(NONE(A), Tpm(f#))) = NONE(B) &
        !(a : mem(A)). App(OB(A, B), Pair(SOME(a#), Tpm(f#))) = App(f#, a#):
   thm
val lnil_def = {(X : set)},  |- lnil(X) = Tpm(Null(X)): thm
val toabs_char0 =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)).
        (App(f#, z#) = NONE(B * A) ==> toabs(f#, z#) = Null(A)) &
        !(b : mem(B))  (a : mem(A)).
          App(f#, z#) = SOME(Pair(b#, a#)) ==>
          toabs(f#, z#) = lcons0(a#, toabs(f#, b#)): thm
val toabs_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1)), (z : mem(B))}, 
   |- !(n : mem(N)).
        App(toabs(f, z), n#) =
          App(OM(p2(B, A)), App(FP(FPB(f)), Pair(n#, App(f, z)))): thm
val toabs_isll =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)). isll(Tpm(toabs(f#, z#))): thm
val toabs_unique =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (g : fun(B, Exp(N, A + 1))).
        (!(z : mem(B)).
            (App(f#, z#) = NONE(B * A) ==> App(g#, z#) = Tpm(Null(A))) &
            !(b : mem(B))  (a : mem(A)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(g#, z#) = Tpm(lcons0(a#, tof(App(g#, b#))))) ==>
        !(z : mem(B)). App(g#, z#) = Tpm(toabs(f#, z#)): thm
val llcr0_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- !(z : mem(B)). App(llcr0(f), z#) = Tpm(toabs(f, z#)): thm
val llrec0_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, Exp(N, A# + 1))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = Tpm(Null(A#))) &
            (!(b : mem(B#))  (a : mem(A#)).
                App(f#, z#) = SOME(Pair(b#, a#)) ==>
                App(cr#, z#) = Tpm(lcons0(a#, tof(App(cr#, b#))))) &
            isll(App(cr#, z#)): thm
val llcr_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, llist(A#))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = LNil(A#)) &
            !(b : mem(B#))  (a : mem(A#)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(cr#, z#) = LCons(a#, App(cr#, b#)): thm
val CB_def =
   {(X : set)}, 
   |- !(R : mem(Pow(llist(X) * llist(X))))  (ll1 : mem(llist(X)))
      (ll2 : mem(llist(X))).
        IN(Pair(ll1#, ll2#), App(CB(X), R#)) <=>
        ll1# = LNil(X) & ll2# = LNil(X) |
        ?(l01 : mem(llist(X)))  (l02 : mem(llist(X)))  (x : mem(X)).
          IN(Pair(l01#, l02#), R#) &
          ll1# = LCons(x#, l01#) & ll2# = LCons(x#, l02#): thm
val CB_monotone = {(X : set)},  |- monotone(CB(X)): thm
val CB_cases = {},  |- !(X : set). gfp(CB(X#)) = App(CB(X#), gfp(CB(X#))):
   thm
val CB_rules0 =
   {}, 
   |- !(X : set).
        IN(Pair(LNil(X#), LNil(X#)), gfp(CB(X#))) &
        !(l01 : mem(llist(X#)))  (l02 : mem(llist(X#))).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          !(x : mem(X#)).
            IN(Pair(LCons(x#, l01#), LCons(x#, l02#)), gfp(CB(X#))): thm
val CB_rules00 =
   {}, 
   |- !(X : set).
        (!(b : mem(llist(X#)))  (a' : mem(llist(X#))).
            a'# = LNil(X#) ==>
            b# = LNil(X#) ==> IN(Pair(a'#, b#), gfp(CB(X#)))) &
        !(a' : mem(llist(X#)))  (b : mem(llist(X#)))  (l01 : mem(llist(X#)))
        (l02 : mem(llist(X#)))  (x : mem(X#)).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          a'# = LCons(x#, l01#) ==>
          b# = LCons(x#, l02#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val CB_coind0 =
   {}, 
   |- !(X : set)  (sa : mem(Pow(llist(X#) * llist(X#)))).
        (!(a' : mem(llist(X#)))  (b : mem(llist(X#))).
            IN(Pair(a'#, b#), sa#) ==>
            a'# = LNil(X#) & b# = LNil(X#) |
            ?(l01 : mem(llist(X#)))  (l02 : mem(llist(X#)))  (x : mem(X#)).
              IN(Pair(l01#, l02#), sa#) &
              a'# = LCons(x#, l01#) & b# = LCons(x#, l02#)) ==>
        !(a' : mem(llist(X#)))  (b : mem(llist(X#))).
          IN(Pair(a'#, b#), sa#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val LHD_THM =
   {(X : set)}, 
   |- LHD(LNil(X)) = NONE(X) &
      !(h : mem(X))  (t : mem(llist(X))). LHD(LCons(h#, t#)) = SOME(h#): thm
val LHD_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))). LHD(ll#) = App(tof(Repll(ll#)), O):
   thm
val LNTH_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). LNTH(n#, ll1#) = LNTH(n#, ll2#)) <=> ll1# = ll2#: thm
val LNTH_def =
   {}, 
   |- !(A : set)  (ll : mem(llist(A#)))  (n : mem(N)).
        LNTH(n#, ll#) = App(tof(Repll(ll#)), n#): thm
val Repll_n_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). App(tof(Repll(ll1#)), n#) = App(tof(Repll(ll2#)), n#)) <=>
        ll1# = ll2#: thm
val isll_cases0 =
   {}, 
   |- !(X : set)  (x : mem(Exp(N, X# + 1))).
        isll(x#) <=>
        x# = Repll(LNil(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          x# = Tpm(lcons0(h#, t#)) & isll(Tpm(t#)): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LTL_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        (LHD(ll#) = NONE(X#) ==> LTL(ll#) = NONE(llist(X#))) &
        !(hd : mem(X#)).
          LHD(ll#) = SOME(hd#) ==>
          ?(ltl0 : mem(llist(X#))).
            LTL(ll#) = SOME(ltl0#) &
            !(n : mem(N)).
              App(tof(Repll(ltl0#)), n#) = App(tof(Repll(ll#)), Suc(n#)): thm
val LCons_xor_LNil =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        ~ll# = LNil(X#) <=>
        ?(h : mem(X#))  (t : mem(llist(X#))). ll# = LCons(h#, t#): thm
val LTL_THM =
   {(X : set)}, 
   |- LTL(LNil(X)) = NONE(llist(X)) &
      !(h : mem(X))  (t : mem(llist(X))). LTL(LCons(h#, t#)) = SOME(t#): thm
val LNTH_THM =
   {}, 
   |- !(X : set).
        (!(n : mem(N)). LNTH(n#, LNil(X#)) = NONE(X#)) &
        (!(h : mem(X#))  (t : mem(llist(X#))).
            LNTH(O, LCons(h#, t#)) = SOME(h#)) &
        !(n : mem(N))  (h : mem(X#))  (t : mem(llist(X#))).
          LNTH(Suc(n#), LCons(h#, t#)) = LNTH(n#, t#): thm
val gfp_CB =
   {}, 
   |- !(X : set)  (g1 : mem(llist(X#)))  (g2 : mem(llist(X#))).
        IN(Pair(g1#, g2#), gfp(CB(X#))) <=> g1# = g2#: thm
val LLIST_BISIMULATION0 =
   {(X : set)}, 
   |- !(ll1 : mem(llist(X)))  (ll2 : mem(llist(X))).
        ll1# = ll2# <=>
        ?(R : mem(Pow(llist(X) * llist(X)))).
          IN(Pair(ll1#, ll2#), R#) &
          !(ll3 : mem(llist(X)))  (ll4 : mem(llist(X))).
            IN(Pair(ll3#, ll4#), R#) ==>
            ll3# = LNil(X) & ll4# = LNil(X) |
            ?(h : mem(X))  (t1 : mem(llist(X)))  (t2 : mem(llist(X))).
              IN(Pair(t1#, t2#), R#) &
              ll3# = LCons(h#, t1#) & ll4# = LCons(h#, t2#): thm
val lcons0_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : fun(N, X + 1))
      (t2 : fun(N, X + 1)).
        lcons0(h1#, t1#) = lcons0(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LCons_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : mem(llist(X)))
      (t2 : mem(llist(X))).
        LCons(h1#, t1#) = LCons(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LMAP_def =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(z : mem(llist(X))).
        (App(lmapf(f), z#) = NONE(llist(X) * Y) ==>
          App(LMAP(f), z#) = LNil(Y)) &
        !(b : mem(llist(X)))  (a : mem(Y)).
          App(lmapf(f), z#) = SOME(Pair(b#, a#)) ==>
          App(LMAP(f), z#) = LCons(a#, App(LMAP(f), b#)): thm
val LMap_def =
   {(X : set), (Y : set), (f : fun(X, Y)), (l : mem(llist(X)))}, 
   |- LMap(f, l) = App(LMAP(f), l): thm
val f_ex0 =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(l : mem(llist(X))).
        ?!(opv : mem(llist(X) * A + 1)).
          l# = LNil(X) & opv# = NONE(llist(X) * A) |
          ?(lh : mem(X))  (lt : mem(llist(X))).
            l# = LCons(lh#, lt#) & opv# = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LNil =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A)). App(lmapf(f#), LNil(X)) = NONE(llist(X) * A): thm
val lmapf_def =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(a : mem(llist(X))).
        a# = LNil(X) & App(lmapf(f), a#) = NONE(llist(X) * A) |
        ?(lh : mem(X))  (lt : mem(llist(X))).
          a# = LCons(lh#, lt#) &
          App(lmapf(f), a#) = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LCons =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A))  (lh : mem(X))  (lt : mem(llist(X))).
        App(lmapf(f#), LCons(lh#, lt#)) = SOME(Pair(lt#, App(f#, lh#))): thm
val LMAP_LNil =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y)). App(LMAP(f#), LNil(X)) = LNil(Y): thm
val LMAP_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        App(LMAP(f#), LCons(lh#, lt#)) =
          LCons(App(f#, lh#), App(LMAP(f#), lt#)): thm
val LMap_LNil =
   {(X : set), (Y : set)},  |- !(f : fun(X, Y)). LMap(f#, LNil(X)) = LNil(Y):
   thm
val LMap_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        LMap(f#, LCons(lh#, lt#)) = LCons(App(f#, lh#), LMap(f#, lt#)): thm
val LMap_functorial =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (g : fun(Z, X))  (ll : mem(llist(Z))).
        LMap(f#, LMap(g#, ll#)) = LMap(f# o g#, ll#): thm
val it = (): unit
******

Loading SEAR file SEARGrp.sml

******
val Grp_def =
   {}, 
   |- !(G : set).
        Inj(iG(G#)) &
        !(a : mem(Exp((G# * G#), G#) * Exp(G#, G#) * G#)).
          isgrp(a#) <=> ?(b : mem(Grp(G#))). a# = App(iG(G#), b#): thm
val RepG_def = {(G : set), (g : mem(Grp(G)))},  |- RepG(g) = App(iG(G), g):
   thm
val RepG_isgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isgrp(RepG(g#)): thm
val asc_def =
   {(A : set), (m : fun(A * A, A))}, 
   |- asc(m) <=>
      !(a1 : mem(A))  (a2 : mem(A))  (a3 : mem(A)).
        mul(m, mul(m, a1#, a2#), a3#) = mul(m, a1#, mul(m, a2#, a3#)): thm
val isgrp_def =
   {(G : set), (g : mem(Exp((G * G), G) * Exp(G, G) * G))}, 
   |- isgrp(g) <=>
      asc(tof(c31(g))) &
      isunit(tof(c31(g)), c33(g)) & isinv(tof(c31(g)), tof(c32(g)), c33(g)):
   thm
val isinv_def =
   {(A : set), (e : mem(A)), (i : fun(A, A)), (m : fun(A * A, A))}, 
   |- isinv(m, i, e) <=>
      !(a : mem(A)). mul(m, App(i, a#), a#) = e & mul(m, a#, App(i, a#)) = e:
   thm
val isunit_def =
   {(A : set), (e : mem(A)), (m : fun(A * A, A))}, 
   |- isunit(m, e) <=> !(a : mem(A)). mul(m, e, a#) = a# & mul(m, a#, e) = a#:
   thm
val mul_def =
   {(G : set), (g1 : mem(G)), (g2 : mem(G)), (m : fun(G * G, G))}, 
   |- mul(m, g1, g2) = App(m, Pair(g1, g2)): thm
val Rnsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rnsg(g#)): thm
val eof_def = {(G : set), (g : mem(Grp(G)))},  |- eof(g) = c33(RepG(g)): thm
val ginv_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G))}, 
   |- ginv(g, x) = App(iof(g), x): thm
val gmul_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G)), (y : mem(G))}, 
   |- gmul(g, x, y) = mul(mof(g), x, y): thm
val iof_def = {(G : set), (g : mem(Grp(G)))},  |- iof(g) = tof(c32(RepG(g))):
   thm
val isghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (f : fun(G1#, G2#))
      (g2 : mem(Grp(G2#))).
        isghom(f#, g1#, g2#) <=>
        !(a : mem(G1#))  (b : mem(G1#)).
          App(f#, gmul(g1#, a#, b#)) = gmul(g2#, App(f#, a#), App(f#, b#)):
   thm
val isnml_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(sgrp(g)))}, 
   |- isnml(h) <=> !(a : mem(G)). rcs(h, a#) = lcs(a#, h): thm
val issgrp_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(Pow(G)))}, 
   |- issgrp(h, g) <=>
      IN(eof(g), h) &
      (!(a : mem(G))  (b : mem(G)).
          IN(a#, h) & IN(b#, h) ==> IN(gmul(g, a#, b#), h)) &
      !(a : mem(G)). IN(a#, h) ==> IN(ginv(g, a#), h): thm
val lcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, lcs(a, H)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, a, h#): thm
val lsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (x : mem(G#))
      (a : mem(G#)).
        IN(a#, lsmul(g#, x#, s#)) <=>
        ?(y : mem(G#)). IN(y#, s#) & a# = gmul(g#, x#, y#): thm
val mof_def = {(G : set), (g : mem(Grp(G)))},  |- mof(g) = tof(c31(RepG(g))):
   thm
val nsg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(sgrp(g))).
        (?(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#) <=>
        ?!(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#: thm
val nsg_uex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(sgrp(g#))).
        isnml(a#) ==> ?!(a : mem(nsgrp(g#))). App(Rnsg(g#), a#) = a#: thm
val nsgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))).
        Inj(Rnsg(g#)) &
        !(a : mem(sgrp(g#))).
          isnml(a#) <=> ?(b : mem(nsgrp(g#))). a# = App(Rnsg(g#), b#): thm
val rcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, rcs(H, a)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, h#, a): thm
val rcs_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        rcs(H#, a#) = rsmul(g#, rsg(H#), a#): thm
val rsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        rsg(H#) = App(Rsg(g#), H#): thm
val rsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (y : mem(G#))
      (a : mem(G#)).
        IN(a#, rsmul(g#, s#, y#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = gmul(g#, x#, y#): thm
val sgrp_def =
   {(G : set), (g : mem(Grp(G)))}, 
   |- Inj(Rsg(g)) &
      !(a : mem(Pow(G))).
        issgrp(a#, g) <=> ?(b : mem(sgrp(g))). a# = App(Rsg(g), b#): thm
val lcs_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        lcs(a#, H#) = lsmul(g#, a#, rsg(H#)): thm
val Rsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rsg(g#)): thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val sg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(Pow(G))).
        (?(a : mem(sgrp(g))). App(Rsg(g), a#) = b#) <=>
        ?!(a : mem(sgrp(g))). App(Rsg(g), a#) = b#: thm
val sg_uex =
   {}, 
   |- !(G : set)  (a : mem(Pow(G#)))  (g : mem(Grp(G#))).
        issgrp(a#, g#) ==> ?!(a : mem(sgrp(g#))). App(Rsg(g#), a#) = a#: thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val gmul_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, ginv(g#, a#), a#) = eof(g#) &
        gmul(g#, a#, ginv(g#, a#)) = eof(g#): thm
val asc_mof = {},  |- !(G : set)  (g : mem(Grp(G#))). asc(mof(g#)): thm
val gmul_assoc =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (c : mem(G#)).
        gmul(g#, gmul(g#, a#, b#), c#) = gmul(g#, a#, gmul(g#, b#, c#)): thm
val gmul_lcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, x#, y#) = gmul(g#, x#, z#) <=> y# = z#: thm
val gmul_rcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, y#, x#) = gmul(g#, z#, x#) <=> y# = z#: thm
val is_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        a1# = ginv(g#, a#) <=>
        gmul(g#, a#, a1#) = eof(g#) | gmul(g#, a1#, a#) = eof(g#): thm
val ginv_e =
   {},  |- !(G : set)  (g : mem(Grp(G#))). ginv(g#, eof(g#)) = eof(g#): thm
val e_sgrp =
   {},  |- !(G : set)  (g : mem(Grp(G#))). issgrp(Sing(eof(g#)), g#): thm
val esg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))). App(Rsg(g#), esg(g#)) = Sing(eof(g#)):
   thm
val rsg_esg =
   {},  |- !(G : set)  (g : mem(Grp(G#))). rsg(esg(g#)) = Sing(eof(g#)): thm
val e_nsgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isnml(esg(g#)): thm
val ensg_def =
   {},  |- !(G : set)  (g : mem(Grp(G#))). App(Rnsg(g#), ensg(g#)) = esg(g#):
   thm
val nsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(sgrp(g#))).
        nsg(h#) = App(LINV(Rnsg(g#), ensg(g#)), h#): thm
val qgR_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        Holds(qgR(H#), a#, b#) <=> lcs(a#, rnsg(H#)) = lcs(b#, rnsg(H#)): thm
val rnsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rnsg(H#) = App(Rnsg(g#), H#): thm
val qgR_Refl =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Refl(qgR(H#)):
   thm
val qgR_Sym =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Sym(qgR(H#)):
   thm
val qgR_Trans =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Trans(qgR(H#)):
   thm
val qgR_ER =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). ER(qgR(H#)):
   thm
val css_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Inj(Rcss(H#)) &
        !(a : mem(Pow(G#))).
          (?(a : mem(G#)). a# = rsi(qgR(H#), a#)) <=>
          ?(b : mem(css(H#))). a# = App(Rcss(H#), b#): thm
val Rcss_Inj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Inj(Rcss(H#)):
   thm
val rcss_def =
   {(G : set), (H : mem(nsgrp(g))), (cs : mem(css(H))), (g : mem(Grp(G)))}, 
   |- rcss(cs) = App(Rcss(H), cs): thm
val rcss_eq_eq =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (a : mem(css(H#)))  (b : mem(css(H#))). rcss(a#) = rcss(b#) <=> a# = b#:
   thm
val mem_css_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ?!(a : mem(css(H#))). rcss(a#) = rsi(qgR(H#), eof(g#)): thm
val Quot_qgR_Rcss =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(qgR(H#), Rcss(H#)): thm
val cs_def =
   {}, 
   |- !(G : set)  (a : mem(G#))  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        cs(a#, H#) = abs(qgR(H#), Rcss(H#), ecs(H#), a#): thm
val ecs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rcss(ecs(H#)) = rsi(qgR(H#), eof(g#)): thm
val rcss_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcss(cs(a#, H#)) = rsi(qgR(H#), a#): thm
val nsgrp_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val nsgrp_swap_l2r =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, a#, h#) = gmul(g#, h#, a#): thm
val smul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, smul(g#, s1#, s2#)) <=>
        ?(x : mem(G#))  (y : mem(G#)).
          IN(x#, s1#) & IN(y#, s2#) & a# = gmul(g#, x#, y#): thm
val nsgrp_swap_r2l =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, h#, a#) = gmul(g#, a#, h#): thm
val rsg_issgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        issgrp(rsg(H#), g#): thm
val e_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        IN(eof(g#), rsg(H#)): thm
val gmul_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h1 : mem(G#)).
        IN(h1#, rsg(H#)) ==>
        !(h2 : mem(G#)). IN(h2#, rsg(H#)) ==> IN(gmul(g#, h1#, h2#), rsg(H#)):
   thm
val ginv_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(H#)) ==> IN(ginv(g#, h#), rsg(H#)): thm
val gmul_lcs_smul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        lcs(gmul(g#, a#, b#), rnsg(H#)) =
          smul(g#, lcs(a#, rnsg(H#)), lcs(b#, rnsg(H#))): thm
val mof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o mof(g#),
       prrel(qgR(H#), qgR(H#))): thm
val prrel_qgR_ER =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ER(prrel(qgR(H#), qgR(H#))): thm
val qgR_Rcss_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#))): thm
val qgR_Rcss_abs_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        abs(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#)),
           Pair(ecs(H#), ecs(H#)), Pair(a#, b#)) =
          Pair(abs(qgR(H#), Rcss(H#), ecs(H#), a#),
           abs(qgR(H#), Rcss(H#), ecs(H#), b#)): thm
val ginv_oneside =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        gmul(g#, a#, a1#) = eof(g#) <=> gmul(g#, a1#, a#) = eof(g#): thm
val mulcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        mul(mulcs(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val sinv_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, sinv(g#, s#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = ginv(g#, x#): thm
val is_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        a# = eof(g#) <=>
        (?(x : mem(G#)). gmul(g#, a#, x#) = x#) |
        ?(x : mem(G#)). gmul(g#, x#, a#) = x#: thm
val ginv_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#)).
        ginv(g#, gmul(g#, a#, b#)) = gmul(g#, ginv(g#, b#), ginv(g#, a#)):
   thm
val ginv_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        ginv(g#, ginv(g#, a#)) = a#: thm
val ginv_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        lcs(ginv(g#, a#), rnsg(H#)) = sinv(g#, lcs(a#, rnsg(H#))): thm
val iof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o iof(g#), qgR(H#)): thm
val invcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(invcs(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_Surj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Surj(qmap(H#)):
   thm
val qmap_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qmap(H#) = Abs(qgR(H#), Rcss(H#), ecs(H#)): thm
val css_rep_ex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (b : mem(css(H#))). ?(a : mem(G#)). b# = cs(a#, H#): thm
val ecs_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ecs(H#) = cs(eof(g#), H#): thm
val mulcs_invcs_ecs_isgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isgrp(Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#)))): thm
val mof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        mof(qgrp(H#)) = mulcs(H#): thm
val qgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        RepG(qgrp(H#)) = Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#))):
   thm
val iof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        iof(qgrp(H#)) = invcs(H#): thm
val eof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        eof(qgrp(H#)) = ecs(H#): thm
val gmul_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        gmul(qgrp(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val ginv_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : set). ginv(qgrp(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(qmap(H#), a#) = cs(a#, H#): thm
val qmap_isghom =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isghom(qmap(H#), g#, qgrp(H#)): thm
val constf_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        isghom(constf(G1#, eof(g2#)), g1#, g2#): thm
val ghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)) &
        !(a : mem(Exp(G1#, G2#))).
          isghom(tof(a#), g1#, g2#) <=>
          ?(b : mem(ghom(g1#, g2#))). a# = App(ih(g1#, g2#), b#): thm
val ghom_ex_uex =
   {(G1 : set), (G2 : set), (g1 : mem(Grp(G1))), (g2 : mem(Grp(G2)))}, 
   |- !(b : mem(Exp(G1, G2))).
        (?(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#) <=>
        ?!(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#: thm
val ghom_uex =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (a : mem(Exp(G1#, G2#))).
        isghom(tof(a#), g1#, g2#) ==>
        ?!(a : mem(ghom(g1#, g2#))). App(ih(g1#, g2#), a#) = a#: thm
val ih_Inj =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)): thm
val eghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        App(ih(g1#, g2#), eghm(g1#, g2#)) = Tpm(constf(G1#, eof(g2#))): thm
val ghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : fun(G1#, G2#)).
        ghm(h#, g1#, g2#) = App(LINV(ih(g1#, g2#), eghm(g1#, g2#)), Tpm(h#)):
   thm
val homfun_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : mem(ghom(g1#, g2#))). homfun(h#) = tof(App(ih(g1#, g2#), h#)): thm
val isghom_homfun_ghm =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : fun(G1#, G2#)).
        isghom(f#, g1#, g2#) <=> homfun(ghm(f#, g1#, g2#)) = f#: thm
val IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#)).
        IN(x#, kers(f#)) <=> App(homfun(f#), x#) = eof(g2#): thm
val ker_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). ker(f#) = nsg(sg(kers(f#), g1#)): thm
val kers_def =
   {(G1 : set), (G2 : set), (f : mem(ghom(g1, g2))), (g1 : mem(Grp(G1))),
    (g2 : mem(Grp(G2)))},  |- kers(f) = PREIM(homfun(f), Sing(eof(g2))): thm
val sg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(Pow(G#))).
        sg(h#, g#) = App(LINV(Rsg(g#), esg(g#)), h#): thm
val homfun_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isghom(homfun(f#), g1#, g2#): thm
val homfun_gmul =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#))  (y : mem(G1#)).
        App(homfun(f#), gmul(g1#, x#, y#)) =
          gmul(g2#, App(homfun(f#), x#), App(homfun(f#), y#)): thm
val homfun_e =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). App(homfun(f#), eof(g1#)) = eof(g2#): thm
val homfun_ginv =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a : mem(G1#)).
        App(homfun(f#), ginv(g1#, a#)) = ginv(g2#, App(homfun(f#), a#)): thm
val e_IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). IN(eof(g1#), kers(f#)): thm
val kers_issgrp =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). issgrp(kers(f#), g1#): thm
val cjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (h : mem(G))}, 
   |- cjg(g, a, h) = gmul(g, a, gmul(g, h, ginv(g, a))): thm
val lsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (s : mem(Pow(G#))).
        lsmul(g#, a#, lsmul(g#, b#, s#)) = lsmul(g#, gmul(g#, a#, b#), s#):
   thm
val qhom_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qhom(H#) = ghm(qmap(H#), g#, qgrp(H#)): thm
val rsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        rsmul(g#, rsmul(g#, s#, a#), b#) = rsmul(g#, s#, gmul(g#, a#, b#)):
   thm
val lsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        lsmul(g#, eof(g#), s#) = s#: thm
val rsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        rsmul(g#, s#, eof(g#)) = s#: thm
val lsmul_rsmul_comm =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#)))
      (b : mem(G#)).
        rsmul(g#, lsmul(g#, a#, s#), b#) = lsmul(g#, a#, rsmul(g#, s#, b#)):
   thm
val isnml_alt =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). scjg(g#, a#, rsg(H#)) = rsg(H#): thm
val scjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (s : mem(Pow(G)))}, 
   |- scjg(g, a, s) = lsmul(g, a, rsmul(g, s, ginv(g, a))): thm
val scjg_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (H : mem(Pow(G#)))
      (x : mem(G#)).
        IN(x#, scjg(g#, a#, H#)) <=>
        ?(h : mem(G#)). IN(h#, H#) & x# = cjg(g#, a#, h#): thm
val SS_scjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#))).
        SS(scjg(g#, a#, s#), s#) <=>
        !(x : mem(G#)). IN(x#, s#) ==> IN(cjg(g#, a#, x#), s#): thm
val SS_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(rsmul(g#, s1#, a#), rsmul(g#, s2#, a#)): thm
val SS_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val isnml_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). SS(scjg(g#, a#, rsg(H#)), rsg(H#)): thm
val IN_gmul_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, H#) <=>
        !(b : mem(G#)). IN(gmul(g#, a#, b#), rsmul(g#, H#, b#)): thm
val IN_gmul_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (b : mem(G#)).
        IN(b#, H#) <=>
        !(a : mem(G#)). IN(gmul(g#, a#, b#), lsmul(g#, a#, H#)): thm
val gmul_IN_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val gmul_IN_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val rnsg_isnml =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). isnml(rnsg(H#)):
   thm
val rnsg_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val SS_ex_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        ?(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val same_cs_cond =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        cs(a#, H#) = cs(b#, H#) <=>
        IN(gmul(g#, a#, ginv(g#, b#)), rsg(rnsg(H#))): thm
val sg_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        sg(rsg(H#), g#) = H#: thm
val nsg_rnsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        nsg(rnsg(H#)) = H#: thm
val issgrp_rsg_sg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#))).
        issgrp(H#, g#) <=> rsg(sg(H#, g#)) = H#: thm
val isnml_rnsg_nsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> rnsg(nsg(H#)) = H#: thm
val sg_kers_isnml =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isnml(sg(kers(f#), g1#)): thm
val rsg_rnsg_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rsg(rnsg(ker(f#))) = kers(f#): thm
val rgh_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rgh(f#) = App(ih(g1#, g2#), f#): thm
val rgh_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        rgh(f1#) = rgh(f2#) <=> f1# = f2#: thm
val homfun_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        homfun(f1#) = homfun(f2#) <=> f1# = f2#: thm
val homfun_eq_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a1 : mem(G1#))  (a2 : mem(G1#)).
        App(homfun(f#), a1#) = App(homfun(f#), a2#) <=>
        App(homfun(f#), gmul(g1#, ginv(g1#, a1#), a2#)) = eof(g2#): thm
val homfun_resp1_qgR_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). resp1(homfun(f#), qgR(ker(f#))): thm
val first_iso_thm =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))).
        ?!(fb : mem(ghom(qgrp(ker(f#)), g2#))).
          Inj(homfun(fb#)) & homfun(fb#) o qmap(ker(f#)) = homfun(f#): thm
val it = (): unit
******

Loading SEAR file SEARexamplecol.sml

******
val AX5 =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
val cardeq_REFL = {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, s#): thm
val cardeq_def =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=>
      ?(R : rel(A, B)).
        (!(a : mem(A)).
            IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R#, a#, b#)) &
        !(b : mem(B)).
          IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R#, a#, b#): thm
val isset_def =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
val cardeq_SYM =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(s2#, s1#): thm
val cardeq_TRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#))).
          cardeq(s2#, s3#) ==> cardeq(s1#, s3#): thm
val restrict_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (R : rel(A#, B#))
      (s2 : mem(Pow(B#)))  (a : mem(A#))  (b : mem(B#)).
        Holds(restrict(R#, s1#, s2#), a#, b#) <=>
        IN(a#, s1#) & IN(b#, s2#) & Holds(R#, a#, b#): thm
val cardeq_Whole_Inj_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set).
        cardeq(s#, Whole(B#)) ==>
        ?(i : fun(B#, A#)). Inj(i#) & IMAGE(i#, Whole(B#)) = s#: thm
val cardeq_Inj_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> cardeq(Whole(A#), IMAGE(f#, Whole(A#))): thm
val Inj_Image =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Inj(f#) ==> Inj(Image(f#)):
   thm
val IMAGE_INJ_cardeq =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#)))
      (f : fun(A#, B#)).
        INJ(f#, s1#, s2#) ==>
        !(s01 : mem(Pow(A#))).
          SS(s01#, s1#) ==> cardeq(s01#, IMAGE(f#, s01#)): thm
val INJ_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (t : mem(Pow(B#))).
        INJ(f#, s#, t#) <=>
        (!(x : mem(A#)). IN(x#, s#) ==> IN(App(f#, x#), t#)) &
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==> App(f#, x#) = App(f#, y#) ==> x# = y#:
   thm
val Inj_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). INJ(f#, s#, IMAGE(f#, s#)): thm
val INJ_SS_dom =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(A#))). SS(s#, s1#) ==> INJ(f#, s#, s2#): thm
val INJ_SS_cod =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(B#))). SS(s2#, s#) ==> INJ(f#, s1#, s#): thm
val o_INJ_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(C : set)  (g : fun(B#, C#))  (s3 : mem(Pow(C#))).
          INJ(g#, s2#, s3#) ==> INJ(g# o f#, s1#, s3#): thm
val cardeq_Inj_IMAGE_gen =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). cardeq(s#, IMAGE(f#, s#)): thm
val INJ_INS_NONE =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X# + 1)))).
        (!(s0 : mem(Pow(X# + 1))). IN(s0#, s#) ==> ~IN(NONE(X#), s0#)) ==>
        INJ(INS(NONE(X#)), s#, IMAGE(INS(NONE(X#)), s#)): thm
val INS_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (a : mem(Pow(X#))).
        App(INS(x0#), a#) = Ins(x0#, a#): thm
val POW_Whole_Pow = {},  |- !(A : set). POW(Whole(A#)) = Whole(Pow(A#)): thm
val POW_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (a : mem(Pow(A#))).
        IN(a#, POW(s0#)) <=> SS(a#, s0#): thm
val cardeq_POW_Whole_Pow =
   {},  |- !(A : set). cardeq(POW(Whole(A#)), Whole(Pow(A#))): thm
val FIB_constf =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#)).
        FIB(constf(A#, b#), b#) = Whole(A#): thm
val nPow_def =
   {}, 
   |- !(A : set)  (B : set)  (n : mem(N)).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)).
          cardeq(FIB(f#, O), Whole(A#)) &
          cardeq(FIB(f#, n#), Whole(B#)) &
          !(n0 : mem(N)).
            Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPow_O = {},  |- !(A : set). nPow(O, A#, A#): thm
val OE_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- OE(f, b0) = coPa(f, El(b0)): thm
val Sg_Sing = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Sgf_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- (!(a : mem(A)). App(Sgf(f, b0), Sing(a#)) = App(f, a#)) &
      !(s : mem(Pow(A))).
        (!(a : mem(A)). ~s# = Sing(a#)) ==> App(Sgf(f, b0), s#) = b0: thm
val content_Sing =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        App(content(x0#), Sing(x#)) = x#: thm
val content_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#)).
        (!(s : mem(Pow(X#)))  (x : mem(X#)).
            s# = Sing(x#) ==> App(content(x0#), s#) = x#) &
        !(s : mem(Pow(X#))).
          (!(x : mem(X#)). ~s# = Sing(x#)) ==> App(content(x0#), s#) = x0#:
   thm
val ctt_def =
   {}, 
   |- !(X : set)  (s : mem(Pow(X#)))  (x0 : mem(X#)).
        ctt(s#, x0#) = App(content(x0#), s#): thm
val PREIM_i1_Sing_SOME =
   {(X : set), (x0 : mem(X))},  |- PREIM(i1(X, 1), Sing(SOME(x0))) = Sing(x0):
   thm
val IMAGE_Sing =
   {(A : set), (B : set), (a : mem(A)), (f : fun(A, B))}, 
   |- IMAGE(f, Sing(a)) = Sing(App(f, a)): thm
val ctt_Sing =
   {},  |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)). ctt(Sing(a#), a0#) = a#:
   thm
val Sing_SOME_NEQ_Ins_NONE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A# + 1))).
        ~Sing(SOME(a#)) = Ins(NONE(A#), s#): thm
val SS_Ri_restrict =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (a : mem(Pow(A#)))  (B : set)
      (R : rel(A#, B#))  (s2 : mem(Pow(B#))).
        SS(App(Ri(restrict(R#, s1#, s2#)), a#), s2#): thm
val biunique_def =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) <=>
      (!(a : mem(A)).
          IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R, a#, b#)) &
      !(b : mem(B)).
        IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R, a#, b#): thm
val nPow_Suc_ex_lemma =
   {}, 
   |- !(C : set)  (X : set)  (i : fun(C#, Pow(X#))).
        Inj(i#) ==>
        !(B : set)  (f : fun(X#, B#))  (bs : mem(Pow(B#)))  (b0 : mem(B#)).
          (!(x : mem(X#)). ~App(f#, x#) = b0#) ==>
          ~IN(b0#, bs#) ==>
          !(b1 : mem(B#)).
            ~b1# = b0# & ~IN(b1#, bs#) ==>
            ?(f1 : fun(Pow(X# + 1), B#)).
              (!(b : mem(B#)).
                  IN(b#, bs#) ==>
                  FIB(f1#, b#) = IMAGE(Sg(X# + 1) o i1(X#, 1), FIB(f#, b#))) &
              FIB(f1#, b0#) =
                IMAGE(INS(NONE(X#)) o Image(i1(X#, 1)) o i#, Whole(C#)): thm
val biunique_op =
   {(A : set), (B : set)}, 
   |- !(R : rel(A, B))  (s1 : mem(Pow(A)))  (s2 : mem(Pow(B))).
        biunique(R#, s1#, s2#) ==> biunique(op(R#), s2#, s1#): thm
val biunique_Ri_restrict =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) ==>
      !(s : mem(Pow(A))).
        SS(s#, s1) ==>
        App(Ri(restrict(op(R), s2, s1)), App(Ri(restrict(R, s1, s2)), s#)) =
          s#: thm
val cardeq_POW =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(POW(s1#), POW(s2#)): thm
val cardeq_biunique =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=> ?(R : rel(A, B)). biunique(R#, s1, s2): thm
val cardeq_BITRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#)))  (D : set)  (s4 : mem(Pow(D#))).
          cardeq(s3#, s4#) ==> (cardeq(s1#, s3#) <=> cardeq(s2#, s4#)): thm
val NONE_NOTIN_IMAGE_i1 =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X#))))  (s0 : mem(Pow(X# + 1))).
        IN(s0#, IMAGE(Image(i1(X#, 1)), s#)) ==> ~IN(NONE(X#), s0#): thm
val shrink_IMAGE =
   {}, 
   |- !(X : set)  (B : set)  (f0 : fun(X#, B#))  (s : mem(Pow(B#)))
      (b0 : mem(B#)).
        ~IN(b0#, s#) ==>
        (!(b : mem(B#)).
            IN(b#, s#) ==> FIB(shrink(f0#, s#, b0#), b#) = FIB(f0#, b#)) &
        !(x : mem(X#)).
          ~IN(App(f0#, x#), s#) ==> App(shrink(f0#, s#, b0#), x#) = b0#: thm
val shrink_def =
   {(B : set), (X : set), (b0 : mem(B)), (f0 : fun(X, B)), (s : mem(Pow(B)))},
   
   |- !(a : mem(X)).
        (IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = App(f0, a#)) &
        (~IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = b0): thm
val nPow_shrink_IMAGE_ex =
   {(A : set), (An : set), (n : mem(N))}, 
   |- nPow(n, A, An) ==>
      ?(X : set)  (f : fun(X#, N)).
        cardeq(FIB(f#, O), Whole(A)) &
        cardeq(FIB(f#, n), Whole(An)) &
        (!(n0 : mem(N)).
            Lt(n0#, n) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#)))) &
        !(x : mem(X#)). ~App(f#, x#) = Suc(n): thm
val nPow_Suc =
   {(n : mem(N))}, 
   |- !(A : set)  (An : set). nPow(n, A#, An#) ==> nPow(Suc(n), A#, Pow(An#)):
   thm
val nPow_ex =
   {},  |- !(A : set)  (n : mem(N)). ?(An : set). nPow(n#, A#, An#): thm
val cardeq_m2s =
   {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, Whole(m2s(s#))): thm
val m2s_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Inj(minc(s#)) &
        !(a : mem(A#)).
          IN(a#, s#) <=> ?(b : mem(m2s(s#))). a# = App(minc(s#), b#): thm
val nPowf_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, N))  (n : mem(N)).
        nPowf(n#, A#, B#, f#) <=>
        cardeq(FIB(f#, O), Whole(A#)) &
        cardeq(FIB(f#, n#), Whole(B#)) &
        !(n0 : mem(N)).
          Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPowf_Preds =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> ?(B0 : set). nPowf(n0#, A#, B0#, f#):
   thm
val nPowf_Preds_FIB =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> nPowf(n0#, A#, m2s(FIB(f#, n0#)), f#):
   thm
val nPow_nPowf =
   {}, 
   |- !(A : set)  (n : mem(N))  (B : set).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)). nPowf(n#, A#, B#, f#): thm
val nPow_unique =
   {}, 
   |- !(A : set)  (n : mem(N))  (An1 : set)  (An2 : set).
        nPow(n#, A#, An1#) & nPow(n#, A#, An2#) ==>
        cardeq(Whole(An1#), Whole(An2#)): thm
val nPow_uex =
   {}, 
   |- !(A : set)  (n : mem(N)).
        ?(An : set).
          nPow(n#, A#, An#) &
          !(An1 : set).
            nPow(n#, A#, An1#) ==> cardeq(Whole(An#), Whole(An1#)): thm
val Pn_def = {},  |- !(A : set)  (n : mem(N)). nPow(n#, A#, Pn(A#, n#)): thm
val cardeq_Whole_REFL = {},  |- !(An : set). cardeq(Whole(An#), Whole(An#)):
   thm
val cardeq_Whole_SYM =
   {}, 
   |- !(An : set)  (An' : set).
        cardeq(Whole(An#), Whole(An'#)) ==> cardeq(Whole(An'#), Whole(An#)):
   thm
val cardeq_Whole_TRANS =
   {}, 
   |- !(An : set)  (An' : set)  (An'' : set).
        cardeq(Whole(An#), Whole(An'#)) & cardeq(Whole(An'#), Whole(An''#)) ==>
        cardeq(Whole(An#), Whole(An''#)): thm
val isset_minc = {},  |- !(A : set)  (s : mem(Pow(A#))). isset(minc(s#), s#):
   thm
val large_ex =
   {}, 
   |- !(A : set).
        ?(P : set). !(n : mem(N)). ?(i : fun(Pn(A#, n#), P#)). Inj(i#): thm
val nPow_ts_ex = {},  |- !(A : set)  (n : mem(N)). ?(An : set). T: thm
val it = (): unit
val it = (): unit
> # # # # # # # val isset_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (A0 : set)
      (i : fun(A0#, A#))  (b : mem(B#)).
        isset(i#, FIB(f#, b#)) ==> f# o i# = constf(A0#, b#): thm
> > val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
               ?(V : set)  (p : fun(V#, U)).
                 Surj(p#) &
                 ?(A : set)  (fa : fun(A#, V#)).
                   !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                     isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holSwPfdDScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holIaJTNgScript.sml

******
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holIaJTNgScript.sml:22: error: ) expected but end was found
Exception- Fail "Static Errors" raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holWVe4WAScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x2))) = a' ==> a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(Pair(a, b)) = Fst(App(inc, App(i, x2)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   a = Fst(App(inc, App(i, x2)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x1))) = Fst(Pair(a', b'))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   a = Fst(App(inc, App(i, x2)))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   14.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   Fst(Pair(a, b)) = Fst(App(inc, App(i, x2)))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x2))) = a' ==> a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> # # # # # # # # # # # poly: : error: Value or constructor (traces) has not been declared
Found near #trace_level (valOf (List.find findfn (traces ())))
poly: : error: Value or constructor (set_trace) has not been declared
Found near
  if 0 < old then (set_trace nm 0; print "off\n") else
  (set_trace nm 1; print "on\n")
poly: : error: Value or constructor (set_trace) has not been declared
Found near
  if 0 < old then (set_trace nm 0; print "off\n") else
  (set_trace nm 1; print "on\n")
Static Errors
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol92eMzQScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   ----------------------------------------------------------------------
   Inj(p2(B, Y) o inc o i)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holscDscuScript.sml

******
2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   b = b'
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   ----------------------------------------------------------------------
   a = a'
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.App(p2(B, Y), Pair(a, b)) = App(p2(B, Y), Pair(a', b'))
   8.p1(B, Y) o inc o i = constf(vA, v)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, App(i, x1)) = Pair(a, b)
   12.App(inc, App(i, x2)) = Pair(a', b')
   13.a = Fst(App(inc, App(i, x1)))
   ----------------------------------------------------------------------
   Fst(App(inc, App(i, x2))) = a' ==> a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   
   ----------------------------------------------------------------------
   p1(B, Y) o inc o i = constf(vA, v) ==>
             Fst(App(inc, App(i, x2))) = a' ==>
             a' = Fst(App(inc, App(i, x1)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x2 : mem(vA))(x1 : mem(vA))(v : mem(B))(b' : mem(Y))(b :
      mem(Y))(a' : mem(B))(a : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.p1(B, Y) o inc o i = constf(vA, v)
   2.a' = Fst(App(inc, App(i, x2)))
   ----------------------------------------------------------------------
   App((p1(B, Y) o inc) o i, x2) = App((p1(B, Y) o inc) o i, x1)
   : proofmanager.proof
> val it =
   U
   
   ----------------------------------------------------------------------
   (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
             ?(V : set)  (p : fun(V#, U)).
               Surj(p#) &
               ?(A : set)  (fa : fun(A#, V#)).
                 !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
                   isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holflkU7OScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(v : mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i :
      fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   ----------------------------------------------------------------------
   ?(i : fun(vA, Y)). Inj(i#) & IMAGE(i#, Whole(vA)) = rsi(M, v)
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # 2 subgoals:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.a = v
   9.Holds(M, a, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(vA))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.x = App(p2(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   ?(a : mem(B)). a# = v & Holds(M, a#, x)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holHc3S9aScript.sml

******
1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = y
   8.Holds(M, v, y) <=> ?(b : mem(R)). Pair(v, y) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.b = App(p1(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   v = b
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = y
   8.Holds(M, v, y) <=> ?(b : mem(R)). Pair(v, y) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.b = App(p1(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   v = App(p1(B, Y), App(inc, App(i, a)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # poly: : error: Type error in function application.
   Function: drule : thm_tactic
   Argument: drule : thm_tactic
   Reason: Can't unify thm to thm -> tactic (Incompatible types)
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (drule drule isset_FIB) before
     Feedback.set_trace "show_typecheck_errors" old end)
poly: : error: Type error in function application.
   Function: drule drule : tactic
   Argument: isset_FIB : thm
   Reason: Can't unify thm to cont * form list * form (Incompatible types)
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (drule drule isset_FIB) before
     Feedback.set_trace "show_typecheck_errors" old end)
poly: : error: Type error in function application.
   Function: proofManagerLib.e : tactic -> proofmanager.proof
   Argument:
      (
      let val old = Feedback.current_trace "show_typecheck_errors";
         val _ = ... ... 0 in
         (drule drule isset_FIB) before
         Feedback.set_trace "show_typecheck_errors" old end) :
      goal list * validation
   Reason:
      Can't unify goal -> goal list * validation to goal list * validation
         (Incompatible types)
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (drule drule isset_FIB) before
     Feedback.set_trace "show_typecheck_errors" old end)
Static Errors
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = y
   8.Holds(M, v, y) <=> ?(b : mem(R)). Pair(v, y) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.b = App(p1(B, Y), App(inc, App(i, a)))
   11.(p1(B, Y) o inc) o i = constf(vA, v)
   ----------------------------------------------------------------------
   v = App(p1(B, Y), App(inc, App(i, a)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.x = y
   8.Holds(M, v, y) <=> ?(b : mem(R)). Pair(v, y) = App(inc, b#)
   9.App(inc, App(i, a)) = Pair(b, y)
   10.b = App(p1(B, Y), App(inc, App(i, a)))
   ----------------------------------------------------------------------
   (p1(B, Y) o inc) o i = constf(vA, v) ==>
             v = App(p1(B, Y), App(inc, App(i, a)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   
   ----------------------------------------------------------------------
   (p1(B, Y) o inc) o i = constf(vA, v) ==>
             v = App(p1(B, Y), App(inc, App(i, a)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(y : mem(Y))(x : mem(Y))(v : mem(B))(b : mem(B))(a :
      mem(vA))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.(p1(B, Y) o inc) o i = constf(vA, v)
   ----------------------------------------------------------------------
   v = App(p1(B, Y), App(inc, App(i, a)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.a = v
   9.Holds(M, a, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.a = v
   9.Holds(M, v, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Holds(M, Fst(Pair(v, x)), Snd(Pair(v, x))) <=>
             ?(b : mem(R)). Pair(v, x) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Pair(v, x) = App(inc, b)
   9.Holds(M, v, x) <=> ?(b : mem(R)). Pair(v, x) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Holds(M, Fst(Pair(v, x)), Snd(Pair(v, x))) <=>
             ?(b : mem(R)). Pair(v, x) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Pair(v, x) = App(inc, b)
   9.Holds(M, v, x) <=> ?(b : mem(R)). Pair(v, x) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Holds(M, Fst(Pair(v, x)), Snd(Pair(v, x))) <=>
             ?(b : mem(R)). Pair(v, x) = App(inc, b#)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.!(a : mem(B * Y)).
               Holds(M, Fst(a#), Snd(a#)) <=>
               ?(b : mem(R)). a# = App(inc, b#)
   6.isset(i, FIB(p1(B, Y) o inc, v))
   7.Inj(p2(B, Y) o inc o i)
   8.a = v
   9.Holds(M, v, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   ----------------------------------------------------------------------
   (Holds(M, Fst(Pair(v, x)), Snd(Pair(v, x))) <=>
               ?(b : mem(R)). Pair(v, x) = App(inc, b#)) ==>
             ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   ----------------------------------------------------------------------
   (?(b : mem(R)). Pair(v, x) = App(inc, b#)) ==>
             ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   ----------------------------------------------------------------------
   (Holds(M, Fst(Pair(v, x)), Snd(Pair(v, x))) <=>
               ?(b : mem(R)). Pair(v, x) = App(inc, b#)) ==>
             ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(a : mem(B))(p : fun(B, U))(inc :
      fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   ----------------------------------------------------------------------
   (?(b : mem(R)). Pair(v, x) = App(inc, b#)) ==>
             ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Pair(v, x) = App(inc, b)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Pair(v, x) = App(inc, b)
   10.Inj(i) & IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Pair(v, x) = App(inc, b)
   10.Inj(i)
   11.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # poly: : error: Value or constructor (IMAGE_eq_FIB) has not been declared
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (drule IMAGE_eq_FIB) before
     Feedback.set_trace "show_typecheck_errors" old end)
Static Errors
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holGN0ghlScript.sml

******
val IMAGE_eq_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))  (C : set)
      (p : fun(B#, C#))  (c : mem(C#)).
        IMAGE(f#, s#) = FIB(p#, c#) <=>
        !(b : mem(B#)).
          (?(a : mem(A#)). IN(a#, s#) & App(f#, a#) = b#) <=>
          App(p#, b#) = c#: thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # >   C-c C-cCompilation interrupted

> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Pair(v, x) = App(inc, b)
   10.Inj(i)
   11.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   12.!(b : mem(R)).
               (?(a : mem(vA)). IN(a#, Whole(vA)) & App(i, a#) = b#) <=>
               App(p1(B, Y) o inc, b#) = v
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Pair(v, x) = App(inc, b)
   10.Inj(i)
   11.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   12.!(b : mem(R)).
               (?(a : mem(vA)). App(i, a#) = b#) <=>
               App(p1(B, Y) o inc, b#) = v
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Pair(v, x) = App(inc, b)
   10.Inj(i)
   11.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   12.(?(a : mem(vA)). App(i, a#) = b) <=> App(p1(B, Y) o inc, b) = v
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Pair(v, x) = App(inc, b)
   10.Inj(i)
   11.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   12.(?(a : mem(vA)). App(i, a#) = b) <=> App(p1(B, Y), App(inc, b)) = v
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.(?(a : mem(vA)). App(i, a#) = b) <=> App(p1(B, Y), App(inc, b)) = v
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a : mem(B))(p :
      fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.(?(a : mem(vA)). App(i, a#) = b) <=> App(p1(B, Y), Pair(v, x)) = v
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, App(i, a')))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, b) = Pair(v, x)
   12.b = App(i, a')
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, App(i, a')))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, b) = Pair(v, x)
   12.b = App(i, a')
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, App(i, a')))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(inc, b) = Pair(v, x)
   12.b = App(i, a')
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, App(i, a')))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, App(i, a')))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   ?(a : mem(vA)). x = App(p2(B, Y), App(inc, App(i, a#)))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, App(i, a')))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, b))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   x = App(p2(B, Y), Pair(v, x))
   : proofmanager.proof
> val it =
   vAYURB(M : rel(B, Y))(x : mem(Y))(v : mem(B))(b : mem(R))(a' : mem(vA))(a :
      mem(B))(p : fun(B, U))(inc : fun(R, B * Y))(i : fun(vA, R))
   1.!(u : mem(U)). ?(X : set). P(u#, X#)
   2.!(a : mem(U))  (X : set). P(a#, X#) ==> ?(b : mem(B)). App(p, b#) = a#
   3.Surj(p)
   4.Inj(inc)
   5.isset(i, FIB(p1(B, Y) o inc, v))
   6.Inj(p2(B, Y) o inc o i)
   7.a = v
   8.Holds(M, v, x)
   9.Inj(i)
   10.IMAGE(i, Whole(vA)) = FIB(p1(B, Y) o inc, v)
   11.App(i, a') = b
   12.App(inc, b) = Pair(v, x)
   ----------------------------------------------------------------------
   x = App(p2(B, Y), App(inc, b))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{(U : set)}, 
   |- (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
      ?(V : set)  (p : fun(V#, U)).
        Surj(p#) &
        ?(A : set)  (fa : fun(A#, V#)).
          !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
            isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#):
   proofmanager.proof
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holeU9t8fScript.sml

******
val col_of_set =
   {(U : set)}, 
   |- (!(u : mem(U)). ?(X : set). P(u#, X#)) ==>
      ?(V : set)  (p : fun(V#, U)).
        Surj(p#) &
        ?(A : set)  (fa : fun(A#, V#)).
          !(v : mem(V#))  (vA : set)  (i : fun(vA#, A#)).
            isset(i#, FIB(fa#, v#)) ==> P(App(p#, v#), vA#): thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> # # # # # # # # Exception- TER ("not a variable: ", [], [Fun ("Z", srt ("set", []), [])])
   raised
> > # # # # # # # # Exception- ERR ("predicate with name: isPb already exists", [], [], [])
   raised
> > isPb_def;
poly: : error: Value or constructor (isPb_def) has not been declared Found near isPb_def
Static Errors
> Loading Binarymap
> # poly: : error: Value or constructor (delete) has not been declared in structure Binarymap
Found near Binarymap.delete
Static Errors
> Loading Binarymap
> # val it = fn: ('a, 'b) Binarymap.dict * 'a -> ('a, 'b) Binarymap.dict * 'b
> # val it = ?: psymd
> Loading Binarymap
> # >   C-c C-cCompilation interrupted

> # # # # # # # # Exception- ERR ("predicate with name: isPb already exists", [], [], [])
   raised
> Loading Binarymap
> # > # val it = fn: psymd -> string -> (string * sort) list option
> # poly: : error: Type error in function application.
   Function: lookup_pred : psymd -> string -> (string * sort) list option
   Argument: (! psyms, "isPb") : psymd * string
   Reason:
      Can't unify (string, (string * sort) list) Binarymap.dict to
         psymd * string (Incompatible types)
Found near lookup_pred (! psyms, "isPb")
Static Errors
> # val it =
   SOME
    [("f", fun(X, Z)), ("g", fun(Y, Z)), ("p", fun(P, X)), ("q", fun(P, Y))]:
   (string * sort) list option
> Loading Binarymap
> # # val it =
   (?,
    [("f", fun(X, Z)), ("g", fun(Y, Z)), ("p", fun(P, X)), ("q", fun(P, Y))]):
   (string, (string * sort) list) Binarymap.dict * (string * sort) list
> Loading Binarymap
> # poly: : error: Type error in function application.
   Function: := : psymd ref * psymd -> unit
   Argument: (psyms, Binarymap.remove (! psyms, "isPb")) :
      psymd ref *
      ((string, (string * sort) list) Binarymap.dict * (string * sort) list)
   Reason:
      Can't unify (string, (string * sort) list) Binarymap.dict to
         (string, (string * sort) list) Binarymap.dict * (string * sort) list
         (Incompatible types)
Found near psyms := Binarymap.remove (! psyms, "isPb")
Static Errors
> Loading Binarymap
> # poly: : error: Type error in function application.
   Function: := : psymd ref * psymd -> unit
   Argument: (psyms, #2 (Binarymap.remove (... ..., ...))) :
      psymd ref * (string * sort) list
   Reason:
      Can't unify
         (string, (string * sort) list) Binarymap.dict
            (*Created from opaque signature*) with
         (string * sort) list (*In Basis*) (Different type constructors)
Found near psyms := #2 (Binarymap.remove (! psyms, "isPb"))
Static Errors
> Loading Binarymap
> # val it =
   (?,
    [("f", fun(X, Z)), ("g", fun(Y, Z)), ("p", fun(P, X)), ("q", fun(P, Y))]):
   (string, (string * sort) list) Binarymap.dict * (string * sort) list
> Loading Binarymap
> # val it = (): unit
> # # # # # # # # Exception- TER ("not a variable: ", [], [Fun ("Z", srt ("set", []), [])])
   raised
> Loading Binarymap
> # # # val it = (): unit
> # # # # # # # # val isPb_def =
   {}, 
   |- !(X : set)  (K : set)  (f : fun(X#, K#))  (Y : set)  (g : fun(Y#, K#))
      (P : set)  (p : fun(P#, X#))  (q : fun(P#, Y#)).
        isPb(f#, g#, p#, q#) <=>
        f# o p# = g# o q# &
        !(A : set)  (u : fun(A#, X#))  (v : fun(A#, Y#)).
          f# o u# = g# o v# ==>
          ?!(a : fun(A#, P#)). p# o a# = u# & q# o a# = v#: thm
> > # # # val isPb_expand =
   {}, 
   |- !(X : set)  (K : set)  (f : fun(X#, K#))  (Y : set)  (g : fun(Y#, K#))
      (P : set)  (p : fun(P#, X#))  (q : fun(P#, Y#)).
        isPb(f#, g#, p#, q#) <=>
        f# o p# = g# o q# &
        !(A : set)  (u : fun(A#, X#))  (v : fun(A#, Y#)).
          f# o u# = g# o v# ==>
          ?(a : fun(A#, P#)).
            (p# o a# = u# & q# o a# = v#) &
            !(a' : fun(A#, P#)). p# o a'# = u# & q# o a'# = v# ==> a'# = a#:
   thm
> > # poly: : error: Value or constructor (isEq_ex) has not been declared Found near isEq_ex
Static Errors
> # # # # # # val isPb_ex =
   {}, 
   |- !(X : set)  (K : set)  (f : fun(X#, K#))  (Y : set)  (g : fun(Y#, K#)).
        ?(P : set)  (p : fun(P#, X#))  (q : fun(P#, Y#)).
          isPb(f#, g#, p#, q#): thm
> > # # # # # val isKer_def =
   {(X : set), (XX : set), (Y : set), (p : fun(X, Y)), (r : fun(XX, X)),
    (s : fun(XX, X))},  |- isKer(r, s, p) <=> isPb(p, p, r, s): thm
> # # # # # # > >   C-c C-cCompilation interrupted

> val it = PRFS []: proofmanager.proofs
> # > Exception- NO_PROOFS raised
> # # # # # # val isKer_ex =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        ?(XX : set)  (r : fun(XX#, X#))  (s : fun(XX#, X#)).
          isKer(r#, s#, f#): thm
> > # # # # # # # # val Pbover_def =
   {(A : set), (Av : set), (B : set), (Bv : set), (U : set), (V : set),
    (a : fun(A, U)), (b : fun(B, U)), (f : fun(A, B)), (fv : fun(Av, Bv)),
    (p : fun(V, U)), (pa1 : fun(Av, V)), (pa2 : fun(Av, A)),
    (pb1 : fun(Bv, V)), (pb2 : fun(Bv, B))}, 
   |- Pbover(p, a, pa1, pa2, b, pb1, pb2, f, fv) <=>
      isPb(p, a, pa1, pa2) &
      isPb(p, b, pb1, pb2) & pb1 o fv = pa1 & pb2 o fv = f o pa2: thm
> val it = PRFS []: proofmanager.proofs
> # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(U : set)  (A : set)  (a : fun(A#, U#))  (B : set)  (b : fun(B#, U#))
               (f : fun(A#, B#))  (g : fun(A#, B#)).
                 b# o f# = a# & b# o g# = a# ==>
                 (!(u : mem(B#)). FIB(f#, u#) = FIB(g#, u#)) ==> f# = g#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a : fun(A, U))
   1.b o f = a
   2.b o g = a
   3.!(u : mem(B)). FIB(f, u#) = FIB(g, u#)
   ----------------------------------------------------------------------
   f = g
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # poly: : error: Value or constructor (fun_ext) has not been declared
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (irule $ iffLR fun_ext) before
     Feedback.set_trace "show_typecheck_errors" old end)
Static Errors
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a : fun(A, U))
   1.b o f = a
   2.b o g = a
   3.!(u : mem(B)). FIB(f, u#) = FIB(g, u#)
   ----------------------------------------------------------------------
   !(a : mem(A)). App(f, a#) = App(g, a#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(a' : mem(A))(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a :
      fun(A, U))
   1.b o f = a
   2.b o g = a
   3.!(u : mem(B)). FIB(f, u#) = FIB(g, u#)
   ----------------------------------------------------------------------
   App(f, a') = App(g, a')
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(a' : mem(A))(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a :
      fun(A, U))
   1.b o f = a
   2.b o g = a
   3.FIB(f, App(f, a')) = FIB(g, App(f, a'))
   ----------------------------------------------------------------------
   App(f, a') = App(g, a')
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # poly: : error: Value or constructor (IN_FIB) has not been declared
Found near [GSYM IN_EXT_iff, IN_FIB]
Static Errors
> # # # # # # val IN_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#: thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(a' : mem(A))(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a :
      fun(A, U))
   1.b o f = a
   2.b o g = a
   3.!(x : mem(A)). App(f, x#) = App(f, a') <=> App(g, x#) = App(f, a')
   ----------------------------------------------------------------------
   App(f, a') = App(g, a')
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(a' : mem(A))(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a :
      fun(A, U))
   1.b o f = a
   2.b o g = a
   3.!(x : mem(A)). App(f, x#) = App(f, a') <=> App(g, x#) = App(f, a')
   ----------------------------------------------------------------------
   App(g, a') = App(f, a')
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(a' : mem(A))(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a :
      fun(A, U))
   1.b o f = a
   2.b o g = a
   3.!(x : mem(A)). App(f, x#) = App(f, a') <=> App(g, x#) = App(f, a')
   ----------------------------------------------------------------------
   App(g, a') = App(f, a')
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(a' : mem(A))(g : fun(A, B))(f : fun(A, B))(b : fun(B, U))(a :
      fun(A, U))
   1.b o f = a
   2.b o g = a
   ----------------------------------------------------------------------
   App(f, a') = App(f, a')
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(U : set)  (A : set)  (a : fun(A#, U#))  (B : set)  (b : fun(B#, U#))
      (f : fun(A#, B#))  (g : fun(A#, B#)).
        b# o f# = a# & b# o g# = a# ==>
        (!(u : mem(B#)). FIB(f#, u#) = FIB(g#, u#)) ==> f# = g#:
   proofmanager.proof
> val it = PRFS []: proofmanager.proofs
> # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(U : set)  (A : set)  (a : fun(A#, U#))  (B : set)  (b : fun(B#, U#))
               (f : fun(A#, B#))  (g : fun(A#, B#)).
                 (!(u : mem(B#)). FIB(f#, u#) = FIB(g#, u#)) ==> f# = g#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # # val it =
   PROVED!{}, 
   |- !(U : set)  (A : set)  (a : fun(A#, U#))  (B : set)  (b : fun(B#, U#))
      (f : fun(A#, B#))  (g : fun(A#, B#)).
        (!(u : mem(B#)). FIB(f#, u#) = FIB(g#, u#)) ==> f# = g#:
   proofmanager.proof
> # # # # # # # # # # # Exception- ERR ("drule.find", [], [], []) raised
> 
*** Emacs/HOL command completed ***

> # # # # # # # # # # # Exception- ERR ("drule.find", [], [], []) raised
> > 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(U : set)  (A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
                 (!(u : mem(B#)). FIB(f#, u#) = FIB(g#, u#)) ==> f# = g#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   UBA(g : fun(A, B))(f : fun(A, B))
   1.!(u : mem(B)). FIB(f, u#) = FIB(g, u#)
   ----------------------------------------------------------------------
   f = g
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   UBA(a : mem(A))(g : fun(A, B))(f : fun(A, B))
   1.!(u : mem(B)). FIB(f, u#) = FIB(g, u#)
   ----------------------------------------------------------------------
   App(f, a) = App(g, a)
   : proofmanager.proof
> # # # # # # # # # # # val repl_of_equality =
   {}, 
   |- !(U : set)  (A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
        (!(u : mem(B#)). FIB(f#, u#) = FIB(g#, u#)) ==> f# = g#: thm
> > 
*** Emacs/HOL command completed ***

> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holKOGBifScript.sml

******
val p41_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set).
        p41(A#, B#, C#, D#) = p1(A#, B# * C# * D#): thm
val p42_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set).
        p42(A#, B#, C#, D#) = p1(B#, C# * D#) o p2(A#, B# * C# * D#): thm
val p43_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set).
        p43(A#, B#, C#, D#) = p1(C#, D#) o p2(B#, C# * D#) o
          p2(A#, B# * C# * D#): thm
val p44_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set).
        p44(A#, B#, C#, D#) = p2(C#, D#) o p2(B#, C# * D#) o
          p2(A#, B# * C# * D#): thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> Pt_def;
poly: : error: Value or constructor (Pt_def) has not been declared Found near Pt_def
Static Errors
> Tp1_def;
val it =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Tp(f# o p1(A#, 1)) = Tp1(f#):
   thm
> Tp0_def;
poly: : error: Value or constructor (Tp0_def) has not been declared Found near Tp0_def
Static Errors
> Tpm_def;
val it =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
        !(sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#): thm
> find_th "Tpm";
val it =
   [("Tpm_def",
     {}, 
     |- !(A : set)  (B : set)  (f : fun(A#, B#)).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
          !(sf' : mem(Exp(A#, B#))).
            (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
            sf'# = Tpm(f#)),
    ("Tpm_eq_eq",
     {}, 
     |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
          Tpm(f1#) = Tpm(f2#) <=> f1# = f2#),
    ("Tpm_tof_inv",
     {},  |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#))). Tpm(tof(f#)) = f#),
    ("is_Tpm",
     {}, 
     |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#)),
    ("tof_Tpm_inv",
     {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). tof(Tpm(f#)) = f#)]:
   (string * thm) list
> # # # val item41_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set)
      (abcd : mem(A# * B# * C# * D#)).
        item41(abcd#) = App(p41(A#, B#, C#, D#), abcd#): thm
> # # # val item42_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set)
      (abcd : mem(A# * B# * C# * D#)).
        item42(abcd#) = App(p42(A#, B#, C#, D#), abcd#): thm
> # # # # val item43_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set)
      (abcd : mem(A# * B# * C# * D#)).
        item43(abcd#) = App(p43(A#, B#, C#, D#), abcd#): thm
> # # # # val item44_def =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (D : set)
      (abcd : mem(A# * B# * C# * D#)).
        item44(abcd#) = App(p44(A#, B#, C#, D#), abcd#): thm
> # # # # # # val Pbsq_def =
   {(K : set), (P : set), (X : set), (Y : set),
    (fgpq : mem(Exp(X, K) * Exp(Y, K) * Exp(P, X) * Exp(P, Y)))}, 
   |- Pbsq(fgpq) <=>
      isPb(tof(item41(fgpq)), tof(item42(fgpq)), tof(item43(fgpq)),
       tof(item44(fgpq))): thm
> # # # # val Pbsq1_def =
   {(K : set), (P : set), (X : set), (Y : set),
    (fgpq : mem(Exp(X, K) * Exp(Y, K) * Exp(P, X) * Exp(P, Y)))}, 
   |- Pbsq1(fgpq) = tof(item41(fgpq)): thm
> # # # # val Pbsq2_def =
   {(K : set), (P : set), (X : set), (Y : set),
    (fgpq : mem(Exp(X, K) * Exp(Y, K) * Exp(P, X) * Exp(P, Y)))}, 
   |- Pbsq2(fgpq) = tof(item42(fgpq)): thm
> # # # # val Pbsq3_def =
   {(K : set), (P : set), (X : set), (Y : set),
    (fgpq : mem(Exp(X, K) * Exp(Y, K) * Exp(P, X) * Exp(P, Y)))}, 
   |- Pbsq3(fgpq) = tof(item43(fgpq)): thm
> # # # # val Pbsq4_def =
   {(K : set), (P : set), (X : set), (Y : set),
    (fgpq : mem(Exp(X, K) * Exp(Y, K) * Exp(P, X) * Exp(P, Y)))}, 
   |- Pbsq4(fgpq) = tof(item44(fgpq)): thm
> Pbsq_def;
val it =
   {(K : set), (P : set), (X : set), (Y : set),
    (fgpq : mem(Exp(X, K) * Exp(Y, K) * Exp(P, X) * Exp(P, Y)))}, 
   |- Pbsq(fgpq) <=>
      isPb(tof(item41(fgpq)), tof(item42(fgpq)), tof(item43(fgpq)),
       tof(item44(fgpq))): thm
> Loading Binarymap
> # val it = (): unit
> # # # # # # # # # Exception- ERR ("predicate with name: Pbover already exists", [], [], [])
   raised
> # # # # # # # # val isPb_def =
   {}, 
   |- !(X : set)  (K : set)  (f : fun(X#, K#))  (Y : set)  (g : fun(Y#, K#))
      (P : set)  (p : fun(P#, X#))  (q : fun(P#, Y#)).
        isPb(f#, g#, p#, q#) <=>
        f# o p# = g# o q# &
        !(A : set)  (u : fun(A#, X#))  (v : fun(A#, Y#)).
          f# o u# = g# o v# ==>
          ?!(a : fun(A#, P#)). p# o a# = u# & q# o a# = v#: thm
> > # # # val isPb_expand =
   {}, 
   |- !(X : set)  (K : set)  (f : fun(X#, K#))  (Y : set)  (g : fun(Y#, K#))
      (P : set)  (p : fun(P#, X#))  (q : fun(P#, Y#)).
        isPb(f#, g#, p#, q#) <=>
        f# o p# = g# o q# &
        !(A : set)  (u : fun(A#, X#))  (v : fun(A#, Y#)).
          f# o u# = g# o v# ==>
          ?(a : fun(A#, P#)).
            (p# o a# = u# & q# o a# = v#) &
            !(a' : fun(A#, P#)). p# o a'# = u# & q# o a'# = v# ==> a'# = a#:
   thm
> > > # # # # val isPb_ex =
   {}, 
   |- !(X : set)  (K : set)  (f : fun(X#, K#))  (Y : set)  (g : fun(Y#, K#)).
        ?(P : set)  (p : fun(P#, X#))  (q : fun(P#, Y#)).
          isPb(f#, g#, p#, q#): thm
> > > # # # Exception- ERR ("predicate with name: isKer already exists", [], [], [])
   raised
> 
*** Emacs/HOL command completed ***

> Loading Binarymap
> # # # # Exception- NotFound raised
> Loading Binarymap
> # # # val it = (): unit
> # # # # # # # # # val Pbover_def =
   {(A : set), (Av : set), (B : set), (Bv : set), (U : set), (V : set),
    (a : fun(A, U)), (b : fun(B, U)), (f : fun(A, B)), (fv : fun(Av, Bv)),
    (p : fun(V, U)), (pa1 : fun(Av, V)), (pa2 : fun(Av, A)),
    (pb1 : fun(Bv, V)), (pb2 : fun(Bv, B))}, 
   |- Pbover(p, a, pa1, pa2, b, pb1, pb2, f, fv) <=>
      b o f = a &
      isPb(p, a, pa1, pa2) &
      isPb(p, b, pb1, pb2) & pb1 o fv = pa1 & pb2 o fv = f o pa2: thm
> # val it =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Inj(minc(s#)) &
        !(a : mem(A#)).
          IN(a#, s#) <=> ?(b : mem(m2s(s#))). a# = App(minc(s#), b#): thm
> val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (a : fun(A#, U))  (B : set)  (b : fun(B#, U))  (u : mem(U))
               (uA : set)  (ia : fun(uA#, A#))  (uB : set)
               (ib : fun(uB#, B#)).
                 isset(ia#, FIB(a#, u#)) & isset(ib#, FIB(b#, u#)) ==>
                 ?!(f : fun(uA#, uB#)). P(u#, f#)]: proofmanager.proofs
> val it = (): unit
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # val it =
   PRFS
    [U
     
     ----------------------------------------------------------------------
     !(A : set)  (a : fun(A#, U))  (B : set)  (b : fun(B#, U)).
                 (!(u : mem(U))  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#)).
                     isset(ia#, FIB(a#, u#)) & isset(ib#, FIB(b#, u#)) ==>
                     ?!(f : fun(uA#, uB#)). P(u#, f#)) ==>
                 ?(g : fun(A#, B#)).
                   !(u : set)  (uA : set)  (ia : fun(uA#, A#))  (uB : set)
                   (ib : fun(uB#, B#))  (u : mem(U)).
                     isset(ia#, FIB(a#, u#)) & isset(ib#, FIB(b#, u#)) ==>
                     !(f : fun(uA#, uB#)). ib# o f# = g# o ia# ==> P(u#, f#)]:
   proofmanager.proofs
> val it = (): unit
> 
Process HOL finished
> Loading empty hol-mode.sml
> > > use "SEARmaster.ML";
val use = fn: string -> unit
******

Loading SEAR file SEARsorts.sml

******
val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = set: sort
val it = (): unit
******

Loading SEAR file SEARnewspec.sml

******
val define_fsym = fn: string * (string * sort) list -> term -> thm
val define_fsym_lemma_fun =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : fun(A#, B#)).
        ?!(newfsym : fun(A#, B#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_mem =
   {}, 
   |- !(A : set)  (newfsym0 : mem(A#)).
        ?!(newfsym : mem(A#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_rel =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : rel(A#, B#)).
        ?!(newfsym : rel(A#, B#)). newfsym# = newfsym0#: thm
val funeqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : fun(A#, B#)). i# = i#) &
        (!(i : fun(A#, B#))  (i' : fun(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : fun(A#, B#))  (i' : fun(A#, B#))  (i'' : fun(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val memeqeqvth =
   {}, 
   |- !(A : set).
        (!(i : mem(A#)). i# = i#) &
        (!(i : mem(A#))  (i' : mem(A#)). i# = i'# ==> i'# = i#) &
        !(i : mem(A#))  (i' : mem(A#))  (i'' : mem(A#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val qdefine_fsym = fn: string * term frag list list -> term frag list -> thm
val qsimple_uex_spec = fn: string -> term frag list list -> thm -> thm
val quex_spec = fn: string -> term frag list list -> thm -> thm -> thm
val releqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : rel(A#, B#)). i# = i#) &
        (!(i : rel(A#, B#))  (i' : rel(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : rel(A#, B#))  (i' : rel(A#, B#))  (i'' : rel(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val simple_uex_spec = fn: string -> (string * sort) list -> thm -> thm
val uex_spec = fn: string -> (string * sort) list -> thm -> thm -> thm
val it = (): unit
******

Loading SEAR file SEARrel.sml

******
val AX1 =
   {}, 
   |- !(A : set)  (B : set).
        ?!(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val Fun_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=> !(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#): thm
val R_EXT =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        (!(a : mem(A#))  (b : mem(B#)).
            Holds(R1#, a#, b#) <=> Holds(R2#, a#, b#)) <=> R1# = R2#: thm
val AX1_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val ao_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, c#)) <=>
        Holds(psi# @ phi#, a#, c#): thm
val ao_def0 =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (b : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, b#)) <=>
        Holds(psi# @ phi#, a#, b#): thm
val ao_uex =
   {(A : set), (B : set), (C : set), (phi : rel(A, B)), (psi : rel(B, C))}, 
   |- ?!(R : rel(A, C)).
        !(a : mem(A))  (b : mem(C)).
          Holds(R#, a#, b#) <=>
          ?(b : mem(B)). Holds(phi, a#, b#) & Holds(psi, b#, b#): thm
val Fun_expand =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=>
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) &
        !(a : mem(A#))  (b1 : mem(B#))  (b2 : mem(B#)).
          Holds(R#, a#, b1#) & Holds(R#, a#, b2#) ==> b1# = b2#: thm
val id_Fun = {},  |- !(A : set). isFun(id(A#)): thm
val id_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)).
        Holds(id(A#), a#, b#) <=> a# = b#: thm
val id_uex =
   {(A : set)}, 
   |- ?!(R : rel(A, A)).
        !(a : mem(A))  (b : mem(A)). Holds(R#, a#, b#) <=> a# = b#: thm
val idL = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). id(B#) @ f# = f#:
   thm
val idR = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). f# @ id(A#) = f#:
   thm
val Thm_2_7_ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val Thm_2_7_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val Thm_2_7_id =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#)).
        phi# @ id(A#) = phi# & id(B#) @ phi# = phi#: thm
val op_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(B#))  (b : mem(A#)).
        Holds(op(R#), a#, b#) <=> Holds(R#, b#, a#): thm
val op_uex =
   {(A : set), (B : set), (R : rel(A, B))}, 
   |- ?!(R' : rel(B, A)).
        !(a : mem(B))  (b : mem(A)). Holds(R'#, a#, b#) <=> Holds(R, b#, a#):
   thm
val ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val ao_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val op_DISTR =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#)). op(psi# @ phi#) = op(phi#) @ op(psi#): thm
val Refl_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> !(a : mem(A#)). Holds(R#, a#, a#): thm
val Sym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> Holds(R#, a2#, a1#): thm
val Trans_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Trans(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#))  (a3 : mem(A#)).
          Holds(R#, a1#, a2#) & Holds(R#, a2#, a3#) ==> Holds(R#, a1#, a3#):
   thm
val ER_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) <=> Refl(R#) & Sym(R#) & Trans(R#): thm
val Sym_Trans_Rright =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) & Trans(R#) ==>
        !(x : mem(A#))  (y : mem(A#)).
          Holds(R#, x#, y#) ==>
          !(z : mem(A#)). Holds(R#, x#, z#) <=> Holds(R#, y#, z#): thm
val op_op =
   {},  |- !(A : set)  (B : set)  (R : rel(A#, B#)). op(op(R#)) = R#: thm
val it = (): unit
******

Loading SEAR file SEARfun.sml

******
val rel2fun =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val rel2fun_ex =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val rel2fun_ex' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val asR_Fun =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). isFun(asR(f#)): thm
val asR_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- !(a : mem(A))  (b : mem(B)). Holds(asR(f), a#, b#) <=> App(f, a#) = b#:
   thm
val asR_uex =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- ?!(R : rel(A, B)).
        !(a : mem(A))  (b : mem(B)). Holds(R#, a#, b#) <=> App(f, a#) = b#:
   thm
val FUN_EXT =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        (!(a : mem(A#)). App(f1#, a#) = App(f2#, a#)) <=> f1# = f2#: thm
val P2fun_uex =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val fun_tm_compr = fn: string * sort -> term -> thm
val fun_tm_compr_uex = fn: string * sort -> term -> thm
val qfun_compr = fn: term frag list -> term frag list -> thm
val unique_lemma =
   {},  |- !(A : set)  (a : mem(A#)). ?!(a' : mem(A#)). a'# = a#: thm
val App_Id = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_def = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_uex =
   {(A : set)}, 
   |- ?!(f : fun(A, A)).
        !(a : mem(A))  (b : mem(A)).
          App(f#, a#) = b# <=> Holds(id(A), a#, b#): thm
val o_ex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val o_uex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?!(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val Inj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) <=>
        !(x1 : mem(A#))  (x2 : mem(A#)).
          App(f#, x1#) = App(f#, x2#) ==> x1# = x2#: thm
val o_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        App(psi# o phi#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#):
   thm
val Surj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) <=> !(b : mem(B#)). ?(a : mem(A#)). App(f#, a#) = b#: thm
val Bij_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> Inj(f#) & Surj(f#): thm
val Bij_op =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> ?(f' : fun(B#, A#)). asR(f'#) = op(asR(f#)): thm
val App_App_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val App_o_l =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val asR_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        asR(g# o f#) = asR(g#) @ asR(f#): thm
val asR_Id = {},  |- !(A : set). asR(Id(A#)) = id(A#): thm
val asR_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        asR(f1#) = asR(f2#) <=> f1# = f2#: thm
val Thm_2_7_bij =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#)).
        Bij(phi#) <=>
        ?(psi : fun(B#, A#)). psi# o phi# = Id(A#) & phi# o psi# = Id(B#):
   thm
val Inj_lcancel =
   {}, 
   |- !(A : set)  (B : set)  (m : fun(A#, B#)).
        Inj(m#) ==>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, A#)).
          m# o f# = m# o g# ==> f# = g#: thm
val IdL = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Id(B#) o f# = f#:
   thm
val IdR = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). f# o Id(A#) = f#:
   thm
val Inj_lift_R_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(R : rel(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?!(a2 : mem(A#)). Holds(R#, App(i#, a1#), App(i#, a2#))) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). Holds(R#, App(i#, a#), App(i# o f#, a#)): thm
val Inj_lift_fun_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val asR_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        Holds(asR(f#), a#, b#) <=> App(f#, a#) = b#: thm
val Inj_lift_fun_lemma' =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?!(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val Inj_eq_eq =
   {}, 
   |- !(X : set)  (Y : set)  (i : fun(X#, Y#)).
        Inj(i#) ==>
        !(x1 : mem(X#))  (x2 : mem(X#)).
          App(i#, x1#) = App(i#, x2#) <=> x1# = x2#: thm
val Inj_lift_fun =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?(f : fun(X#, A#)). !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#):
   thm
val Inj_lift_fun_uex =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?!(f : fun(X#, A#)).
            !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#): thm
val o_assoc =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (D : set)  (h : fun(C#, D#)). (h# o g#) o f# = h# o g# o f#: thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val P2fun_uex0 =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val it = (): unit
******

Loading SEAR file SEARsetting.sml

******
val AX0 = {},  |- ?(A : set)  (a : mem(A#)). T: thm
val Tab_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) <=>
        (!(x : mem(A#))  (y : mem(B#)).
            Holds(R#, x#, y#) <=>
            ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val AX2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        ?(TR : set)  (p : fun(TR#, A#))  (q : fun(TR#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              Holds(R#, x#, y#) <=>
              ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
          !(r : mem(TR#))  (s : mem(TR#)).
            App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Empty_unique =
   {}, 
   |- !(E1 : set)  (E2 : set).
        (!(a : mem(E1#)). F) & (!(a : mem(E2#)). F) ==>
        ?(i : fun(E1#, E2#))  (j : fun(E2#, E1#)).
          i# o j# = Id(E2#) & j# o i# = Id(E1#): thm
val Thm_2_2 = {},  |- ?(Empty : set). !(a : mem(Empty#)). F: thm
val Thm_2_3 =
   {},  |- ?(ONE : set)  (x : mem(ONE#)). !(x' : mem(ONE#)). x'# = x#: thm
val unique_fun_to_ONE =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#)).
        (!(a : mem(ONE#)). a# = x#) ==> !(A : set). ?!(f : fun(A#, ONE#)). T:
   thm
val ONE_unique =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#))  (ONE' : set)  (x' : mem(ONE'#)).
        (!(a : mem(ONE#)). a# = x#) & (!(a : mem(ONE'#)). a# = x'#) ==>
        ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
          i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso0_REFL =
   {}, 
   |- !(A : set).
        ?(i : fun(A#, A#))  (j : fun(A#, A#)).
          i# o j# = Id(A#) & j# o i# = Id(A#): thm
val iso0_SYM =
   {}, 
   |- !(A : set)  (A' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
        ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
          i# o j# = Id(A#) & j# o i# = Id(A'#): thm
val iso0_TRANS =
   {}, 
   |- !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_uex =
   {}, 
   |- ?(ONE : set).
        (?(x : mem(ONE#)). !(a : mem(ONE#)). a# = x#) &
        !(ONE' : set).
          (?(x : mem(ONE'#)). !(a : mem(ONE'#)). a# = x#) ==>
          ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
            i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso_Reqv =
   {}, 
   |- (!(A : set).
          ?(i : fun(A#, A#))  (j : fun(A#, A#)).
            i# o j# = Id(A#) & j# o i# = Id(A#)) &
      (!(A : set)  (A' : set).
          (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
              i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
          ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
            i# o j# = Id(A#) & j# o i# = Id(A'#)) &
      !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_def = {},  |- ?(x : mem(1)). !(a : mem(1)). a# = x#: thm
val dot_uex = {},  |- ?!(x : mem(1)). x# = x#: thm
val dot_def = {},  |- !(a : mem(1)). a# = dot: thm
val dot_def0 = {},  |- dot = dot: thm
val ONE = 1: term
val Thm_2_3_5 = {},  |- !(A : set). ?!(f : rel(A#, 1)). isFun(f#): thm
val To1_ex = {},  |- !(A : set). ?!(f : fun(A#, 1)). T: thm
val dot = dot: term
val To1_uex = {},  |- !(A : set). ?!(f : fun(A#, 1)). f# = f#: thm
val To1_def = {},  |- !(A : set)  (f' : fun(A#, 1)). f'# = To1(A#): thm
val To1_def0 = {(A : set)},  |- To1(A) = To1(A): thm
val Thm_2_4_R_ver =
   {}, 
   |- !(A : set)  (R : rel(1, A#)).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)).
            Holds(R#, dot, a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Rel_Pred1 =
   {}, 
   |- !(A : set).
        ?!(R : rel(1, A#)). !(a : mem(A#)). Holds(R#, dot, a#) <=> P(a#): thm
val Tab_App_Rel =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (x : mem(A#))  (y : mem(B#)).
          App(p#, r#) = x# & App(q#, r#) = y# ==> Holds(R#, x#, y#): thm
val Thm_2_4 =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Tab_mem_R =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#)). Holds(R#, App(p#, r#), App(q#, r#)): thm
val Tab_prop1 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(x : mem(A#))  (y : mem(B#)).
          Holds(R#, x#, y#) <=>
          ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#: thm
val T_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(T0 : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(T0#, a#, b#): thm
val T_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          (!(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#)) &
          !(R' : rel(A#, B#)).
            (!(a : mem(A#))  (b : mem(B#)). Holds(R'#, a#, b#)) ==> R'# = R#:
   thm
val Tab_prop2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Thm_2_5 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (T1 : set)
      (p1 : fun(T1#, A#))  (q1 : fun(T1#, B#))  (T2 : set)
      (p2 : fun(T2#, A#))  (q2 : fun(T2#, B#)).
        isTab(R#, p1#, q1#) & isTab(R#, p2#, q2#) ==>
        ?(b : fun(T1#, T2#)). Bij(b#): thm
val isPair_def =
   {(A : set), (AxB : set), (B : set), (p1 : fun(AxB, A)), (p2 : fun(AxB, B))},
   
   |- isPair(p1, p2) <=>
      !(x : mem(A))  (y : mem(B)).
        ?!(r : mem(AxB)). App(p1, r#) = x# & App(p2, r#) = y#: thm
val isPair_uex =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (p1 : fun(AB#, A#))
      (p2 : fun(AB#, B#))  (AB' : set)  (p1' : fun(AB'#, A#))
      (p2' : fun(AB'#, B#)).
        isPair(p1#, p2#) & isPair(p1'#, p2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          p1'# o i# = p1# &
          p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AxB : set)  (p1 : fun(AxB#, A#))  (p2 : fun(AxB#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              ?(r : mem(AxB#)). App(p1#, r#) = x# & App(p2#, r#) = y#) &
          !(r : mem(AxB#))  (s : mem(AxB#)).
            App(p1#, r#) = App(p1#, s#) & App(p2#, r#) = App(p2#, s#) ==>
            r# = s#: thm
val Pr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)).
          isPair(p1#, p2#) &
          !(AB' : set)  (p1' : fun(AB'#, A#))  (p2' : fun(AB'#, B#)).
            isPair(p1'#, p2'#) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_p12_def =
   {},  |- !(A : set)  (B : set). isPair(p1(A#, B#), p2(A#, B#)): thm
val Pr_ts_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)). T: thm
val isPair_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            p1# o i# = p1# & p2# o i# = p2# & p1# o j# = p1# & p2# o j# = p2#) &
      (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
        (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            p1# o i# = p1'# &
            p2# o i# = p2'# & p1'# o j# = p1# & p2'# o j# = p2#) &
      !(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
      (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B))  (AB'' : set)
      (p1'' : fun(AB''#, A))  (p2'' : fun(AB''#, B)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            p1'# o i# = p1# &
            p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            p1''# o i# = p1'# &
            p2''# o i# = p2'# & p1'# o j# = p1''# & p2'# o j# = p2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          p1''# o i# = p1# &
          p2''# o i# = p2# & p1# o j# = p1''# & p2# o j# = p2''#: thm
val p2_def =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#))  (y : mem(B#)).
            ?(r : mem(A# * B#)).
              App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#) &
        !(r : mem(A# * B#))  (s : mem(A# * B#)).
          App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
          App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val SetPr_def =
   {}, 
   |- !(A : set)  (AB : set)  (p1 : fun(AB#, A#))  (B : set)
      (p2 : fun(AB#, B#)).
        SetPr(p1#, p2#) <=>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
          ?!(fg : fun(X#, AB#)). p1# o fg# = f# & p2# o fg# = g#: thm
val Cross = fn: term -> term -> term
val Pa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        (p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#) &
        !(fg' : fun(X#, A# * B#)).
          p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==>
          fg'# = Pa(f#, g#): thm
val Pa_def0 =
   {(A : set), (B : set), (X : set), (f : fun(X, A)), (g : fun(X, B))}, 
   |- p1(A, B) o Pa(f, g) = f & p2(A, B) o Pa(f, g) = g: thm
val Thm_2_8_SetPr =
   {},  |- !(A : set)  (B : set). SetPr(p1(A#, B#), p2(A#, B#)): thm
val p12_of_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#: thm
val p1_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f#: thm
val p2_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p2(A#, B#) o Pa(f#, g#) = g#: thm
val is_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (fg' : fun(X#, A# * B#)).
        p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==> fg'# = Pa(f#, g#):
   thm
val AX3 =
   {}, 
   |- !(A : set).
        ?(PA : set)  (e : rel(A#, PA#)).
          !(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#): thm
val Pow_uex =
   {(A : set)}, 
   |- ?(PA : set)  (e : rel(A, PA#)).
        (!(S0 : rel(1, A)).
            ?!(s : mem(PA#)).
              !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        !(PA' : set)  (e' : rel(A, PA'#)).
          (!(S0 : rel(1, A)).
              ?!(s : mem(PA'#)).
                !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
          ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val Pow_unique =
   {}, 
   |- !(A : set)  (PA : set)  (e : rel(A#, PA#))  (PA' : set)
      (e' : rel(A#, PA'#)).
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA'#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
        ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
          i# o j# = Id(PA'#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val SetEz_def =
   {(A : set), (B : set), (E : set), (e : fun(E, A)), (f : fun(A, B)),
    (g : fun(A, B))}, 
   |- SetEz(f, g, e) <=>
      !(X : set)  (x : fun(X#, A)).
        f o x# = g o x# ==> ?!(x0 : fun(X#, E)). x# = e o x0#: thm
val Thm_2_10 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(M : set)  (e : fun(A#, M#))  (m : fun(M#, B#)).
          f# = m# o e# & Surj(e#) & Inj(m#): thm
val Thm_2_9_Eqlz =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
        ?(E : set)  (e : fun(E#, A#)). SetEz(f#, g#, e#): thm
val BC0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))).
        Holds(BC0(f#), a#, b#) <=>
        !(z : mem(Z#)).
          Holds(In(Z#), z#, b#) <=> Holds(In(Y#), App(f#, z#), a#): thm
val Pow = fn: term -> term
val Pow_REFL =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#)).
        ?(i : fun(PA#, PA#))  (j : fun(PA#, PA#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e# & asR(j#) @ e# = e#: thm
val Pow_SYM =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) ==>
        ?(i : fun(PA'#, PA#))  (j : fun(PA#, PA'#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA'#) & asR(i#) @ e'# = e# & asR(j#) @ e# = e'#: thm
val Pow_TRANS =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#))
      (PA'' : set)  (e'' : rel(A, PA''#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) &
        (?(i : fun(PA'#, PA''#))  (j : fun(PA''#, PA'#)).
            i# o j# = Id(PA''#) &
            j# o i# = Id(PA'#) & asR(i#) @ e'# = e''# & asR(j#) @ e''# = e'#) ==>
        ?(i : fun(PA#, PA''#))  (j : fun(PA''#, PA#)).
          i# o j# = Id(PA''#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e''# & asR(j#) @ e''# = e#: thm
val Pow_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val All0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(All0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, a#): thm
val All0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(All0(f#)): thm
val BC0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(BC0(f#)): thm
val Ex0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(Ex0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          ?(z : mem(Z#)). Holds(In(Z#), z#, a#) & App(f#, z#) = y#: thm
val Ex0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(Ex0(f#)): thm
val In_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). Holds(In(A#), x#, s1#) <=> Holds(In(A#), x#, s2#)) ==>
        s1# = s2#: thm
val In_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val In_def_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (s0 : fun(A0#, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)).
            (?(a0 : mem(A0#)). x# = App(s0#, a0#)) <=> Holds(In(A#), x#, s#):
   thm
val In_def_P =
   {}, 
   |- !(A : set).
        ?!(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> Holds(In(A#), a#, s#):
   thm
val PO_def =
   {}, 
   |- !(A : set)  (S1 : mem(Pow(A#)))  (S2 : mem(Pow(A#))).
        PO(S1#, S2#) <=>
        !(a : mem(A#)). Holds(In(A#), a#, S1#) ==> Holds(In(A#), a#, S2#):
   thm
val BC_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))). App(BC(f#), a#) = b# <=> Holds(BC0(f#), a#, b#):
   thm
val In_App_BC =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (z : mem(Z#))
      (ys : mem(Pow(Y#))).
        Holds(In(Z#), z#, App(BC(f#), ys#)) <=>
        Holds(In(Y#), App(f#, z#), ys#): thm
val Ex_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(Ex(f#), a#) = b# <=> Holds(Ex0(f#), a#, b#):
   thm
val In_App_Ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(Ex(f#), zs#)) <=>
        ?(z : mem(Z#)). Holds(In(Z#), z#, zs#) & App(f#, z#) = y#: thm
val All_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(All(f#), a#) = b# <=> Holds(All0(f#), a#, b#):
   thm
val In_App_All =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(All(f#), zs#)) <=>
        !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, zs#): thm
val Thm_2_11_SEx_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (zs : mem(Pow(Z#)))
      (ys : mem(Pow(Y#))).
        PO(App(Ex(f#), zs#), ys#) <=> PO(zs#, App(BC(f#), ys#)): thm
val Thm_2_11_SAll_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (ys : mem(Pow(Y#)))
      (zs : mem(Pow(Z#))).
        PO(App(BC(f#), ys#), zs#) <=> PO(ys#, App(All(f#), zs#)): thm
val Sub_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, R2#) <=>
        !(a : mem(A#))  (b : mem(B#)).
          Holds(R1#, a#, b#) ==> Holds(R2#, a#, b#): thm
val Meet_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Meet(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) & Holds(R2#, a#, b#): thm
val Sub_Meet =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(Meet(R1#, R2#), R1#) &
        Sub(Meet(R1#, R2#), R2#) &
        !(R0 : rel(A#, B#)).
          Sub(R0#, R1#) & Sub(R0#, R2#) ==> Sub(R0#, Meet(R1#, R2#)): thm
val Join_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Join(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) | Holds(R2#, a#, b#): thm
val Sub_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, Join(R1#, R2#)) &
        Sub(R2#, Join(R1#, R2#)) &
        !(R0 : rel(A#, B#)).
          Sub(R1#, R0#) & Sub(R2#, R0#) ==> Sub(Join(R1#, R2#), R0#): thm
val MODULAR_LAW =
   {}, 
   |- !(x : set)  (y : set)  (phi : rel(x#, y#))  (z : set)
      (psi : rel(y#, z#))  (chi : rel(x#, z#)).
        Sub(Meet(psi# @ phi#, chi#), psi# @ Meet(phi#, op(psi#) @ chi#)): thm
val left_o_pres_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (C : set)  (R : rel(B#, C#)).
        R# @ Join(R1#, R2#) = Join(R# @ R1#, R# @ R2#): thm
val right_o_pres_Join =
   {(C : set)}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (R : rel(C, A#)). Join(R1#, R2#) @ R# = Join(R1# @ R#, R2# @ R#): thm
val Div_ex =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (C : set)  (s : rel(A#, C#)).
        ?(sdr : rel(B#, C#)).
          !(t : rel(B#, C#)). Sub(t#, sdr#) <=> Sub(t# @ r#, s#): thm
val MF_def = {},  |- !(A : set)  (a : mem(A#)). App(MF(a#), dot) = a#: thm
val Pair_uex =
   {}, 
   |- !(A : set)  (B : set)  (x : mem(A#))  (y : mem(B#)).
        ?!(r : mem(A# * B#)).
          App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#: thm
val Thm_2_12 =
   {}, 
   |- !(B : set)  (A : set)  (R : rel(B#, A#)).
        ?!(fR : fun(B#, Pow(A#))).
          !(y : mem(B#))  (x : mem(A#)).
            Holds(R#, y#, x#) <=> Holds(In(A#), x#, App(fR#, y#)): thm
val Thm_2_3_5_el =
   {},  |- !(A : set)  (a : mem(A#)). ?!(R : fun(1, A#)). App(R#, dot) = a#:
   thm
val Pair_App_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val Pair_def =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val Pair_component =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)).
        Pair(App(p1(A#, B#), r#), App(p2(A#, B#), r#)) = r#: thm
val Pair_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
      (b2 : mem(B#)).
        Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#: thm
val Pair_p12 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        Pair(App(p1(A#, B#), ab#), App(p2(A#, B#), ab#)) = ab#: thm
val Ap1_def =
   {}, 
   |- !(A : set)  (X : set)  (x : mem(X#))  (B : set)  (f : fun(A# * X#, B#))
      (a : mem(A#)). App(Ap1(f#, x#), a#) = App(f#, Pair(a#, x#)): thm
val Ap1_uex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#))
      (x : mem(X#)).
        ?!(fx : fun(A#, B#)).
          !(a : mem(A#)). App(fx#, a#) = App(f#, Pair(a#, x#)): thm
val Cross_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val App_Pa =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (D : set)
      (g : fun(B#, D#))  (ab : mem(A# * B#)).
        App(Pa(f# o p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(f# o p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_o_p2 =
   {}, 
   |- !(B : set)  (C : set)  (f : fun(B#, C#))  (A : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p2(A#, B#), Pair(a#, b#)) = App(f#, b#): thm
val App_o_p1 =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p1(A#, B#), Pair(a#, b#)) = App(f#, a#): thm
val Fst_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p1(A, B), x) = Fst(x):
   thm
val Pair_def' =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#: thm
val Snd_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p2(A, B), x) = Snd(x):
   thm
val Pair_Fst_Snd =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)). Pair(Fst(r#), Snd(r#)) = r#:
   thm
val Pair_has_comp =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#): thm
val p12_of_Pair =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val dest_cross = fn: term -> term * term
val basic_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_fconv = fn: form -> thm
val mk_Pair = fn: term -> term -> term
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val Prla_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (D : set)
      (g : fun(C#, D#)). Prla(f#, g#) = Pa(f# o p1(A#, C#), g# o p2(A#, C#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Exp_ev_unique =
   {}, 
   |- !(A : set)  (B : set)  (A2B : set)  (ev : fun(A# * A2B#, B#))
      (A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B'#)).
              !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
        ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
          i# o j# = Id(A2B'#) &
          j# o i# = Id(A2B#) &
          ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#: thm
val Exp_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#): thm
val Exp_ex_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          (!(f : fun(A#, B#)).
              ?!(sf : mem(A2B#)).
                !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
          !(A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
            (!(f : fun(A#, B#)).
                ?!(sf : mem(A2B'#)).
                  !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
            ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
              i# o j# = Id(A2B'#) &
              j# o i# = Id(A2B#) &
              ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#:
   thm
val Thm_2_13 =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A2B# * A#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(sf#, a#)) = App(f#, a#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Ev_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_uex_refl =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B)).
        ?(i : fun(A2B#, A2B#))  (j : fun(A2B#, A2B#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B#) &
          ev# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_sym =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) ==>
        ?(i : fun(A2B'#, A2B#))  (j : fun(A2B#, A2B'#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B'#) &
          ev# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_trans =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B))  (A2B'' : set)  (ev'' : fun(A * A2B''#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) &
        (?(i : fun(A2B'#, A2B''#))  (j : fun(A2B''#, A2B'#)).
            i# o j# = Id(A2B''#) &
            j# o i# = Id(A2B'#) &
            ev''# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev''#) ==>
        ?(i : fun(A2B#, A2B''#))  (j : fun(A2B''#, A2B#)).
          i# o j# = Id(A2B''#) &
          j# o i# = Id(A2B#) &
          ev''# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev''#: thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val Tpm_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
        !(sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#): thm
val Tpm_def0 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#): thm
val is_Tpm =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sf' : mem(Exp(A#, B#))).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
        sf'# = Tpm(f#): thm
val Tp_def0 =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f: thm
val Tp_ex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#)).
        ?!(h : fun(X#, Exp(A#, B#))).
          Ev(A#, B#) o Pa(p1(A#, X#), h# o p2(A#, X#)) = f#: thm
val Tp_def =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f &
      !(h' : fun(X, Exp(A, B))).
        Ev(A, B) o Pa(p1(A, X), h'# o p2(A, X)) = f ==> h'# = Tp(f): thm
val is_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (h' : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), h'# o p2(A#, X#)) = f# ==> h'# = Tp(f#):
   thm
val Thm_2_14 =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        ?(B : set)  (q : fun(A#, B#)).
          Surj(q#) &
          !(x : mem(A#))  (y : mem(A#)).
            Holds(R#, x#, y#) <=> App(q#, x#) = App(q#, y#): thm
val IN_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#))).
        IN(a#, ss#) <=> Holds(In(A#), a#, ss#): thm
val IN_def_P_expand =
   {}, 
   |- !(A : set).
        ?(s : mem(Pow(A#))).
          (!(a : mem(A#)). P(a#) <=> IN(a#, s#)) &
          !(s' : mem(Pow(A#))).
            (!(a : mem(A#)). P(a#) <=> IN(a#, s'#)) ==> s'# = s#: thm
val IN_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) ==> s1# = s2#: thm
val SS_def =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) <=> !(a : mem(A#)). IN(a#, P1#) ==> IN(a#, P2#): thm
val SS_Trans =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) ==> !(P3 : mem(Pow(A#))). SS(P2#, P3#) ==> SS(P1#, P3#):
   thm
val SS_SS_eq =
   {}, 
   |- !(A : set)  (p1 : mem(Pow(A#)))  (p2 : mem(Pow(A#))).
        SS(p1#, p2#) & SS(p2#, p1#) ==> p1# = p2#: thm
val IN_def_P_ex =
   {}, 
   |- !(A : set). ?(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> IN(a#, s#):
   thm
val IN_def_P =
   {}, 
   |- !(A : set). ?!(s : mem(Pow(A#))). !(a : mem(A#)). IN(a#, s#) <=> P(a#):
   thm
val AX4 =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set).
        ?!(BI : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BI#, sss#)) <=>
            !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val BI_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BI(A#), sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val N0 = N0: term
val N0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val O0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val S0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_def =
   {(A : set), (sss : mem(Pow(Pow(A))))},  |- App(BI(A), sss) = BIGINTER(sss):
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        ?(isss : mem(Pow(A#))). App(BI(A#), sss#) = isss#: thm
val IN_BIGINTER =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGINTER(sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
******

Loading SEAR file SEARreln.sml

******
val mk_App = fn: term -> term -> term
SEARreln.sml:75: warning: Matches are not exhaustive.
Found near
  case (view_form ante, view_form conseq) of
     (vConn ("&", ...), vConn (...)) =>
     let val ip1 = ... ...; val ... = ... in conj_monotone ip1 ip2 end |
     (vConn (...), ... ...) => let val ... = ...; val ... in ... ... ip2 end
     |
     (... ..., ...) => let val ... in ... ... end |
     (...) => let ... in ... end
SEARreln.sml:247: warning: Pattern is not exhaustive.
Found near
  val [fnterm, LFP] = fLFP |> #3 o dest_fun handle _ => raise ... ...
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
val conj_monotone = fn: thm -> thm -> thm
val disj_monotone = fn: thm -> thm -> thm
val exists_monotone = fn: thm -> thm
val forall_monotone = fn: thm -> thm
val imp_induce = fn: thm -> form -> thm
val mk_LFP = fn: term -> thm
val mk_Pow = fn: term -> term
val mk_SS = fn: thm -> thm -> thm
val mk_cases = fn: thm -> thm -> thm -> thm
val mk_cond = fn: thm -> thm -> thm
val mk_fdef = fn: string -> thm -> thm
val mk_fex = fn: form -> string -> thm
val mk_ind = fn: thm -> thm
val mk_ind1 = fn: thm -> thm -> thm
val mk_monotone = fn: thm -> thm
val mk_prim = fn: thm -> thm
val mk_rules = fn: thm -> thm -> thm -> thm
val trivial_imp = fn: form -> thm
val PULL_CONJ = fn: (form -> bool) -> form -> thm option
val conj_assoc_fconv = fn: form -> thm
val conj_cossa_fconv = fn: form -> thm
val conj_swap_fconv = fn: form -> thm
val disj_imp_distr_fconv = fn: form -> thm
val exists_eq_fconv = fn: form -> thm
val forall_conj_split_fconv = fn: form -> thm
val forall_eq_fconv = fn: form -> thm
val mk_case1 = fn: thm -> thm -> thm
val mk_rules1 = fn: thm -> thm -> thm
val mk_rules2 = fn: thm -> thm
val pull_conj_fconv = fn: (form -> bool) -> form -> thm
val pull_exists_fconv1 = fn: form -> thm
SEARreln.sml:599: warning: Pattern is not exhaustive.
Found near val [qv, newtm] = conc |> dest_pred |> #2
val conj_imp_fconv = fn: form -> thm
val disj_imp_undistr_fconv = fn: form -> thm
val forall_in_eq_fconv = fn: form -> thm
val mk_incond = fn: form -> form * string
val mk_ind2 = fn: thm -> thm
val mk_rules3 = fn: thm -> thm
val remove_list_item = fn: ''a -> ''a list -> ''a list
val unpull_exists_fconv1 = fn: form -> thm
val it = (): unit
val inN's_def =
   {},  |- !(a : mem(Pow(N0))). IN(a#, inN's) <=> SS(App(inNf, a#), a#): thm
val inN_cases0 = {},  |- App(inNf, inNs) = inNs: thm
val inN_cases1 =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_incond =
   !(n : mem(N0)).
     IN(n#, inN1) <=>
     n# = O0 | ?(n0 : mem(N0)). IN(n0#, inN0) & n# = App(S0, n0#): form
val inN_ind =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_ind0 =
   {},  |- !(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> SS(inNs, ss#):
   thm
val inN_ind1 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        (!(a : mem(N0)).
            a# = O0 | (?(n0 : mem(N0)). IN(n0#, ss#) & a# = App(S0, n0#)) ==>
            IN(a#, ss#)) ==> !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#):
   thm
val inN_ind2 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_rules0 = {},  |- SS(App(inNf, inNs), inNs): thm
val inN_rules1 =
   {}, 
   |- !(a : mem(N0)).
        a# = O0 | (?(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#)) ==>
        IN(a#, inNs): thm
val inN_rules2 =
   {}, 
   |- !(a : mem(N0)).
        (a# = O0 ==> IN(a#, inNs)) &
        !(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#) ==> IN(a#, inNs):
   thm
val inN_rules3 =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val inNf_def =
   {}, 
   |- !(a : mem(Pow(N0)))  (n : mem(N0)).
        IN(n#, App(inNf, a#)) <=>
        n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_ex =
   {}, 
   |- ?!(f : fun(Pow(N0), Pow(N0))).
        !(a : mem(Pow(N0)))  (n : mem(N0)).
          IN(n#, App(f#, a#)) <=>
          n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_monotone =
   {}, 
   |- !(s1 : mem(Pow(N0)))  (s2 : mem(Pow(N0))).
        SS(s1#, s2#) ==> SS(App(inNf, s1#), App(inNf, s2#)): thm
val inNs_SS =
   {},  |- !(a : mem(Pow(N0))). SS(App(inNf, a#), a#) ==> SS(inNs, a#): thm
val inNs_cond =
   {}, 
   |- !(a : mem(N0)).
        (!(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, inNs): thm
val inNs_def = {},  |- inNs = BIGINTER(inN's): thm
val x1 = "inN0": string
val inN_cases =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_rules =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val N_def =
   {}, 
   |- Inj(iN) &
      !(a : mem(N0)). IN(a#, inNs) <=> ?(b : mem(N)). a# = App(iN, b#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val iN_Inj = {},  |- Inj(iN): thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val iN_inNs = {},  |- !(n : mem(N)). IN(App(iN, n#), inNs): thm
val SUC_ex_lemma =
   {},  |- !(n1 : mem(N)). ?(b : mem(N)). App(S0 o iN, n1#) = App(iN, b#):
   thm
val SUC_def = {},  |- !(a : mem(N)). App(iN o SUC, a#) = App(S0 o iN, a#):
   thm
val iN_eq_eq =
   {}, 
   |- !(x1 : mem(N))  (x2 : mem(N)).
        App(iN, x1#) = App(iN, x2#) ==> x1# = x2#: thm
val O_def = {},  |- O0 = App(iN, O): thm
val iN_ex_uex =
   {}, 
   |- !(b : mem(N0)).
        (?(a : mem(N)). App(iN, a#) = b#) <=>
        ?!(a : mem(N)). App(iN, a#) = b#: thm
val S0_eq_eq =
   {}, 
   |- !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) ==> n# = m#:
   thm
val SUC_Inj = {},  |- Inj(SUC): thm
val iN_O = {},  |- !(n : mem(N)). App(iN, n#) = O0 <=> n# = O: thm
val SUC_NONZERO = {},  |- !(n : mem(N)). ~App(SUC, n#) = O: thm
val Image_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(im : fun(Pow(A#), Pow(B#))).
          !(sa : mem(Pow(A#)))  (b : mem(B#)).
            IN(b#, App(im#, sa#)) <=>
            ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val Image_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sa : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Image(f#), sa#)) <=>
        ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val IMAGE_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (b : mem(B#)).
        IN(b#, IMAGE(f#, s0#)) <=>
        ?(a : mem(A#)). IN(a#, s0#) & b# = App(f#, a#): thm
val IMAGE_def0 =
   {(A : set), (B : set), (f : fun(A, B)), (s0 : mem(Pow(A)))}, 
   |- IMAGE(f, s0) = App(Image(f), s0): thm
val Whole_def = {},  |- !(A : set)  (a : mem(A#)). IN(a#, Whole(A#)): thm
val IN_IMAGE_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(s : mem(Pow(A#)))  (a : mem(A#)).
          IN(a#, s#) <=> IN(App(i#, a#), IMAGE(i#, s#)): thm
val N_ind_P =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(App(SUC, n#))) ==>
      !(n : mem(N)). P(n#): thm
val O_xor_SUC =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = App(SUC, pn#): thm
val SUC_eq_eq =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)).
        App(SUC, n1#) = App(SUC, n2#) <=> n1# = n2#: thm
val Suc_def = {},  |- !(n : mem(N)). Suc(n#) = App(SUC, n#): thm
val O_xor_Suc =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = Suc(pn#): thm
val Suc_eq_eq =
   {},  |- !(n1 : mem(N))  (n2 : mem(N)). Suc(n1#) = Suc(n2#) <=> n1# = n2#:
   thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val N_induct =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Eqv_def =
   {},  |- !(A : set)  (B : set). Eqv(A#, B#) <=> ?(f : fun(A#, B#)). Bij(f#):
   thm
val Asset_def =
   {}, 
   |- !(B : set)  (bs : mem(Pow(B#)))  (B0 : set).
        Asset(bs#, B0#) <=>
        !(B1 : set)  (i : fun(B1#, B#)).
          Inj(i#) &
          (!(b : mem(B#)).
              (?(b0 : mem(B1#)). App(i#, b0#) = b#) <=> IN(b#, bs#)) ==>
          Eqv(B0#, B1#): thm
val Sg_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (a0 : mem(A#)).
        IN(a0#, App(Sg(A#), a#)) <=> a0# = a#: thm
val Sing_def = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Empty_def = {},  |- !(X : set)  (a : mem(X#)). ~IN(a#, Empty(X#)): thm
val Sing_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Sing(a1#) = Sing(a2#) <=> a1# = a2#: thm
val Sing_NONEMPTY = {},  |- !(A : set)  (a : mem(A#)). ~Sing(a#) = Empty(A#):
   thm
val iscoPr_def =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (i1 : fun(A#, AB#))
      (i2 : fun(B#, AB#)).
        iscoPr(i1#, i2#) <=>
        !(X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
          ?!(fg : fun(AB#, X#)). fg# o i1# = f# & fg# o i2# = g#: thm
val tof_def =
   {(A : set), (B : set), (f0 : mem(Exp(A, B)))}, 
   |- !(a : mem(A)). App(Ev(A, B), Pair(a#, f0)) = App(tof(f0), a#): thm
val coPr_unique =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        iscoPr(i1#, i2#) & iscoPr(i1'#, i2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          j# o i1'# = i1# &
          j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val iscoPr_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          iscoPr(i1#, i2#) &
          Inj(i1#) &
          Inj(i2#) &
          (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
          !(ab : mem(AB#)).
            (?(a : mem(A#)). ab# = App(i1#, a#)) |
            ?(b : mem(B#)). ab# = App(i2#, b#): thm
val coPr_REFL =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
        ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB#) &
          j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#:
   thm
val coPr_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#) &
      (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
        (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            j# o i1# = i1'# &
            j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#) &
      !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_SYM =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
        ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB'#) &
          j# o i1# = i1'# &
          j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#: thm
val coPr_TRANS =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          (iscoPr(i1#, i2#) &
            Inj(i1#) &
            Inj(i2#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
            !(ab : mem(AB#)).
              (?(a : mem(A#)). ab# = App(i1#, a#)) |
              ?(b : mem(B#)). ab# = App(i2#, b#)) &
          !(AB' : set)  (i1' : fun(A#, AB'#))  (i2' : fun(B#, AB'#)).
            iscoPr(i1'#, i2'#) &
            Inj(i1'#) &
            Inj(i2'#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1'#, a#) = App(i2'#, b#)) &
            (!(ab : mem(AB'#)).
                (?(a : mem(A#)). ab# = App(i1'#, a#)) |
                ?(b : mem(B#)). ab# = App(i2'#, b#)) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val coPo_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i2_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val coPa_def0 =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#: thm
val coPa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        (coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#) &
        !(fg' : fun(A# + B#, X#)).
          fg'# o i1(A#, B#) = f# & fg'# o i2(A#, B#) = g# ==>
          fg'# = coPa(f#, g#): thm
val i1_Inj = {},  |- !(A : set)  (B : set). Inj(i1(A#, B#)): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val i1_or_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
        ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_xor_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) <=>
        ?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#): thm
val i2_xor_i1 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#)) <=>
        ?(a : mem(A#)). ab# = App(i1(A#, B#), a#): thm
val it = (): unit
******

Loading SEAR file SEARpred_set.sml

******
val tof_Tpm_inv =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). tof(Tpm(f#)) = f#: thm
val Tpm_tof_inv =
   {},  |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#))). Tpm(tof(f#)) = f#:
   thm
val Tpm_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        Tpm(f1#) = Tpm(f2#) <=> f1# = f2#: thm
val tof_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (g : mem(Exp(A#, B#))).
        tof(f#) = tof(g#) <=> f# = g#: thm
val IN_Sing =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)).
        IN(a#, Sing(a0#)) <=> a# = a0#: thm
val BU_ex =
   {}, 
   |- !(A : set).
        ?!(BU : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BU#, sss#)) <=>
            ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val EMPTY_def = {(A : set)},  |- EMPTY(A) <=> !(x : mem(A)). F: thm
val BU_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BU(A#), sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val BIGUNION_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        BIGUNION(sss#) = App(BU(A#), sss#): thm
val IN_BIGUNION =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGUNION(sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val IMAGE_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (s : mem(Pow(A#))). IMAGE(g# o f#, s#) = IMAGE(g#, IMAGE(f#, s#)): thm
val ex_eq_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#))).
        (!(b : mem(B#)). IN(b#, s#) ==> ?(a : mem(A#)). b# = App(f#, a#)) ==>
        ?(s0 : mem(Pow(A#))). s# = IMAGE(f#, s0#): thm
val App_IN_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))
      (a : mem(A#)). IN(a#, s#) ==> IN(App(f#, a#), IMAGE(f#, s#)): thm
val IMAGE_BIGUNION =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(Pow(A#)))).
        IMAGE(f#, BIGUNION(ss#)) = BIGUNION(IMAGE(Image(f#), ss#)): thm
val Prla_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(C : set)  (D : set)  (g : fun(C#, D#)).
          Inj(g#) ==> Inj(Prla(f#, g#)): thm
val Id_Inj = {},  |- !(X : set). Inj(Id(X#)): thm
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Pa_distr =
   {}, 
   |- !(A : set)  (X : set)  (a1 : fun(X#, A#))  (B : set)
      (a2 : fun(X#, B#))  (X0 : set)  (x : fun(X0#, X#)).
        Pa(a1#, a2#) o x# = Pa(a1# o x#, a2# o x#): thm
val Pa_eq_eq =
   {}, 
   |- !(A : set)  (X : set)  (f1 : fun(X#, A#))  (f2 : fun(X#, A#))
      (B : set)  (g1 : fun(X#, B#))  (g2 : fun(X#, B#)).
        Pa(f1#, g1#) = Pa(f2#, g2#) <=> f1# = f2# & g1# = g2#: thm
val p2_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(B#, C#)).
        f# o p2(A#, B#) = p2(A#, C#) o Prla(Id(A#), f#): thm
val p1_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(A#, C#)).
        f# o p1(A#, B#) = p1(C#, B#) o Prla(f#, Id(B#)): thm
val p1_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#)). p1(X#, Y#) o Prla(f#, g#) = f# o p1(A#, B#): thm
val IMAGE_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#))  (x : mem(X#))  (y : mem(Y#))
      (s : mem(Pow(A# * B#))).
        IN(Pair(x#, y#), IMAGE(Prla(f#, g#), s#)) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          IN(Pair(a#, b#), s#) & x# = App(f#, a#) & y# = App(g#, b#): thm
val exists_cross_fconv = fn: form -> thm
val Image_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        App(Image(f#), s#) = IMAGE(f#, s#): thm
val IMAGE_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        IMAGE(f#, Empty(A#)) = Empty(B#): thm
val IN_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        (?(a : mem(A#)). IN(a#, s#)) <=> ~s# = Empty(A#): thm
val IMAGE_Empty_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val BIGUNION_Empty_Empty =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        BIGUNION(ss#) = Empty(A#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val BIGUNION_NONEMPTY =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        ~BIGUNION(ss#) = Empty(A#) <=>
        ?(s : mem(Pow(A#))). IN(s#, ss#) & ~s# = Empty(A#): thm
val BIGUNION_Empty_Empty' =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        Empty(A#) = BIGUNION(ss#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val INTER_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(INTER(A), Pair(a'#, b#))) <=> IN(a#, a'#) & IN(a#, b#):
   thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Inter_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Inter(s1, s2) = App(INTER(A), Pair(s1, s2)): thm
val UNION_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(UNION(A), Pair(a'#, b#))) <=> IN(a#, a'#) | IN(a#, b#):
   thm
val COMPL_def =
   {(A : set)}, 
   |- !(a : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(COMPL(A), a#)) <=> ~IN(a#, a#): thm
val Compl_def =
   {(A : set), (s : mem(Pow(A)))},  |- Compl(s) = App(COMPL(A), s): thm
val IN_Compl =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Compl(s#)) <=> ~IN(a#, s#): thm
val IN_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Union(s1#, s2#)) <=> IN(a#, s1#) | IN(a#, s2#): thm
val Union_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Union(s1, s2) = App(UNION(A), Pair(s1, s2)): thm
val m2r_def =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (od : mem(Pow(A# * A#))).
        Holds(m2r(od#), a1#, a2#) <=> IN(Pair(a1#, a2#), od#): thm
val r2m_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(Pair(a1#, a2#), r2m(R#)) <=> Holds(R#, a1#, a2#): thm
val Union_Empty_Empty =
   {},  |- !(A : set). Union(Empty(A#), Empty(A#)) = Empty(A#): thm
val SS_Refl = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(s#, s#): thm
val NONE_def = {(X : set)},  |- NONE(X) = App(i2(X, 1), dot): thm
val Null_def =
   {},  |- !(X : set)  (n : mem(N)). App(Null(X#), n#) = App(i2(X#, 1), dot):
   thm
val PREIM_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#)))
      (a : mem(A#)).
        IN(a#, PREIM(f#, s#)) <=>
        ?(b : mem(B#)). IN(b#, s#) & App(f#, a#) = b#: thm
val SOME_def =
   {},  |- !(A : set)  (a : mem(A#)). SOME(a#) = App(i1(A#, 1), a#): thm
val Surj_Epi =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) ==>
        !(C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
          g1# o f# = g2# o f# ==> g1# = g2#: thm
val false_def = {},  |- false = App(i1(1, 1), dot): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val true_def = {},  |- true = App(i2(1, 1), dot): thm
val true_ne_false = {},  |- ~true = false: thm
val true_or_false = {},  |- !(tv : mem(1 + 1)). tv# = true | tv# = false: thm
val true_xor_false = {},  |- !(tv : mem(1 + 1)). ~tv# = true <=> tv# = false:
   thm
val false_xor_true = {},  |- !(tv : mem(1 + 1)). ~tv# = false <=> tv# = true:
   thm
val tv_eq_true =
   {}, 
   |- !(tv1 : mem(1 + 1))  (tv2 : mem(1 + 1)).
        tv1# = tv2# <=> tv1# = true <=> tv2# = true: thm
val tf_eq_true =
   {}, 
   |- !(A : set)  (tf1 : fun(A#, 1 + 1))  (tf2 : fun(A#, 1 + 1)).
        tf1# = tf2# <=>
        !(a : mem(A#)). App(tf1#, a#) = true <=> App(tf2#, a#) = true: thm
val basic_fconv_tac = fn: conv -> fconv -> tactic
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
******

Loading SEAR file lambda.sml

******
val TAUT = {},  |- A | ~A: thm
val cond_unique_lemma =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b# = b'#: thm
val cond_unique_lemma' =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b'# = b#: thm
val conj1 = fn: form -> form
val conj2 = fn: form -> form
val conjIs = fn: thm list -> thm
val disj1 = fn: form -> form
val disj2 = fn: form -> form
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val disj_neg_absorb = {},  |- A | ~A & B <=> A | B: thm
val disj_of_negconj = {},  |- ~A & ~B <=> ~(A | B): thm
val djE = fn: form * thm -> form * thm -> form * thm
val djEs = fn: (form * thm) list -> form * thm
val drop_last_cj = fn: form -> form * form
val iant = fn: form -> form
val iconc = fn: form -> form
val imp_dimp_distr = {},  |- A ==> (B <=> C) <=> A ==> B <=> A ==> C: thm
val strip_conj = fn: form -> form list
val strip_disj = fn: form -> form list
val cond_rw_fconv = fn: form -> thm
val conj_assoc_fm = fn: form -> form
val define_lambda = fn: form -> thm
val define_lambda_fun = fn: form -> thm
val nlist = fn: int -> int list
val normalise_lambda_input = fn: form -> form
val it = (): unit
val NOT_def = {},  |- App(NOT, true) = false & App(NOT, false) = true: thm
val OR_def =
   {}, 
   |- App(OR, Pair(true, true)) = true &
      App(OR, Pair(true, false)) = true &
      App(OR, Pair(false, true)) = true & App(OR, Pair(false, false)) = false:
   thm
val constf_def =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#))  (a : mem(A#)).
        App(constf(A#, b#), a#) = b#: thm
val f2r_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * B#, 1 + 1))  (a : mem(A#))
      (b : mem(B#)). Holds(f2r(f#), a#, b#) <=> App(f#, Pair(a#, b#)) = true:
   thm
val r2f_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = App(i2(1, 1), dot) <=> Holds(R#, a#, b#):
   thm
val r2f_def' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = true <=> Holds(R#, a#, b#): thm
val ss2f =
   {(A : set), (s : mem(Pow(A)))}, 
   |- !(a : mem(A)). App(ss2f(s), a#) = true <=> IN(a#, s): thm
val FIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : fun(A, B))}, 
   |- FIB(f, b) = PREIM(f, Sing(b)): thm
val Inj_Image_Inj =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(A#, B#)). Inj(i#) ==> Inj(Image(i#)):
   thm
val mApp_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (f : mem(Exp(A#, B#))).
        mApp(f#, a#) = App(tof(f#), a#): thm
val mFIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : mem(Exp(A, B)))}, 
   |- mFIB(f, b) = PREIM(tof(f), Sing(b)): thm
val Compl_Whole = {},  |- !(A : set). Compl(Whole(A#)) = Empty(A#): thm
val Compl_Empty = {},  |- !(A : set). Compl(Empty(A#)) = Whole(A#): thm
val Inter_Compl_Compl =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J)))}, 
   |- Inter(Compl(s1), Compl(s2)) = Compl(Union(s1, s2)): thm
val neg_or_distr = {},  |- ~(A | B) <=> ~A & ~B: thm
val SS_Union =
   {}, 
   |- (!(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
          SS(a#, Union(a#, b#))) &
      !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val SS_Union1 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(a#, b#)): thm
val SS_Union2 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val Ins_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (s0 : mem(Pow(X#)))  (a : mem(X#)).
        IN(a#, Ins(x0#, s0#)) <=> a# = x0# | IN(a#, s0#): thm
val Union_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Union(Sing(a#), s#) = Ins(a#, s#): thm
val SS_Ins =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(s#, Ins(a#, s#)):
   thm
val BIGINTER_Sing =
   {},  |- !(A : set)  (s : mem(Pow(A#))). BIGINTER(Sing(s#)) = s#: thm
val Whole_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Whole(A#), s#) = s#: thm
val Inter_Whole =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Whole(A#)) = s#: thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Empty_SS = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(Empty(A#), s#): thm
val BIGINTER_Empty = {(A : set)},  |- BIGINTER(Empty(Pow(A))) = Whole(A): thm
val BIGINTER_Ins_Empty =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#))). BIGINTER(Ins(x#, Empty(Pow(A#)))) = x#:
   thm
val Inter_same = {},  |- !(A : set)  (x : mem(Pow(A#))). Inter(x#, x#) = x#:
   thm
val BIGINTER_Ins =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#)))  (xs0 : mem(Pow(Pow(A#)))).
        BIGINTER(Ins(x#, xs0#)) = Inter(x#, BIGINTER(xs0#)): thm
val imp_or_distr = {},  |- A | B ==> C <=> (A ==> C) & (B ==> C): thm
val BIGINTER_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(Pow(A#))))  (s2 : mem(Pow(Pow(A#)))).
        BIGINTER(Union(s1#, s2#)) = Inter(BIGINTER(s1#), BIGINTER(s2#)): thm
val Empty_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Empty(A#), s#) = Empty(A#):
   thm
val Union_EMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val neg_and_distr = {},  |- ~(A & B) <=> ~A | ~B: thm
val SS_Union_split =
   {}, 
   |- !(W : set)  (A : mem(Pow(W#)))  (B : mem(Pow(W#)))  (s : mem(Pow(W#))).
        SS(s#, Union(A#, B#)) <=>
        ?(s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
          SS(s1#, A#) & SS(s2#, B#) & s# = Union(s1#, s2#): thm
val Inter_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Empty(A#)) = Empty(A#):
   thm
val SS_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        SS(s#, Sing(a#)) <=> s# = Sing(a#) | s# = Empty(A#): thm
val Empty_Union =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(Empty(A#), s#) = s#: thm
val SS_Empty =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))). SS(s#, Empty(A#)) <=> s# = Empty(A#):
   thm
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val Union_assoc =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Union(Union(s1#, s2#), s3#) = Union(s1#, Union(s2#, s3#)): thm
val Inter_Whole_Whole =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Whole(A#) <=> s1# = Whole(A#) & s2# = Whole(A#):
   thm
val Union_SS1 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(Union(s1#, s2#), s#) <=> SS(s1#, s#) & SS(s2#, s#): thm
val SS_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s#, Inter(s1#, s2#)) <=> SS(s#, s1#) & SS(s#, s2#): thm
val Union_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        SS(Inter(s1#, s2#), s1#) & SS(Inter(s1#, s2#), s2#): thm
val Whole_SS =
   {}, 
   |- !(A : set)  (X : mem(Pow(A#))). SS(Whole(A#), X#) ==> X# = Whole(A#):
   thm
val SS_Whole = {},  |- !(A : set)  (X : mem(Pow(A#))). SS(X#, Whole(A#)): thm
val Sing_Ins_Empty =
   {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = Ins(a#, Empty(A#)): thm
val EMPTY_Empty_Whole =
   {},  |- !(A : set). EMPTY(A#) <=> Empty(A#) = Whole(A#): thm
val NOT_EMPTY = {},  |- !(A : set). ~EMPTY(A#) <=> ?(a : mem(A#)). T: thm
val NEQ_IN =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val PSS_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- PSS(s1, s2) <=> SS(s1, s2) & ~s1 = s2: thm
val PSS_alt =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) <=>
        SS(s1#, s2#) & ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val Inter_Compl =
   {},  |- !(A : set)  (a : mem(Pow(A#))). Inter(a#, Compl(a#)) = Empty(A#):
   thm
val neg_iff = {},  |- ~(A <=> B) <=> A & ~B | B & ~A: thm
val Union_Empty2 =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(s#, Empty(A#)) = s#: thm
val Inter_eq_Empty =
   {}, 
   |- !(W : set)  (s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
        Inter(s1#, s2#) = Empty(W#) <=> SS(s2#, Compl(s1#)): thm
val PSS_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) ==> SS(s1#, s2#): thm
val SS_BIGUNION =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(Pow(A#)))))
      (s0 : mem(Pow(Pow(A#)))).
        IN(s0#, ss#) & SS(s#, s0#) ==> SS(s#, BIGUNION(ss#)): thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val Del_def =
   {}, 
   |- !(X : set)  (s0 : mem(Pow(X#)))  (x0 : mem(X#))  (a : mem(X#)).
        IN(a#, Del(s0#, x0#)) <=> IN(a#, s0#) & ~a# = x0#: thm
val c31_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c31(abc) = Fst(abc): thm
val c32_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c32(abc) = Fst(Snd(abc)): thm
val c33_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c33(abc) = Snd(Snd(abc)): thm
val Del_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        ~IN(x0#, xs0#) ==> Del(Ins(x0#, xs0#), x0#) = xs0#: thm
val Ins_absorb =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        IN(x0#, xs0#) ==> Ins(x0#, xs0#) = xs0#: thm
val Ins_Del =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, s#) ==> Ins(a#, Del(s#, a#)) = s#: thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
        IMAGE(f#, ss#) = Empty(B#) <=> ss# = Empty(A#): thm
val NOTIN_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        ~IN(a#, s#) ==> Del(s#, a#) = s#: thm
val Inj_IMAGE_Del =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#)))
      (a : mem(A#)).
        Inj(f#) ==>
        IMAGE(f#, Del(ss#, a#)) = Del(IMAGE(f#, ss#), App(f#, a#)): thm
val disj_not_imp = {},  |- A | ~B <=> B ==> A: thm
val exists_forall = fn: string * sort -> thm
val exists_forall_th =
   {(A : set)},  |- (?(a : mem(A)). f0(a#)) <=> ~!(a : mem(A)). ~f0(a#): thm
val not_disj_imp = {},  |- ~B | A <=> B ==> A: thm
val set_NEQ =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). ~IN(a#, s1#) & IN(a#, s2#): thm
val Pa_Inj =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#)).
        Inj(f#) ==> !(B : set)  (g : fun(X#, B#)). Inj(Pa(g#, f#)): thm
val o_Inj_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_restrict =
   {}, 
   |- !(D : set)  (D0 : set)  (i1 : fun(D#, D0#)).
        Inj(i1#) ==>
        !(C : set)  (C0 : set)  (i2 : fun(C#, C0#)).
          Inj(i2#) ==>
          !(f0 : fun(D0#, C0#)).
            (!(d : mem(D#)).
                ?!(c : mem(C#)). App(f0# o i1#, d#) = App(i2#, c#)) ==>
            ?!(f : fun(D#, C#)). i2# o f# = f0# o i1#: thm
val SS_Del =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(Del(s#, a#), s#):
   thm
val Inj_o_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        Inj(g# o f#) ==> Inj(f#): thm
val SS_Ins_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#)))  (G : mem(Pow(A#))).
        SS(ss#, Ins(a#, G#)) ==> SS(Del(ss#, a#), G#): thm
val SOME_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (x2 : mem(X#)).
        SOME(x1#) = SOME(x2#) <=> x1# = x2#: thm
val option_xor =
   {}, 
   |- !(A : set)  (a1 : mem(A# + 1)).
        ~a1# = NONE(A#) <=> ?!(a0 : mem(A#)). a1# = SOME(a0#): thm
val NOT_true_iff_false =
   {},  |- !(tv : mem(1 + 1)). App(NOT, tv#) = true <=> tv# = false: thm
val SOME_NOTNONE = {},  |- !(X : set)  (x : mem(X#)). ~SOME(x#) = NONE(X#):
   thm
val OM_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- App(OM(f), NONE(A)) = NONE(B) &
      !(a : mem(A)). App(OM(f), SOME(a#)) = SOME(App(f, a#)): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val Diff_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Diff(s1#, s2#)) <=> IN(a#, s1#) & ~IN(a#, s2#): thm
val Inter_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        ~Inter(s#, Sing(a#)) = Empty(A#) <=> IN(a#, s#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val Diff_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Diff(s#, Empty(A#)) = s#: thm
val Diff_Empty_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Diff(s1#, s2#) = Empty(A#) <=> SS(s1#, s2#): thm
val Ins_Union =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Ins(a#, s#) = Union(Sing(a#), s#): thm
val Union_Empty_both_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Inter(s1#, Union(s2#, s3#)) = Union(Inter(s1#, s2#), Inter(s1#, s3#)):
   thm
val Inter_Diff_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Sing(x#)) = Empty(A#) <=>
        IN(x#, Diff(s1#, s2#)): thm
val Diff_Ins_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Ins(x#, s3#)) = Empty(A#) <=>
        ~Inter(Diff(s1#, s2#), s3#) = Empty(A#) | IN(x#, Diff(s1#, s2#)): thm
val Inter_Empty2 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Empty(A#) ==>
        !(a : mem(A#)). IN(a#, s2#) ==> ~IN(a#, s1#): thm
val Inter_both_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~Inter(s1#, s2#) = Empty(A#) ==> ~s1# = Empty(A#) & ~s2# = Empty(A#):
   thm
val neg_imp_conj = {},  |- ~(A ==> B) <=> A & ~B: thm
val forall_exists_dual =
   {},  |- !(A : set). (!(a : mem(A#)). P(a#)) <=> ~?(a : mem(A#)). ~P(a#):
   thm
val neg_conj_imp = {},  |- ~(A & B) <=> A ==> ~B: thm
val it = (): unit
******

Loading SEAR file SEARNarith.sml

******
val Nind's_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        IN(a#, Nind's(f0, x0)) <=> SS(App(Nindf(f0, x0), a#), a#): thm
val Nind_cases0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- App(Nindf(f0, x0), Ninds(f0, x0)) = Ninds(f0, x0): thm
val Nind_cases1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_incond =
   !(nx : mem(N * X)).
     IN(nx#, Nind1) <=>
     nx# = Pair(O, x0) |
     ?(nx0 : mem(N * X)).
       IN(nx0#, Nind0) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): form
val Nind_ind =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), ss#), ss#) ==> SS(Ninds(f0, x0), ss#): thm
val Nind_ind1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        (!(a : mem(N * X)).
            a# = Pair(O, x0) |
            (?(nx0 : mem(N * X)).
                IN(nx0#, ss#) & a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_rules0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- SS(App(Nindf(f0, x0), Ninds(f0, x0)), Ninds(f0, x0)): thm
val Nind_rules1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        a# = Pair(O, x0) |
        (?(nx0 : mem(N * X)).
            IN(nx0#, Ninds(f0, x0)) &
            a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
        IN(a#, Ninds(f0, x0)): thm
val Nind_rules2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (a# = Pair(O, x0) ==> IN(a#, Ninds(f0, x0))) &
        !(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))) ==>
          IN(a#, Ninds(f0, x0)): thm
val Nind_rules3 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nindf_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
        IN(nx#, App(Nindf(f0, x0), a#)) <=>
        nx# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nindf_ex =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(N * X), Pow(N * X))).
        !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
          IN(nx#, App(f#, a#)) <=>
          nx# = Pair(O, x0) |
          ?(nx0 : mem(N * X)).
            IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))):
   thm
val Nindf_monotone =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(N * X)))  (s2 : mem(Pow(N * X))).
        SS(s1#, s2#) ==> SS(App(Nindf(f0, x0), s1#), App(Nindf(f0, x0), s2#)):
   thm
val Ninds_SS =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), a#), a#) ==> SS(Ninds(f0, x0), a#): thm
val Ninds_cond =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (!(ss : mem(Pow(N * X))).
            SS(App(Nindf(f0, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Ninds(f0, x0)): thm
val Ninds_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- Ninds(f0, x0) = BIGINTER(Nind's(f0, x0)): thm
val x1 = "Nind0": string
val Nind_cases =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_rules =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nind_uex =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        ?!(x : mem(X#)). IN(Pair(n#, x#), Ninds(f0#, x0#)): thm
val Nrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (a : mem(N)).
        IN(Pair(a#, App(Nrec(x0#, f0#), a#)), Ninds(f0#, x0#)): thm
val Nrec_O =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        App(Nrec(x0#, f0#), O) = x0#: thm
val App_Nrec_Ninds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N))
      (x : mem(X#)).
        App(Nrec(x0#, f0#), n#) = x# <=> IN(Pair(n#, x#), Ninds(f0#, x0#)):
   thm
val Nrec_Suc =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        App(Nrec(x0#, f0#), Suc(n#)) = App(f0#, App(Nrec(x0#, f0#), n#)): thm
val Nrec_unique =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Nrec_Suc_eqn =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        Nrec(x0#, f0#) o SUC = f0# o Nrec(x0#, f0#): thm
val El_def = {},  |- !(A : set)  (a : mem(A#)). App(El(a#), dot) = a#: thm
val El_eq_eq =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). El(a#) = El(b#) <=> a# = b#:
   thm
val App_o_El =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(f#, a#) = App(f# o El(a#), dot): thm
val Nrec_El =
   {}, 
   |- !(X : set)  (a : mem(X#))  (f : fun(X#, X#)).
        Nrec(a#, f#) o El(O) = El(a#) &
        Nrec(a#, f#) o SUC = f# o Nrec(a#, f#) &
        !(u : fun(N, X#)).
          u# o El(O) = El(a#) & u# o SUC = f# o u# ==> u# = Nrec(a#, f#): thm
val App_El_mem =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(f#, a#) = b# <=> f# o El(a#) = El(b#): thm
val Nrec_O_SUC = {},  |- Nrec(O, SUC) = Id(N): thm
val comm_with_SUC_id0 =
   {}, 
   |- !(f : fun(N, N)). App(f#, O) = O & f# o SUC = SUC o f# ==> f# = Id(N):
   thm
val comm_with_SUC_id =
   {}, 
   |- !(f : fun(N, N)).
        f# o El(O) = El(O) & f# o SUC = SUC o f# ==> f# = Id(N): thm
val Thm1_case1_comm_condition =
   {}, 
   |- !(B : set)  (f0 : fun(N, B#))  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        f0# o El(O) = g# & f0# o SUC = h# o Pa(Id(N), f0#) <=>
        Pa(Id(N), f0#) o El(O) = Pa(El(O), g#) &
        Pa((SUC o p1(N, B#)), h#) o Pa(Id(N), f0#) = Pa(Id(N), f0#) o SUC:
   thm
val Dot_def = {},  |- !(A : set)  (f : fun(1, A#)). Dot(f#) = App(f#, dot):
   thm
val Dot_of_El = {},  |- !(A : set)  (a : mem(A#)). Dot(El(a#)) = a#: thm
val El_of_Dot = {},  |- !(X : set)  (f : fun(1, X#)). El(Dot(f#)) = f#: thm
val to_P_component =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#)).
        Pa(p1(A#, B#) o f#, p2(A#, B#) o f#) = f#: thm
val Thm1_case_1 =
   {}, 
   |- !(B : set)  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        ?!(f : fun(N, B#)). f# o El(O) = g# & f# o SUC = h# o Pa(Id(N), f#):
   thm
val is_Nrec =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Tp1_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(tpf : fun(1, Exp(A#, B#))). Tp(f# o p1(A#, 1)) = tpf#: thm
val Ev_of_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#)).
        Ev(A#, B#) o Pa(p1(A#, X#), Tp(f#) o p2(A#, X#)) = f#: thm
val Tp1_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Tp(f# o p1(A#, 1)) = Tp1(f#):
   thm
val Tp_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (g : fun(A# * X#, B#)). Tp(f#) = Tp(g#) <=> f# = g#: thm
val Ev_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, Exp(A#, B#)))
      (g : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), f# o p2(A#, X#)) = Ev(A#, B#) o
          Pa(p1(A#, X#), g# o p2(A#, X#)) ==> f# = g#: thm
val to_P_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#))
      (g : fun(X#, A# * B#)).
        p1(A#, B#) o f# = p1(A#, B#) o g# & p2(A#, B#) o f# = p2(A#, B#) o g# ==>
        f# = g#: thm
val Pa_o_split =
   {}, 
   |- !(B : set)  (X : set)  (f : fun(B#, X#))  (Y : set)  (g : fun(X#, Y#))
      (A : set).
        Pa(p1(A#, B#), g# o f# o p2(A#, B#)) =
          Pa(p1(A#, X#), (g# o p2(A#, X#))) o Pa(p1(A#, B#), f# o p2(A#, B#)):
   thm
val Thm1_comm_eq_left =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))  (g : fun(A#, B#)).
        Tp(f#) o El(O) = Tp1(g#) <=>
        f# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1): thm
val Pa_p1_p2 =
   {},  |- !(A : set)  (B : set). Pa(p1(A#, B#), p2(A#, B#)) = Id(A# * B#):
   thm
val Thm1_comm_eq_right =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))
      (h : fun((A# * N) * B#, B#))
      (l : fun(A# * N * Exp(A#, B#), (A# * N) * B#)).
        Pa(Pa(p1(A#, N * Exp(A#, B#)), p1(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#))), Ev(A#, B#) o
           Pa(p1(A#, N * Exp(A#, B#)), p2(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#)))) = l# ==>
        (h# o Pa(Id(A# * N), f#) = f# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
          Tp((h# o l#)) o Pa(Id(N), Tp(f#)) = Tp(f#) o SUC): thm
val Ev_of_Tp_el =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))  (P : set)
      (a : fun(P#, A#))  (x : fun(P#, X#)).
        Ev(A#, B#) o Pa(a#, Tp(f#) o x#) = f# o Pa(a#, x#): thm
val Ev_of_Tp_el' =
   {}, 
   |- !(A : set)  (B : set)  (P : set)  (f : fun(A# * P#, B#))
      (a : fun(P#, A#)). Ev(A#, B#) o Pa(a#, Tp(f#)) = f# o Pa(a#, Id(P#)):
   thm
val Tp_of_Ev =
   {(A : set), (B : set), (X : set), (f : fun(X, Exp(A, B)))}, 
   |- Tp(Ev(A, B) o Pa(p1(A, X), f o p2(A, X))) = f: thm
val Thm1 =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val Thm1_uex =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?!(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val PRE_def = {},  |- PRE o El(O) = El(O) & PRE o SUC = Id(N): thm
val Pre_def = {},  |- !(n : mem(N)). Pre(n#) = App(PRE, n#): thm
val Pre_eqn = {},  |- Pre(O) = O & !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val ADD_def =
   {}, 
   |- ADD o Pa(p1(N, 1), El(O) o To1(N * 1)) = p1(N, 1) &
      SUC o ADD = ADD o Pa(p1(N, N), SUC o p2(N, N)): thm
val Add_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Add(n1#, n2#) = App(ADD, Pair(n1#, n2#)):
   thm
val Add_O = {},  |- !(n : mem(N)). Add(n#, O) = n#: thm
val App_input_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a1 : mem(A#))
      (a2 : mem(A#)). a1# = a2# ==> App(f#, a1#) = App(f#, a2#): thm
val Add_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, Suc(n#)) = Suc(Add(m#, n#)):
   thm
val Pre_O = {},  |- Pre(O) = O: thm
val Pre_Suc = {},  |- !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val SUB_def =
   {}, 
   |- SUB o Pa(p1(N, 1), El(O) o p2(N, 1)) = p1(N, 1) &
      PRE o SUB = SUB o Pa(p1(N, N), SUC o p2(N, N)): thm
val o_eq_r =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        f1# = f2# ==> !(C : set)  (g : fun(B#, C#)). g# o f1# = g# o f2#: thm
val Sub_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Sub(n1#, n2#) = App(SUB, Pair(n1#, n2#)):
   thm
val Sub_O = {},  |- !(n : mem(N)). Sub(n#, O) = n#: thm
val Sub_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, Suc(n#)) = Pre(Sub(m#, n#)):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Le_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Pre_eq_O = {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O):
   thm
val Lt_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val Le_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val Lt_Le = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> Le(m#, n#):
   thm
val Lt_NE = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> ~m# = n#: thm
val Le_NE_Lt =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) & ~m# = n# ==> Lt(m#, n#):
   thm
val Lt_Le_NE =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val Sub_mono_eq =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(Suc(m#), Suc(n#)) = Sub(m#, n#):
   thm
val Add_Sub = {},  |- !(c : mem(N))  (a : mem(N)). Sub(Add(a#, c#), c#) = a#:
   thm
val Add_O2 = {},  |- !(n : mem(N)). Add(O, n#) = n#: thm
val Sub_EQ_O = {},  |- !(n : mem(N)). Sub(n#, n#) = O: thm
val Le_refl = {},  |- !(n : mem(N)). Le(n#, n#): thm
val Le_O_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val o_eq_l =
   {}, 
   |- !(B : set)  (C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
        g1# = g2# ==> !(A : set)  (f : fun(A#, B#)). g1# o f# = g2# o f#: thm
val Le_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) ==> Lt(m#, n#) | m# = n#:
   thm
val Le_Sub =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val cancel_Sub =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Le(a#, c#) ==> (Sub(b#, a#) = Sub(c#, a#) <=> b# = c#):
   thm
val th =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Sub_of_O = {},  |- !(n : mem(N)). Sub(O, n#) = O: thm
val O_LESS_EQ = {},  |- !(x : mem(N)). Le(O, x#): thm
val LESS_EQ_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val LESS_O = {},  |- !(n : mem(N)). Lt(O, Suc(n#)): thm
val LESS_MONO_EQ =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val LE_O_iff = {},  |- !(n : mem(N)). Le(n#, O) <=> n# = O: thm
val LESS_cases =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | Le(b#, a#): thm
val LESS_EQ_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) | Le(n#, m#): thm
val Add_Suc1 =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(Suc(a#), b#) = Suc(Add(a#, b#)):
   thm
val Add_comm =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(a#, b#) = Add(b#, a#): thm
val Suc_Sub = {},  |- !(n : mem(N)). Sub(Suc(n#), n#) = Suc(O): thm
val Sub_DIFF_1 =
   {},  |- !(a : mem(N))  (b : mem(N)). Sub(a#, b#) = Suc(O) <=> a# = Suc(b#):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Sub_Suc_O_cases =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, Suc(b#)) = O ==> a# = Suc(b#) | Sub(a#, b#) = O: thm
val Le_cases_iff =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) <=> Lt(a#, b#) | a# = b#:
   thm
val Lt_Suc_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Suc(b#)) <=> Le(a#, b#): thm
val Sub_EQ_O1 =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, n#) = O <=> Le(m#, n#): thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val strong_ind =
   {}, 
   |- (!(a : mem(N)). (!(a0 : mem(N)). Lt(a0#, a#) ==> P(a0#)) ==> P(a#)) ==>
      !(a : mem(N)). P(a#): thm
val WOP =
   {}, 
   |- !(a : mem(N)).
        P(a#) ==>
        ?(a0 : mem(N)). P(a0#) & !(a1 : mem(N)). P(a1#) ==> Le(a0#, a1#): thm
val MUL_def0 =
   {}, 
   |- MUL o Pa(p1(N, 1), El(O) o To1(N * 1)) = El(O) o To1(N * 1) &
      ADD o Pa(MUL, p1(N, N)) = MUL o Pa(p1(N, N), SUC o p2(N, N)): thm
val Mul_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Mul(n1#, n2#) = App(MUL, Pair(n1#, n2#)):
   thm
val App_Pa2 =
   {}, 
   |- !(A : set)  (B : set)  (D : set)  (g : fun(B#, D#))
      (ab : mem(A# * B#)).
        App(Pa(p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_p1_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p1(A#, B#), Pair(a#, b#)) = a#: thm
val App_p2_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p2(A#, B#), Pair(a#, b#)) = b#: thm
val Mul_O = {},  |- !(n : mem(N)). Mul(n#, O) = O: thm
val Mul_Suc =
   {}, 
   |- !(n : mem(N))  (n0 : mem(N)). Mul(n#, Suc(n0#)) = Add(Mul(n#, n0#), n#):
   thm
val Mul_LEFT_O = {},  |- !(m : mem(N)). Mul(O, m#) = O: thm
val Mul_LEFT_1 = {},  |- !(m : mem(N)). Mul(Suc(O), m#) = m#: thm
val Mul_RIGHT_1 = {},  |- !(m : mem(N)). Mul(m#, Suc(O)) = m#: thm
val Add_comm' =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(b#, a#) = Add(a#, b#): thm
val Add_assoc =
   {}, 
   |- !(m : mem(N))  (n0 : mem(N))  (p : mem(N)).
        Add(m#, Add(n0#, p#)) = Add(Add(m#, n0#), p#): thm
val Add_eq_eq =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (a : mem(N)).
        Add(m#, a#) = Add(n#, a#) ==> m# = n#: thm
val Mul_Suc1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Mul(Suc(n#), m#) = Add(m#, Mul(n#, m#)):
   thm
val Mul_clauses =
   {}, 
   |- (!(m : mem(N)).
          Mul(O, m#) = O &
          Mul(m#, O) = O & Mul(Suc(O), m#) = m# & Mul(m#, Suc(O)) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Mul(Suc(m#), n#) = Add(Mul(m#, n#), n#) &
        Mul(m#, Suc(n#)) = Add(m#, Mul(m#, n#)): thm
val Mul_comm =
   {},  |- !(m : mem(N))  (n : mem(N)). Mul(m#, n#) = Mul(n#, m#): thm
val Add_clauses =
   {}, 
   |- (!(m : mem(N)). Add(O, m#) = m# & Add(m#, O) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Add(Suc(m#), n#) = Suc(Add(m#, n#)) &
        Add(m#, Suc(n#)) = Suc(Add(m#, n#)): thm
val Nind_tac = fn: tactic
val RIGHT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Add(m#, n#), p#) = Add(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Add(m#, n#)) = Add(Mul(p#, m#), Mul(p#, n#)): thm
val Mul_assoc =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(m#, Mul(n#, p#)) = Mul(Mul(m#, n#), p#): thm
val Sub_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Sub(a#, Add(b#, c#)) = Sub(Sub(a#, b#), c#): thm
val Le_O_iff = {},  |- !(a : mem(N)). Le(a#, O) <=> a# = O: thm
val Le_Suc =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, Suc(b#)) ==> Le(a#, b#) | a# = Suc(b#): thm
val Le_Add_ex =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(n#, m#) ==> ?(p : mem(N)). Add(p#, n#) = m#: thm
val LE_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Sub(a#, b#) = O:
   thm
val LT_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Holds(LT, a#, b#) <=> Holds(LE, a#, b#) & ~a# = b#: thm
val LE_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Le(a#, b#): thm
val LT_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LT, a#, b#) <=> Lt(a#, b#): thm
val LE_Trans = {},  |- Trans(LE): thm
val LESS_MONO_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(m#, n#) <=> Lt(Add(m#, p#), Add(n#, p#)): thm
val EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val LESS_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(Add(m#, p#), Add(n#, p#)) <=> Lt(m#, n#): thm
val LESS_OR_EQ =
   {(m : mem(N)), (n : mem(N))},  |- Le(m, n) <=> Lt(m, n) | m = n: thm
val LESS_EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(Add(m#, p#), Add(n#, p#)) <=> Le(m#, n#): thm
val Le_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, c#) & Le(b#, d#) ==> Le(Add(a#, b#), Add(c#, d#)): thm
val Le_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Le(a1#, a2#) & Le(a2#, a3#) ==> Le(a1#, a3#): thm
val Asym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Asym(R#) <=>
        !(a : mem(A#))  (b : mem(A#)).
          Holds(R#, a#, b#) & Holds(R#, b#, a#) ==> a# = b#: thm
val Lt_Suc = {},  |- !(a : mem(N)). Lt(a#, Suc(a#)): thm
val Suc_NEQ = {},  |- !(a : mem(N)). ~a# = Suc(a#): thm
val Add_Suc_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Add(a#, Suc(b#))): thm
val LT_Trans = {},  |- Trans(LT): thm
val Lt_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Lt(a1#, a2#) & Lt(a2#, a3#) ==> Lt(a1#, a3#): thm
val LE_Asym = {},  |- Asym(LE): thm
val Le_Asym =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) ==> a# = b#:
   thm
val LESS_EQ_LESS_EQ_MONO =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N))  (q : mem(N)).
        Le(m#, p#) & Le(n#, q#) ==> Le(Add(m#, n#), Add(p#, q#)): thm
val Le_MONO_Mul =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(m#, n#) ==> Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul' =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(m#, n#) ==> !(p : mem(N)). Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Le(m#, i#) & Le(n#, j#) ==> Le(Mul(m#, n#), Mul(i#, j#)): thm
val Le_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val Le_O' = {},  |- !(x : mem(N)). Le(O, x#): thm
val Sub_Suc1 =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(b#, a#) ==> Sub(Suc(a#), b#) = Suc(Sub(a#, b#)): thm
val SUB_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Le(n#, m#) ==> Add(Sub(m#, n#), n#) = m#:
   thm
val ADD_EQ_SUB =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(n#, p#) ==> (Add(m#, n#) = p# <=> m# = Sub(p#, n#)): thm
val NOT_SUC_LESS_EQ_O = {},  |- !(n : mem(N)). ~Le(Suc(n#), O): thm
val NOT_SUC_LT_O = {},  |- !(n : mem(N)). ~Lt(Suc(n#), O): thm
val Lt_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val Lt_trichotomy =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | a# = b# | Lt(b#, a#):
   thm
val NEQ_O_Lt = {},  |- !(a : mem(N)). ~a# = O <=> Lt(O, a#): thm
val Add_eq_O =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, n#) = O <=> m# = O & n# = O:
   thm
val Mul_eq_O =
   {}, 
   |- !(a : mem(N)). ~a# = O ==> !(b : mem(N)). Mul(a#, b#) = O <=> b# = O:
   thm
val Sub_Sub_O_eq =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, b#) = O & Sub(b#, a#) = O ==> a# = b#: thm
val NOT_LESS =
   {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#): thm
val RIGHT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Sub(m#, n#), p#) = Sub(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Sub(m#, n#)) = Sub(Mul(p#, m#), Mul(p#, n#)): thm
val MULT_MONO_EQ =
   {}, 
   |- !(n : mem(N))  (m : mem(N))  (i : mem(N)).
        Mul(Suc(n#), m#) = Mul(Suc(n#), i#) <=> m# = i#: thm
val Mul_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        ~p# = O ==> (Mul(m#, p#) = Mul(n#, p#) <=> m# = n#): thm
val Lt_MONO_Mul =
   {}, 
   |- !(p : mem(N)).
        Lt(O, p#) ==>
        !(m : mem(N))  (n : mem(N)).
          Lt(m#, n#) ==> Lt(Mul(m#, p#), Mul(n#, p#)): thm
val Le_Lt_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Lt(a#, c#): thm
val Lt_O_Lt = {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) ==> Lt(O, b#):
   thm
val Lt_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Lt(m#, i#) & Lt(n#, j#) ==> Lt(Mul(m#, n#), Mul(i#, j#)): thm
val LESS_ADD_NONZERO =
   {},  |- !(m : mem(N))  (n : mem(N)). ~n# = O ==> Lt(m#, Add(m#, n#)): thm
val SUB_LESS =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Lt(O, n#) & Le(n#, m#) ==> Lt(Sub(m#, n#), m#): thm
val Add_leq =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (b : mem(N)).
        a1# = a2# ==> Add(a1#, b#) = Add(a2#, b#): thm
val Add_req =
   {}, 
   |- !(a : mem(N))  (b1 : mem(N))  (b2 : mem(N)).
        b1# = b2# ==> Add(a#, b1#) = Add(a#, b2#): thm
val Add_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, b#), Add(c#, d#)): thm
val Add_split_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(a#, Add(Add(b#, c#), d#)): thm
val Add_last_middle_split =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, d#), Add(b#, c#)): thm
val Add_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val Add_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (m : mem(N))  (n : mem(N)).
        Add(a#, m#) = Add(a#, n#) <=> m# = n#: thm
val Lt_Sub_O =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) <=> Lt(O, Sub(b#, a#)):
   thm
val Lt_Le_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(a#, b#) & Le(b#, c#) ==> Lt(a#, c#): thm
val LESS_EQ_SUC = {},  |- !(n : mem(N)). Le(n#, Suc(n#)): thm
val Le_Lt_Le =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Le(a#, c#): thm
val Add_Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(Add(a#, b#), Add(c#, d#)) = Add(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_Lt_Lt_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Lt(c#, d#) ==> Lt(Add(a#, c#), Add(b#, d#)): thm
val Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Add(a#, Add(b#, c#)) = Add(b#, Add(a#, c#)): thm
val NOT_LESS_EQ =
   {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
val SUC_NOT_LESS_EQ = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
val Lt_Le_Suc =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(b#, a#) <=> Le(Suc(b#), a#): thm
val Le_Le_iff_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) <=> a# = b#:
   thm
val Le_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Le(a#, b#) ==> Le(Sub(a#, c#), Sub(b#, c#)): thm
val Lt_imp_Sub_O =
   {(a : mem(N)), (b : mem(N))},  |- Lt(a, b) ==> Sub(a, b) = O: thm
val Lt_Sub_imp_Le =
   {(a : mem(N)), (b : mem(N)), (c : mem(N))}, 
   |- Lt(a, Sub(b, c)) ==> Le(c, b): thm
val Lt_MONO_Sub_hard_direction =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(Sub(a#, c#), Sub(b#, c#)) & Le(c#, a#) ==> Lt(a#, b#): thm
val Lt_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Lt(a#, b#) <=> Lt(Sub(a#, c#), Sub(b#, c#)): thm
val Add_Le = {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, Add(a#, b#)): thm
val Add_pos_Lt =
   {}, 
   |- !(a : mem(N)).
        Lt(O, a#) ==>
        !(b : mem(N))  (c : mem(N)). Add(a#, b#) = c# ==> Lt(b#, c#): thm
val Le_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Le(c#, d#) ==>
          Le(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val Lt_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Lt(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Lt(c#, d#) ==>
          Lt(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val num1_def = {},  |- num1 = Suc(O): thm
val num2_def = {},  |- num2 = Suc(num1): thm
val num3_def = {},  |- num3 = Suc(num2): thm
val num4_def = {},  |- num4 = Suc(num3): thm
val WOP' =
   {}, 
   |- !(s : mem(Pow(N))).
        ~s# = Empty(N) ==>
        ?(a0 : mem(N)).
          IN(a0#, s#) & !(a1 : mem(N)). IN(a1#, s#) ==> Le(a0#, a1#): thm
val division_theorem_N_ex0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Lt(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val division_theorem_N_ex =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Le(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val NOT_Lt_O_O = {},  |- ~Lt(O, O): thm
val it = (): unit
******

Loading SEAR file SEARZarith.sml

******
val ZR_def =
   {}, 
   |- !(x : mem(N))  (y : mem(N))  (u : mem(N))  (v : mem(N)).
        Holds(ZR, Pair(x#, y#), Pair(u#, v#)) <=> Add(x#, v#) = Add(u#, y#):
   thm
val ZR_Refl = {},  |- Refl(ZR): thm
val ZR_Trans = {},  |- Trans(ZR): thm
val ZR_Sym = {},  |- Sym(ZR): thm
val ZR_ER = {},  |- ER(ZR): thm
val Ri_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (s : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Ri(r#), s#)) <=>
        ?(a : mem(A#)). IN(a#, s#) & Holds(r#, a#, b#): thm
val Rsi_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#)). Rsi(r#) = Ri(r#) o Sg(A#):
   thm
val rsi_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (r : rel(A#, B#)).
        rsi(r#, a#) = App(Rsi(r#), a#): thm
val IN_rsi =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
val ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          (!(x : mem(A#)). Holds(r#, a1#, x#) <=> Holds(r#, a2#, x#)) <=>
          Holds(r#, a1#, a2#): thm
val rsi_eq_ER =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          rsi(r#, a1#) = rsi(r#, a2#) <=> Holds(r#, a1#, a2#): thm
val Z_def =
   {}, 
   |- Inj(iZ) &
      !(a : mem(Pow(N * N))).
        (?(n : mem(N * N)). a# = rsi(ZR, n#)) <=>
        ?(b : mem(Z)). a# = App(iZ, b#): thm
val iZ_Inj = {},  |- Inj(iZ): thm
val iZ_eq_eq =
   {}, 
   |- !(x1 : mem(Z))  (x2 : mem(Z)).
        App(iZ, x1#) = App(iZ, x2#) ==> x1# = x2#: thm
val iZ_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(m : mem(N))  (n : mem(N)). App(iZ, z#) = rsi(ZR, Pair(m#, n#)): thm
val rsi_iZ =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        ?(b : mem(Z)). rsi(ZR, Pair(m#, n#)) = App(iZ, b#): thm
val resp_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#)).
        resp(f#, r1#, r2#) <=>
        !(y : mem(A#))  (z : mem(A#)).
          Holds(r1#, y#, z#) ==> Holds(r2#, App(f#, y#), App(f#, z#)): thm
val rext_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a0 : mem(Pow(A#)))  (b0 : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a0#, b0#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a0# = rsi(r1#, a#) & b0# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val rext_def0 =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a : mem(Pow(A#)))  (b : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a#, b#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a# = rsi(r1#, a#) & b# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val prrel_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#))
      (a1 : mem(A#))  (b1 : mem(B#))  (a2 : mem(A#))  (b2 : mem(B#)).
        Holds(prrel(r1#, r2#), Pair(a1#, b1#), Pair(a2#, b2#)) <=>
        Holds(r1#, a1#, a2#) & Holds(r2#, b1#, b2#): thm
val main =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val ipow2_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (b : mem(B#))  (Q1 : set)
      (aq : mem(Q1#))  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (bq : mem(Q2#))
      (i2 : fun(Q2#, Pow(B#))).
        IN(Pair(a#, b#), App(ipow2(i1#, i2#), Pair(aq#, bq#))) <=>
        IN(a#, App(i1#, aq#)) & IN(b#, App(i2#, bq#)): thm
val addf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(addf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(a#, a'#), Add(b#, b''#)): thm
val prrel_ER_ER =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#)).
        ER(r1#) & ER(r2#) ==> ER(prrel(r1#, r2#)): thm
val Pow_conj_eq0 =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3#: thm
val Pow_conj_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3# & s2# = s4#: thm
val ipow2_Inj_Inj =
   {}, 
   |- !(Q1 : set)  (A : set)  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (B : set)
      (i2 : fun(Q2#, Pow(B#))).
        (!(q1 : mem(Q1#)). ?(a : mem(A#)). IN(a#, App(i1#, q1#))) &
        (!(q2 : mem(Q2#)). ?(b : mem(B#)). IN(b#, App(i2#, q2#))) &
        Inj(i1#) & Inj(i2#) ==> Inj(ipow2(i1#, i2#)): thm
val Quo_def =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quo(r#, i#) <=>
        !(s : mem(Pow(A#))).
          (?!(q : mem(Q#)). s# = App(i#, q#)) <=>
          ?(a : mem(A#)). s# = rsi(r#, a#): thm
val Inj_Quo =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Inj(i) &
      (!(s : mem(Pow(A))).
          (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#)) <=>
      Inj(i) & Quo(r, i): thm
val ER_rsi_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a : mem(A#)).
        ER(r#) ==> IN(a#, rsi(r#, a#)): thm
val Quo_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) & Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        Quo(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val Quo_fun =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val main_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val Inj_Quo_Z = {},  |- Inj(iZ) & Quo(ZR, iZ): thm
val Quo_fun_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val iZ_nonempty =
   {},  |- !(z : mem(Z)). ?(ab : mem(N * N)). IN(ab#, App(iZ, z#)): thm
val addf0_resp = {},  |- resp(addf0, prrel(ZR, ZR), ZR): thm
val addz_conds =
   {}, 
   |- ER(prrel(ZR, ZR)) &
      ER(ZR) &
      resp(addf0, prrel(ZR, ZR), ZR) &
      Inj(ipow2(iZ, iZ)) &
      Inj(iZ) & Quo(prrel(ZR, ZR), ipow2(iZ, iZ)) & Quo(ZR, iZ): thm
val main_addz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(addz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(addf0, a#) = b#: thm
val main_addz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(addz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val Inj_Quo_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Inj(i#) & Quo(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). App(i#, q#) = rsi(r#, a#): thm
val Z_has_rep =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). App(iZ, z#) = rsi(ZR, Pair(a'#, b#)):
   thm
val Addz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Addz(z1#, z2#) = App(addz, Pair(z1#, z2#)): thm
val Repz_def = {},  |- !(z : mem(Z)). Repz(z#) = App(iZ, z#): thm
val Repz_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = rsi(ZR, Pair(a'#, b#)): thm
val ZC_def = {},  |- !(ab : mem(N * N)). ZC(ab#) = rsi(ZR, ab#): thm
val Repz_ZC =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = ZC(Pair(a'#, b#)): thm
val Addz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Addz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val ZC_ZR =
   {}, 
   |- !(ab : mem(N * N))  (cd : mem(N * N)).
        ZC(ab#) = ZC(cd#) <=> Holds(ZR, ab#, cd#): thm
val Addz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Addz(z1#, z2#)) = ZC(Pair(Add(a1#, a3#), Add(a2#, a4#))): thm
val Repz_eq_eq =
   {},  |- !(x1 : mem(Z))  (x2 : mem(Z)). Repz(x1#) = Repz(x2#) ==> x1# = x2#:
   thm
val Repz_eq_ZR =
   {}, 
   |- !(a1 : mem(N * N))  (a2 : mem(N * N)).
        ZC(a1#) = ZC(a2#) <=> Holds(ZR, a1#, a2#): thm
val eq_ZR =
   {},  |- !(a : mem(N * N))  (b : mem(N * N)). a# = b# ==> Holds(ZR, a#, b#):
   thm
val Addz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Addz(z1#, z2#) = Addz(z2#, z1#):
   thm
val negf0_def =
   {},  |- !(a : mem(N * N)). App(negf0, a#) = Pair(Snd(a#), Fst(a#)): thm
val negf0_def1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). App(negf0, Pair(m#, n#)) = Pair(n#, m#):
   thm
val negf0_resp = {},  |- resp(negf0, ZR, ZR): thm
val Negz_def = {},  |- !(z : mem(Z)). Negz(z#) = App(negz, z#): thm
val main_negz =
   {(z : mem(Z))}, 
   |- ?(a : mem(N * N))  (b : mem(N * N)).
        Repz(z) = ZC(a#) & Repz(App(negz, z)) = ZC(b#) & App(negf0, a#) = b#:
   thm
val Negz_char =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = ZC(Pair(a#, b#)) ==> Repz(Negz(z#)) = ZC(Pair(b#, a#)):
   thm
val main_negz1 =
   {(z : mem(Z))}, 
   |- ?(a1' : mem(N))  (a2' : mem(N)).
        Repz(z) = ZC(Pair(a1'#, a2'#)) & Repz(Negz(z)) = ZC(Pair(a2'#, a1'#)):
   thm
val mulf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(mulf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(Mul(a#, a'#), Mul(b#, b''#)),
           Add(Mul(a#, b''#), Mul(b#, a'#))): thm
val mulf0_resp = {},  |- resp(mulf0, prrel(ZR, ZR), ZR): thm
val main_mulz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(mulz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(mulf0, a#) = b#: thm
val main_mulz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(mulz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
           Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Mulz(z1#, z2#) = App(mulz, Pair(z1#, z2#)): thm
val Mulz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Mulz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Mulz(z1#, z2#)) =
            ZC(Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
              Add(Mul(a1#, a4#), Mul(a2#, a3#)))): thm
val ZC_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        ?!(z : mem(Z)). Repz(z#) = ZC(Pair(a#, b#)): thm
val ZC_Repz' =
   {},  |- !(ab : mem(N * N)). ?!(z : mem(Z)). Repz(z#) = ZC(ab#): thm
val absz_def =
   {}, 
   |- !(a' : mem(N))  (b : mem(N))  (b : mem(Z)).
        App(absz, Pair(a'#, b#)) = b# <=> Repz(b#) = ZC(Pair(a'#, b#)): thm
val Absz_def = {},  |- !(ab : mem(N * N)). Absz(ab#) = App(absz, ab#): thm
val Asz_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Asz(a#, b#) = Absz(Pair(a#, b#)): thm
val Zc_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Zc(a#, b#) = ZC(Pair(a#, b#)): thm
val Absz_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Repz(Absz(Pair(a#, b#))) = ZC(Pair(a#, b#)): thm
val Asz_Repz =
   {},  |- !(a : mem(N))  (b : mem(N)). Repz(Asz(a#, b#)) = Zc(a#, b#): thm
val Oz_def = {},  |- Oz = Asz(O, O): thm
val En_def = {},  |- En = Suc(O): thm
val Ez_def = {},  |- Ez = Asz(En, O): thm
val Addz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Addz(z1#, z2#)) = Zc(Add(a1#, a3#), Add(a2#, a4#)): thm
val Addz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Addz(Asz(a#, b#), Asz(c#, d#)) = Asz(Add(a#, c#), Add(b#, d#)): thm
val Mulz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Mulz(z1#, z2#)) =
            Zc(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))): thm
val Mulz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Mulz(Asz(a#, b#), Asz(c#, d#)) =
          Asz(Add(Mul(a#, c#), Mul(b#, d#)), Add(Mul(a#, d#), Mul(b#, c#))):
   thm
val Negz_th0 =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) ==> Repz(Negz(z#)) = Zc(b#, a#): thm
val Negz_Asz =
   {},  |- !(a : mem(N))  (b : mem(N)). Negz(Asz(a#, b#)) = Asz(b#, a#): thm
val cases_z =
   {},  |- !(z : mem(Z)). ?(a : mem(N))  (b : mem(N)). z# = Asz(a#, b#): thm
val Addz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Addz(Addz(z1#, z2#), z3#) = Addz(z1#, Addz(z2#, z3#)): thm
val casesz =
   {}, 
   |- (!(a : mem(N))  (b : mem(N)). P(Asz(a#, b#))) <=> !(z : mem(Z)). P(z#):
   thm
SEARZarith.sml:1213: warning: Matches are not exhaustive. Found near fn [th0] => dimp_mp_l2r th0 th
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val casez_tac = fn: cont * form list * form -> goal list * validation
val Asz_eq_ZR =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Asz(a#, b#) = Asz(c#, d#) <=> Holds(ZR, Pair(a#, b#), Pair(c#, d#)):
   thm
val Addz_Negz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Negz(z#)) = Oz: thm
val Mulz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Mulz(z1#, z2#), z3#) = Mulz(z1#, Mulz(z2#, z3#)): thm
val LDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(z1#, Addz(z2#, z3#)) = Addz(Mulz(z1#, z2#), Mulz(z1#, z3#)): thm
val Mulz_Ez = {},  |- !(z : mem(Z)). Mulz(z#, Ez) = z#: thm
val Mulz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Mulz(z1#, z2#) = Mulz(z2#, z1#):
   thm
val RDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Addz(z2#, z3#), z1#) = Addz(Mulz(z2#, z1#), Mulz(z3#, z1#)): thm
val le0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b' : mem(N)).
        le0(Pair(a#, b#), Pair(a'#, b'#)) <=> Le(Add(a#, b'#), Add(b#, a'#)):
   thm
val Lez_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) <=>
        !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
          Repz(z1#) = Zc(a#, b#) & Repz(z2#) = Zc(c#, d#) ==>
          Le(Add(a#, d#), Add(b#, c#)): thm
val LEz_def =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Holds(LEz, a#, b#) <=> Lez(a#, b#):
   thm
val LEz_Refl = {},  |- Refl(LEz): thm
val Repz_Zc =
   {}, 
   |- !(z : mem(Z)). ?(a' : mem(N))  (b : mem(N)). Repz(z#) = Zc(a'#, b#):
   thm
val LEz_Trans = {},  |- Trans(LEz): thm
val LEz_Asym = {},  |- Asym(LEz): thm
val Total_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Total(R#) <=>
        !(a : mem(A#))  (b : mem(A#)). Holds(R#, a#, b#) | Holds(R#, b#, a#):
   thm
val Lez_resp0 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N))  (e : mem(N))
      (f : mem(N))  (g : mem(N))  (h : mem(N)).
        Holds(ZR, Pair(a#, b#), Pair(c#, d#)) &
        Holds(ZR, Pair(e#, f#), Pair(g#, h#)) ==>
        (Le(Add(a#, f#), Add(b#, e#)) <=> Le(Add(c#, h#), Add(d#, g#))): thm
val LEz_Total = {},  |- Total(LEz): thm
val Lez_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Lez(Asz(a#, b#), Asz(c#, d#)) <=> Le(Add(a#, d#), Add(b#, c#)): thm
val Lez_Addz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) ==> !(z3 : mem(Z)). Lez(Addz(z1#, z3#), Addz(z2#, z3#)):
   thm
val Lez_Mulz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Lez(z1#, z2#) & Lez(Oz, z3#) ==> Lez(Mulz(z1#, z3#), Mulz(z2#, z3#)):
   thm
val EVEN_def =
   {}, 
   |- (!(a : mem(1)). App(EVEN, O) = true) &
      !(a : mem(N)). App(EVEN, Suc(a#)) = App(NOT, App(EVEN, a#)): thm
val Even_def = {(n : mem(N))},  |- Even(n) <=> App(EVEN, n) = true: thm
val O_Even = {},  |- Even(O): thm
val Suc_Even = {},  |- !(n : mem(N)). Even(Suc(n#)) <=> ~Even(n#): thm
val Even_not_Odd = {},  |- !(n : mem(N)). Even(n#) <=> ~Odd(n#): thm
val Odd_def = {(n : mem(N))},  |- Odd(n) <=> ~Even(n): thm
val Odd_not_Even = {},  |- !(n : mem(N)). Odd(n#) <=> ~Even(n#): thm
val id_ER = {},  |- !(A : set). ER(id(A#)): thm
val Sg_Inj = {},  |- !(A : set). Inj(Sg(A#)): thm
val Quo_id_Sg = {},  |- !(A : set). Quo(id(A#), Sg(A#)): thm
val Pow_conj_eq' =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (s1 : mem(Pow(A#)))  (B : set)
      (b0 : mem(B#))  (s2 : mem(Pow(B#))).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        !(s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#))).
          (!(a : mem(A#))  (b : mem(B#)).
              IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) <=>
          s1# = s3# & s2# = s4#: thm
val Repz_iff_Asz =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) <=> Asz(a#, b#) = z#: thm
val ipow2_prrel_ZR =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N)), (z1 : mem(Z)),
    (z2 : mem(Z))}, 
   |- App(ipow2(iZ, iZ), Pair(z1, z2)) =
        rsi(prrel(ZR, ZR), Pair(Pair(a, b), Pair(c, d))) <=>
      Asz(a, b) = z1 & Asz(c, d) = z2: thm
val Asz_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, b#) = Asz(a#, c#) <=> b# = c#: thm
val Ltz_def =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Lez(a#, b#) & ~a# = b#:
   thm
val N2Z_def = {},  |- !(a : mem(N)). App(N2Z, a#) = Asz(a#, O): thm
val n2z_def = {},  |- !(n : mem(N)). n2z(n#) = App(N2Z, n#): thm
val Asz_eq_eq_l =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, c#) = Asz(b#, c#) <=> a# = b#: thm
val N2Z_Inj = {},  |- Inj(N2Z): thm
val Repz_eq_eq_iff =
   {(x1 : mem(Z)), (x2 : mem(Z))},  |- Repz(x1) = Repz(x2) <=> x1 = x2: thm
val prove_dimp_th = fn: thm -> thm
val Abv_positive_ex0 =
   {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> ?(n : mem(N)). Asz(n#, O) = z#: thm
val Lez_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Lez(Negz(z#), Negz(b#)) <=> Lez(b#, z#):
   thm
val Negz_eq_eq =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Negz(z#) = Negz(b#) <=> z# = b#: thm
val Negz_Oz = {},  |- Negz(Oz) = Oz: thm
val Abv_negative_ex0 =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> ?(n : mem(N)). Asz(O, n#) = z#: thm
val Lez_dichotomy =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Lez(z#, b#) | Lez(b#, z#): thm
val Ltz_Asz =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N))}, 
   |- Ltz(Asz(a, b), Asz(c, d)) <=> Lt(Add(a, d), Add(b, c)): thm
val NOT_Lez_Ltz =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Lez(z#, b#) <=> Ltz(b#, z#): thm
val Abv_def =
   {}, 
   |- !(z : mem(Z)).
        Lez(Oz, z#) & Asz(Abv(z#), O) = z# |
        Ltz(z#, Oz) & Asz(O, Abv(z#)) = z#: thm
val Abv_nonneg = {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> Asz(Abv(z#), O) = z#:
   thm
val Abv_uex =
   {}, 
   |- !(z : mem(Z)).
        ?!(n : mem(N)).
          Lez(Oz, z#) & Asz(n#, O) = z# | Ltz(z#, Oz) & Asz(O, n#) = z#: thm
val n2z_Abv = {},  |- !(a : mem(Z)). Lez(Oz, a#) ==> n2z(Abv(a#)) = a#: thm
val Oz_Mulz = {},  |- !(z : mem(Z)). Mulz(Oz, z#) = Oz: thm
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val Oz_Ltz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, Oz) & Ltz(b#, Oz) ==> Ltz(Oz, Mulz(z#, b#)): thm
val int1_NONZERO = {},  |- ~int1 = Oz: thm
val int1_def = {},  |- int1 = n2z(Suc(O)): thm
val Negz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Negz(Mulz(z#, b#)):
   thm
val Ltz_Addz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, b#) <=> Ltz(Addz(z#, Negz(b#)), Oz): thm
val Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(z#, Negz(b#)) = Negz(Mulz(z#, b#)):
   thm
val Mulz_int1 = {},  |- !(z : mem(Z)). Mulz(z#, int1) = z#: thm
val Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) ==> Lez(z#, b#): thm
val n2z_Oz_Lez = {},  |- !(a : mem(N)). Lez(Oz, n2z(a#)): thm
val Negz_Addz_Oz = {},  |- !(z : mem(Z)). Addz(Negz(z#), z#) = Oz: thm
val Lez_Addz_ex =
   {}, 
   |- !(z : mem(Z))  (m : mem(Z)).
        Lez(z#, m#) ==> ?(p : mem(Z)). Lez(Oz, p#) & Addz(p#, z#) = m#: thm
val Lez_Addz_2 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Lez(z#, c#) & Lez(b#, d#) ==> Lez(Addz(z#, b#), Addz(c#, d#)): thm
val Oz_Lez_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(Oz, z#) & Lez(Oz, b#) ==>
        Lez(z#, Addz(z#, b#)) & Lez(b#, Addz(z#, b#)): thm
val Oz_Ltz_Addz =
   {}, 
   |- !(z : mem(Z)). Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(b#, Addz(z#, b#)):
   thm
val int1_Asz = {},  |- int1 = Asz(Suc(O), O): thm
val Ltz_int1_Lez_Oz = {},  |- !(z : mem(Z)). Ltz(int1, z#) ==> Lez(Oz, z#):
   thm
val Lez_Oz_Addz_Lez =
   {}, 
   |- !(z : mem(Z)). Lez(z#, Oz) ==> !(a : mem(Z)). Lez(Addz(a#, z#), a#):
   thm
val Lez_Ltz_TRANS_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(z#, c#): thm
val Ltz_trans =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(a#, c#): thm
val NOT_Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Ltz(z#, b#) <=> Lez(b#, z#): thm
val Addz_Rarr =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = c# <=> z# = Addz(c#, Negz(b#)): thm
val Addz_eq_eq =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = Addz(z#, c#) <=> b# = c#: thm
val Negz_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Negz(Addz(z#, b#)) = Addz(Negz(z#), Negz(b#)): thm
val Lez_cases =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) <=> Ltz(a#, b#) | a# = b#:
   thm
val Lez_refl = {},  |- !(a : mem(Z)). Lez(a#, a#): thm
val Lez_REFL = {},  |- !(z : mem(Z)). Lez(z#, z#): thm
val Oz_Lez_int1 = {},  |- Lez(Oz, int1): thm
val Oz_Ltz_int1 = {},  |- Ltz(Oz, int1): thm
val Ltz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(Negz(z#), Negz(b#)) <=> Ltz(b#, z#):
   thm
val NEQ_Ltz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). ~a# = b# <=> Ltz(a#, b#) | Ltz(b#, a#):
   thm
val Ltz_iff_Lez_int1 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) <=> Lez(Addz(z#, int1), b#):
   thm
val Negz_Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Mulz(z#, Negz(b#)):
   thm
val Oz_Addz = {},  |- !(z : mem(Z)). Addz(Oz, z#) = z#: thm
val Addz_eq_eq' =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(a#, c#) = Addz(b#, c#) <=> a# = b#: thm
val between_int1_Oz =
   {},  |- !(z : mem(Z)). Ltz(Negz(int1), z#) & Ltz(z#, int1) <=> z# = Oz:
   thm
val Addz_Negz_Oz_eq =
   {}, 
   |- !(z : mem(Z))  (z2 : mem(Z)). Addz(z#, Negz(z2#)) = Oz <=> z# = z2#:
   thm
val Negz_Negz = {},  |- !(z : mem(Z)). Negz(Negz(z#)) = z#: thm
val Ltz_iff_O_Ltz_Sub =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) <=> Ltz(Oz, Addz(b#, Negz(a#))): thm
val Ltz_Ltz_Mulz_Ltz =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, Mulz(z#, b#)) ==> Ltz(Oz, b#):
   thm
val Ltz_Ltz_Mulz_pos =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, b#) ==> Ltz(Oz, Mulz(z#, b#)):
   thm
val Mulz_Ltz_Ltz =
   {}, 
   |- !(a : mem(Z)).
        Ltz(Oz, a#) ==>
        !(b : mem(Z))  (c : mem(Z)).
          Ltz(Mulz(a#, b#), Mulz(a#, c#)) <=> Ltz(b#, c#): thm
val Ltz_Oz_Lez_int1 = {},  |- !(z : mem(Z)). Ltz(Oz, z#) <=> Lez(int1, z#):
   thm
val Addz_Rarr_both_sides =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Addz(z#, b#) = Addz(c#, d#) <=>
        Addz(d#, Negz(b#)) = Addz(z#, Negz(c#)): thm
val Lez_Ltz_Addz_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==>
        !(c : mem(Z))  (d : mem(Z)).
          Ltz(c#, d#) ==> Ltz(Addz(z#, c#), Addz(b#, d#)): thm
val Mulz_Negz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), Negz(b#)) = Mulz(z#, b#):
   thm
val Lez_asym =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) & Lez(b#, a#) ==> a# = b#:
   thm
val Ltz_NOT_Ltz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) ==> ~Ltz(b#, a#): thm
val Abv_Negz = {},  |- !(z : mem(Z)). Abv(Negz(z#)) = Abv(z#): thm
val Abv_Oz = {},  |- Abv(Oz) = O: thm
val n2z_Abv_Negz =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> n2z(Abv(z#)) = Negz(z#): thm
val n2z_is_Abv =
   {},  |- !(n : mem(N))  (z : mem(Z)). n2z(n#) = z# ==> n# = Abv(z#): thm
val Le_Abv_Abv =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Lez(Oz, a#) & Lez(Oz, b#) ==> (Le(Abv(a#), Abv(b#)) <=> Lez(a#, b#)):
   thm
val division_theorem_ex0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_ex1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val Lez_trans =
   {}, 
   |- !(a1 : mem(Z))  (a2 : mem(Z))  (a3 : mem(Z)).
        Lez(a1#, a2#) & Lez(a2#, a3#) ==> Lez(a1#, a3#): thm
val division_theorem_ex =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?(q : mem(Z))  (r : mem(Z)).
            a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_unique0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem_unique1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        ?!(qr : mem(Z * Z)).
          a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
          Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val DIVRz_def =
   {}, 
   |- !(a : mem(Z * Z)).
        Snd(a#) = Oz & App(DIVRz, a#) = Pair(Oz, Oz) |
        ~Snd(a#) = Oz &
        Fst(a#) =
          Addz(Mulz(Fst(App(DIVRz, a#)), Snd(a#)), Snd(App(DIVRz, a#))) &
        Lez(Oz, Snd(App(DIVRz, a#))) &
        Ltz(Snd(App(DIVRz, a#)), n2z(Abv(Snd(a#)))): thm
val Divrz_Oz =
   {}, 
   |- !(d : mem(Z)). d# = Oz ==> !(a : mem(Z)). Divrz(a#, d#) = Pair(Oz, Oz):
   thm
val Divrz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divrz(a, d) = App(DIVRz, Pair(a, d)):
   thm
val Divrz_property0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        d# = Oz & Divrz(a#, d#) = Pair(Oz, Oz) |
        ~d# = Oz &
        a# = Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) &
        Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divrz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) = a# &
          Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divz_Remz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Divz(a#, d#), d#), Remz(a#, d#)) = a# &
          Lez(Oz, Remz(a#, d#)) & Ltz(Remz(a#, d#), n2z(Abv(d#))): thm
val Divz_Remz_Oz =
   {},  |- !(a : mem(Z)). Divz(a#, Oz) = Oz & Remz(a#, Oz) = Oz: thm
val Divz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divz(a, d) = Fst(Divrz(a, d)): thm
val Remz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Remz(a, d) = Snd(Divrz(a, d)): thm
val Subz_Addz =
   {},  |- !(m : mem(Z))  (n : mem(Z)). Addz(Subz(m#, n#), n#) = m#: thm
val Subz_def =
   {(a : mem(Z)), (b : mem(Z))},  |- Subz(a, b) = Addz(a, Negz(b)): thm
val Mulz_Oz = {},  |- !(z : mem(Z)). Mulz(z#, Oz) = Oz: thm
val Oz_Ltz_Negz = {},  |- !(a : mem(Z)). Ltz(Oz, a#) <=> Ltz(Negz(a#), Oz):
   thm
val Ltz_Oz_Negz = {},  |- !(a : mem(Z)). Ltz(a#, Oz) <=> Ltz(Oz, Negz(a#)):
   thm
val Mulz_Ltz_Ltz_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(Mulz(a#, b#), Oz) <=>
        Ltz(Oz, a#) & Ltz(b#, Oz) | Ltz(Oz, b#) & Ltz(a#, Oz): thm
val Mulz_Oz_iff_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Mulz(a#, b#) = Oz <=> a# = Oz | b# = Oz:
   thm
val Divz_Remz_unique =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z))  (q : mem(Z))  (r : mem(Z)).
          Addz(Mulz(q#, d#), r#) = a# & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))) ==>
          q# = Divz(a#, d#) & r# = Remz(a#, d#): thm
val division_theorem' =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?!(qr : mem(Z * Z)).
            a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
            Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val Ltz_Subz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Ltz(Oz, Subz(b#, a#)):
   thm
val Subz_Ltz =
   {}, 
   |- !(a : mem(Z)). Ltz(Oz, a#) ==> !(b : mem(Z)). Ltz(Subz(b#, a#), b#):
   thm
val int1_Mulz = {},  |- !(z : mem(Z)). Mulz(int1, z#) = z#: thm
val Addz_Subz_Rarr =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(Addz(a#, b#), Subz(c#, b#)) = Addz(a#, c#): thm
val Divz_pos_Remz =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(Oz, a#) & Ltz(Oz, d#) ==> Ltz(Remz(a#, d#), d#): thm
val n2z_eq_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). n2z(a#) = n2z(b#) <=> a# = b#: thm
val n2z_Asz = {},  |- !(n : mem(N)). n2z(n#) = Asz(n#, O): thm
val n2z_Oz = {},  |- n2z(O) = Oz: thm
val Lez_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Lez(n2z(a#), n2z(b#)) <=> Le(a#, b#):
   thm
val Ltz_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Ltz(n2z(a#), n2z(b#)) <=> Lt(a#, b#):
   thm
val Oz_Lez_n2z = {},  |- !(n : mem(N)). Lez(Oz, n2z(n#)): thm
val Mulz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Mulz(n2z(a#), n2z(b#)) = n2z(Mul(a#, b#)):
   thm
val Addz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Addz(n2z(a#), n2z(b#)) = n2z(Add(a#, b#)):
   thm
val n2z_Oz_O = {},  |- !(n : mem(N)). n2z(n#) = Oz <=> n# = O: thm
val Le_num1_Lt_O = {},  |- !(a : mem(N)). Le(num1, a#) <=> Lt(O, a#): thm
val division_theorem_N_uex =
   {}, 
   |- !(d : mem(N)).
        Le(num1, d#) ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val qfun_compr = fn: term frag list -> term frag list -> thm
******

Loading SEAR file quo.sml

******
val resp1_def =
   {(A : set), (B : set), (R : rel(A, A)), (f : fun(A, B))}, 
   |- resp1(f, R) <=> resp(f, R, id(B)): thm
val resp1_property =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (R : rel(A#, A#)).
        resp1(f#, R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> App(f#, a1#) = App(f#, a2#): thm
val Inj_INV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          ?!(ivf : fun(B#, A#)).
            ivf# o f# = Id(A#) &
            !(b : mem(B#)).
              (!(a : mem(A#)). ~App(f#, a#) = b#) ==> App(ivf#, b#) = a0#:
   thm
val Abs_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- Abs(r, i, q0) = LINV(i, q0) o Rsi(r): thm
val Inj_LINV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(a : mem(A#)). LINV(f#, a#) o f# = Id(A#): thm
val LINV_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          LINV(f#, a0#) o f# = Id(A#) &
          !(b : mem(B#)).
            (!(a : mem(A#)). ~App(f#, a#) = b#) ==>
            App(LINV(f#, a0#), b#) = a0#: thm
val Quot_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Quot(r, i) <=>
      Inj(i) &
      !(s : mem(Pow(A))).
        (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#):
   thm
val abs_def =
   {(A : set), (Q : set), (a : mem(A)), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- abs(r, i, q0, a) = App(Abs(r, i, q0), a): thm
val eth = {(A : set), (B : set), (a0 : mem(A))},  |- ?(f : fun(B, A)). T: thm
val fname = "LINV": string
val fun_mem_ex =
   {},  |- !(A : set)  (a0 : mem(A#))  (B : set). ?(f : fun(B#, A#)). T: thm
val qvl =
   [[QUOTE " (*#loc 80 35*)f:A->B"], [QUOTE " (*#loc 80 48*)a0:mem(A)"]]:
   term frag list list
val uexth0 =
   {(A : set), (B : set), (a0 : mem(A)), (f : fun(A, B))}, Inj(f)
   |- ?!(ivf : fun(B, A)).
        ivf# o f = Id(A) &
        !(b : mem(B)).
          (!(a : mem(A)). ~App(f, a#) = b#) ==> App(ivf#, b#) = a0: thm
val Abs_Surj =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==> !(q0 : mem(Q#)). Surj(Abs(r#, i#, q0#)): thm
val Quot_ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            App(i#, q1#) = rsi(r#, a1#) & App(i#, q2#) = rsi(r#, a2#) ==>
            (Holds(r#, a1#, a2#) <=> q1# = q2#): thm
val Quot_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            abs(r#, i#, q0#, a1#) = abs(r#, i#, q0#, a2#) <=>
            Holds(r#, a1#, a2#): thm
val Quot_UMP =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        !(B : set)  (f : fun(A#, B#)).
          resp1(f#, R#) ==>
          !(Q : set)  (i : fun(Q#, Pow(A#))).
            Quot(R#, i#) ==>
            !(q0 : mem(Q#)).
              ?!(fb : fun(Q#, B#)).
                !(a : mem(A#)). App(fb#, abs(R#, i#, q0#, a#)) = App(f#, a#):
   thm
val Quot_Quo =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) <=> Inj(i#) & Quo(r#, i#): thm
val ER_Quot_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). IN(a#, App(i#, q#)): thm
val Quot_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        Quot(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val abs_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        !(q1 : mem(Q1#))  (q2 : mem(Q2#))  (a : mem(A#))  (b : mem(B#)).
          abs(prrel(r1#, r2#), ipow2(i1#, i2#), Pair(q1#, q2#), Pair(a#, b#)) =
            Pair(abs(r1#, i1#, q1#, a#), abs(r2#, i2#, q2#, b#)): thm
val Rep_of_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(q0 : mem(Q#))  (a : mem(A#)).
          App(i#, abs(r#, i#, q0#, a#)) = rsi(r#, a#): thm
val Quot_rsi_uex =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). App(i#, q#) = rsi(r#, a#): thm
val ER_Quot_rsi_char =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q : mem(Q#))  (a : mem(A#)).
            IN(a#, App(i#, q#)) <=> App(i#, q#) = rsi(r#, a#): thm
val Quot_IN_BIGUNION_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            ?(a : mem(Q#)). IN(a#, s#) & abs(r#, i#, q0#, ra#) = a#: thm
val Quot_IN_BIGUNION_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            IN(abs(r#, i#, q0#, ra#), s#): thm
val Quot_el_same =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#)).
            q1# = q2# <=>
            ?(a1 : mem(A#))  (a2 : mem(A#)).
              IN(a1#, App(i#, q1#)) &
              IN(a2#, App(i#, q2#)) & Holds(r#, a1#, a2#): thm
val ER_Quot_has_mem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val ER_Quot_has_umem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val it = (): unit
val NONZERO_O_Lt = {},  |- !(n : mem(N)). ~n# = O <=> Lt(O, n#): thm
val DIVR_def =
   {}, 
   |- !(a : mem(N * N)).
        Snd(a#) = O & App(DIVR, a#) = Pair(O, O) |
        ~Snd(a#) = O &
        Fst(a#) = Add(Mul(Fst(App(DIVR, a#)), Snd(a#)), Snd(App(DIVR, a#))) &
        Lt(Snd(App(DIVR, a#)), Snd(a#)): thm
val Divr_O =
   {},  |- !(d : mem(N)). d# = O ==> !(a : mem(N)). Divr(a#, d#) = Pair(O, O):
   thm
val Divr_def =
   {(a : mem(N)), (d : mem(N))},  |- Divr(a, d) = App(DIVR, Pair(a, d)): thm
val Divr_property0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        d# = O & Divr(a#, d#) = Pair(O, O) |
        ~d# = O &
        a# = Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) &
        Lt(Snd(Divr(a#, d#)), d#): thm
val Z2N_def = {},  |- Z2N = LINV(N2Z, O): thm
val Divr_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) = a# &
          Lt(Snd(Divr(a#, d#)), d#): thm
val Div2_def = {(n : mem(N))},  |- Div2(n) = Div(n, num2): thm
val Div_Rem_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Div(a#, d#), d#), Rem(a#, d#)) = a# & Lt(Rem(a#, d#), d#):
   thm
val Div_def = {(a : mem(N)), (d : mem(N))},  |- Div(a, d) = Fst(Divr(a, d)):
   thm
val Rem_def = {(a : mem(N)), (d : mem(N))},  |- Rem(a, d) = Snd(Divr(a, d)):
   thm
val num2_NONZERO = {},  |- ~num2 = O: thm
val Mul_num2 = {},  |- !(a : mem(N)). Mul(num2, a#) = Add(a#, a#): thm
val Div_Rem_num2 =
   {}, 
   |- !(a : mem(N)).
        Add(Mul(Div2(a#), num2), Rem(a#, num2)) = a# &
        Lt(Rem(a#, num2), num2): thm
val Div_Rem_unique =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N))  (q : mem(N))  (r : mem(N)).
          Add(Mul(q#, d#), r#) = a# & Lt(r#, d#) ==>
          q# = Div(a#, d#) & r# = Rem(a#, d#): thm
val division_theorem_N_uex' =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val Div_Rem_Mul =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)). Div(Mul(d#, a#), d#) = a# & Rem(Mul(d#, a#), d#) = O:
   thm
val Div2_Mul = {},  |- !(n : mem(N)). Div2(Mul(num2, n#)) = n#: thm
val num1_Lt_num2 = {},  |- Lt(num1, num2): thm
val Div2_Suc_Mul_num2 =
   {}, 
   |- !(n : mem(N)).
        Div2(Suc(Mul(num2, n#))) = n# & Rem(Suc(Mul(num2, n#)), num2) = num1:
   thm
val Even_Suc = {},  |- !(a : mem(N)). Even(Suc(a#)) <=> ~Even(a#): thm
val num2_Mul_Even = {},  |- !(a : mem(N)). Even(Mul(num2, a#)): thm
val Suc_num2_Mul_Odd = {},  |- !(a : mem(N)). Odd(Suc(Mul(num2, a#))): thm
val O_Even = {},  |- Even(O): thm
val O_NEQ_num1 = {},  |- ~O = num1: thm
val O_NEQ_num2 = {},  |- ~O = num2: thm
val O_NEQ_num3 = {},  |- ~O = num3: thm
val O_NEQ_num4 = {},  |- ~O = num4: thm
val num1_NEQ_num4 = {},  |- ~num1 = num4: thm
val num1_NEQ_num3 = {},  |- ~num1 = num3: thm
val num1_NEQ_num2 = {},  |- ~num1 = num2: thm
val num2_NEQ_num3 = {},  |- ~num2 = num3: thm
val num2_NEQ_num4 = {},  |- ~num2 = num4: thm
val num4_NEQ_num3 = {},  |- ~num4 = num3: thm
val Div_of_O = {},  |- !(n : mem(N)). Div(O, n#) = O & Rem(O, n#) = O: thm
val Even_Sub_num2 = {},  |- !(a : mem(N)). Even(a#) ==> Even(Sub(a#, num2)):
   thm
val Odd_num1 = {},  |- Odd(num1): thm
val Lt_num2 = {},  |- !(a : mem(N)). Lt(a#, num2) <=> a# = O | a# = num1: thm
val Even_Div2 =
   {}, 
   |- !(a : mem(N)).
        Even(a#) <=> Mul(Div2(a#), num2) = a# & Rem(a#, num2) = O: thm
val Odd_Div2 =
   {}, 
   |- !(a : mem(N)).
        Odd(a#) <=> Suc(Mul(Div2(a#), num2)) = a# & Rem(a#, num2) = num1: thm
val it = (): unit
******

Loading SEAR file SEARFiniteness.sml

******
val FI's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). IN(a#, FI's(X)) <=> SS(App(FIf(X), a#), a#):
   thm
val FI_cases0 = {(X : set)},  |- App(FIf(X), FIs(X)) = FIs(X): thm
val FI_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_incond =
   !(xs : mem(Pow(X))).
     IN(xs#, FIs1) <=>
     xs# = Empty(X) |
     ?(xs0 : mem(Pow(X)))  (x : mem(X)). IN(xs0#, FIs0) & xs# = Ins(x#, xs0#):
   form
val FI_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> SS(FIs(X), ss#):
   thm
val FI_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        (!(a : mem(Pow(X))).
            a# = Empty(X) |
            (?(xs0 : mem(Pow(X)))  (x : mem(X)).
                IN(xs0#, ss#) & a# = Ins(x#, xs0#)) ==> IN(a#, ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_rules0 = {(X : set)},  |- SS(App(FIf(X), FIs(X)), FIs(X)): thm
val FI_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        a# = Empty(X) |
        (?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#)) ==> IN(a#, FIs(X)): thm
val FI_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (a# = Empty(X) ==> IN(a#, FIs(X))) &
        !(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#) ==> IN(a#, FIs(X)): thm
val FI_rules3 =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val FIf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
        IN(xs#, App(FIf(X), a#)) <=>
        xs# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X)), Pow(Pow(X)))).
        !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
          IN(xs#, App(f#, a#)) <=>
          xs# = Empty(X) |
          ?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X))))  (s2 : mem(Pow(Pow(X)))).
        SS(s1#, s2#) ==> SS(App(FIf(X), s1#), App(FIf(X), s2#)): thm
val FIs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). SS(App(FIf(X), a#), a#) ==> SS(FIs(X), a#):
   thm
val FIs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (!(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, FIs(X)): thm
val FIs_def = {(X : set)},  |- FIs(X) = BIGINTER(FI's(X)): thm
val x1 = "FIs0": string
val FI_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_rules =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val Fin_def =
   {},  |- !(X : set)  (A : mem(Pow(X#))). Fin(A#) <=> IN(A#, FIs(X#)): thm
val Cd's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))).
        IN(a#, Cd's(X)) <=> SS(App(Cdf(X), a#), a#): thm
val Cd_cases0 = {(X : set)},  |- App(Cdf(X), Cds(X)) = Cds(X): thm
val Cd_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_incond =
   !(xsn : mem(Pow(X) * N)).
     IN(xsn#, Cds1) <=>
     xsn# = Pair(Empty(X), O) |
     ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
       IN(xsn0#, Cds0) &
       ~IN(x#, Fst(xsn0#)) &
       xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): form
val Cd_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        SS(App(Cdf(X), ss#), ss#) ==> SS(Cds(X), ss#): thm
val Cd_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        (!(a : mem(Pow(X) * N)).
            a# = Pair(Empty(X), O) |
            (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
                IN(xsn0#, ss#) &
                ~IN(x#, Fst(xsn0#)) &
                a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_rules0 = {(X : set)},  |- SS(App(Cdf(X), Cds(X)), Cds(X)): thm
val Cd_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        a# = Pair(Empty(X), O) |
        (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, Cds(X)) &
            ~IN(x#, Fst(xsn0#)) &
            a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
        IN(a#, Cds(X)): thm
val Cd_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (a# = Pair(Empty(X), O) ==> IN(a#, Cds(X))) &
        !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))) ==> IN(a#, Cds(X)):
   thm
val Cd_rules3 =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cdf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
        IN(xsn#, App(Cdf(X), a#)) <=>
        xsn# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, a#) &
          ~IN(x#, Fst(xsn0#)) &
          xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X) * N), Pow(Pow(X) * N))).
        !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
          IN(xsn#, App(f#, a#)) <=>
          xsn# = Pair(Empty(X), O) |
          ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, a#) &
            ~IN(x#, Fst(xsn0#)) &
            xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X) * N)))  (s2 : mem(Pow(Pow(X) * N))).
        SS(s1#, s2#) ==> SS(App(Cdf(X), s1#), App(Cdf(X), s2#)): thm
val Cds_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))). SS(App(Cdf(X), a#), a#) ==> SS(Cds(X), a#):
   thm
val Cds_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (!(ss : mem(Pow(Pow(X) * N))).
            SS(App(Cdf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, Cds(X)):
   thm
val Cds_def = {(X : set)},  |- Cds(X) = BIGINTER(Cd's(X)): thm
val x1 = "Cds0": string
val Cd_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_rules =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cds_ind =
   {}, 
   |- !(X : set)  (ss : mem(Pow(Pow(X#) * N))).
        IN(Pair(Empty(X#), O), ss#) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            IN(Pair(xs0#, n0#), ss#) & ~IN(x#, xs0#) ==>
            IN(Pair(Ins(x#, xs0#), Suc(n0#)), ss#)) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> IN(Pair(xs#, n#), ss#): thm
val Cd_induct0 =
   {}, 
   |- !(X : set).
        P(Pair(Empty(X#), O)) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(Pair(xs0#, n0#)) & ~IN(x#, xs0#) ==>
            P(Pair(Ins(x#, xs0#), Suc(n0#)))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(Pair(xs#, n#)): thm
val Cd_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(xs#, n#): thm
val Fin_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#)) &
        (!(xs0 : mem(Pow(X#)))  (x : mem(X#)). P(xs0#) ==> P(Ins(x#, xs0#))) ==>
        !(xs : mem(Pow(X#))). Fin(xs#) ==> P(xs#): thm
val Cdr_def =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) <=> IN(Pair(xs#, n#), Cds(X#)): thm
val Cdr_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)). Cdr(xs#, n#) ==> P(xs#, n#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs0#, n#) ==>
        !(x : mem(X#)). ~IN(x#, xs0#) ==> Cdr(Ins(x#, xs0#), Suc(n#)): thm
val Ins_NONEMPTY =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs : mem(Pow(X#))).
        ~Ins(x0#, xs#) = Empty(X#): thm
val IN_Ins_SND =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (x : mem(X#)).
        IN(x#, Ins(x0#, xs0#)) & ~x# = x0# ==> IN(x#, xs0#): thm
val Cdr_Empty_unique =
   {},  |- !(X : set)  (n : mem(N)). Cdr(Empty(X#), n#) ==> n# = O: thm
val Del_Ins_SWAP =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        ~x0# = x# ==>
        !(xs : mem(Pow(X#))). Del(Ins(x0#, xs#), x#) = Ins(x0#, Del(xs#, x#)):
   thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(Ins(x0#, xs0#), n#) <=>
        ?(a : mem(Pow(X#)))  (b : mem(N))  (x : mem(X#)).
          Cdr(a#, b#) &
          ~IN(x#, a#) & Ins(x0#, xs0#) = Ins(x#, a#) & n# = Suc(b#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) ==>
        Cdr(xs#, n#) &
        !(x : mem(X#)). IN(x#, xs#) ==> Cdr(Del(xs#, x#), Pre(n#)): thm
val Fin_Card =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> ?!(n : mem(N)). Cdr(xs#, n#): thm
val CARD_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        Holds(CARD(X#), a#, b#) <=> Fin(a#) & Cdr(a#, b#) | ~Fin(a#) & b# = O:
   thm
val CARD_unique =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        ?!(n : mem(N)). Holds(CARD(X#), xs#, n#): thm
val Cd0_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        App(Cd0(X#), a#) = b# <=> Holds(CARD(X#), a#, b#): thm
val Card_def =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Card(xs#) = App(Cd0(X#), xs#):
   thm
val Del_Empty =
   {},  |- !(X : set)  (x : mem(X#)). Del(Empty(X#), x#) = Empty(X#): thm
val Ins_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (s1 : mem(Pow(A#)))  (a2 : mem(A#))
      (s2 : mem(Pow(A#))).
        ~IN(a1#, s1#) &
        ~IN(a2#, s2#) &
        ~IN(a1#, s2#) & ~IN(a2#, s1#) & Ins(a1#, s1#) = Ins(a2#, s2#) ==>
        a1# = a2# & s1# = s2#: thm
val Fin_Empty = {},  |- !(X : set). Fin(Empty(X#)): thm
val Fin_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#))).
        Fin(xs0#) ==> !(x : mem(X#)). Fin(Ins(x#, xs0#)): thm
val Fin_Ins_Ins =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Fin(Ins(a1#, Ins(a2#, Empty(A#)))): thm
val Fin_Del0 =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> Fin(xs#) & !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Fin_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Card_Fin =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(n : mem(N)). Card(xs#) = n# <=> Cdr(xs#, n#): thm
val Card_Empty = {},  |- !(X : set). Card(Empty(X#)) = O: thm
val Cdr_Card =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Fin(xs#) ==> Cdr(xs#, Card(xs#)):
   thm
val Card_Ins =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). ~IN(x#, xs#) ==> Card(Ins(x#, xs#)) = Suc(Card(xs#)):
   thm
val Card_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). IN(x#, xs#) ==> Card(Del(xs#, x#)) = Pre(Card(xs#)):
   thm
val IN_App_IMAGE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        IN(a#, s#) ==>
        !(B : set)  (f : fun(A#, B#)). IN(App(f#, a#), IMAGE(f#, s#)): thm
val Fin_SS =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Fin(s#) ==> !(t : mem(Pow(A#))). SS(t#, s#) ==> Fin(t#): thm
val Fin_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(Union(s1#, s2#)) <=> Fin(s1#) & Fin(s2#): thm
val Ins_Ins_Fin =
   {(A : set), (s1 : mem(A)), (s2 : mem(A))}, 
   |- Fin(Ins(s1, Ins(s2, Empty(A)))): thm
val Fin_Sing = {},  |- !(A : set)  (a : mem(A#)). Fin(Sing(a#)): thm
val it = (): unit
******

Loading SEAR file SEARList.sml

******
val isL's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        IN(a#, isL's(X)) <=> SS(App(isLf(X), a#), a#): thm
val isL_cases0 = {(X : set)},  |- App(isLf(X), isLs(X)) = isLs(X): thm
val isL_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_incond =
   !(ls : mem(Pow(N * X))).
     IN(ls#, isLs1) <=>
     ls# = Empty(N * X) |
     ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
       IN(ls0#, isLs0) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): form
val isL_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), ss#), ss#) ==> SS(isLs(X), ss#): thm
val isL_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        (!(a : mem(Pow(N * X))).
            a# = Empty(N * X) |
            (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
                IN(ls0#, ss#) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_rules0 = {(X : set)},  |- SS(App(isLf(X), isLs(X)), isLs(X)): thm
val isL_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        a# = Empty(N * X) |
        (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
        IN(a#, isLs(X)): thm
val isL_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (a# = Empty(N * X) ==> IN(a#, isLs(X))) &
        !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#) ==>
          IN(a#, isLs(X)): thm
val isL_rules3 =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val isLf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
        IN(ls#, App(isLf(X), a#)) <=>
        ls# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(N * X)), Pow(Pow(N * X)))).
        !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
          IN(ls#, App(f#, a#)) <=>
          ls# = Empty(N * X) |
          ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(N * X))))  (s2 : mem(Pow(Pow(N * X)))).
        SS(s1#, s2#) ==> SS(App(isLf(X), s1#), App(isLf(X), s2#)): thm
val isLs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), a#), a#) ==> SS(isLs(X), a#): thm
val isLs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (!(ss : mem(Pow(Pow(N * X)))).
            SS(App(isLf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isLs(X)):
   thm
val isLs_def = {(X : set)},  |- isLs(X) = BIGINTER(isL's(X)): thm
val x1 = "isLs0": string
val isL_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_rules =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val List_def =
   {}, 
   |- !(X : set).
        Inj(iL(X#)) &
        !(a : mem(Pow(N * X#))).
          IN(a#, isLs(X#)) <=> ?(b : mem(List(X#))). a# = App(iL(X#), b#):
   thm
val iL_Inj = {},  |- !(X : set). Inj(iL(X#)): thm
val isL_def =
   {},  |- !(X : set)  (l : mem(Pow(N * X#))). isL(l#) <=> IN(l#, isLs(X#)):
   thm
val isL_induct =
   {}, 
   |- !(X : set).
        P(Empty(N * X#)) &
        (!(ls0 : mem(Pow(N * X#)))  (x : mem(X#)).
            P(ls0#) ==> P(Ins(Pair(Card(ls0#), x#), ls0#))) ==>
        !(l : mem(Pow(N * X#))). isL(l#) ==> P(l#): thm
val isL_Empty = {},  |- !(X : set). isL(Empty(N * X#)): thm
val isL_Ins =
   {}, 
   |- !(X : set)  (ls0 : mem(Pow(N * X#))).
        isL(ls0#) ==> !(x : mem(X#)). isL(Ins(Pair(Card(ls0#), x#), ls0#)):
   thm
val Repl_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Repl(l#) = App(iL(X#), l#): thm
val Nil_def = {},  |- !(X : set). Repl(Nil(X#)) = Empty(N * X#): thm
val cons0_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- cons0(x, l) = Ins(Pair(Card(l), x), l): thm
val cons1_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- App(cons1(X), Pair(x, l)) = Ins(Pair(Card(l), x), l): thm
val iL_isL = {},  |- !(X : set)  (l : mem(List(X#))). isL(App(iL(X#), l#)):
   thm
val isL_Repl =
   {}, 
   |- !(X : set)  (a : mem(Pow(N * X#))).
        isL(a#) <=> ?(b : mem(List(X#))). a# = Repl(b#): thm
val CONS_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Ins(Pair(Card(Repl(l#)), x#), Repl(l#)) =
          Repl(App(CONS(X#), Pair(x#, l#))): thm
val lift_cond2 =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val lift_cond2' =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?!(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val Cons_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Cons(x#, l#) = App(CONS(X#), Pair(x#, l#)): thm
val Repl_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Repl(Cons(x#, l#)) = Ins(Pair(Card(Repl(l#)), x#), Repl(l#)): thm
val Repl_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(List(X#)))  (l2 : mem(List(X#))).
        Repl(l1#) = Repl(l2#) <=> l1# = l2#: thm
val Cons_NONNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(List(X#))). ~Cons(x#, l#) = Nil(X#):
   thm
val Repl_Empty_uex =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        Repl(l#) = Empty(N * X#) <=> l# = Nil(X#): thm
val List_induct =
   {}, 
   |- !(X : set).
        P(Nil(X#)) &
        (!(l : mem(List(X#))). P(l#) ==> !(x : mem(X#)). P(Cons(x#, l#))) ==>
        !(l : mem(List(X#))). P(l#): thm
val Fin_Repl = {},  |- !(X : set)  (l : mem(List(X#))). Fin(Repl(l#)): thm
val isL_Card_NOTIN0 =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (n : mem(N))  (x : mem(X#)).
        IN(Pair(n#, x#), Repl(l#)) ==> Lt(n#, Card(Repl(l#))): thm
val CONS_Inj = {},  |- !(X : set). Inj(CONS(X#)): thm
val Cons_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (l1 : mem(List(X#)))  (x2 : mem(X#))
      (l2 : mem(List(X#))).
        Cons(x1#, l1#) = Cons(x2#, l2#) <=> x1# = x2# & l1# = l2#: thm
val Cons_or_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        l# = Nil(X#) |
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Cons_xor_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        ~l# = Nil(X#) <=>
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Lind's_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        IN(a#, Lind's(a0, f0)) <=> SS(App(Lindf(a0, f0), a#), a#): thm
val Lind_cases0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- App(Lindf(a0, f0), Linds(a0, f0)) = Linds(a0, f0): thm
val Lind_cases1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_incond =
   !(p : mem(List(X) * A)).
     IN(p#, Lind1) <=>
     p# = Pair(Nil(X), a0) |
     ?(p0 : mem(List(X) * A))  (x : mem(X)).
       IN(p0#, Lind0) &
       p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): form
val Lind_ind =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), ss#), ss#) ==> SS(Linds(a0, f0), ss#): thm
val Lind_ind1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        (!(a : mem(List(X) * A)).
            a# = Pair(Nil(X), a0) |
            (?(p0 : mem(List(X) * A))  (x : mem(X)).
                IN(p0#, ss#) &
                a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_rules0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- SS(App(Lindf(a0, f0), Linds(a0, f0)), Linds(a0, f0)): thm
val Lind_rules1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        a# = Pair(Nil(X), a0) |
        (?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, Linds(a0, f0)) &
            a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
        IN(a#, Linds(a0, f0)): thm
val Lind_rules2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (a# = Pair(Nil(X), a0) ==> IN(a#, Linds(a0, f0))) &
        !(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))) ==>
          IN(a#, Linds(a0, f0)): thm
val Lind_rules3 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lindf_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
        IN(p#, App(Lindf(a0, f0), a#)) <=>
        p# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, a#) &
          p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_ex =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- ?!(f : fun(Pow(List(X) * A), Pow(List(X) * A))).
        !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Nil(X), a0) |
          ?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, a#) &
            p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_monotone =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(s1 : mem(Pow(List(X) * A)))  (s2 : mem(Pow(List(X) * A))).
        SS(s1#, s2#) ==> SS(App(Lindf(a0, f0), s1#), App(Lindf(a0, f0), s2#)):
   thm
val Linds_SS =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), a#), a#) ==> SS(Linds(a0, f0), a#): thm
val Linds_cond =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (!(ss : mem(Pow(List(X) * A))).
            SS(App(Lindf(a0, f0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Linds(a0, f0)): thm
val Linds_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- Linds(a0, f0) = BIGINTER(Lind's(a0, f0)): thm
val x1 = "Lind0": string
val Lind_cases =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_rules =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lind_uex =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#))). ?!(a : mem(A#)). IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_def =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (a : mem(List(X#))).
        IN(Pair(a#, App(Lrec(a0#, f0#), a#)), Linds(a0#, f0#)): thm
val Lrec_Nil =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        App(Lrec(a0#, f0#), Nil(X#)) = a0#: thm
val App_Lrec_Linds =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (a : mem(A#)).
        App(Lrec(a0#, f0#), l#) = a# <=> IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_Cons =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (x : mem(X#)).
        App(Lrec(a0#, f0#), Cons(x#, l#)) =
          App(f0#, Pair(x#, App(Lrec(a0#, f0#), l#))): thm
val Lrec_unique =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f : fun(X# * A#, A#))
      (r : fun(List(X#), A#)).
        App(r#, Nil(X#)) = a0# & r# o CONS(X#) = f# o Prla(Id(X#), r#) ==>
        r# = Lrec(a0#, f#): thm
val Lrec_Cons_eqn =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        Lrec(a0#, f0#) o CONS(X#) = f0# o Prla(Id(X#), Lrec(a0#, f0#)): thm
val LENGTH_def = {},  |- !(X : set). LENGTH(X#) = Lrec(O, SUC o p2(X#, N)):
   thm
val Length_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Length(l#) = App(LENGTH(X#), l#):
   thm
val Length_Nil = {},  |- !(X : set). Length(Nil(X#)) = O: thm
val Length_Cons =
   {}, 
   |- !(A : set)  (a : mem(A#))  (l : mem(List(A#))).
        Length(Cons(a#, l#)) = Suc(Length(l#)): thm
val HD_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        App(HD(X#), Cons(x#, l#)) = SOME(x#): thm
val HD_Nil = {(X : set)},  |- App(HD(X), Nil(X)) = NONE(X): thm
val HD_def =
   {},  |- !(X : set). HD(X#) = Lrec(NONE(X#), i1(X#, 1) o p1(X#, X# + 1)):
   thm
val Hd_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Hd(Cons(x#, l#)) = SOME(x#): thm
val Hd_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Hd(l#) = App(HD(X#), l#): thm
val TL_Nil = {(X : set)},  |- App(TL(X), Nil(X)) = Nil(X): thm
val TL_def =
   {}, 
   |- !(X : set)  (a : mem(List(X#))).
        a# = Nil(X#) & App(TL(X#), a#) = Nil(X#) |
        ~a# = Nil(X#) & ?(x : mem(X#)). a# = Cons(x#, App(TL(X#), a#)): thm
val TL_ex =
   {(X : set)}, 
   |- !(l : mem(List(X))).
        ?!(tl : mem(List(X))).
          l# = Nil(X) & tl# = Nil(X) |
          ~l# = Nil(X) & ?(x : mem(X)). l# = Cons(x#, tl#): thm
val TL_Cons =
   {(X : set)}, 
   |- !(x : mem(X))  (tl : mem(List(X))). App(TL(X), Cons(x#, tl#)) = tl#:
   thm
val ELn_Nil = {(X : set)},  |- App(ELn(X), O) = Tpm(HD(X)): thm
val ELn_def =
   {(X : set)}, 
   |- ELn(X) = Nrec(Tpm(HD(X)), Ap1(MO(List(X), List(X), X + 1), Tpm(TL(X)))):
   thm
val Eln_Map =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(n : mem(N))  (l : mem(List(X))).
        Lt(n#, Length(l#)) ==> Eln(n#, Map(f, l#)) = App(OM(f), Eln(n#, l#)):
   thm
val Eln_O = {(X : set)},  |- !(a : mem(List(X))). Eln(O, a#) = Hd(a#): thm
val Eln_Suc =
   {(X : set)}, 
   |- !(n : mem(N))  (a : mem(List(X))). Eln(Suc(n#), a#) = Eln(n#, Tl(a#)):
   thm
val Eln_def =
   {(X : set), (l : mem(List(X))), (n : mem(N))}, 
   |- Eln(n, l) = App(tof(App(ELn(X), n)), l): thm
val MAP_Cons =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(l : mem(List(X)))  (x : mem(X)).
        App(MAP(f), Cons(x#, l#)) = Cons(App(f, x#), App(MAP(f), l#)): thm
val MAP_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        App(MAP(f#), Nil(X#)) = Nil(Y#): thm
val MAP_def =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        MAP(f#) = Lrec(Nil(Y#), CONS(Y#) o Prla(f#, Id(List(Y#)))): thm
val MO_def =
   {(A : set), (B : set), (C : set), (fm : mem(Exp(A, B))),
    (gm : mem(Exp(B, C)))},  |- App(MO(A, B, C), Pair(gm, fm)) = mo(gm, fm):
   thm
val Map_Cons =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#))  (l : mem(List(X#)))
      (x : mem(X#)). Map(f#, Cons(x#, l#)) = Cons(App(f#, x#), Map(f#, l#)):
   thm
val Map_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)). Map(f#, Nil(X#)) = Nil(Y#):
   thm
val Map_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (Y : set)  (f : fun(X#, Y#)).
        Map(f#, l#) = App(MAP(f#), l#): thm
val Tl_Cons =
   {}, 
   |- !(X : set)  (x : mem(X#))  (tl : mem(List(X#))).
        Tl(Cons(x#, tl#)) = tl#: thm
val Tl_Nil = {},  |- !(X : set). Tl(Nil(X#)) = Nil(X#): thm
val Tl_def = {(X : set), (l : mem(List(X)))},  |- Tl(l) = App(TL(X), l): thm
val mo_def =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (C : set)
      (g : mem(Exp(B#, C#))). mo(g#, f#) = Tpm(tof(g#) o tof(f#)): thm
val it = (): unit
******

Loading SEAR file SEARfm.sml

******
val InjA_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjA(A#), a#)) <=> a# = SOME(a#): thm
val InjN_def =
   {}, 
   |- !(A : set)  (a : mem(N))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjN(A#), a#)) <=> n# = a#: thm
val InjUU0_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * A)))  (b : mem(Pow(N * A)))  (n : mem(N))
      (a : mem(A)).
        IN(Pair(n#, a#), App(InjUU0(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val injUU0_char =
   {}, 
   |- (!(n : mem(N)).
          Even(n#) ==>
          !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
          (a : mem(A#)).
            IN(Pair(n#, a#), injUU0(u1#, u2#)) <=>
            IN(Pair(Div2(n#), a#), u1#)) &
      !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val injUU0_def =
   {(A : set), (u1 : mem(Pow(N * A))), (u2 : mem(Pow(N * A)))}, 
   |- injUU0(u1, u2) = App(InjUU0(A), Pair(u1, u2)): thm
val InjUU0_Inj = {},  |- !(A : set). Inj(InjUU0(A#)): thm
val injUU0_Even =
   {}, 
   |- !(n : mem(N)).
        Even(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u1#):
   thm
val injUU0_Odd =
   {}, 
   |- !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val F0_def = {(A : set)},  |- F0(A) = injN(A, O): thm
val InjA_Inj = {},  |- !(A : set). Inj(InjA(A#)): thm
val InjUU_Inj = {},  |- !(A : set). Inj(InjUU(A#)): thm
val InjUU_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * (A + 1))))  (b : mem(Pow(N * (A + 1))))
      (n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), App(InjUU(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val InjUU_def0 = {},  |- !(A : set). InjUU(A#) = InjUU0(A# + 1): thm
val injA_def = {(A : set), (a : mem(A))},  |- injA(a) = App(InjA(A), a): thm
val injN_def = {(A : set), (n : mem(N))},  |- injN(A, n) = App(InjN(A), n):
   thm
val VAR0_Inj = {},  |- !(A : set). Inj(VAR0(A#)): thm
val VAR0_def =
   {(A : set)}, 
   |- VAR0(A) = InjUU(A) o Pa(El(injN(A, num1)) o To1(A), InjA(A)): thm
val NEG0_Inj = {},  |- !(A : set). Inj(NEG0(A#)): thm
val NEG0_def =
   {(A : set)}, 
   |- NEG0(A) = InjUU(A) o
        Pa(El(injN(A, num2)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Var0_def = {(A : set), (a : mem(A))},  |- Var0(a) = App(VAR0(A), a): thm
val DISJ0_Inj = {},  |- !(A : set). Inj(DISJ0(A#)): thm
val DISJ0_def =
   {(A : set)}, 
   |- DISJ0(A) = InjUU(A) o
        Pa(El(injN(A, num3)) o To1(Pow((N * (A + 1))) * Pow(N * (A + 1))),
         InjUU(A)): thm
val Neg0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- Neg0(f0) = App(NEG0(A), f0):
   thm
val DIAM0_Inj = {},  |- !(A : set). Inj(DIAM0(A#)): thm
val DIAM0_def =
   {(A : set)}, 
   |- DIAM0(A) = InjUU(A) o
        Pa(El(injN(A, num4)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Disj0_def =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- Disj0(f1, f2) = App(DISJ0(A), Pair(f1, f2)): thm
val Diam0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- Diam0(f0) = App(DIAM0(A), f0): thm
val f =
   (nas = F0 ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_cl =
   (nas = F0(A) ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_incond =
   !(nas : mem(Pow(N * (A + 1)))).
     IN(nas#, isfms1) <=>
     nas# = F0(A) |
     (?(p : mem(A)). nas# = Var0(p#)) |
     (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Neg0(f0#)) |
     (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
         IN(f1#, isfms0) & IN(f2#, isfms0) & nas# = Disj0(f1#, f2#)) |
     ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Diam0(f0#): form
val x1 = "isfms0": string
val isfmf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(Pow(N * (A + 1))), Pow(Pow(N * (A + 1))))).
        !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
          IN(nas#, App(f#, a#)) <=>
          nas# = F0(A) |
          (?(p : mem(A)). nas# = Var0(p#)) |
          (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
          (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
              IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
          ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
        IN(nas#, App(isfmf(A), a#)) <=>
        nas# = F0(A) |
        (?(p : mem(A)). nas# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(Pow(N * (A + 1)))))  (s2 : mem(Pow(Pow(N * (A + 1))))).
        SS(s1#, s2#) ==> SS(App(isfmf(A), s1#), App(isfmf(A), s2#)): thm
val isfm's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        IN(a#, isfm's(A)) <=> SS(App(isfmf(A), a#), a#): thm
val isfms_def = {(A : set)},  |- isfms(A) = BIGINTER(isfm's(A)): thm
val isfms_cond =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (!(ss : mem(Pow(Pow(N * (A + 1))))).
            SS(App(isfmf(A), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isfms(A)):
   thm
val isfms_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), a#), a#) ==> SS(isfms(A), a#): thm
val isfm_rules0 = {(A : set)},  |- SS(App(isfmf(A), isfms(A)), isfms(A)): thm
val isfm_cases0 = {(A : set)},  |- App(isfmf(A), isfms(A)) = isfms(A): thm
val isfm_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), ss#), ss#) ==> SS(isfms(A), ss#): thm
val isfm_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (!(a : mem(Pow(N * (A + 1)))).
            a# = F0(A) |
            (?(p : mem(A)). a# = Var0(p#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Neg0(f0#)) |
            (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj0(f1#, f2#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Diam0(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases1 =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules1 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        a# = F0(A) |
        (?(p : mem(A)). a# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Diam0(f0#)) ==>
        IN(a#, isfms(A)): thm
val isfm_rules2 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (a# = F0(A) ==> IN(a#, isfms(A))) &
        (!(p : mem(A)). a# = Var0(p#) ==> IN(a#, isfms(A))) &
        (!(f0 : mem(Pow(N * (A + 1)))).
            IN(f0#, isfms(A)) & a# = Neg0(f0#) ==> IN(a#, isfms(A))) &
        (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#) ==>
            IN(a#, isfms(A))) &
        !(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) & a# = Diam0(f0#) ==> IN(a#, isfms(A)): thm
val isfm_rules3 =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_def =
   {}, 
   |- !(A : set)  (f : mem(Pow(N * (A# + 1)))).
        isfm(f#) <=> IN(f#, isfms(A#)): thm
val isfm_induct =
   {}, 
   |- !(A : set).
        P(F0(A#)) &
        (!(p : mem(A#)). P(Var0(p#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Neg0(f0#))) &
        (!(f1 : mem(Pow(N * (A# + 1))))  (f2 : mem(Pow(N * (A# + 1)))).
            P(f1#) & P(f2#) ==> P(Disj0(f1#, f2#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Diam0(f0#))) ==>
        !(f0 : mem(Pow(N * (A# + 1)))). isfm(f0#) ==> P(f0#): thm
val isfm_F0 = {},  |- !(A : set). isfm(F0(A#)): thm
val isfm_Diam0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val isfm_Neg0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#)): thm
val isfm_Var0 = {},  |- !(A : set)  (p : mem(A#)). isfm(Var0(p#)): thm
val isfm_clauses =
   {(A : set)}, 
   |- isfm(F0(A)) &
      (!(p : mem(A)). isfm(Var0(p#))) &
      (!(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#))) &
      !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val form_def =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). a# = App(repf(A), b#): thm
val isfm_Disj0 =
   {(A : set)}, 
   |- !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
        isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#)): thm
val repf_Inj = {(A : set)},  |- Inj(repf(A)): thm
val Bot_def = {(A : set)},  |- Repf(Bot(A)) = F0(A): thm
val Repf_def =
   {},  |- !(A : set)  (f : mem(form(A#))). Repf(f#) = App(repf(A#), f#): thm
val VAR_def =
   {(A : set)},  |- !(a : mem(A)). App(repf(A) o VAR(A), a#) = Var0(a#): thm
val flip_fconv = fn: form -> thm
val form_def' =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). App(repf(A), b#) = a#: thm
val repf_isfm = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Repf(f0#)): thm
val VAR_VAR0 = {},  |- !(A : set). repf(A#) o VAR(A#) = VAR0(A#): thm
val VAR_Inj = {},  |- !(A : set). Inj(VAR(A#)): thm
val NEG_NEG0 = {},  |- !(A : set). repf(A#) o NEG(A#) = NEG0(A#) o repf(A#):
   thm
val NEG_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(NEG(A), a#)) = Neg0(Repf(a#)): thm
val Neg0_Repf = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Neg0(Repf(f0#))):
   thm
val NEG_Inj = {},  |- !(A : set). Inj(NEG(A#)): thm
val DIAM_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(DIAM(A), a#)) = Diam0(Repf(a#)): thm
val Diam0_Repf =
   {(A : set)},  |- !(f0 : mem(form(A))). isfm(Diam0(Repf(f0#))): thm
val form_def_uex =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (?!(b : mem(form(A))). a# = Repf(b#)) <=> isfm(a#): thm
val DISJ_DISJ0 =
   {}, 
   |- !(A : set). repf(A#) o DISJ(A#) = DISJ0(A#) o Prla(repf(A#), repf(A#)):
   thm
val DISJ_def =
   {(A : set)}, 
   |- !(a' : mem(form(A)))  (b : mem(form(A))).
        Repf(App(DISJ(A), Pair(a'#, b#))) = Disj0(Repf(a'#), Repf(b#)): thm
val DISJ_Inj = {},  |- !(A : set). Inj(DISJ(A#)): thm
val DIAM_DIAM0 =
   {},  |- !(A : set). repf(A#) o DIAM(A#) = DIAM0(A#) o repf(A#): thm
val DIAM_Inj = {},  |- !(A : set). Inj(DIAM(A#)): thm
val Diam_def =
   {(A : set), (f : mem(form(A)))},  |- Diam(f) = App(DIAM(A), f): thm
val Disj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Disj(f1, f2) = App(DISJ(A), Pair(f1, f2)): thm
val Neg_def = {(A : set), (f : mem(form(A)))},  |- Neg(f) = App(NEG(A), f):
   thm
val Var_def = {(A : set), (a : mem(A))},  |- Var(a) = App(VAR(A), a): thm
val Var_eq_eq =
   {(A : set)}, 
   |- !(p1 : mem(A))  (p2 : mem(A)). Var(p1#) = Var(p2#) <=> p1# = p2#: thm
val Neg_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Neg(f1#) = Neg(f2#) <=> f1# = f2#: thm
val Diam_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Diam(f1#) = Diam(f2#) <=> f1# = f2#: thm
val Disj_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A)))  (g1 : mem(form(A)))
      (g2 : mem(form(A))).
        Disj(f1#, f2#) = Disj(g1#, g2#) <=> f1# = g1# & f2# = g2#: thm
val Repf_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Repf(f1#) = Repf(f2#) <=> f1# = f2#: thm
val form_induct =
   {}, 
   |- !(A : set).
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Neg(f0#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Diam(f0#))) ==>
        !(f0 : mem(form(A#))). P(f0#): thm
val fmind's_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        IN(a#, fmind's(djf, dmf, nf, vf, x0)) <=>
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#): thm
val fmind_cases0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)) =
        fminds(djf, dmf, nf, vf, x0): thm
val fmind_cases1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_incond =
   !(p : mem(form(A) * X)).
     IN(p#, fmind1) <=>
     p# = Pair(Bot(A), x0) |
     (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
     ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
       IN(p1#, fmind0) &
       IN(p2#, fmind0) &
       p# =
         Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))):
   form
val fmind_ind =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), ss#): thm
val fmind_ind1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (!(a : mem(form(A) * X)).
            a# = Pair(Bot(A), x0) |
            (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
            (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
                IN(p1#, ss#) &
                IN(p2#, ss#) &
                a# =
                  Pair(Disj(Fst(p1#), Fst(p2#)),
                   App(djf, Pair(Snd(p1#), Snd(p2#))))) ==> IN(a#, ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_rules0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- SS(App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)),
       fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        a# = Pair(Bot(A), x0) |
        (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
            IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
            a# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#))))) ==>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (a# = Pair(Bot(A), x0) ==> IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(a' : mem(A)).
            a# = Pair(Var(a'#), App(vf, a'#)) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          a# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))) ==>
          IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules3 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val fmindf_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
        IN(p#, App(fmindf(djf, dmf, nf, vf, x0), a#)) <=>
        p# = Pair(Bot(A), x0) |
        (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, a#) &
          IN(p2#, a#) &
          p# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_ex =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(form(A) * X), Pow(form(A) * X))).
        !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Bot(A), x0) |
          (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
          ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, a#) &
            IN(p2#, a#) &
            p# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_monotone =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(form(A) * X)))  (s2 : mem(Pow(form(A) * X))).
        SS(s1#, s2#) ==>
        SS(App(fmindf(djf, dmf, nf, vf, x0), s1#),
         App(fmindf(djf, dmf, nf, vf, x0), s2#)): thm
val fminds_SS =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), a#): thm
val fminds_cond =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (!(ss : mem(Pow(form(A) * X))).
            SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fminds_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- fminds(djf, dmf, nf, vf, x0) = BIGINTER(fmind's(djf, dmf, nf, vf, x0)):
   thm
val x1 = "fmind0": string
val fmind_cases =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_rules =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val IN_F0 =
   {(A : set)}, 
   |- !(n : mem(N))  (a : mem(A + 1)). IN(Pair(n#, a#), F0(A)) <=> n# = O:
   thm
val IN_Var0 =
   {(A : set), (a0 : mem(A))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Var0(a0)) <=>
        Even(n#) & Div2(n#) = num1 | Odd(n#) & a# = SOME(a0): thm
val IN_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Neg0(f0)) <=>
        Even(n#) & Div2(n#) = num2 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Diam0(f0)) <=>
        Even(n#) & Div2(n#) = num4 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Disj0(f1, f2)) <=>
        Even(n#) & Div2(n#) = num3 |
        Odd(n#) &
        (Even(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f1) |
          Odd(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f2)): thm
val F0_NOT_Var0 = {(A : set), (p : mem(A))},  |- ~F0(A) = Var0(p): thm
val Bot_NOT_Var = {(A : set), (p : mem(A))},  |- ~Bot(A) = Var(p): thm
val F0_NOT_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- ~F0(A) = Disj0(f1, f2): thm
val Bot_NOT_Disj =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Bot(A) = Disj(f1, f2): thm
val F0_NOT_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Neg0(f0): thm
val Bot_NOT_Neg = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Neg(f): thm
val F0_NOT_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Diam0(f0): thm
val Bot_NOT_Diam = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Diam(f):
   thm
val Bot_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Bot(A#) = Var(p#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Neg(f#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Diam(f#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Bot(A#) = Disj(f1#, f2#): thm
val InjN_Inj = {},  |- !(A : set). Inj(InjN(A#)): thm
val Var0_NOT_Diam0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Diam0(f0): thm
val VAR_def' =
   {(A : set)},  |- !(a : mem(A)). Repf(App(VAR(A), a#)) = Var0(a#): thm
val Var_NOT_Diam =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Diam(f): thm
val Var0_NOT_Disj0 =
   {(A : set), (a : mem(A)), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Var0(a) = Disj0(f1, f2): thm
val Var_NOT_Disj =
   {(A : set), (a : mem(A)), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Var(a) = Disj(f1, f2): thm
val Var0_NOT_Neg0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Neg0(f0): thm
val Var_NOT_Neg =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Neg(f): thm
val Var_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Var(p#) = Bot(A#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Neg(f#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Diam(f#)) &
        !(p : mem(A#))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Var(p#) = Disj(f1#, f2#): thm
val Neg0_NOT_Diam0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Neg0(f) = Diam0(f0): thm
val Neg_NOT_Diam =
   {(A : set), (f : mem(form(A))), (f0 : mem(form(A)))}, 
   |- ~Neg(f) = Diam(f0): thm
val Neg0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Neg0(f) = Disj0(f1, f2): thm
val Neg_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Neg(f) = Disj(f1, f2): thm
val Neg_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Neg(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Neg(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Neg(f#) = Diam(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Neg(f#) = Disj(f1#, f2#): thm
val Diam0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Diam0(f) = Disj0(f1, f2): thm
val Diam_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Diam(f) = Disj(f1, f2): thm
val Diam_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Diam(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Diam(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Diam(f#) = Neg(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Diam(f#) = Disj(f1#, f2#): thm
val Disj_NOT =
   {}, 
   |- !(A : set).
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            ~Disj(f1#, f2#) = Bot(A#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (p : mem(A#)).
            ~Disj(f1#, f2#) = Var(p#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f0 : mem(form(A#))).
            ~Disj(f1#, f2#) = Diam(f0#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f : mem(form(A#))).
          ~Disj(f1#, f2#) = Neg(f#): thm
val fmind_Neg =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Neg(f), App(nf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_Disj =
   {}, 
   |- !(A : set)  (f1 : mem(form(A#)))  (X : set)  (djf : fun(X# * X#, X#))
      (dmf : fun(X#, X#))  (nf : fun(X#, X#))  (vf : fun(A#, X#))
      (x0 : mem(X#))  (x1 : mem(X#)).
        IN(Pair(f1#, x1#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
        !(f2 : mem(form(A#)))  (x2 : mem(X#)).
          IN(Pair(f2#, x2#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
          IN(Pair(Disj(f1#, f2#), App(djf#, Pair(x1#, x2#))),
           fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmind_Diam =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Diam(f), App(dmf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_uex =
   {(X : set)}, 
   |- !(A : set)  (x0 : mem(X))  (vf : fun(A#, X))  (nf : fun(X, X))
      (djf : fun(X * X, X))  (dmf : fun(X, X))  (f : mem(form(A#))).
        ?!(x : mem(X)). IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)):
   thm
val fmrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (a : mem(form(A#))).
        IN(Pair(a#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), a#)),
       fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val App_fmrec_fminds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (f : mem(form(A#)))  (x : mem(X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#) = x# <=>
        IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmrec_clauses =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), Bot(A#)) = x0# &
        (!(p : mem(A#)).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Var(p#)) = App(vf#, p#)) &
        (!(f : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Neg(f#)) =
              App(nf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Disj(f1#, f2#)) =
              App(djf#,
               Pair(App(fmrec(x0#, vf#, nf#, djf#, dmf#), f1#),
                App(fmrec(x0#, vf#, nf#, djf#, dmf#), f2#)))) &
        !(f : mem(form(A#))).
          App(fmrec(x0#, vf#, nf#, djf#, dmf#), Diam(f#)) =
            App(dmf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#)): thm
val it = (): unit
******

Loading SEAR file SEARUF.sml

******
val Inter_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val Inter_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val filter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- filter(L) <=>
      ~EMPTY(J) &
      IN(Whole(J), L) &
      (!(X : mem(Pow(J)))  (Y : mem(Pow(J))).
          IN(X#, L) & IN(Y#, L) ==> IN(Inter(X#, Y#), L)) &
      !(X : mem(Pow(J))).
        IN(X#, L) ==> !(Y : mem(Pow(J))). SS(X#, Y#) ==> IN(Y#, L): thm
val ufilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). ~IN(Compl(X#), L) <=> IN(X#, L): thm
val ufilter_filter =
   {},  |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> filter(L#):
   thm
val SS_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val SS_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val Whole_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). filter(L#) ==> IN(Whole(J#), L#):
   thm
val Whole_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> IN(Whole(J#), L#):
   thm
val Empty_NOTIN_UF =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> ~IN(Empty(J#), L#):
   thm
val IN_UF_NONEMPTY =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==> !(X : mem(Pow(J#))). IN(X#, L#) ==> ~X# = Empty(J#):
   thm
val Repu_def = {(J : set), (u : mem(UFs(J)))},  |- Repu(u) = App(iUF(J), u):
   thm
val Repu_ufilter = {},  |- !(A : set)  (u : mem(UFs(A#))). ufilter(Repu(u#)):
   thm
val UFs_def =
   {(J : set)}, 
   |- Inj(iUF(J)) &
      !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = App(iUF(J), b#): thm
val from_UFs =
   {(J : set)}, 
   |- !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = Repu(b#): thm
val Empty_NOTIN_UFs =
   {},  |- !(J : set)  (u : mem(UFs(J#))). ~IN(Empty(J#), Repu(u#)): thm
val ufilter_alt =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). IN(Compl(X#), L) <=> ~IN(X#, L): thm
val Compl_Repu =
   {(J : set), (X : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Compl(X), Repu(u)) <=> ~IN(X, Repu(u)): thm
val Union_Repu =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Union(s1, s2), Repu(u)) <=> IN(s1, Repu(u)) | IN(s2, Repu(u)): thm
val CUI_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- CUI(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        IN(BIGINTER(ss0#), ss): thm
val CUI_iff_binary =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#)))).
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) <=>
        !(s : mem(Pow(Pow(W#)))).
          SS(s#, A#) & Fin(s#) & ~s# = Empty(Pow(W#)) ==>
          IN(BIGINTER(s#), A#): thm
val FIP_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- FIP(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        ~BIGINTER(ss0#) = Empty(A): thm
val FIP_CUI_lemma =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        ~IN(Empty(W#), A#) & ~IN(Empty(W#), B#): thm
val FIP_closed_under_Inter =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) &
        (!(b1 : mem(Pow(W#))).
            IN(b1#, B#) ==>
            !(b2 : mem(Pow(W#))). IN(b2#, B#) ==> IN(Inter(b1#, b2#), B#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        FIP(Union(A#, B#)): thm
val IN_gfilter =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(x : mem(Pow(A))).
        IN(x#, gfilter(s)) <=>
        !(ss : mem(Pow(Pow(A)))). SS(s, ss#) & filter(ss#) ==> IN(x#, ss#):
   thm
val gfilter_def =
   {(A : set), (s : mem(Pow(Pow(A))))},  |- gfilter(s) = BIGINTER(gfss(s)):
   thm
val gfilter_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter(s#)): thm
val gfilter_ind =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(A#)))).
        SS(s#, ss#) & filter(ss#) ==>
        !(x : mem(Pow(A#))). IN(x#, gfilter(s#)) ==> IN(x#, ss#): thm
val gfss_def =
   {(A : set), (s0 : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(Pow(A)))). IN(a#, gfss(s0)) <=> SS(s0, a#) & filter(a#):
   thm
val SS_gfilter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter(s#)): thm
val pfilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- pfilter(L) <=> filter(L) & ~L = Whole(Pow(J)): thm
val gfilter1_def =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, gfilter1(s)) <=>
        a# = Whole(A) |
        ?(ss : mem(Pow(Pow(A)))).
          SS(ss#, s) &
          Fin(ss#) & ~ss# = Empty(Pow(A)) & SS(BIGINTER(ss#), a#): thm
val gfilter1_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter1(s#)): thm
val SS_gfilter1 =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter1(s#)): thm
val CUI_filter =
   {},  |- !(A : set)  (L : mem(Pow(Pow(A#)))). filter(L#) ==> CUI(L#): thm
val gfilter_gfilter1 =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) ==> gfilter(s#) = gfilter1(s#): thm
val Empty_NOTIN_pfilter =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) <=> filter(s#) & ~IN(Empty(A#), s#): thm
val FIP_Empty_NOTIN_gfilter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))). FIP(s#) ==> ~IN(Empty(A#), gfilter(s#)):
   thm
val FIP_PSUBSET_proper_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))).
          FIP(s#) ==> ?(v : mem(Pow(Pow(A#)))). pfilter(v#) & SS(s#, v#): thm
val filter_Whole = {},  |- !(J : set). ~EMPTY(J#) ==> filter(Whole(Pow(J#))):
   thm
val filter_Empty_Whole =
   {}, 
   |- !(J : set).
        ~EMPTY(J#) ==>
        !(L : mem(Pow(Pow(J#)))).
          filter(L#) & IN(Empty(J#), L#) <=> L# = Whole(Pow(J#)): thm
val ufilter_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        ufilter(u#) ==>
        !(s : mem(Pow(Pow(J#)))).
          filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#)): thm
val CUI_Empty_NOTIN_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        CUI(s#) & ~IN(Empty(W#), s#) ==> FIP(s#): thm
val pfilter_FIP =
   {},  |- !(W : set)  (s : mem(Pow(Pow(W#)))). pfilter(s#) ==> FIP(s#): thm
val pfilter_filter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). pfilter(s#) ==> filter(s#):
   thm
val pfilter_INSERT_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        pfilter(s#) ==>
        !(b : mem(Pow(W#))).
          ~IN(b#, s#) & ~IN(Compl(b#), s#) ==> FIP(Ins(b#, s#)): thm
val maximal_ufilter =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        (!(s : mem(Pow(Pow(J#)))).
            filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) ==> ufilter(u#):
   thm
val chain_def =
   {(A : set), (R : rel(A, A)), (t : mem(Pow(A)))}, 
   |- chain(t, R) <=>
      !(a1 : mem(A))  (a2 : mem(A)).
        IN(a1#, t) & IN(a2#, t) ==> Holds(R, a1#, a2#) | Holds(R, a2#, a1#):
   thm
val ismax_def =
   {(A : set), (R : rel(A, A)), (m : mem(A))}, 
   |- ismax(R, m) <=> !(x : mem(A)). Holds(R, m, x#) ==> x# = m: thm
val ptorder_def =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> Trans(R) & Refl(R) & Asym(R): thm
val ubound_def =
   {(A : set), (R : rel(A, A)), (s : mem(Pow(A))), (x : mem(A))}, 
   |- ubound(s, R, x) <=> !(y : mem(A)). IN(y#, s) ==> Holds(R, y#, x): thm
******

Loading SEAR file zorns.sml

******
val AC =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). Holds(R#, a#, App(f#, a#)): thm
val antisym_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        antisym(r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, x#), r#) ==> x# = y#: thm
val chain0_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        chain0(s#, r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==>
          IN(Pair(x#, y#), r#) | IN(Pair(y#, x#), r#): thm
val domain_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, domain(r#)) <=> ?(y : mem(A#)). IN(Pair(a#, y#), r#): thm
val ischoice_def =
   {(A : set), (f : fun(Pow(A), A)), (s : mem(Pow(Pow(A))))}, 
   |- ischoice(f, s) <=>
      ~IN(Empty(A), s) &
      !(s0 : mem(Pow(A))). IN(s0#, s) ==> IN(App(f, s0#), s0#): thm
val ischoice_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) & ~IN(Empty(A#), s#) ==>
        ?(f : fun(Pow(A#), A#)). ischoice(f#, s#): thm
val maximal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, maximal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(a#, x'#), r#) ==> a# = x'#:
   thm
val minimal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, minimal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(x'#, a#), r#) ==> a# = x'#:
   thm
val partial_order_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        partial_order(r#, s#) <=>
        SS(domain(r#), s#) &
        SS(range(r#), s#) & transitive(r#) & reflexive(r#, s#) & antisym(r#):
   thm
val range_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, range(r#)) <=> ?(x : mem(A#)). IN(Pair(x#, a#), r#): thm
val reflexive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        reflexive(r#, s#) <=>
        !(x : mem(A#)). IN(x#, s#) ==> IN(Pair(x#, x#), r#): thm
val transitive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        transitive(r#) <=>
        !(x : mem(A#))  (y : mem(A#))  (z : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, z#), r#) ==>
          IN(Pair(x#, z#), r#): thm
val upper_bounds_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, upper_bounds(s#, r#)) <=>
        IN(a#, range(r#)) &
        !(y : mem(A#)). IN(y#, s#) ==> IN(Pair(y#, a#), r#): thm
val fchains_def =
   {(A : set), (f : fun(Pow(A), A)), (r : mem(Pow(A * A)))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, fchains(r, f)) <=>
        chain0(a#, r) &
        ~a# = Empty(A) &
        !(C : mem(Pow(A))).
          chain0(C#, r) &
          SS(C#, a#) & ~Inter(Diff(upper_bounds(C#, r), C#), a#) = Empty(A) ==>
          IN(App(f, Diff(upper_bounds(C#, r), C#)),
           minimal_elements(Inter(Diff(upper_bounds(C#, r), C#), a#), r)):
   thm
val hatclass_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(Pow(A#))).
        IN(a#, hatclass(r#)) <=>
        ~a# = Empty(A#) &
        ?(C : mem(Pow(A#))). a# = Diff(upper_bounds(C#, r#), C#): thm
val lemma1 =
   {(A : set)}, 
   |- !(x : mem(A))  (s : mem(Pow(A)))  (r : mem(Pow(A * A))).
        chain0(s#, r#) & IN(x#, s#) ==>
        IN(x#, domain(r#)) & IN(x#, range(r#)): thm
val lemma2 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A)))  (x : mem(A))  (x' : mem(A)).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        IN(k1#, fchains(r#, f#)) &
        IN(k2#, fchains(r#, f#)) & IN(x#, k1#) & IN(x'#, k2#) & ~IN(x'#, k1#) ==>
        IN(Pair(x#, x'#), r#): thm
val lemma3 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) & IN(k1#, fchains(r#, f#)) & IN(k2#, fchains(r#, f#)) ==>
        SS(k1#, k2#) | SS(k2#, k1#): thm
val lemma4 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A)).
        ischoice(f#, hatclass(r#)) & antisym(r#) & transitive(r#) ==>
        chain0(BIGUNION(fchains(r#, f#)), r#) &
        !(x : mem(A))  (x' : mem(A))  (k : mem(Pow(A))).
          IN(Pair(x'#, x#), r#) &
          IN(x'#, BIGUNION(fchains(r#, f#))) &
          IN(x#, BIGUNION(fchains(r#, f#))) &
          IN(k#, fchains(r#, f#)) & IN(x#, k#) ==> IN(x'#, k#): thm
val lemma5 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) & ~range(r#) = Empty(A) & reflexive(r#, s#) ==>
        IN(Sing(App(f#, range(r#))), fchains(r#, f#)): thm
val lemma6 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (k : mem(Pow(A)))
      (x : mem(A))  (C : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) &
        IN(k#, fchains(r#, f#)) &
        IN(x#, k#) &
        chain0(C#, r#) &
        IN(x#, Diff(upper_bounds(C#, r#), C#)) &
        SS(C#, BIGUNION(fchains(r#, f#))) ==>
        IN(App(f#, Diff(upper_bounds(C#, r#), C#)), k#) &
        IN(Pair(App(f#, Diff(upper_bounds(C#, r#), C#)), x#), r#): thm
val lemma7 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        IN(BIGUNION(fchains(r#, f#)), fchains(r#, f#)): thm
val lemma8 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A)))
      (k : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        reflexive(r#, s#) &
        antisym(r#) &
        transitive(r#) &
        IN(k#, fchains(r#, f#)) & ~Diff(upper_bounds(k#, r#), k#) = Empty(A) ==>
        IN(Ins(App(f#, Diff(upper_bounds(k#, r#), k#)), k#), fchains(r#, f#)):
   thm
val upper_bounds_lem =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A)))  (x1 : mem(A))
      (x2 : mem(A)).
        transitive(r#) &
        IN(x1#, upper_bounds(s#, r#)) & IN(Pair(x1#, x2#), r#) ==>
        IN(x2#, upper_bounds(s#, r#)): thm
val lemma9 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        SS(upper_bounds(BIGUNION(fchains(r#, f#)), r#),
         maximal_elements(s#, r#)): thm
val zorns_lemma0 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A))).
        ~s# = Empty(A) &
        partial_order(r#, s#) &
        (!(t : mem(Pow(A))).
            chain0(t#, r#) ==> ~upper_bounds(t#, r#) = Empty(A)) ==>
        ?(x : mem(A)). IN(x#, maximal_elements(s#, r#)): thm
val Trans_transitive =
   {},  |- !(A : set)  (R : rel(A#, A#)). Trans(R#) <=> transitive(r2m(R#)):
   thm
val Refl_reflexive =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> reflexive(r2m(R#), Whole(A#)): thm
val Asym_antisym =
   {},  |- !(A : set)  (R : rel(A#, A#)). Asym(R#) <=> antisym(r2m(R#)): thm
val ptorder_partial_order =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> partial_order(r2m(R), Whole(A)): thm
val zorns_lemma =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ~EMPTY(A#) & ptorder(R#) ==>
        (!(c : mem(Pow(A#))).
            chain(c#, R#) & ~c# = Empty(A#) ==>
            ?(ub : mem(A#)). ubound(c#, R#, ub#)) ==>
        ?(m : mem(A#)). ismax(R#, m#): thm
val it = (): unit
val ufilter_iff_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        ((!(s : mem(Pow(Pow(J#)))).
              filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) <=>
          ufilter(u#)): thm
val UNION_chain_filter_filter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> filter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          filter(BIGUNION(ss#)): thm
val UNION_chain_pfilter_pfilter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> pfilter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          pfilter(BIGUNION(ss#)): thm
val ufilter_thm =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) ==> ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(s#, u#):
   thm
val ufilter_thm_coro =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==>
        ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(ss#, u#): thm
val Prop_5_3 =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==> ?(u : mem(UFs(A#))). SS(ss#, Repu(u#)): thm
val FIP_Sing =
   {},  |- !(W : set)  (a : mem(Pow(W#))). ~a# = Empty(W#) ==> FIP(Sing(a#)):
   thm
val it = (): unit
******

Loading SEAR file SEARmmmt.sml

******
val Rm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w1 : mem(W)), (w2 : mem(W))}, 
   |- Rm(M, w1, w2) <=> IN(Pair(w1, w2), Rof(M)): thm
val Rof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Rof(M#) = Fst(M#): thm
val Vof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Vof(M#) = tof(Snd(M#)): thm
val HAT_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(A))  (w : mem(W)).
        IN(w#, App(HAT(M), a#)) <=> IN(a#, App(Vof(M), w#)): thm
val satis_def0 =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A))), (w : mem(W))}, 
   |- satis(M, w, f) <=> IN(w, App(satisf(M), f)): thm
val satis_dmf =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(Pow(W)))  (w : mem(W)).
        IN(w#, App(sdmf(M), a#)) <=>
        ?(w0 : mem(W)). IN(w0#, a#) & Rm(M, w#, w0#): thm
val satisf_clause =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- App(satisf(M), Bot(A)) = Empty(W) &
      (!(p : mem(A)). App(satisf(M), Var(p#)) = App(HAT(M), p#)) &
      (!(f : mem(form(A))).
          App(satisf(M), Neg(f#)) = App(COMPL(W), App(satisf(M), f#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          App(satisf(M), Disj(f1#, f2#)) =
            App(UNION(W), Pair(App(satisf(M), f1#), App(satisf(M), f2#)))) &
      !(f : mem(form(A))).
        App(satisf(M), Diam(f#)) = App(sdmf(M), App(satisf(M), f#)): thm
val satisf_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- satisf(M) = fmrec(Empty(W), HAT(M), COMPL(W), UNION(W), sdmf(M)): thm
val satis_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))}, 
   |- ~satis(M, w, Bot(A)) &
      (!(a : mem(A)). satis(M, w, Var(a#)) <=> IN(a#, App(Vof(M), w))) &
      (!(f : mem(form(A))). satis(M, w, Neg(f#)) <=> ~satis(M, w, f#)) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          satis(M, w, Disj(f1#, f2#)) <=> satis(M, w, f1#) | satis(M, w, f2#)) &
      !(f : mem(form(A))).
        satis(M, w, Diam(f#)) <=>
        ?(v : mem(W)). Rm(M, w, v#) & satis(M, v#, f#): thm
val SATIS_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (fs : mem(Pow(form(A)))), (w : mem(W))}, 
   |- SATIS(M, w, fs) <=> !(f : mem(form(A))). IN(f#, fs) ==> satis(M, w, f#):
   thm
val Top_def = {(A : set)},  |- Top(A) = Neg(Bot(A)): thm
val Conj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Conj(f1, f2) = Neg(Disj(Neg(f1), Neg(f2))): thm
val satis_Conj =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f1 : mem(form(A)))  (f2 : mem(form(A))).
        satis(M#, w#, Conj(f1#, f2#)) <=>
        satis(M#, w#, f1#) & satis(M#, w#, f2#): thm
val PE's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). IN(a#, PE's(A)) <=> SS(App(PEf(A), a#), a#):
   thm
val PE_cases0 = {(A : set)},  |- App(PEf(A), PEs(A)) = PEs(A): thm
val PE_cases1 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_incond =
   !(f : mem(form(A))).
     IN(f#, PEs1) <=>
     f# = Top(A) |
     f# = Bot(A) |
     (?(p : mem(A)). f# = Var(p#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Conj(f1#, f2#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Disj(f1#, f2#)) |
     ?(f0 : mem(form(A))). IN(f0#, PEs0) & f# = Diam(f0#): form
val PE_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        (!(a : mem(form(A))).
            a# = Top(A) |
            a# = Bot(A) |
            (?(p : mem(A)). a# = Var(p#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Conj(f1#, f2#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj(f1#, f2#)) |
            (?(f0 : mem(form(A))). IN(f0#, ss#) & a# = Diam(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_rules0 = {(A : set)},  |- SS(App(PEf(A), PEs(A)), PEs(A)): thm
val PE_rules1 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        a# = Top(A) |
        a# = Bot(A) |
        (?(p : mem(A)). a# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#)) |
        (?(f0 : mem(form(A))). IN(f0#, PEs(A)) & a# = Diam(f0#)) ==>
        IN(a#, PEs(A)): thm
val PE_rules2 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (a# = Top(A) ==> IN(a#, PEs(A))) &
        (a# = Bot(A) ==> IN(a#, PEs(A))) &
        (!(p : mem(A)). a# = Var(p#) ==> IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        !(f0 : mem(form(A))).
          IN(f0#, PEs(A)) & a# = Diam(f0#) ==> IN(a#, PEs(A)): thm
val PE_rules3 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PEf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A))))  (f : mem(form(A))).
        IN(f#, App(PEf(A), a#)) <=>
        f# = Top(A) |
        f# = Bot(A) |
        (?(p : mem(A)). f# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(form(A)), Pow(form(A)))).
        !(a : mem(Pow(form(A))))  (f : mem(form(A))).
          IN(f#, App(f#, a#)) <=>
          f# = Top(A) |
          f# = Bot(A) |
          (?(p : mem(A)). f# = Var(p#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
          ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==> SS(App(PEf(A), s1#), App(PEf(A), s2#)): thm
val PEs_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). SS(App(PEf(A), a#), a#) ==> SS(PEs(A), a#):
   thm
val PEs_cond =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (!(ss : mem(Pow(form(A)))). SS(App(PEf(A), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, PEs(A)): thm
val PEs_def = {(A : set)},  |- PEs(A) = BIGINTER(PE's(A)): thm
val x1 = "PEs0": string
val PE_cases0 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_rules0 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PE_def0 = {(A : set), (f : mem(form(A)))},  |- PE(f) <=> IN(f, PEs(A)):
   thm
val PE_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). PE(a#) ==> IN(a#, ss#): thm
val PE_cases =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        PE(x#) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). PE(f0#) & x# = Diam(f0#): thm
val PE_rules =
   {(A : set)}, 
   |- PE(Top(A)) &
      PE(Bot(A)) &
      (!(p : mem(A)). PE(Var(p#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#))) &
      !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val PE_induct =
   {}, 
   |- !(A : set).
        P(Top(A#)) &
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Conj(f1#, f2#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f : mem(form(A#))). P(f#) ==> P(Diam(f#))) ==>
        !(f : mem(form(A#))). PE(f#) ==> P(f#): thm
val satis_Bot =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
      (w : mem(W#)). ~satis(M#, w#, Bot(A#)): thm
val satis_Top =
   {(W : set)}, 
   |- !(A : set)  (M : mem(Pow((W * W)) * Exp(W, Pow(A#))))  (w : mem(W)).
        satis(M#, w#, Top(A#)): thm
val PUS_Var = {},  |- !(A : set)  (p : mem(A#)). PUS(Var(p#)): thm
val PUS_def =
   {(A : set), (f : mem(form(A)))}, 
   |- PUS(f) <=>
      !(W1 : set)  (W2 : set)  (R : rel(W1#, W2#))
      (M1 : mem(Pow((W1# * W1#)) * Exp(W1#, Pow(A))))
      (M2 : mem(Pow((W2# * W2#)) * Exp(W2#, Pow(A)))).
        Sim(R#, M1#, M2#) ==>
        !(w1 : mem(W1#))  (w2 : mem(W2#)).
          Holds(R#, w1#, w2#) ==> satis(M1#, w1#, f) ==> satis(M2#, w2#, f):
   thm
val Sim_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (R : rel(W1, W2)),
    (W1 : set), (W2 : set)}, 
   |- Sim(R, M1, M2) <=>
      !(w1 : mem(W1))  (w2 : mem(W2)).
        Holds(R, w1#, w2#) ==>
        (!(p : mem(A)).
            IN(p#, App(Vof(M1), w1#)) ==> IN(p#, App(Vof(M2), w2#))) &
        !(v : mem(W1)).
          Rm(M1, w1#, v#) ==>
          ?(v' : mem(W2)). Holds(R, v#, v'#) & Rm(M2, w2#, v'#): thm
val PUS_Top = {},  |- !(A : set). PUS(Top(A#)): thm
val PUS_Bot = {},  |- !(A : set). PUS(Bot(A#)): thm
val Thm_6_25_r2l0 =
   {},  |- !(A : set)  (f : mem(form(A#))). PE(f#) ==> PUS(f#): thm
val EQV_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- EQV(f1, f2) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, f1) <=> satis(M#, w#, f2): thm
val Thm_6_25_r2l =
   {}, 
   |- !(A : set)  (f : mem(form(A#)))  (f0 : mem(form(A#))).
        PE(f0#) & EQV(f#, f0#) ==> PUS(f#): thm
val Fsab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Fsab(fs, X, M) <=>
      !(ss : mem(Pow(form(A)))). Fin(ss#) & SS(ss#, fs) ==> Sab(ss#, X, M):
   thm
val Msat_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- Msat(M) <=>
      !(w : mem(W))  (fs : mem(Pow(form(A)))).
        Fsab(fs#, Sucm(M, w#), M) ==> Sab(fs#, Sucm(M, w#), M): thm
val Sab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Sab(fs, X, M) <=> ?(x : mem(W)). IN(x#, X) & SATIS(M, x#, fs): thm
val Sucm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))},  |- !(a : mem(W)). IN(a#, Sucm(M, w)) <=> Rm(M, w, a#):
   thm
val Tat_def =
   {(A : set), (W : set), (a : mem(A)), (f0 : fun(W, Pow(A)))}, 
   |- !(a' : mem(W)). IN(a'#, Tat(f0, a)) <=> IN(a, App(f0, a'#)): thm
val fun_mem_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(f : fun(A#, B#)). P(f#)) <=> ?(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val mem_fun_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(m : mem(Exp(A#, B#))). P(m#)) <=> ?(f : fun(A#, B#)). P(Tpm(f#)):
   thm
val fun_mem_uex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?!(f : fun(A#, B#)). P(f#)) <=> ?!(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val UE_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- UE(M) = Pair(ueR(M), ueV(M)): thm
val csee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, csee(M, X)) <=> ?(v : mem(W)). Rm(M, a#, v#) & IN(v#, X): thm
val osee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, osee(M, X)) <=> !(v : mem(W)). Rm(M, a#, v#) ==> IN(v#, X):
   thm
val ueR_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a' : mem(UFs(W)))  (b : mem(UFs(W))).
        IN(Pair(a'#, b#), ueR(M)) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(b#)) ==> IN(csee(M, X#), Repu(a'#)):
   thm
val ueV_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(u : mem(UFs(W)))  (a : mem(A)).
        IN(a#, App(tof(ueV(M)), u#)) <=> IN(Tat(Vof(M), a#), Repu(u#)): thm
val ufilter_Compl =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))). ~IN(Compl(X#), L#) <=> IN(X#, L#): thm
val exists_forall_dual =
   {},  |- !(A : set). (?(a : mem(A#)). P(a#)) <=> ~!(a : mem(A#)). ~P(a#):
   thm
val Prop_5_4_1 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        csee(M#, X#) = Compl(osee(M#, Compl(X#))): thm
val Prop_5_4_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        osee(M#, X#) = Compl(csee(M#, Compl(X#))): thm
val Prop_5_6 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val MEQ_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (W1 : set), (W2 : set),
    (w1 : mem(W1)), (w2 : mem(W2))}, 
   |- MEQ(M1, w1, M2, w2) <=>
      !(f : mem(form(A))). satis(M1, w1, f#) <=> satis(M2, w2, f#): thm
val pufilter_def =
   {(A : set), (a : mem(A))}, 
   |- !(a' : mem(Pow(A))). IN(a'#, pufilter(a)) <=> IN(a, a'#): thm
val pufilter_filter =
   {},  |- !(A : set)  (a : mem(A#)). filter(pufilter(a#)): thm
val ueR_alt =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val pufilter_ufilter =
   {},  |- !(A : set)  (a : mem(A#)). ufilter(pufilter(a#)): thm
val Repu_eq_eq =
   {}, 
   |- !(W : set)  (u1 : mem(UFs(W#)))  (u2 : mem(UFs(W#))).
        Repu(u1#) = Repu(u2#) ==> u1# = u2#: thm
val Pft_def =
   {(W : set), (w0 : mem(W))}, 
   |- !(ws : mem(Pow(W))). IN(ws#, Repu(Pft(w0))) <=> IN(w0, ws#): thm
val Prop_5_5_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W)))
      (Y : mem(Pow(W))).
        osee(M#, Inter(X#, Y#)) = Inter(osee(M#, X#), osee(M#, Y#)): thm
val SW_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(form(A)))  (w : mem(W)).
        IN(w#, App(SW(M), a#)) <=> satis(M, w#, a#): thm
val Sw_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A)))},  |- Sw(M, f) = App(SW(M), f): thm
val Sw_Bot =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Sw(M#, Bot(A)) = Empty(W):
   thm
val Sw_Var =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        Sw(M#, Var(p#)) = App(HAT(M#), p#): thm
val Vof_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Vof(UE(M#)) = tof(ueV(M#)):
   thm
val HAT_Tat =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        App(HAT(M#), p#) = Tat(Vof(M#), p#): thm
val Sw_Neg =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        Sw(M#, Neg(f#)) = Compl(Sw(M#, f#)): thm
val Sw_Disj =
   {(A : set), (W : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        Sw(M#, Disj(f1, f2)) = Union(Sw(M#, f1), Sw(M#, f2)): thm
val Rm_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (u' : mem(UFs(W))).
        Rm(UE(M#), u#, u'#) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(u'#)) ==> IN(csee(M#, X#), Repu(u#)):
   thm
val csee_Sw_DIAM =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        csee(M#, Sw(M#, f#)) = Sw(M#, Diam(f#)): thm
val Prop_5_8 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
      (phi : mem(form(A)))  (u : mem(UFs(W#))).
        IN(Sw(M#, phi#), Repu(u#)) <=> satis(UE(M#), u#, phi#): thm
val Prop_5_7 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        MEQ(M#, w#, UE(M#), Pft(w#)): thm
val SATIS_Sing =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f : mem(form(A))). SATIS(M#, w#, Sing(f#)) <=> satis(M#, w#, f#): thm
val Fin_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(s1#) | Fin(s2#) ==> Fin(Inter(s1#, s2#)): thm
val SATIS_Union =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SATIS(M#, w#, Union(s1#, s2#)) <=>
        SATIS(M#, w#, s1#) & SATIS(M#, w#, s2#): thm
val only_see_whole_world =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        osee(M#, Whole(W)) = Whole(W): thm
val SATIS_Empty =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        SATIS(M#, w#, Empty(form(A))): thm
val BIGCONJ_EXISTS =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        ?(ff : mem(form(A))).
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val SS_Union_of =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s1#, s#) & SS(s2#, s#) ==> SS(Union(s1#, s2#), s#): thm
val Prop_5_9 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Msat(UE(M#)): thm
val PE_BIGCONJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val PE_Conj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#)): thm
val PE_BIGDISJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)).
            satis(M#, w#, ff#) <=>
            ?(f : mem(form(A))). IN(f#, s#) & satis(M#, w#, f#): thm
val PE_Disj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#)): thm
val PE_Diam =
   {(A : set)},  |- !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val Thm_6_22 =
   {(A : set), (W1 : set), (W2 : set)}, 
   |- !(M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A))))
      (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))).
        Msat(M1#) & Msat(M2#) ==>
        !(w1 : mem(W1))  (w2 : mem(W2)).
          (!(f : mem(form(A))).
              PE(f#) ==> satis(M1#, w1#, f#) ==> satis(M2#, w2#, f#)) ==>
          ?(R : rel(W1, W2)). Sim(R#, M1#, M2#) & Holds(R#, w1#, w2#): thm
val ENT_def =
   {(A : set), (phis : mem(Pow(form(A)))), (psi : mem(form(A)))}, 
   |- ENT(phis, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        SATIS(M#, w#, phis) ==> satis(M#, w#, psi): thm
val MCOMPACT_def =
   {}, 
   |- MCOMPACT <=>
      !(A : set)  (fs : mem(Pow(form(A#)))).
        (!(ffs : mem(Pow(form(A#)))).
            SS(ffs#, fs#) & Fin(ffs#) ==>
            ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
            (w : mem(W#)). SATIS(M#, w#, ffs#)) ==>
        ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
        (w : mem(W#)). SATIS(M#, w#, fs#): thm
val satis_Neg =
   {(A : set), (W : set), (f : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        satis(M#, w#, Neg(f)) <=> ~satis(M#, w#, f): thm
val Ent_def =
   {(A : set), (phi : mem(form(A))), (psi : mem(form(A)))}, 
   |- Ent(phi, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, phi) ==> satis(M#, w#, psi): thm
val SATIS_SS =
   {(A : set), (W : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==>
        !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
          SATIS(M#, w#, s2#) ==> SATIS(M#, w#, s1#): thm
val Thm_6_24 =
   {(A : set)}, 
   |- MCOMPACT ==>
      !(fs : mem(Pow(form(A))))  (phi : mem(form(A))).
        ENT(fs#, phi#) ==>
        ?(ffs : mem(Pow(form(A)))).
          SS(ffs#, fs#) & Fin(ffs#) & ENT(ffs#, phi#): thm
val Fin_ENT_PE =
   {(A : set)}, 
   |- !(fs : mem(Pow(form(A)))).
        Fin(fs#) & (!(f : mem(form(A))). IN(f#, fs#) ==> PE(f#)) ==>
        ?(phi : mem(form(A))).
          PE(phi#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). SATIS(M#, w#, fs#) <=> satis(M#, w#, phi#): thm
val PEC_def =
   {(A : set), (f : mem(form(A)))}, 
   |- !(a : mem(form(A))). IN(a#, PEC(f)) <=> PE(a#) & Ent(f, a#): thm
val SATIS_PEC =
   {(A : set), (W : set)}, 
   |- !(f : mem(form(A)))  (M : mem(Pow((W * W)) * Exp(W, Pow(A))))
      (w : mem(W)). satis(M#, w#, f#) ==> SATIS(M#, w#, PEC(f#)): thm
val Del_Fin =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        Fin(Del(s#, a#)) ==> Fin(s#): thm
val Fin_Inj0 =
   {}, 
   |- !(B : set)  (s : mem(Pow(B#))).
        Fin(s#) ==>
        !(A : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
          s# = IMAGE(f#, ss#) ==> Inj(f#) ==> Fin(ss#): thm
val Fin_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(ss : mem(Pow(A#))). Fin(IMAGE(f#, ss#)) ==> Fin(ss#):
   thm
val Thm_6_25_iff =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) <=> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val Thm_6_25_l2r =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) ==> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val it = (): unit
******

Loading SEAR file SEARllist.sml

******
val IN_gfp =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (a : mem(A)).
        IN(a#, gfp(f#)) <=>
        ?(sa : mem(Pow(A))). SS(sa#, App(f#, sa#)) & IN(a#, sa#): thm
val gfp_def =
   {}, 
   |- !(A : set)  (f : fun(Pow(A#), Pow(A#))). gfp(f#) = BIGUNION(prims(f#)):
   thm
val prims_def =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- !(a : mem(Pow(A))). IN(a#, prims(f)) <=> SS(a#, App(f, a#)): thm
val weak_coind =
   {}, 
   |- !(A : set)  (sa : mem(Pow(A#)))  (a : mem(A#))
      (f : fun(Pow(A#), Pow(A#))).
        IN(a#, sa#) & SS(sa#, App(f#, sa#)) ==> IN(a#, gfp(f#)): thm
val SS_gfp_fgfp =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(gfp(f), App(f, gfp(f))): thm
val monotone_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(Pow(A#), Pow(B#))).
        monotone(f#) <=>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          SS(s1#, s2#) ==> SS(App(f#, s1#), App(f#, s2#)): thm
val rules0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(App(f, gfp(f)), gfp(f)): thm
val cases0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> gfp(f) = App(f, gfp(f)): thm
val coind0 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (sa : mem(Pow(A))).
        SS(sa#, App(f#, sa#)) ==> SS(sa#, gfp(f#)): thm
val lcons0_def =
   {}, 
   |- !(X : set)  (f0 : fun(N, X# + 1))  (x : mem(X#)).
        App(lcons0(x#, f0#), O) = SOME(x#) &
        !(n : mem(N)). App(lcons0(x#, f0#), Suc(n#)) = App(f0#, n#): thm
val llf_uex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Exp(N, X + 1)), Pow(Exp(N, X + 1)))).
        !(gs : mem(Pow(Exp(N, X + 1))))  (g : mem(Exp(N, X + 1))).
          IN(g#, App(f#, gs#)) <=>
          g# = Tpm(Null(X)) |
          ?(h : mem(X))  (t : fun(N, X + 1)).
            g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_def =
   {}, 
   |- !(X : set)  (gs : mem(Pow(Exp(N, X# + 1))))  (g : mem(Exp(N, X# + 1))).
        IN(g#, App(llf(X#), gs#)) <=>
        g# = Tpm(Null(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_monotone = {},  |- !(X : set). monotone(llf(X#)): thm
val islls_def = {(X : set)},  |- islls(X) = gfp(llf(X)): thm
val llist_def1 =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          IN(a#, islls(X#)) <=>
          ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_Inj = {},  |- !(X : set). Inj(repll(X#)): thm
val isll_def =
   {}, 
   |- !(X : set)  (l : mem(Exp(N, X# + 1))). isll(l#) <=> IN(l#, islls(X#)):
   thm
val ll_cases = {},  |- !(X : set). islls(X#) = App(llf(X#), islls(X#)): thm
val ll_coind =
   {}, 
   |- !(X : set)  (sa : mem(Pow(Exp(N, X# + 1)))).
        (!(a : mem(Exp(N, X# + 1))).
            IN(a#, sa#) ==>
            a# = Tpm(Null(X#)) |
            ?(h : mem(X#))  (t : fun(N, X# + 1)).
              a# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), sa#)) ==>
        !(a : mem(Exp(N, X# + 1))). IN(a#, sa#) ==> IN(a#, islls(X#)): thm
val ll_rules =
   {}, 
   |- !(X : set).
        IN(Tpm(Null(X#)), islls(X#)) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          IN(Tpm(t#), islls(X#)) ==> IN(Tpm(lcons0(h#, t#)), islls(X#)): thm
val isll_lnil = {},  |- !(X : set). isll(Tpm(Null(X#))): thm
val isll_shift =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val Repll_def =
   {},  |- !(X : set)  (l : mem(llist(X#))). Repll(l#) = App(repll(X#), l#):
   thm
val LNil_def = {},  |- !(X : set). Repll(LNil(X#)) = Tpm(Null(X#)): thm
val llist_def =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          isll(a#) <=> ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_isll =
   {},  |- !(X : set)  (ll : mem(llist(X#))). isll(App(repll(X#), ll#)): thm
val isll_Repll =
   {}, 
   |- !(X : set)  (a : mem(Exp(N, X# + 1))).
        isll(a#) <=> ?(b : mem(llist(X#))). a# = Repll(b#): thm
val Repll_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(llist(X#)))  (l2 : mem(llist(X#))).
        Repll(l1#) = Repll(l2#) <=> l1# = l2#: thm
val Repll_isll = {},  |- !(X : set)  (ll : mem(llist(X#))). isll(Repll(ll#)):
   thm
val isll_lcons0 =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val isll_rules =
   {}, 
   |- !(X : set).
        isll(Tpm(Null(X#))) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          isll(Tpm(t#)) ==> isll(Tpm(lcons0(h#, t#))): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LCons_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#)))  (x : mem(X#)).
        Repll(LCons(x#, ll#)) = Tpm(lcons0(x#, tof(Repll(ll#)))): thm
val Repll_lnil_uex =
   {}, 
   |- !(X : set)  (l : mem(llist(X#))).
        Repll(l#) = Tpm(Null(X#)) <=> l# = LNil(X#): thm
val FPB_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- App(FPB(f), NONE(B * A)) = NONE(B * A) &
      !(b : mem(B))  (a : mem(A)).
        App(FPB(f), SOME(Pair(b#, a#))) = App(f, b#): thm
val FP_def =
   {(X : set), (f : fun(X, X))}, 
   |- !(x : mem(X)).
        App(FP(f), Pair(O, x#)) = x# &
        !(n : mem(N)).
          App(FP(f), Pair(Suc(n#), x#)) = App(FP(f), Pair(n#, App(f, x#))):
   thm
val OB_def =
   {(A : set), (B : set)}, 
   |- !(f : fun(A, B + 1)).
        App(OB(A, B), Pair(NONE(A), Tpm(f#))) = NONE(B) &
        !(a : mem(A)). App(OB(A, B), Pair(SOME(a#), Tpm(f#))) = App(f#, a#):
   thm
val lnil_def = {(X : set)},  |- lnil(X) = Tpm(Null(X)): thm
val toabs_char0 =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)).
        (App(f#, z#) = NONE(B * A) ==> toabs(f#, z#) = Null(A)) &
        !(b : mem(B))  (a : mem(A)).
          App(f#, z#) = SOME(Pair(b#, a#)) ==>
          toabs(f#, z#) = lcons0(a#, toabs(f#, b#)): thm
val toabs_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1)), (z : mem(B))}, 
   |- !(n : mem(N)).
        App(toabs(f, z), n#) =
          App(OM(p2(B, A)), App(FP(FPB(f)), Pair(n#, App(f, z)))): thm
val toabs_isll =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)). isll(Tpm(toabs(f#, z#))): thm
val toabs_unique =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (g : fun(B, Exp(N, A + 1))).
        (!(z : mem(B)).
            (App(f#, z#) = NONE(B * A) ==> App(g#, z#) = Tpm(Null(A))) &
            !(b : mem(B))  (a : mem(A)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(g#, z#) = Tpm(lcons0(a#, tof(App(g#, b#))))) ==>
        !(z : mem(B)). App(g#, z#) = Tpm(toabs(f#, z#)): thm
val llcr0_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- !(z : mem(B)). App(llcr0(f), z#) = Tpm(toabs(f, z#)): thm
val llrec0_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, Exp(N, A# + 1))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = Tpm(Null(A#))) &
            (!(b : mem(B#))  (a : mem(A#)).
                App(f#, z#) = SOME(Pair(b#, a#)) ==>
                App(cr#, z#) = Tpm(lcons0(a#, tof(App(cr#, b#))))) &
            isll(App(cr#, z#)): thm
val llcr_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, llist(A#))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = LNil(A#)) &
            !(b : mem(B#))  (a : mem(A#)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(cr#, z#) = LCons(a#, App(cr#, b#)): thm
val CB_def =
   {(X : set)}, 
   |- !(R : mem(Pow(llist(X) * llist(X))))  (ll1 : mem(llist(X)))
      (ll2 : mem(llist(X))).
        IN(Pair(ll1#, ll2#), App(CB(X), R#)) <=>
        ll1# = LNil(X) & ll2# = LNil(X) |
        ?(l01 : mem(llist(X)))  (l02 : mem(llist(X)))  (x : mem(X)).
          IN(Pair(l01#, l02#), R#) &
          ll1# = LCons(x#, l01#) & ll2# = LCons(x#, l02#): thm
val CB_monotone = {(X : set)},  |- monotone(CB(X)): thm
val CB_cases = {},  |- !(X : set). gfp(CB(X#)) = App(CB(X#), gfp(CB(X#))):
   thm
val CB_rules0 =
   {}, 
   |- !(X : set).
        IN(Pair(LNil(X#), LNil(X#)), gfp(CB(X#))) &
        !(l01 : mem(llist(X#)))  (l02 : mem(llist(X#))).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          !(x : mem(X#)).
            IN(Pair(LCons(x#, l01#), LCons(x#, l02#)), gfp(CB(X#))): thm
val CB_rules00 =
   {}, 
   |- !(X : set).
        (!(b : mem(llist(X#)))  (a' : mem(llist(X#))).
            a'# = LNil(X#) ==>
            b# = LNil(X#) ==> IN(Pair(a'#, b#), gfp(CB(X#)))) &
        !(a' : mem(llist(X#)))  (b : mem(llist(X#)))  (l01 : mem(llist(X#)))
        (l02 : mem(llist(X#)))  (x : mem(X#)).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          a'# = LCons(x#, l01#) ==>
          b# = LCons(x#, l02#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val CB_coind0 =
   {}, 
   |- !(X : set)  (sa : mem(Pow(llist(X#) * llist(X#)))).
        (!(a' : mem(llist(X#)))  (b : mem(llist(X#))).
            IN(Pair(a'#, b#), sa#) ==>
            a'# = LNil(X#) & b# = LNil(X#) |
            ?(l01 : mem(llist(X#)))  (l02 : mem(llist(X#)))  (x : mem(X#)).
              IN(Pair(l01#, l02#), sa#) &
              a'# = LCons(x#, l01#) & b# = LCons(x#, l02#)) ==>
        !(a' : mem(llist(X#)))  (b : mem(llist(X#))).
          IN(Pair(a'#, b#), sa#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val LHD_THM =
   {(X : set)}, 
   |- LHD(LNil(X)) = NONE(X) &
      !(h : mem(X))  (t : mem(llist(X))). LHD(LCons(h#, t#)) = SOME(h#): thm
val LHD_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))). LHD(ll#) = App(tof(Repll(ll#)), O):
   thm
val LNTH_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). LNTH(n#, ll1#) = LNTH(n#, ll2#)) <=> ll1# = ll2#: thm
val LNTH_def =
   {}, 
   |- !(A : set)  (ll : mem(llist(A#)))  (n : mem(N)).
        LNTH(n#, ll#) = App(tof(Repll(ll#)), n#): thm
val Repll_n_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). App(tof(Repll(ll1#)), n#) = App(tof(Repll(ll2#)), n#)) <=>
        ll1# = ll2#: thm
val isll_cases0 =
   {}, 
   |- !(X : set)  (x : mem(Exp(N, X# + 1))).
        isll(x#) <=>
        x# = Repll(LNil(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          x# = Tpm(lcons0(h#, t#)) & isll(Tpm(t#)): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LTL_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        (LHD(ll#) = NONE(X#) ==> LTL(ll#) = NONE(llist(X#))) &
        !(hd : mem(X#)).
          LHD(ll#) = SOME(hd#) ==>
          ?(ltl0 : mem(llist(X#))).
            LTL(ll#) = SOME(ltl0#) &
            !(n : mem(N)).
              App(tof(Repll(ltl0#)), n#) = App(tof(Repll(ll#)), Suc(n#)): thm
val LCons_xor_LNil =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        ~ll# = LNil(X#) <=>
        ?(h : mem(X#))  (t : mem(llist(X#))). ll# = LCons(h#, t#): thm
val LTL_THM =
   {(X : set)}, 
   |- LTL(LNil(X)) = NONE(llist(X)) &
      !(h : mem(X))  (t : mem(llist(X))). LTL(LCons(h#, t#)) = SOME(t#): thm
val LNTH_THM =
   {}, 
   |- !(X : set).
        (!(n : mem(N)). LNTH(n#, LNil(X#)) = NONE(X#)) &
        (!(h : mem(X#))  (t : mem(llist(X#))).
            LNTH(O, LCons(h#, t#)) = SOME(h#)) &
        !(n : mem(N))  (h : mem(X#))  (t : mem(llist(X#))).
          LNTH(Suc(n#), LCons(h#, t#)) = LNTH(n#, t#): thm
val gfp_CB =
   {}, 
   |- !(X : set)  (g1 : mem(llist(X#)))  (g2 : mem(llist(X#))).
        IN(Pair(g1#, g2#), gfp(CB(X#))) <=> g1# = g2#: thm
val LLIST_BISIMULATION0 =
   {(X : set)}, 
   |- !(ll1 : mem(llist(X)))  (ll2 : mem(llist(X))).
        ll1# = ll2# <=>
        ?(R : mem(Pow(llist(X) * llist(X)))).
          IN(Pair(ll1#, ll2#), R#) &
          !(ll3 : mem(llist(X)))  (ll4 : mem(llist(X))).
            IN(Pair(ll3#, ll4#), R#) ==>
            ll3# = LNil(X) & ll4# = LNil(X) |
            ?(h : mem(X))  (t1 : mem(llist(X)))  (t2 : mem(llist(X))).
              IN(Pair(t1#, t2#), R#) &
              ll3# = LCons(h#, t1#) & ll4# = LCons(h#, t2#): thm
val lcons0_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : fun(N, X + 1))
      (t2 : fun(N, X + 1)).
        lcons0(h1#, t1#) = lcons0(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LCons_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : mem(llist(X)))
      (t2 : mem(llist(X))).
        LCons(h1#, t1#) = LCons(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LMAP_def =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(z : mem(llist(X))).
        (App(lmapf(f), z#) = NONE(llist(X) * Y) ==>
          App(LMAP(f), z#) = LNil(Y)) &
        !(b : mem(llist(X)))  (a : mem(Y)).
          App(lmapf(f), z#) = SOME(Pair(b#, a#)) ==>
          App(LMAP(f), z#) = LCons(a#, App(LMAP(f), b#)): thm
val LMap_def =
   {(X : set), (Y : set), (f : fun(X, Y)), (l : mem(llist(X)))}, 
   |- LMap(f, l) = App(LMAP(f), l): thm
val f_ex0 =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(l : mem(llist(X))).
        ?!(opv : mem(llist(X) * A + 1)).
          l# = LNil(X) & opv# = NONE(llist(X) * A) |
          ?(lh : mem(X))  (lt : mem(llist(X))).
            l# = LCons(lh#, lt#) & opv# = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LNil =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A)). App(lmapf(f#), LNil(X)) = NONE(llist(X) * A): thm
val lmapf_def =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(a : mem(llist(X))).
        a# = LNil(X) & App(lmapf(f), a#) = NONE(llist(X) * A) |
        ?(lh : mem(X))  (lt : mem(llist(X))).
          a# = LCons(lh#, lt#) &
          App(lmapf(f), a#) = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LCons =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A))  (lh : mem(X))  (lt : mem(llist(X))).
        App(lmapf(f#), LCons(lh#, lt#)) = SOME(Pair(lt#, App(f#, lh#))): thm
val LMAP_LNil =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y)). App(LMAP(f#), LNil(X)) = LNil(Y): thm
val LMAP_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        App(LMAP(f#), LCons(lh#, lt#)) =
          LCons(App(f#, lh#), App(LMAP(f#), lt#)): thm
val LMap_LNil =
   {(X : set), (Y : set)},  |- !(f : fun(X, Y)). LMap(f#, LNil(X)) = LNil(Y):
   thm
val LMap_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        LMap(f#, LCons(lh#, lt#)) = LCons(App(f#, lh#), LMap(f#, lt#)): thm
val LMap_functorial =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (g : fun(Z, X))  (ll : mem(llist(Z))).
        LMap(f#, LMap(g#, ll#)) = LMap(f# o g#, ll#): thm
val it = (): unit
******

Loading SEAR file SEARGrp.sml

******
val Grp_def =
   {}, 
   |- !(G : set).
        Inj(iG(G#)) &
        !(a : mem(Exp((G# * G#), G#) * Exp(G#, G#) * G#)).
          isgrp(a#) <=> ?(b : mem(Grp(G#))). a# = App(iG(G#), b#): thm
val RepG_def = {(G : set), (g : mem(Grp(G)))},  |- RepG(g) = App(iG(G), g):
   thm
val RepG_isgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isgrp(RepG(g#)): thm
val asc_def =
   {(A : set), (m : fun(A * A, A))}, 
   |- asc(m) <=>
      !(a1 : mem(A))  (a2 : mem(A))  (a3 : mem(A)).
        mul(m, mul(m, a1#, a2#), a3#) = mul(m, a1#, mul(m, a2#, a3#)): thm
val isgrp_def =
   {(G : set), (g : mem(Exp((G * G), G) * Exp(G, G) * G))}, 
   |- isgrp(g) <=>
      asc(tof(c31(g))) &
      isunit(tof(c31(g)), c33(g)) & isinv(tof(c31(g)), tof(c32(g)), c33(g)):
   thm
val isinv_def =
   {(A : set), (e : mem(A)), (i : fun(A, A)), (m : fun(A * A, A))}, 
   |- isinv(m, i, e) <=>
      !(a : mem(A)). mul(m, App(i, a#), a#) = e & mul(m, a#, App(i, a#)) = e:
   thm
val isunit_def =
   {(A : set), (e : mem(A)), (m : fun(A * A, A))}, 
   |- isunit(m, e) <=> !(a : mem(A)). mul(m, e, a#) = a# & mul(m, a#, e) = a#:
   thm
val mul_def =
   {(G : set), (g1 : mem(G)), (g2 : mem(G)), (m : fun(G * G, G))}, 
   |- mul(m, g1, g2) = App(m, Pair(g1, g2)): thm
val Rnsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rnsg(g#)): thm
val eof_def = {(G : set), (g : mem(Grp(G)))},  |- eof(g) = c33(RepG(g)): thm
val ginv_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G))}, 
   |- ginv(g, x) = App(iof(g), x): thm
val gmul_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G)), (y : mem(G))}, 
   |- gmul(g, x, y) = mul(mof(g), x, y): thm
val iof_def = {(G : set), (g : mem(Grp(G)))},  |- iof(g) = tof(c32(RepG(g))):
   thm
val isghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (f : fun(G1#, G2#))
      (g2 : mem(Grp(G2#))).
        isghom(f#, g1#, g2#) <=>
        !(a : mem(G1#))  (b : mem(G1#)).
          App(f#, gmul(g1#, a#, b#)) = gmul(g2#, App(f#, a#), App(f#, b#)):
   thm
val isnml_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(sgrp(g)))}, 
   |- isnml(h) <=> !(a : mem(G)). rcs(h, a#) = lcs(a#, h): thm
val issgrp_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(Pow(G)))}, 
   |- issgrp(h, g) <=>
      IN(eof(g), h) &
      (!(a : mem(G))  (b : mem(G)).
          IN(a#, h) & IN(b#, h) ==> IN(gmul(g, a#, b#), h)) &
      !(a : mem(G)). IN(a#, h) ==> IN(ginv(g, a#), h): thm
val lcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, lcs(a, H)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, a, h#): thm
val lsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (x : mem(G#))
      (a : mem(G#)).
        IN(a#, lsmul(g#, x#, s#)) <=>
        ?(y : mem(G#)). IN(y#, s#) & a# = gmul(g#, x#, y#): thm
val mof_def = {(G : set), (g : mem(Grp(G)))},  |- mof(g) = tof(c31(RepG(g))):
   thm
val nsg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(sgrp(g))).
        (?(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#) <=>
        ?!(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#: thm
val nsg_uex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(sgrp(g#))).
        isnml(a#) ==> ?!(a : mem(nsgrp(g#))). App(Rnsg(g#), a#) = a#: thm
val nsgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))).
        Inj(Rnsg(g#)) &
        !(a : mem(sgrp(g#))).
          isnml(a#) <=> ?(b : mem(nsgrp(g#))). a# = App(Rnsg(g#), b#): thm
val rcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, rcs(H, a)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, h#, a): thm
val rcs_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        rcs(H#, a#) = rsmul(g#, rsg(H#), a#): thm
val rsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        rsg(H#) = App(Rsg(g#), H#): thm
val rsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (y : mem(G#))
      (a : mem(G#)).
        IN(a#, rsmul(g#, s#, y#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = gmul(g#, x#, y#): thm
val sgrp_def =
   {(G : set), (g : mem(Grp(G)))}, 
   |- Inj(Rsg(g)) &
      !(a : mem(Pow(G))).
        issgrp(a#, g) <=> ?(b : mem(sgrp(g))). a# = App(Rsg(g), b#): thm
val lcs_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        lcs(a#, H#) = lsmul(g#, a#, rsg(H#)): thm
val Rsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rsg(g#)): thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val sg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(Pow(G))).
        (?(a : mem(sgrp(g))). App(Rsg(g), a#) = b#) <=>
        ?!(a : mem(sgrp(g))). App(Rsg(g), a#) = b#: thm
val sg_uex =
   {}, 
   |- !(G : set)  (a : mem(Pow(G#)))  (g : mem(Grp(G#))).
        issgrp(a#, g#) ==> ?!(a : mem(sgrp(g#))). App(Rsg(g#), a#) = a#: thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val gmul_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, ginv(g#, a#), a#) = eof(g#) &
        gmul(g#, a#, ginv(g#, a#)) = eof(g#): thm
val asc_mof = {},  |- !(G : set)  (g : mem(Grp(G#))). asc(mof(g#)): thm
val gmul_assoc =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (c : mem(G#)).
        gmul(g#, gmul(g#, a#, b#), c#) = gmul(g#, a#, gmul(g#, b#, c#)): thm
val gmul_lcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, x#, y#) = gmul(g#, x#, z#) <=> y# = z#: thm
val gmul_rcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, y#, x#) = gmul(g#, z#, x#) <=> y# = z#: thm
val is_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        a1# = ginv(g#, a#) <=>
        gmul(g#, a#, a1#) = eof(g#) | gmul(g#, a1#, a#) = eof(g#): thm
val ginv_e =
   {},  |- !(G : set)  (g : mem(Grp(G#))). ginv(g#, eof(g#)) = eof(g#): thm
val e_sgrp =
   {},  |- !(G : set)  (g : mem(Grp(G#))). issgrp(Sing(eof(g#)), g#): thm
val esg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))). App(Rsg(g#), esg(g#)) = Sing(eof(g#)):
   thm
val rsg_esg =
   {},  |- !(G : set)  (g : mem(Grp(G#))). rsg(esg(g#)) = Sing(eof(g#)): thm
val e_nsgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isnml(esg(g#)): thm
val ensg_def =
   {},  |- !(G : set)  (g : mem(Grp(G#))). App(Rnsg(g#), ensg(g#)) = esg(g#):
   thm
val nsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(sgrp(g#))).
        nsg(h#) = App(LINV(Rnsg(g#), ensg(g#)), h#): thm
val qgR_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        Holds(qgR(H#), a#, b#) <=> lcs(a#, rnsg(H#)) = lcs(b#, rnsg(H#)): thm
val rnsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rnsg(H#) = App(Rnsg(g#), H#): thm
val qgR_Refl =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Refl(qgR(H#)):
   thm
val qgR_Sym =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Sym(qgR(H#)):
   thm
val qgR_Trans =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Trans(qgR(H#)):
   thm
val qgR_ER =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). ER(qgR(H#)):
   thm
val css_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Inj(Rcss(H#)) &
        !(a : mem(Pow(G#))).
          (?(a : mem(G#)). a# = rsi(qgR(H#), a#)) <=>
          ?(b : mem(css(H#))). a# = App(Rcss(H#), b#): thm
val Rcss_Inj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Inj(Rcss(H#)):
   thm
val rcss_def =
   {(G : set), (H : mem(nsgrp(g))), (cs : mem(css(H))), (g : mem(Grp(G)))}, 
   |- rcss(cs) = App(Rcss(H), cs): thm
val rcss_eq_eq =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (a : mem(css(H#)))  (b : mem(css(H#))). rcss(a#) = rcss(b#) <=> a# = b#:
   thm
val mem_css_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ?!(a : mem(css(H#))). rcss(a#) = rsi(qgR(H#), eof(g#)): thm
val Quot_qgR_Rcss =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(qgR(H#), Rcss(H#)): thm
val cs_def =
   {}, 
   |- !(G : set)  (a : mem(G#))  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        cs(a#, H#) = abs(qgR(H#), Rcss(H#), ecs(H#), a#): thm
val ecs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rcss(ecs(H#)) = rsi(qgR(H#), eof(g#)): thm
val rcss_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcss(cs(a#, H#)) = rsi(qgR(H#), a#): thm
val nsgrp_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val nsgrp_swap_l2r =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, a#, h#) = gmul(g#, h#, a#): thm
val smul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, smul(g#, s1#, s2#)) <=>
        ?(x : mem(G#))  (y : mem(G#)).
          IN(x#, s1#) & IN(y#, s2#) & a# = gmul(g#, x#, y#): thm
val nsgrp_swap_r2l =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, h#, a#) = gmul(g#, a#, h#): thm
val rsg_issgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        issgrp(rsg(H#), g#): thm
val e_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        IN(eof(g#), rsg(H#)): thm
val gmul_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h1 : mem(G#)).
        IN(h1#, rsg(H#)) ==>
        !(h2 : mem(G#)). IN(h2#, rsg(H#)) ==> IN(gmul(g#, h1#, h2#), rsg(H#)):
   thm
val ginv_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(H#)) ==> IN(ginv(g#, h#), rsg(H#)): thm
val gmul_lcs_smul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        lcs(gmul(g#, a#, b#), rnsg(H#)) =
          smul(g#, lcs(a#, rnsg(H#)), lcs(b#, rnsg(H#))): thm
val mof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o mof(g#),
       prrel(qgR(H#), qgR(H#))): thm
val prrel_qgR_ER =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ER(prrel(qgR(H#), qgR(H#))): thm
val qgR_Rcss_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#))): thm
val qgR_Rcss_abs_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        abs(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#)),
           Pair(ecs(H#), ecs(H#)), Pair(a#, b#)) =
          Pair(abs(qgR(H#), Rcss(H#), ecs(H#), a#),
           abs(qgR(H#), Rcss(H#), ecs(H#), b#)): thm
val ginv_oneside =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        gmul(g#, a#, a1#) = eof(g#) <=> gmul(g#, a1#, a#) = eof(g#): thm
val mulcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        mul(mulcs(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val sinv_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, sinv(g#, s#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = ginv(g#, x#): thm
val is_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        a# = eof(g#) <=>
        (?(x : mem(G#)). gmul(g#, a#, x#) = x#) |
        ?(x : mem(G#)). gmul(g#, x#, a#) = x#: thm
val ginv_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#)).
        ginv(g#, gmul(g#, a#, b#)) = gmul(g#, ginv(g#, b#), ginv(g#, a#)):
   thm
val ginv_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        ginv(g#, ginv(g#, a#)) = a#: thm
val ginv_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        lcs(ginv(g#, a#), rnsg(H#)) = sinv(g#, lcs(a#, rnsg(H#))): thm
val iof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o iof(g#), qgR(H#)): thm
val invcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(invcs(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_Surj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Surj(qmap(H#)):
   thm
val qmap_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qmap(H#) = Abs(qgR(H#), Rcss(H#), ecs(H#)): thm
val css_rep_ex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (b : mem(css(H#))). ?(a : mem(G#)). b# = cs(a#, H#): thm
val ecs_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ecs(H#) = cs(eof(g#), H#): thm
val mulcs_invcs_ecs_isgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isgrp(Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#)))): thm
val mof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        mof(qgrp(H#)) = mulcs(H#): thm
val qgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        RepG(qgrp(H#)) = Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#))):
   thm
val iof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        iof(qgrp(H#)) = invcs(H#): thm
val eof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        eof(qgrp(H#)) = ecs(H#): thm
val gmul_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        gmul(qgrp(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val ginv_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : set). ginv(qgrp(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(qmap(H#), a#) = cs(a#, H#): thm
val qmap_isghom =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isghom(qmap(H#), g#, qgrp(H#)): thm
val constf_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        isghom(constf(G1#, eof(g2#)), g1#, g2#): thm
val ghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)) &
        !(a : mem(Exp(G1#, G2#))).
          isghom(tof(a#), g1#, g2#) <=>
          ?(b : mem(ghom(g1#, g2#))). a# = App(ih(g1#, g2#), b#): thm
val ghom_ex_uex =
   {(G1 : set), (G2 : set), (g1 : mem(Grp(G1))), (g2 : mem(Grp(G2)))}, 
   |- !(b : mem(Exp(G1, G2))).
        (?(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#) <=>
        ?!(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#: thm
val ghom_uex =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (a : mem(Exp(G1#, G2#))).
        isghom(tof(a#), g1#, g2#) ==>
        ?!(a : mem(ghom(g1#, g2#))). App(ih(g1#, g2#), a#) = a#: thm
val ih_Inj =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)): thm
val eghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        App(ih(g1#, g2#), eghm(g1#, g2#)) = Tpm(constf(G1#, eof(g2#))): thm
val ghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : fun(G1#, G2#)).
        ghm(h#, g1#, g2#) = App(LINV(ih(g1#, g2#), eghm(g1#, g2#)), Tpm(h#)):
   thm
val homfun_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : mem(ghom(g1#, g2#))). homfun(h#) = tof(App(ih(g1#, g2#), h#)): thm
val isghom_homfun_ghm =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : fun(G1#, G2#)).
        isghom(f#, g1#, g2#) <=> homfun(ghm(f#, g1#, g2#)) = f#: thm
val IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#)).
        IN(x#, kers(f#)) <=> App(homfun(f#), x#) = eof(g2#): thm
val ker_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). ker(f#) = nsg(sg(kers(f#), g1#)): thm
val kers_def =
   {(G1 : set), (G2 : set), (f : mem(ghom(g1, g2))), (g1 : mem(Grp(G1))),
    (g2 : mem(Grp(G2)))},  |- kers(f) = PREIM(homfun(f), Sing(eof(g2))): thm
val sg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(Pow(G#))).
        sg(h#, g#) = App(LINV(Rsg(g#), esg(g#)), h#): thm
val homfun_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isghom(homfun(f#), g1#, g2#): thm
val homfun_gmul =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#))  (y : mem(G1#)).
        App(homfun(f#), gmul(g1#, x#, y#)) =
          gmul(g2#, App(homfun(f#), x#), App(homfun(f#), y#)): thm
val homfun_e =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). App(homfun(f#), eof(g1#)) = eof(g2#): thm
val homfun_ginv =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a : mem(G1#)).
        App(homfun(f#), ginv(g1#, a#)) = ginv(g2#, App(homfun(f#), a#)): thm
val e_IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). IN(eof(g1#), kers(f#)): thm
val kers_issgrp =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). issgrp(kers(f#), g1#): thm
val cjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (h : mem(G))}, 
   |- cjg(g, a, h) = gmul(g, a, gmul(g, h, ginv(g, a))): thm
val lsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (s : mem(Pow(G#))).
        lsmul(g#, a#, lsmul(g#, b#, s#)) = lsmul(g#, gmul(g#, a#, b#), s#):
   thm
val qhom_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qhom(H#) = ghm(qmap(H#), g#, qgrp(H#)): thm
val rsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        rsmul(g#, rsmul(g#, s#, a#), b#) = rsmul(g#, s#, gmul(g#, a#, b#)):
   thm
val lsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        lsmul(g#, eof(g#), s#) = s#: thm
val rsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        rsmul(g#, s#, eof(g#)) = s#: thm
val lsmul_rsmul_comm =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#)))
      (b : mem(G#)).
        rsmul(g#, lsmul(g#, a#, s#), b#) = lsmul(g#, a#, rsmul(g#, s#, b#)):
   thm
val isnml_alt =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). scjg(g#, a#, rsg(H#)) = rsg(H#): thm
val scjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (s : mem(Pow(G)))}, 
   |- scjg(g, a, s) = lsmul(g, a, rsmul(g, s, ginv(g, a))): thm
val scjg_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (H : mem(Pow(G#)))
      (x : mem(G#)).
        IN(x#, scjg(g#, a#, H#)) <=>
        ?(h : mem(G#)). IN(h#, H#) & x# = cjg(g#, a#, h#): thm
val SS_scjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#))).
        SS(scjg(g#, a#, s#), s#) <=>
        !(x : mem(G#)). IN(x#, s#) ==> IN(cjg(g#, a#, x#), s#): thm
val SS_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(rsmul(g#, s1#, a#), rsmul(g#, s2#, a#)): thm
val SS_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val isnml_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). SS(scjg(g#, a#, rsg(H#)), rsg(H#)): thm
val IN_gmul_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, H#) <=>
        !(b : mem(G#)). IN(gmul(g#, a#, b#), rsmul(g#, H#, b#)): thm
val IN_gmul_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (b : mem(G#)).
        IN(b#, H#) <=>
        !(a : mem(G#)). IN(gmul(g#, a#, b#), lsmul(g#, a#, H#)): thm
val gmul_IN_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val gmul_IN_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val rnsg_isnml =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). isnml(rnsg(H#)):
   thm
val rnsg_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val SS_ex_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        ?(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val same_cs_cond =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        cs(a#, H#) = cs(b#, H#) <=>
        IN(gmul(g#, a#, ginv(g#, b#)), rsg(rnsg(H#))): thm
val sg_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        sg(rsg(H#), g#) = H#: thm
val nsg_rnsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        nsg(rnsg(H#)) = H#: thm
val issgrp_rsg_sg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#))).
        issgrp(H#, g#) <=> rsg(sg(H#, g#)) = H#: thm
val isnml_rnsg_nsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> rnsg(nsg(H#)) = H#: thm
val sg_kers_isnml =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isnml(sg(kers(f#), g1#)): thm
val rsg_rnsg_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rsg(rnsg(ker(f#))) = kers(f#): thm
val rgh_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rgh(f#) = App(ih(g1#, g2#), f#): thm
val rgh_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        rgh(f1#) = rgh(f2#) <=> f1# = f2#: thm
val homfun_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        homfun(f1#) = homfun(f2#) <=> f1# = f2#: thm
val homfun_eq_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a1 : mem(G1#))  (a2 : mem(G1#)).
        App(homfun(f#), a1#) = App(homfun(f#), a2#) <=>
        App(homfun(f#), gmul(g1#, ginv(g1#, a1#), a2#)) = eof(g2#): thm
val homfun_resp1_qgR_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). resp1(homfun(f#), qgR(ker(f#))): thm
val first_iso_thm =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))).
        ?!(fb : mem(ghom(qgrp(ker(f#)), g2#))).
          Inj(homfun(fb#)) & homfun(fb#) o qmap(ker(f#)) = homfun(f#): thm
val it = (): unit
******

Loading SEAR file SEARexamplecol.sml

******
val AX5 =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
val cardeq_REFL = {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, s#): thm
val cardeq_def =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=>
      ?(R : rel(A, B)).
        (!(a : mem(A)).
            IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R#, a#, b#)) &
        !(b : mem(B)).
          IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R#, a#, b#): thm
val isset_def =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
val cardeq_SYM =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(s2#, s1#): thm
val cardeq_TRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#))).
          cardeq(s2#, s3#) ==> cardeq(s1#, s3#): thm
val restrict_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (R : rel(A#, B#))
      (s2 : mem(Pow(B#)))  (a : mem(A#))  (b : mem(B#)).
        Holds(restrict(R#, s1#, s2#), a#, b#) <=>
        IN(a#, s1#) & IN(b#, s2#) & Holds(R#, a#, b#): thm
val cardeq_Whole_Inj_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set).
        cardeq(s#, Whole(B#)) ==>
        ?(i : fun(B#, A#)). Inj(i#) & IMAGE(i#, Whole(B#)) = s#: thm
val cardeq_Inj_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> cardeq(Whole(A#), IMAGE(f#, Whole(A#))): thm
val Inj_Image =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Inj(f#) ==> Inj(Image(f#)):
   thm
val IMAGE_INJ_cardeq =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#)))
      (f : fun(A#, B#)).
        INJ(f#, s1#, s2#) ==>
        !(s01 : mem(Pow(A#))).
          SS(s01#, s1#) ==> cardeq(s01#, IMAGE(f#, s01#)): thm
val INJ_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (t : mem(Pow(B#))).
        INJ(f#, s#, t#) <=>
        (!(x : mem(A#)). IN(x#, s#) ==> IN(App(f#, x#), t#)) &
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==> App(f#, x#) = App(f#, y#) ==> x# = y#:
   thm
val Inj_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). INJ(f#, s#, IMAGE(f#, s#)): thm
val INJ_SS_dom =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(A#))). SS(s#, s1#) ==> INJ(f#, s#, s2#): thm
val INJ_SS_cod =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(B#))). SS(s2#, s#) ==> INJ(f#, s1#, s#): thm
val o_INJ_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(C : set)  (g : fun(B#, C#))  (s3 : mem(Pow(C#))).
          INJ(g#, s2#, s3#) ==> INJ(g# o f#, s1#, s3#): thm
val cardeq_Inj_IMAGE_gen =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). cardeq(s#, IMAGE(f#, s#)): thm
val INJ_INS_NONE =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X# + 1)))).
        (!(s0 : mem(Pow(X# + 1))). IN(s0#, s#) ==> ~IN(NONE(X#), s0#)) ==>
        INJ(INS(NONE(X#)), s#, IMAGE(INS(NONE(X#)), s#)): thm
val INS_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (a : mem(Pow(X#))).
        App(INS(x0#), a#) = Ins(x0#, a#): thm
val POW_Whole_Pow = {},  |- !(A : set). POW(Whole(A#)) = Whole(Pow(A#)): thm
val POW_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (a : mem(Pow(A#))).
        IN(a#, POW(s0#)) <=> SS(a#, s0#): thm
val cardeq_POW_Whole_Pow =
   {},  |- !(A : set). cardeq(POW(Whole(A#)), Whole(Pow(A#))): thm
val FIB_constf =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#)).
        FIB(constf(A#, b#), b#) = Whole(A#): thm
val nPow_def =
   {}, 
   |- !(A : set)  (B : set)  (n : mem(N)).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)).
          cardeq(FIB(f#, O), Whole(A#)) &
          cardeq(FIB(f#, n#), Whole(B#)) &
          !(n0 : mem(N)).
            Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPow_O = {},  |- !(A : set). nPow(O, A#, A#): thm
val OE_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- OE(f, b0) = coPa(f, El(b0)): thm
val Sg_Sing = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Sgf_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- (!(a : mem(A)). App(Sgf(f, b0), Sing(a#)) = App(f, a#)) &
      !(s : mem(Pow(A))).
        (!(a : mem(A)). ~s# = Sing(a#)) ==> App(Sgf(f, b0), s#) = b0: thm
val content_Sing =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        App(content(x0#), Sing(x#)) = x#: thm
val content_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#)).
        (!(s : mem(Pow(X#)))  (x : mem(X#)).
            s# = Sing(x#) ==> App(content(x0#), s#) = x#) &
        !(s : mem(Pow(X#))).
          (!(x : mem(X#)). ~s# = Sing(x#)) ==> App(content(x0#), s#) = x0#:
   thm
val ctt_def =
   {}, 
   |- !(X : set)  (s : mem(Pow(X#)))  (x0 : mem(X#)).
        ctt(s#, x0#) = App(content(x0#), s#): thm
val PREIM_i1_Sing_SOME =
   {(X : set), (x0 : mem(X))},  |- PREIM(i1(X, 1), Sing(SOME(x0))) = Sing(x0):
   thm
val IMAGE_Sing =
   {(A : set), (B : set), (a : mem(A)), (f : fun(A, B))}, 
   |- IMAGE(f, Sing(a)) = Sing(App(f, a)): thm
val ctt_Sing =
   {},  |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)). ctt(Sing(a#), a0#) = a#:
   thm
val Sing_SOME_NEQ_Ins_NONE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A# + 1))).
        ~Sing(SOME(a#)) = Ins(NONE(A#), s#): thm
val SS_Ri_restrict =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (a : mem(Pow(A#)))  (B : set)
      (R : rel(A#, B#))  (s2 : mem(Pow(B#))).
        SS(App(Ri(restrict(R#, s1#, s2#)), a#), s2#): thm
val biunique_def =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) <=>
      (!(a : mem(A)).
          IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R, a#, b#)) &
      !(b : mem(B)).
        IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R, a#, b#): thm
val nPow_Suc_ex_lemma =
   {}, 
   |- !(C : set)  (X : set)  (i : fun(C#, Pow(X#))).
        Inj(i#) ==>
        !(B : set)  (f : fun(X#, B#))  (bs : mem(Pow(B#)))  (b0 : mem(B#)).
          (!(x : mem(X#)). ~App(f#, x#) = b0#) ==>
          ~IN(b0#, bs#) ==>
          !(b1 : mem(B#)).
            ~b1# = b0# & ~IN(b1#, bs#) ==>
            ?(f1 : fun(Pow(X# + 1), B#)).
              (!(b : mem(B#)).
                  IN(b#, bs#) ==>
                  FIB(f1#, b#) = IMAGE(Sg(X# + 1) o i1(X#, 1), FIB(f#, b#))) &
              FIB(f1#, b0#) =
                IMAGE(INS(NONE(X#)) o Image(i1(X#, 1)) o i#, Whole(C#)): thm
val biunique_op =
   {(A : set), (B : set)}, 
   |- !(R : rel(A, B))  (s1 : mem(Pow(A)))  (s2 : mem(Pow(B))).
        biunique(R#, s1#, s2#) ==> biunique(op(R#), s2#, s1#): thm
val biunique_Ri_restrict =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) ==>
      !(s : mem(Pow(A))).
        SS(s#, s1) ==>
        App(Ri(restrict(op(R), s2, s1)), App(Ri(restrict(R, s1, s2)), s#)) =
          s#: thm
val cardeq_POW =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(POW(s1#), POW(s2#)): thm
val cardeq_biunique =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=> ?(R : rel(A, B)). biunique(R#, s1, s2): thm
val cardeq_BITRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#)))  (D : set)  (s4 : mem(Pow(D#))).
          cardeq(s3#, s4#) ==> (cardeq(s1#, s3#) <=> cardeq(s2#, s4#)): thm
val NONE_NOTIN_IMAGE_i1 =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X#))))  (s0 : mem(Pow(X# + 1))).
        IN(s0#, IMAGE(Image(i1(X#, 1)), s#)) ==> ~IN(NONE(X#), s0#): thm
val shrink_IMAGE =
   {}, 
   |- !(X : set)  (B : set)  (f0 : fun(X#, B#))  (s : mem(Pow(B#)))
      (b0 : mem(B#)).
        ~IN(b0#, s#) ==>
        (!(b : mem(B#)).
            IN(b#, s#) ==> FIB(shrink(f0#, s#, b0#), b#) = FIB(f0#, b#)) &
        !(x : mem(X#)).
          ~IN(App(f0#, x#), s#) ==> App(shrink(f0#, s#, b0#), x#) = b0#: thm
val shrink_def =
   {(B : set), (X : set), (b0 : mem(B)), (f0 : fun(X, B)), (s : mem(Pow(B)))},
   
   |- !(a : mem(X)).
        (IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = App(f0, a#)) &
        (~IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = b0): thm
val nPow_shrink_IMAGE_ex =
   {(A : set), (An : set), (n : mem(N))}, 
   |- nPow(n, A, An) ==>
      ?(X : set)  (f : fun(X#, N)).
        cardeq(FIB(f#, O), Whole(A)) &
        cardeq(FIB(f#, n), Whole(An)) &
        (!(n0 : mem(N)).
            Lt(n0#, n) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#)))) &
        !(x : mem(X#)). ~App(f#, x#) = Suc(n): thm
val nPow_Suc =
   {(n : mem(N))}, 
   |- !(A : set)  (An : set). nPow(n, A#, An#) ==> nPow(Suc(n), A#, Pow(An#)):
   thm
val nPow_ex =
   {},  |- !(A : set)  (n : mem(N)). ?(An : set). nPow(n#, A#, An#): thm
val cardeq_m2s =
   {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, Whole(m2s(s#))): thm
val m2s_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Inj(minc(s#)) &
        !(a : mem(A#)).
          IN(a#, s#) <=> ?(b : mem(m2s(s#))). a# = App(minc(s#), b#): thm
val nPowf_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, N))  (n : mem(N)).
        nPowf(n#, A#, B#, f#) <=>
        cardeq(FIB(f#, O), Whole(A#)) &
        cardeq(FIB(f#, n#), Whole(B#)) &
        !(n0 : mem(N)).
          Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPowf_Preds =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> ?(B0 : set). nPowf(n0#, A#, B0#, f#):
   thm
val nPowf_Preds_FIB =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> nPowf(n0#, A#, m2s(FIB(f#, n0#)), f#):
   thm
val nPow_nPowf =
   {}, 
   |- !(A : set)  (n : mem(N))  (B : set).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)). nPowf(n#, A#, B#, f#): thm
val nPow_unique =
   {}, 
   |- !(A : set)  (n : mem(N))  (An1 : set)  (An2 : set).
        nPow(n#, A#, An1#) & nPow(n#, A#, An2#) ==>
        cardeq(Whole(An1#), Whole(An2#)): thm
val nPow_uex =
   {}, 
   |- !(A : set)  (n : mem(N)).
        ?(An : set).
          nPow(n#, A#, An#) &
          !(An1 : set).
            nPow(n#, A#, An1#) ==> cardeq(Whole(An#), Whole(An1#)): thm
val Pn_def = {},  |- !(A : set)  (n : mem(N)). nPow(n#, A#, Pn(A#, n#)): thm
val cardeq_Whole_REFL = {},  |- !(An : set). cardeq(Whole(An#), Whole(An#)):
   thm
val cardeq_Whole_SYM =
   {}, 
   |- !(An : set)  (An' : set).
        cardeq(Whole(An#), Whole(An'#)) ==> cardeq(Whole(An'#), Whole(An#)):
   thm
val cardeq_Whole_TRANS =
   {}, 
   |- !(An : set)  (An' : set)  (An'' : set).
        cardeq(Whole(An#), Whole(An'#)) & cardeq(Whole(An'#), Whole(An''#)) ==>
        cardeq(Whole(An#), Whole(An''#)): thm
val isset_minc = {},  |- !(A : set)  (s : mem(Pow(A#))). isset(minc(s#), s#):
   thm
val large_ex =
   {}, 
   |- !(A : set).
        ?(P : set). !(n : mem(N)). ?(i : fun(Pn(A#, n#), P#)). Inj(i#): thm
val nPow_ts_ex = {},  |- !(A : set)  (n : mem(N)). ?(An : set). T: thm
val it = (): unit
val it = (): unit
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holQFOnLOScript.sml

******
val Inj_same_IMAGE =
   {}, 
   |- !(X : set)  (A1 : set)  (i1 : fun(A1#, X#))  (A2 : set)
      (i2 : fun(A2#, X#)).
        Inj(i1#) & Inj(i2#) & IMAGE(i1#, Whole(A1#)) = IMAGE(i2#, Whole(A2#)) ==>
        ?(f : fun(A1#, A2#))  (g : fun(A2#, A1#)).
          f# o g# = Id(A2#) &
          g# o f# = Id(A1#) & i2# o f# = i1# & i1# o g# = i2#: thm
val Inj_same_IMAGE_unique =
   {}, 
   |- !(X : set)  (A1 : set)  (i1 : fun(A1#, X#))  (A2 : set)
      (i2 : fun(A2#, X#)).
        Inj(i1#) & Inj(i2#) & IMAGE(i1#, Whole(A1#)) = IMAGE(i2#, Whole(A2#)) ==>
        ?!(f : fun(A1#, A2#)). i2# o f# = i1#: thm
val Bij_Inj =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Bij(f#) ==> Inj(f#): thm
val ex_mem_eq =
   {}, 
   |- (!(A : set)  (a : mem(A#)). ?(a0 : mem(A#)). a# = a0#) &
      (!(A : set)  (a : mem(A#)). ?(a0 : mem(A#)). a0# = a#) &
      (!(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
          ?(a0 : mem(A#)). App(f#, a0#) = App(f#, a#)) &
      !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        ?(a0 : mem(A#)). App(f#, a#) = App(f#, a0#): thm
val Inj_Pow_EXT =
   {}, 
   |- !(X : set)  (A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
      (R : rel(X#, X#)).
        Inj(i#) &
        Inj(pi#) &
        (!(ax : mem(X#))  (sx : mem(X#)).
            (?(a : mem(A#)). ax# = App(i#, a#)) &
            (?(s : mem(Pow(A#))). sx# = App(pi#, s#)) ==>
            (Holds(R#, ax#, sx#) <=>
              ?(a : mem(A#))  (s : mem(Pow(A#))).
                IN(a#, s#) & App(i#, a#) = ax# & App(pi#, s#) = sx#)) ==>
        !(sx1 : mem(X#))  (sx2 : mem(X#)).
          IN(sx1#, IMAGE(pi#, Whole(Pow(A#)))) &
          IN(sx2#, IMAGE(pi#, Whole(Pow(A#)))) ==>
          (sx1# = sx2# <=>
            !(ax : mem(X#)).
              IN(ax#, IMAGE(i#, Whole(A#))) ==>
              (Holds(R#, ax#, sx1#) <=> Holds(R#, ax#, sx2#))): thm
val Les_O_Sing = {},  |- Les(O) = Sing(O): thm
val Les_def =
   {},  |- !(n : mem(N))  (a : mem(N)). IN(a#, Les(n#)) <=> Le(a#, n#): thm
val Upows_def =
   {(R : rel(X, X)), (X : set), (n : mem(N)), (p : fun(X, N)),
    (z : fun(N, X))}, 
   |- Upows(n, p, R, z) <=>
      IMAGE(p, Whole(X)) = Les(n) &
      Inj(z) &
      IMAGE(z, Whole(N)) = FIB(p, O) &
      (!(n0 : mem(N)).
          Lt(n0#, n) ==>
          ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
      !(x : mem(X))  (s : mem(X)).
        Holds(R, x#, s#) <=>
        Lt(App(p, x#), n) &
        Suc(App(p, x#)) = App(p, s#) &
        ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))  (a : mem(A#))
        (sa : mem(Pow(A#))).
          Inj(i#) &
          Inj(pi#) &
          IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
          IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
          (!(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
          IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
val constf_iff_Sing =
   {}, 
   |- !(A : set).
        (?(a : mem(A#)). T) ==>
        !(B : set)  (f : fun(A#, B#))  (b : mem(B#)).
          IMAGE(f#, Whole(A#)) = Sing(b#) <=> f# = constf(A#, b#): thm
val IMAGE_constf =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        ~s# = Empty(A#) ==>
        !(X : set)  (x : mem(X#)). IMAGE(constf(A#, x#), s#) = Sing(x#): thm
val Upows_O =
   {(R : rel(X, X)), (X : set), (p : fun(X, N)), (z : fun(N, X))}, 
   |- Upows(O, p, R, z) <=>
      IMAGE(z, Whole(N)) = FIB(p, O) &
      p = constf(X, O) &
      (!(x1 : mem(X))  (x2 : mem(X)). ~Holds(R, x1#, x2#)) & Bij(z): thm
val IMAGE_Id =
   {},  |- !(A : set)  (s : mem(Pow(A#))). IMAGE(Id(A#), s#) = s#: thm
val REmpty_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). ~Holds(REmpty(A#), a#, b#):
   thm
val Id_Surj = {},  |- !(A : set). Surj(Id(A#)): thm
val Bij_Id = {},  |- !(A : set). Bij(Id(A#)): thm
val Upows_O_ex = {},  |- Upows(O, constf(N, O), REmpty(N), Id(N)): thm
val Apr_def =
   {}, 
   |- !(A : set)  (X : set)  (R0 : rel(X#, X#))  (f : fun(X#, A#))
      (a : mem(A#))  (b : mem(A#)).
        Holds(Apr(f#, R0#), a#, b#) <=>
        ?(x1 : mem(X#))  (x2 : mem(X#)).
          App(f#, x1#) = a# & App(f#, x2#) = b# & Holds(R0#, x1#, x2#): thm
val Inj_Pow_choice_independence =
   {}, 
   |- !(X : set)  (A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
      (R : rel(X#, X#)).
        Inj(i#) &
        Inj(pi#) &
        (!(ax : mem(X#))  (sx : mem(X#)).
            (?(a : mem(A#)). ax# = App(i#, a#)) &
            (?(s : mem(Pow(A#))). sx# = App(pi#, s#)) ==>
            (Holds(R#, ax#, sx#) <=>
              ?(a : mem(A#))  (s : mem(Pow(A#))).
                IN(a#, s#) & App(i#, a#) = ax# & App(pi#, s#) = sx#)) ==>
        !(A1 : set)  (i1 : fun(A1#, X#))  (pi1 : fun(Pow(A1#), X#)).
          Inj(i1#) &
          Inj(pi1#) &
          (!(ax : mem(X#))  (sx : mem(X#)).
              (?(a1 : mem(A1#)). ax# = App(i1#, a1#)) &
              (?(s1 : mem(Pow(A1#))). sx# = App(pi1#, s1#)) ==>
              (Holds(R#, ax#, sx#) <=>
                ?(a1 : mem(A1#))  (s1 : mem(Pow(A1#))).
                  IN(a1#, s1#) & App(i1#, a1#) = ax# & App(pi1#, s1#) = sx#)) &
          IMAGE(i#, Whole(A#)) = IMAGE(i1#, Whole(A1#)) &
          IMAGE(pi#, Whole(Pow(A#))) = IMAGE(pi1#, Whole(Pow(A1#))) ==>
          ?(f : fun(A#, A1#)).
            Bij(f#) & i1# o f# = i# & pi1# o Image(f#) = pi#: thm
val Upow_choice_independence =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n0 : mem(N)).
          Lt(n0#, n#) ==>
          ?(uA : set)  (ui : fun(uA#, X#))  (upi : fun(Pow(uA#), X#)).
            Inj(ui#) &
            Inj(upi#) &
            IMAGE(ui#, Whole(uA#)) = FIB(p#, n0#) &
            IMAGE(upi#, Whole(Pow(uA#))) = FIB(p#, Suc(n0#)) &
            (!(a : mem(uA#))  (s : mem(Pow(uA#))).
                Holds(R#, App(ui#, a#), App(upi#, s#)) <=> IN(a#, s#)) &
            !(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#)).
              Inj(i#) &
              Inj(pi#) &
              IMAGE(i#, Whole(A#)) = FIB(p#, n0#) &
              IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, Suc(n0#)) &
              (!(a : mem(A#))  (s : mem(Pow(A#))).
                  Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) ==>
              ?(f : fun(uA#, A#)).
                Bij(f#) & i# o f# = ui# & pi# o Image(f#) = upi#: thm
val FIB_PREIM_FIB =
   {}, 
   |- !(A1 : set)  (A2 : set)  (i : fun(A1#, A2#))  (X : set)
      (p1 : fun(A1#, X#))  (p2 : fun(A2#, X#)).
        p2# o i# = p1# ==>
        !(x : mem(X#)). FIB(p1#, x#) = PREIM(i#, FIB(p2#, x#)): thm
val Image_Id = {},  |- !(A : set). Image(Id(A#)) = Id(Pow(A#)): thm
val Upows_p1_O_iff_z1 =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(x : mem(X#)). (?(n : mem(N)). x# = App(z#, n#)) <=> App(p#, x#) = O:
   thm
val Upows_Le_n =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==> !(x : mem(X#)). Le(App(p#, x#), n#): thm
val Upows_Lt_i_ex =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n0 : mem(N)).
          Lt(n0#, n#) ==>
          ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p#, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#): thm
val IMAGE_eq_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))  (C : set)
      (p : fun(B#, C#))  (c : mem(C#)).
        IMAGE(f#, s#) = FIB(p#, c#) <=>
        !(b : mem(B#)).
          (?(a : mem(A#)). IN(a#, s#) & App(f#, a#) = b#) <=>
          App(p#, b#) = c#: thm
val Inj_Inj_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_o_comm =
   {}, 
   |- !(X1 : set)  (X2 : set)  (f : fun(X1#, X2#)).
        Bij(f#) ==>
        !(B : set)  (p1 : fun(X1#, B#))  (p2 : fun(X2#, B#)).
          p2# o f# = p1# ==>
          !(A : set)  (i : fun(A#, X1#))  (b : mem(B#)).
            IMAGE(i#, Whole(A#)) = FIB(p1#, b#) ==>
            IMAGE(f# o i#, Whole(A#)) = FIB(p2#, b#): thm
val Inj_Apr =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
          Holds(Apr(f#, R#), App(f#, a1#), App(f#, a2#)) <=>
          Holds(R#, a1#, a2#): thm
val Bij_Apr =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==>
        !(R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
          Holds(Apr(f#, R#), App(f#, a1#), App(f#, a2#)) <=>
          Holds(R#, a1#, a2#): thm
val Upows_iso_unique =
   {}, 
   |- !(n : mem(N))  (X1 : set)  (p1 : fun(X1#, N))  (R1 : rel(X1#, X1#))
      (z1 : fun(N, X1#))  (X2 : set)  (p2 : fun(X2#, N))
      (R2 : rel(X2#, X2#))  (z2 : fun(N, X2#)).
        Upows(n#, p1#, R1#, z1#) & Upows(n#, p2#, R2#, z2#) ==>
        !(f1 : fun(X1#, X2#))  (f2 : fun(X1#, X2#)).
          Bij(f1#) &
          Bij(f2#) &
          p2# o f1# = p1# &
          R2# = Apr(f1#, R1#) &
          f1# o z1# = z2# &
          p2# o f2# = p1# & R2# = Apr(f2#, R1#) & f2# o z1# = z2# ==>
          f1# = f2#: thm
val IMAGE_Union =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(A#))).
        IMAGE(f#, Union(s1#, s2#)) = Union(IMAGE(f#, s1#), IMAGE(f#, s2#)):
   thm
val IMAGE_coPa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (g : fun(B#, X#))
      (s : mem(Pow(A# + B#))).
        IMAGE(coPa(f#, g#), s#) =
          Union(IMAGE(f#, PREIM(i1(A#, B#), s#)),
           IMAGE(g#, PREIM(i2(A#, B#), s#))): thm
val PREIM_i12_Whole =
   {}, 
   |- !(A : set)  (B : set).
        PREIM(i1(A#, B#), Whole(A# + B#)) = Whole(A#) &
        PREIM(i2(A#, B#), Whole(A# + B#)) = Whole(B#): thm
val IMAGE_coPa_Whole =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (g : fun(B#, X#)).
        IMAGE(coPa(f#, g#), Whole(A# + B#)) =
          Union(IMAGE(f#, Whole(A#)), IMAGE(g#, Whole(B#))): thm
val Les_Suc = {},  |- !(n : mem(N)). Les(Suc(n#)) = Ins(Suc(n#), Les(n#)):
   thm
val Upows_z_Inj =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)). Upows(n#, p#, R#, z#) ==> Inj(z#): thm
val Upows_IMAGE_p =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==> IMAGE(p#, Whole(X#)) = Les(n#): thm
val Pow_NOT_EMPTY = {},  |- !(A : set). ?(s : mem(Pow(A#))). T: thm
val Union_comm =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Union(s2#, s1#): thm
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holQFOnLOScript.sml:966: error: Value or constructor (IN_FIB) has not been declared
Found near [GSYM IN_EXT_iff, IN_FIB, Empty_def, constf_def]
Exception- Fail "Static Errors" raised
> 
*** Emacs/HOL command completed ***

> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holnajECFScript.sml

******
val IN_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#: thm
val FIB_constf_Empty =
   {}, 
   |- !(B : set)  (b0 : mem(B#))  (b : mem(B#)).
        ~b# = b0# ==> !(A : set). FIB(constf(A#, b0#), b#) = Empty(A#): thm
val Upows_IMAGE_z =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==> IMAGE(z#, Whole(N)) = FIB(p#, O): thm
val NOT_Suc_Le = {},  |- !(n : mem(N)). ~Le(Suc(n#), n#): thm
val NOT_ex_F = {},  |- !(A : set). (?(a : mem(A#)). F) <=> F: thm
val i1_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        App(i1(A#, B#), a1#) = App(i1(A#, B#), a2#) <=> a1# = a2#: thm
val i2_Inj = {},  |- !(A : set)  (B : set). Inj(i2(A#, B#)): thm
val i2_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (b1 : mem(B#))  (b2 : mem(B#)).
        App(i2(A#, B#), b1#) = App(i2(A#, B#), b2#) <=> b1# = b2#: thm
val FIB_coPa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (g : fun(B#, X#))
      (x : mem(X#)).
        FIB(coPa(f#, g#), x#) =
          Union(IMAGE(i1(A#, B#), FIB(f#, x#)),
           IMAGE(i2(A#, B#), FIB(g#, x#))): thm
val Inj_IMAGE_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          IMAGE(f#, s1#) = IMAGE(f#, s2#) <=> s1# = s2#: thm
val i1_IMAGE_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        IMAGE(i1(A#, B#), s1#) = IMAGE(i1(A#, B#), s2#) <=> s1# = s2#: thm
val Upows_FIB_n_Lt_Empty =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n1 : mem(N)). Lt(n#, n1#) ==> FIB(p#, n1#) = Empty(X#): thm
val Upows_R =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(x : mem(X#))  (s : mem(X#)).
          Holds(R#, x#, s#) <=>
          Lt(App(p#, x#), n#) &
          Suc(App(p#, x#)) = App(p#, s#) &
          ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
          (a : mem(A#))  (sa : mem(Pow(A#))).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p#, App(p#, x#)) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, App(p#, s#)) &
            (!(a : mem(A#))  (s : mem(Pow(A#))).
                Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
            IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holnajECFScript.sml:148: error: Value or constructor (Suc_Le_Lt) has not been declared
Found near [GSYM Suc_Le_Lt]
Exception- Fail "Static Errors" raised
> 
*** Emacs/HOL command completed ***

> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holomAApBScript.sml

******
val Suc_Le_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(Suc(a#), b#) <=> Lt(a#, b#): thm
val Upows_R_last_clause =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        IMAGE(p#, Whole(X#)) = Les(n#) &
        Inj(z#) &
        IMAGE(z#, Whole(N)) = FIB(p#, O) &
        (!(n0 : mem(N)).
            Lt(n0#, n#) ==>
            ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#)).
              Inj(i#) &
              Inj(pi#) &
              IMAGE(i#, Whole(A#)) = FIB(p#, n0#) &
              IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, Suc(n0#)) &
              !(a : mem(A#))  (s : mem(Pow(A#))).
                Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) ==>
        (!(x : mem(X#))  (s : mem(X#)).
            Holds(R#, x#, s#) ==> Suc(App(p#, x#)) = App(p#, s#)) ==>
        !(x : mem(X#))  (s : mem(X#)).
          Holds(R#, x#, s#) <=>
          Lt(App(p#, x#), n#) &
          Suc(App(p#, x#)) = App(p#, s#) &
          ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
          (a : mem(A#))  (sa : mem(Pow(A#))).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p#, App(p#, x#)) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, App(p#, s#)) &
            (!(a : mem(A#))  (s : mem(Pow(A#))).
                Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
            IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
val Upows_alt =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) <=>
        IMAGE(p#, Whole(X#)) = Les(n#) &
        Inj(z#) &
        IMAGE(z#, Whole(N)) = FIB(p#, O) &
        (!(n0 : mem(N)).
            Lt(n0#, n#) ==>
            ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#)).
              Inj(i#) &
              Inj(pi#) &
              IMAGE(i#, Whole(A#)) = FIB(p#, n0#) &
              IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, Suc(n0#)) &
              !(a : mem(A#))  (s : mem(Pow(A#))).
                Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
        !(x : mem(X#))  (s : mem(X#)).
          Holds(R#, x#, s#) ==> Suc(App(p#, x#)) = App(p#, s#): thm
val Upows_R_imp_Suc =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(x : mem(X#))  (s : mem(X#)).
          Holds(R#, x#, s#) ==> Suc(App(p#, x#)) = App(p#, s#): thm
val Upows_Suc =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(A : set)  (i : fun(A#, X#)).
          Inj(i#) & IMAGE(i#, Whole(A#)) = FIB(p#, n#) ==>
          !(R1 : rel(X# + Pow(A#), X# + Pow(A#))).
            (!(x1 : mem(X# + Pow(A#)))  (s1 : mem(X# + Pow(A#))).
                Holds(R1#, x1#, s1#) <=>
                (?(x : mem(X#))  (s : mem(X#)).
                    App(i1(X#, Pow(A#)), x#) = x1# &
                    App(i1(X#, Pow(A#)), s#) = s1# & Holds(R#, x#, s#)) |
                ?(a : mem(A#))  (s : mem(Pow(A#))).
                  App(i1(X#, Pow(A#)) o i#, a#) = x1# &
                  App(i2(X#, Pow(A#)), s#) = s1# & IN(a#, s#)) ==>
            Upows(Suc(n#), coPa(p#, constf(Pow(A#), Suc(n#))), R1#,
             i1(X#, Pow(A#)) o z#): thm
val IMAGE_i1_fac =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# + B#)).
        SS(IMAGE(f#, Whole(X#)), IMAGE(i1(A#, B#), Whole(A#))) ==>
        ?(f0 : fun(X#, A#)). f# = i1(A#, B#) o f0#: thm
val IMAGE_Inj_fac =
   {}, 
   |- !(X : set)  (B : set)  (i : fun(X#, B#)).
        Inj(i#) ==>
        !(A : set)  (f : fun(A#, B#)).
          SS(IMAGE(f#, Whole(A#)), IMAGE(i#, Whole(X#))) ==>
          ?(f0 : fun(A#, X#)). f# = i# o f0#: thm
val NOT_Le_Suc = {},  |- !(n : mem(N)). ~Le(Suc(n#), n#): thm
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holomAApBScript.sml:413: error: Value or constructor (IMAGE_Whole) has not been declared
Found near [GSYM IMAGE_Whole]
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holomAApBScript.sml:483: error: Value or constructor (IMAGE_Whole) has not been declared
Found near [GSYM IMAGE_Whole]
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holomAApBScript.sml:486: error: Value or constructor (IMAGE_Whole) has not been declared
Found near [GSYM IMAGE_Whole]
Exception- Fail "Static Errors" raised
> 
*** Emacs/HOL command completed ***

> # # # # # val IMAGE_Whole =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (b : mem(B#)).
        IN(b#, IMAGE(f#, Whole(A#))) <=> ?(a : mem(A#)). b# = App(f#, a#):
   thm
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol4zwfQbScript.sml

******
val Upows_embed =
   {}, 
   |- !(n : mem(N))  (X1 : set)  (p1 : fun(X1#, N))  (R1 : rel(X1#, X1#))
      (z1 : fun(N, X1#)).
        Upows(Suc(n#), p1#, R1#, z1#) ==>
        !(X : set)  (inc : fun(X#, X1#))  (p : fun(X#, N))  (R : rel(X#, X#))
        (z : fun(N, X#)).
          Inj(inc#) &
          IMAGE(inc#, Whole(X#)) = Diff(Whole(X1#), FIB(p1#, Suc(n#))) &
          IMAGE(p#, Whole(X#)) = Les(n#) &
          p1# o inc# = p# &
          inc# o z# = z1# &
          (!(x : mem(X#))  (s : mem(X#)).
              Holds(R#, x#, s#) <=> Holds(R1#, App(inc#, x#), App(inc#, s#))) ==>
          Upows(n#, p#, R#, z#): thm
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol4zwfQbScript.sml:144: error: Value or constructor (Upows_p_NOT_n_imp_Lt) has not been declared
Found near
  prove_store ("Upows_embed_ex", e0 (... >> ...) (form_goal (... ...)))
Exception- Fail "Static Errors" raised
> 
*** Emacs/HOL command completed ***

> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holzcQzpWScript.sml

******
val Upows_p_NOT_n_imp_Lt =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(x : mem(X#)). ~App(p#, x#) = n# <=> Lt(App(p#, x#), n#): thm
val Upows_embed_ex =
   {}, 
   |- !(n : mem(N))  (X1 : set)  (p1 : fun(X1#, N))  (R1 : rel(X1#, X1#))
      (z1 : fun(N, X1#)).
        Upows(Suc(n#), p1#, R1#, z1#) ==>
        ?(X : set)  (inc : fun(X#, X1#))  (p : fun(X#, N))  (R : rel(X#, X#))
        (z : fun(N, X#)).
          Inj(inc#) &
          IMAGE(inc#, Whole(X#)) = Diff(Whole(X1#), FIB(p1#, Suc(n#))) &
          IMAGE(p#, Whole(X#)) = Les(n#) &
          p1# o inc# = p# &
          inc# o z# = z1# &
          (!(x : mem(X#))  (s : mem(X#)).
              Holds(R#, x#, s#) <=> Holds(R1#, App(inc#, x#), App(inc#, s#))) &
          Upows(n#, p#, R#, z#): thm
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holzcQzpWScript.sml:80: error: <identifier> expected but ) was found
/var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holzcQzpWScript.sml:81: error: ) expected but ; was found
Exception- Fail "Static Errors" raised
> 
*** Emacs/HOL command completed ***

> # # # # # poly: : error: <identifier> expected but ) was found
# poly: : error: ) expected but ; was found
Static Errors
> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#)).
                 Bij(f#) <=>
                 !(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   BA(f : fun(A, B))
   
   ----------------------------------------------------------------------
   (!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#) &
             (!(b : mem(B)). ?(a : mem(A)). App(f, a#) = b#) <=>
             !(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 3 subgoals:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   BA(x2 : mem(A))(x1 : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   ----------------------------------------------------------------------
   x1 = x2
   BA(b : mem(B))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.!(b : mem(B)). ?(a : mem(A)). App(f, a#) = b#
   ----------------------------------------------------------------------
   ?!(a : mem(A)). b = App(f, a#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.!(b : mem(B)). ?(a : mem(A)). App(f, a#) = b#
   ----------------------------------------------------------------------
   ?(a : mem(A)).
               b = App(f, a#) & !(a' : mem(A)). b = App(f, a'#) ==> a'# = a#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.App(f, a) = b
   ----------------------------------------------------------------------
   ?(a : mem(A)).
               b = App(f, a#) & !(a' : mem(A)). b = App(f, a'#) ==> a'# = a#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.App(f, a) = b
   ----------------------------------------------------------------------
   b = App(f, a) & !(a' : mem(A)). b = App(f, a'#) ==> a'# = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.App(f, a) = b
   ----------------------------------------------------------------------
   !(a' : mem(A)). b = App(f, a'#) ==> a'# = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.b = App(f, a)
   ----------------------------------------------------------------------
   !(a' : mem(A)). b = App(f, a'#) ==> a'# = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.b = App(f, a)
   ----------------------------------------------------------------------
   !(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   BA(x2 : mem(A))(x1 : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(f : fun(A, B))
   1.App(f, x1) = App(f, x2)
   2.?!(a : mem(A)). App(f, x2) = App(f, a#)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.App(f, x1) = App(f, x2)
   2.App(f, x2) = App(f, a)
   3.!(a' : mem(A)). App(f, x2) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("drule.find", [], [], []) raised
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=> !(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holc5gdbfScript.sml

******
2 subgoals:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   BA(x2 : mem(A))(x1 : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, x2) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.a = a
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, x2) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=> !(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holxG0AA2Script.sml

******
2 subgoals:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   BA(x2 : mem(A))(x1 : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x1) = App(f, a)
   4.!(a' : mem(A)). App(f, x1) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = a & x2 = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x2 = a
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   ----------------------------------------------------------------------
   App(f, a) = App(f, x1)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x2 = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.?!(a : mem(A)). b = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.b = App(f, a)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.b = App(f, a)
   ----------------------------------------------------------------------
   App(f, a) = b
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> !(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#):
   proofmanager.proof
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holiJuYU5Script.sml

******
Exception- ERR ("drule.find", [], [], []) raised
> 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#)).
                 Bij(f#) <=>
                 !(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/hol4mCnmTScript.sml

******
2 subgoals:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x2 = a
   : proofmanager.proof
val it = (): unit
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=> !(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holy3iAMCScript.sml

******
2 subgoals:
val it =
   BA(b : mem(B))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(a : mem(A)). App(f, a#) = b
   BA(x2 : mem(A))(x1 : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   ----------------------------------------------------------------------
   x1 = x2
   : proofmanager.proof
val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 1 subgoal:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = a & x2 = a
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x2 = a
   BA(x2 : mem(A))(x1 : mem(A))(a : mem(A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.App(f, x1) = App(f, x2)
   3.App(f, x2) = App(f, a)
   4.!(a' : mem(A)). App(f, a) = App(f, a'#) ==> a'# = a
   ----------------------------------------------------------------------
   x1 = a
   : proofmanager.proof
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holOvEGvoScript.sml

******
val Bij_char =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> !(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#): thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#)).
                 Bij(f#) <=>
                 ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#)]:
   proofmanager.proofs
> val it = (): unit
> Bij_op;
val it =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> ?(f' : fun(B#, A#)). asR(f'#) = op(asR(f#)): thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f : fun(A, B))
   
   ----------------------------------------------------------------------
   Bij(f) <=> ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=>
               ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   BA(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   Inj(f) & Surj(f)
   BA(f : fun(A, B))
   1.Inj(f)
   2.Surj(f)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=>
               ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   BA(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   Bij(f)
   BA(f : fun(A, B))
   1.Bij(f)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f : fun(A, B))
   1.Bij(f)
   2.?(f' : fun(B, A)). asR(f'#) = op(asR(f))
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.Bij(f)
   2.asR(f') = op(asR(f))
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=>
               ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#):
   proofmanager.proof
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=>
               ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   BA(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   (!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#) &
             !(b : mem(B)). ?(a : mem(A)). App(f, a#) = b#
   BA(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.!(b : mem(B)). ?(a : mem(A)). App(f, a#) = b#
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               Bij(f#) <=>
               ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#):
   proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               (!(b : mem(B#)). ?!(a : mem(A#)). b# = App(f#, a#)) <=>
               ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f : fun(A, B))
   
   ----------------------------------------------------------------------
   (!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)) <=>
             ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   BA(b : mem(B))(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   ?!(a : mem(A)). b = App(f, a#)
   BA(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
> # # Exception- UNCHANGED raised
> # val it =
   {(A : set), (B : set)}, 
   |- (!(x : mem(B)). ?!(y : mem(A)). P(x#, y#)) ==>
      ?(f : fun(B, A)).
        !(a : mem(B))  (b : mem(A)). App(f#, a#) = b# <=> P(a#, b#): thm
> # # val it =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- (!(x : mem(B)). ?!(y : mem(A)). x# = App(f, y#)) ==>
      ?(f' : fun(B, A)).
        !(a : mem(B))  (b : mem(A)). App(f'#, a#) = b# <=> a# = App(f, b#):
   thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # 1 subgoal:
val it =
   BA(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.?(f' : fun(B, A)).
               !(a : mem(B))  (b : mem(A)).
                 App(f'#, a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   f o f' = Id(B) & f' o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception-
   ERR
     ("exists_tac.goal is not an existential", [], [],
      [Conn
        ("&",
         [Pred ("=", true, [f o f', Id(B)]),
          Pred ("=", true, [f' o f, Id(A)])])]) raised
> val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   f o f' = Id(B) & f' o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   (!(a : mem(B)). App(f o f', a#) = App(Id(B), a#)) &
             !(a : mem(A)). App(f' o f, a#) = App(Id(A), a#)
   : proofmanager.proof
> val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   f o f' = Id(B) & f' o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   (!(a : mem(B)). App(f o f', a#) = a#) &
             !(a : mem(A)). App(f' o f, a#) = a#
   : proofmanager.proof
> val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   f o f' = Id(B) & f' o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   (!(a : mem(B)). App(f, App(f', a#)) = a#) &
             !(a : mem(A)). App(f', App(f, a#)) = a#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). App(f', a#) = b# <=> a# = App(f, b#)
   ----------------------------------------------------------------------
   !(a : mem(B)). App(f, App(f', a#)) = a#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). a# = App(f, b#) <=> App(f', a#) = b#
   ----------------------------------------------------------------------
   !(a : mem(B)). App(f, App(f', a#)) = a#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(f' : fun(B, A))(f : fun(A, B))
   1.!(b : mem(B)). ?!(a : mem(A)). b# = App(f, a#)
   2.!(a : mem(B))  (b : mem(A)). a# = App(f, b#) <=> App(f', a#) = b#
   ----------------------------------------------------------------------
   !(a : mem(B)). a# = App(f, App(f', a#))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   BA(b : mem(B))(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   ?!(a : mem(A)). b = App(f, a#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   ?(a : mem(A)).
               b = App(f, a#) & !(a' : mem(A)). b = App(f, a'#) ==> a'# = a#
   : proofmanager.proof
> find_th "comm";
val it =
   [("Add_comm",
     {},  |- !(b : mem(N))  (a : mem(N)). Add(a#, b#) = Add(b#, a#)),
    ("Add_comm'",
     {},  |- !(b : mem(N))  (a : mem(N)). Add(b#, a#) = Add(a#, b#)),
    ("Addz_comm",
     {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Addz(z1#, z2#) = Addz(z2#, z1#)),
    ("Inj_o_comm",
     {}, 
     |- !(X1 : set)  (X2 : set)  (f : fun(X1#, X2#)).
          Bij(f#) ==>
          !(B : set)  (p1 : fun(X1#, B#))  (p2 : fun(X2#, B#)).
            p2# o f# = p1# ==>
            !(A : set)  (i : fun(A#, X1#))  (b : mem(B#)).
              IMAGE(i#, Whole(A#)) = FIB(p1#, b#) ==>
              IMAGE(f# o i#, Whole(A#)) = FIB(p2#, b#)),
    ("Mul_comm",
     {},  |- !(m : mem(N))  (n : mem(N)). Mul(m#, n#) = Mul(n#, m#)),
    ("Mulz_comm",
     {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Mulz(z1#, z2#) = Mulz(z2#, z1#)),
    ("Thm1_case1_comm_condition",
     {}, 
     |- !(B : set)  (f0 : fun(N, B#))  (g : fun(1, B#))
        (h : fun(N * B#, B#)).
          f0# o El(O) = g# & f0# o SUC = h# o Pa(Id(N), f0#) <=>
          Pa(Id(N), f0#) o El(O) = Pa(El(O), g#) &
          Pa((SUC o p1(N, B#)), h#) o Pa(Id(N), f0#) = Pa(Id(N), f0#) o SUC),
    ("Thm1_comm_eq_left",
     {}, 
     |- !(A : set)  (B : set)  (f : fun(A# * N, B#))  (g : fun(A#, B#)).
          Tp(f#) o El(O) = Tp1(g#) <=>
          f# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1)),
    ("Thm1_comm_eq_right",
     {}, 
     |- !(A : set)  (B : set)  (f : fun(A# * N, B#))
        (h : fun((A# * N) * B#, B#))
        (l : fun(A# * N * Exp(A#, B#), (A# * N) * B#)).
          Pa(Pa(p1(A#, N * Exp(A#, B#)), p1(N, Exp(A#, B#)) o
              p2(A#, N * Exp(A#, B#))), Ev(A#, B#) o
             Pa(p1(A#, N * Exp(A#, B#)), p2(N, Exp(A#, B#)) o
              p2(A#, N * Exp(A#, B#)))) = l# ==>
          (h# o Pa(Id(A# * N), f#) = f# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            Tp((h# o l#)) o Pa(Id(N), Tp(f#)) = Tp(f#) o SUC)),
    ("Union_comm",
     {}, 
     |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          Union(s1#, s2#) = Union(s2#, s1#)),
    ("comm_with_SUC_id",
     {}, 
     |- !(f : fun(N, N)).
          f# o El(O) = El(O) & f# o SUC = SUC o f# ==> f# = Id(N)),
    ("comm_with_SUC_id0",
     {}, 
     |- !(f : fun(N, N)). App(f#, O) = O & f# o SUC = SUC o f# ==> f# = Id(N)),
    ("p1_comm",
     {}, 
     |- !(A : set)  (B : set)  (C : set)  (f : fun(A#, C#)).
          f# o p1(A#, B#) = p1(C#, B#) o Prla(f#, Id(B#))),
    ("p2_comm",
     {}, 
     |- !(A : set)  (B : set)  (C : set)  (f : fun(B#, C#)).
          f# o p2(A#, B#) = p2(A#, C#) o Prla(Id(A#), f#)),
    ("rsmul_lsmul_comm",
     {}, 
     |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#)))
        (b : mem(G#)).
          rsmul(g#, lsmul(g#, a#, s#), b#) = lsmul(g#, a#, rsmul(g#, s#, b#)))]:
   (string * thm) list
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   b = App(f, App(g, b)) &
             !(a' : mem(A)). b = App(f, a'#) ==> a'# = App(g, b)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   !(a' : mem(A)). b = App(f, a'#) ==> a'# = App(g, b)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a' : mem(A))(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   3.b = App(f, a')
   ----------------------------------------------------------------------
   a' = App(g, b)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a' : mem(A))(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   3.b = App(f, a')
   ----------------------------------------------------------------------
   a' = App(g, App(f, a'))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#):
   proofmanager.proof
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holuyNDQiScript.sml

******
val Bij_inv =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> ?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#):
   thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#)).
                 Bij(f#) ==>
                 !(C : set)  (g : fun(B#, C#)). Bij(g#) ==> Bij(g# o f#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   CBA(g : fun(B, C))(f : fun(A, B))
   1.Bij(f)
   2.Bij(g)
   ----------------------------------------------------------------------
   Bij(g o f)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   CBA(g : fun(B, C))(f : fun(A, B))
   1.Inj(f)
   2.Surj(f)
   3.Inj(g)
   4.Surj(g)
   ----------------------------------------------------------------------
   Inj(g o f) & Surj(g o f)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   CBA(g : fun(B, C))(f : fun(A, B))
   1.Inj(f)
   2.Surj(f)
   3.Inj(g)
   4.Surj(g)
   ----------------------------------------------------------------------
   Surj(g o f)
   CBA(g : fun(B, C))(f : fun(A, B))
   1.Inj(f)
   2.Surj(f)
   3.Inj(g)
   4.Surj(g)
   ----------------------------------------------------------------------
   Inj(g o f)
   : proofmanager.proof
> # val it =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   CBA(g : fun(B, C))(f : fun(A, B))
   1.Inj(f)
   2.Surj(f)
   3.Inj(g)
   4.Surj(g)
   ----------------------------------------------------------------------
   Inj(f) & Inj(g)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   CBA(g : fun(B, C))(f : fun(A, B))
   1.Inj(f)
   2.Surj(f)
   3.Inj(g)
   4.Surj(g)
   ----------------------------------------------------------------------
   Surj(g o f)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # poly: : error: Value or constructor (Surj_Surj_o) has not been declared
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (irule Surj_Surj_o) before
     Feedback.set_trace "show_typecheck_errors" old end)
Static Errors
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # poly: : error: Value or constructor (Surj_Surj_o) has not been declared
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (irule Surj_Surj_o) before
     Feedback.set_trace "show_typecheck_errors" old end)
Static Errors
> # # # # # # # # # val Surj_Surj_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) ==>
        !(C : set)  (g : fun(B#, C#)). Surj(g#) ==> Surj(g# o f#): thm
> 
*** Emacs/HOL command completed ***

> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   CBA(g : fun(B, C))(f : fun(A, B))
   1.Inj(f)
   2.Surj(f)
   3.Inj(g)
   4.Surj(g)
   ----------------------------------------------------------------------
   Surj(f) & Surj(g)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> !(C : set)  (g : fun(B#, C#)). Bij(g#) ==> Bij(g# o f#):
   proofmanager.proof
> # # # # # # # # val Bij_Bij_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> !(C : set)  (g : fun(B#, C#)). Bij(g#) ==> Bij(g# o f#):
   thm
> > val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#)).
                 Bij(f#) <=>
                 ?(g : fun(B#, A#)).
                   Bij(g#) & f# o g# = Id(B#) & g# o f# = Id(A#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#)).
               (?(g : fun(B#, A#)). f# o g# = Id(B#) & g# o f# = Id(A#)) <=>
               ?(g : fun(B#, A#)).
                 (?(g : fun(A#, B#)). g# o g# = Id(A#) & g# o g# = Id(B#)) &
                 f# o g# = Id(B#) & g# o f# = Id(A#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   BA(g' : fun(A, B))(g : fun(B, A))(f : fun(A, B))
   1.g o g' = Id(A)
   2.g' o g = Id(B)
   3.f o g = Id(B)
   4.g o f = Id(A)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   BA(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)).
               (?(g : fun(A, B)). g# o g# = Id(A) & g# o g# = Id(B)) &
               f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   (?(g' : fun(A, B)). g o g'# = Id(A) & g'# o g = Id(B)) &
             f o g = Id(B) & g o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   ?(g' : fun(A, B)). g o g'# = Id(A) & g'# o g = Id(B)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(g : fun(B, A))(f : fun(A, B))
   1.f o g = Id(B)
   2.g o f = Id(A)
   ----------------------------------------------------------------------
   g o f = Id(A) & f o g = Id(B)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   BA(g' : fun(A, B))(g : fun(B, A))(f : fun(A, B))
   1.g o g' = Id(A)
   2.g' o g = Id(B)
   3.f o g = Id(B)
   4.g o f = Id(A)
   ----------------------------------------------------------------------
   ?(g : fun(B, A)). f o g# = Id(B) & g# o f = Id(A)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=>
        ?(g : fun(B#, A#)). Bij(g#) & f# o g# = Id(B#) & g# o f# = Id(A#):
   proofmanager.proof
> # # # # # # # # # # poly: : error: Value or constructor (eqexists_tac) has not been declared
Found near prove_store ("Bij_inv'", e0 (... >> ...) (form_goal (... ...)))
Static Errors
> # # # # # # # # # val Bij_inv' =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=>
        ?(g : fun(B#, A#)). Bij(g#) & f# o g# = Id(B#) & g# o f# = Id(A#):
   thm
> > 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # # # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(X1 : set)  (p1 : fun(X1#, N))  (R1 : rel(X1#, X1#))
               (z1 : fun(N, X1#))  (X2 : set)  (p2 : fun(X2#, N))
               (R2 : rel(X2#, X2#))  (z2 : fun(N, X2#)).
                 Upows(O, p1#, R1#, z1#) & Upows(O, p2#, R2#, z2#) ==>
                 ?(f : fun(X1#, X2#)).
                   Bij(f#) &
                   p2# o f# = p1# & R2# = Apr(f#, R1#) & f# o z1# = z2#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # # 1 subgoal:
val it =
   X2X1(R2 : rel(X2, X2))(R1 : rel(X1, X1))(z2 : fun(N, X2))(z1 : fun(N, X1))(p2 :
      fun(X2, N))(p1 : fun(X1, N))(g : fun(X1, N))
   1.IMAGE(z1, Whole(N)) = FIB(p1, O)
   2.p1 = constf(X1, O)
   3.!(x1 : mem(X1))  (x2 : mem(X1)). ~Holds(R1, x1#, x2#)
   4.Bij(z1)
   5.IMAGE(z2, Whole(N)) = FIB(p2, O)
   6.p2 = constf(X2, O)
   7.!(x1 : mem(X2))  (x2 : mem(X2)). ~Holds(R2, x1#, x2#)
   8.Bij(z2)
   9.Bij(g)
   10.z1 o g = Id(X1)
   11.g o z1 = Id(N)
   ----------------------------------------------------------------------
   Bij(z2 o g) &
             constf(X2, O) o z2 o g = constf(X1, O) &
             R2 = Apr(z2 o g, R1) & (z2 o g) o z1 = z2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # val it =
   PROVED!{}, 
   |- !(X1 : set)  (p1 : fun(X1#, N))  (R1 : rel(X1#, X1#))
      (z1 : fun(N, X1#))  (X2 : set)  (p2 : fun(X2#, N))
      (R2 : rel(X2#, X2#))  (z2 : fun(N, X2#)).
        Upows(O, p1#, R1#, z1#) & Upows(O, p2#, R2#, z2#) ==>
        ?(f : fun(X1#, X2#)).
          Bij(f#) & p2# o f# = p1# & R2# = Apr(f#, R1#) & f# o z1# = z2#:
   proofmanager.proof
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holl71Yj8Script.sml

******
val Upows_O_iso =
   {}, 
   |- !(X1 : set)  (p1 : fun(X1#, N))  (R1 : rel(X1#, X1#))
      (z1 : fun(N, X1#))  (X2 : set)  (p2 : fun(X2#, N))
      (R2 : rel(X2#, X2#))  (z2 : fun(N, X2#)).
        Upows(O, p1#, R1#, z1#) & Upows(O, p2#, R2#, z2#) ==>
        ?(f : fun(X1#, X2#)).
          Bij(f#) & p2# o f# = p1# & R2# = Apr(f#, R1#) & f# o z1# = z2#: thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
                 IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
               (?(b' : mem(B#)). b'# = b# & App(f#, a#) = b'#) <=>
               App(f#, a#) = b#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   
   ----------------------------------------------------------------------
   (?(b' : mem(B)). b'# = b & App(f, a) = b'#) <=> App(f, a) = b
   : proofmanager.proof
> # poly: : error: Value or constructor (EXISTS_EQN_FCONV) has not been declared
Found near EXISTS_EQN_FCONV
Static Errors
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holcko3UiScript.sml

******
val EXISTS_EQN_FCONV = fn: form -> thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> # poly: : error: Value or constructor (EXISTS_EQ_FCONV) has not been declared
Found near EXISTS_EQ_FCONV
Static Errors
> # val it =
   {( 8 : set), (B : set), (a : mem( 8)), (b : mem(B)), (f : fun( 8, B))}, 
   |- (?(b' : mem(B)). b'# = b & App(f, a) = b'#) <=> App(f, a) = b: thm
> # val it =
   {(A : set), (B : set), (a : mem(A)), (b : mem(B)), (f : fun(A, B))}, 
   |- (?(b' : mem(B)). b'# = b & App(f, a) = b'#) <=> App(f, a) = b: thm
> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
                 IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # # # 2 subgoals:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.App(f, a) = b
   ----------------------------------------------------------------------
   ?(b' : mem(B)). b'# = b & App(f, a) = b'#
   BA(b' : mem(B))(b : mem(B))(a : mem(A))(f : fun(A, B))
   1.b' = b
   2.App(f, a) = b'
   ----------------------------------------------------------------------
   App(f, a) = b
   : proofmanager.proof
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
               IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#: proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   
   
   ----------------------------------------------------------------------
   !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
               (?(b' : mem(B#)). b'# = b# & App(f#, a#) = b'#) <=>
               App(f#, a#) = b#
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(b : mem(B))(a : mem(A))(f : fun(A, B))
   
   ----------------------------------------------------------------------
   (?(b' : mem(B)). b'# = b & App(f, a) = b'#) <=> App(f, a) = b
   : proofmanager.proof
> # val it = fn: conv -> fconv -> fconv
> # val it = fn: conv -> fconv -> tactic
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#: proofmanager.proof
> # # # # # # # val IN_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#: thm
> > val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : mem(N)). ~Le(Suc(n#), n#)]: proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (n : mem(N))
   
   ----------------------------------------------------------------------
   ~Le(Suc(n), n)
   : proofmanager.proof
> NOT_Le_Suc;
val it = {},  |- !(n : mem(N)). ~Le(Suc(n#), n#): thm
> find_th "NOT_LE";
val it =
   [("NOT_LESS",
     {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#)),
    ("NOT_LESS_EQ",
     {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#)),
    ("SUC_NOT_LESS_EQ", {},  |- !(a : mem(N)). ~Le(Suc(a#), a#))]:
   (string * thm) list
> # val NOT_Suc_Le = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set). (?(a : mem(A#)). F) <=> F]: proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   A
   
   ----------------------------------------------------------------------
   (?(a : mem(A)). F) <=> F
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("drule.no tactic", [], [], []) raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("drule.no tactic", [], [], []) raised
> val it =
   
   
   ----------------------------------------------------------------------
   !(A : set). (?(a : mem(A#)). F) <=> F: proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it = PROVED!{},  |- !(A : set). (?(a : mem(A#)). F) <=> F:
   proofmanager.proof
> # # # # # val NOT_ex_F = {},  |- !(A : set). (?(a : mem(A#)). F) <=> F: thm
> > val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (a1 : mem(A#))  (a2 : mem(A#)).
                 App(i1(A#, B#), a1#) = App(i1(A#, B#), a2#) <=> a1# = a2#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(a2 : mem(A))(a1 : mem(A))
   
   ----------------------------------------------------------------------
   App(i1(A, B), a1) = App(i1(A, B), a2) <=> a1 = a2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(a2 : mem(A))(a1 : mem(A))
   1.Inj(i1(A, B))
   ----------------------------------------------------------------------
   App(i1(A, B), a1) = App(i1(A, B), a2) <=> a1 = a2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(a2 : mem(A))(a1 : mem(A))
   1.Inj(i1(A, B))
   2.!(x1 : mem(A))  (x2 : mem(A)).
               App(i1(A, B), x1#) = App(i1(A, B), x2#) <=> x1# = x2#
   ----------------------------------------------------------------------
   App(i1(A, B), a1) = App(i1(A, B), a2) <=> a1 = a2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(A : set)  (B : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        App(i1(A#, B#), a1#) = App(i1(A#, B#), a2#) <=> a1# = a2#:
   proofmanager.proof
> # # # # # # # val i1_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        App(i1(A#, B#), a1#) = App(i1(A#, B#), a2#) <=> a1# = a2#: thm
> > # val it =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
> # val it =
   {(A : set), (B : set)}, 
   |- Inj(i1(A, B)) &
      Inj(i2(A, B)) &
      (!(a : mem(A))  (b : mem(B)). ~App(i1(A, B), a#) = App(i2(A, B), b#)) &
      !(ab : mem(A + B)).
        (?(a : mem(A)). ab# = App(i1(A, B), a#)) |
        ?(b : mem(B)). ab# = App(i2(A, B), b#): thm
> # # val it = {(A : set), (B : set)},  |- Inj(i2(A, B)): thm
> # # # # # val i2_Inj = {},  |- !(A : set)  (B : set). Inj(i2(A#, B#)): thm
> # # # # # # # val i2_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (b1 : mem(B#))  (b2 : mem(B#)).
        App(i2(A#, B#), b1#) = App(i2(A#, B#), b2#) <=> b1# = b2#: thm
> > val it = PRFS []: proofmanager.proofs
> # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
                 IMAGE(i1(A#, B#), s1#) = IMAGE(i1(A#, B#), s2#) <=>
                 s1# = s2#]: proofmanager.proofs
> val it = (): unit
> # val it =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          IMAGE(f#, s1#) = IMAGE(f#, s2#) <=> s1# = s2#: thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # Exception- ERR ("variable to be abstract occurs in assumption", [], [], [])
   raised
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(s2 : mem(Pow(A)))(s1 : mem(Pow(A)))
   
   ----------------------------------------------------------------------
   Inj(i1(A, B))
   : proofmanager.proof
> # # # # # # # # val i1_IMAGE_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        IMAGE(i1(A#, B#), s1#) = IMAGE(i1(A#, B#), s2#) <=> s1# = s2#: thm
> > val it = PRFS []: proofmanager.proofs
> # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(A : set)  (B : set)  (f : fun(A#, B#)).
                 Inj(f#) ==>
                 !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
                   IMAGE(f#, s1#) = IMAGE(f#, s2#) <=> s1# = s2#]:
   proofmanager.proofs
> val it = (): unit
> # val it =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(A#, B#)). Inj(i#) ==> Inj(Image(i#)):
   thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # poly: : error: Type error in function application.
   Function: >> : tactic * tactic -> tactic
   Argument: (rpt strip_tac, Inj_Image_Inj) : tactic * thm
   Reason:
      Can't unify thm to goal -> goal list * validation (Incompatible types)
Found near
  proofManagerLib.e
  (
  let val old = Feedback.current_trace "show_typecheck_errors";
     val _ = ... ... in
     (rpt strip_tac >> Inj_Image_Inj) before
     Feedback.set_trace "show_typecheck_errors" old end)
Static Errors
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(s2 : mem(Pow(A)))(s1 : mem(Pow(A)))(f : fun(A, B))
   1.Inj(f)
   2.Inj(Image(f))
   ----------------------------------------------------------------------
   IMAGE(f, s1) = IMAGE(f, s2) <=> s1 = s2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(s2 : mem(Pow(A)))(s1 : mem(Pow(A)))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.!(x1 : mem(Pow(A)))  (x2 : mem(Pow(A))).
               App(Image(f), x1#) = App(Image(f), x2#) ==> x1# = x2#
   ----------------------------------------------------------------------
   IMAGE(f, s1) = IMAGE(f, s2) <=> s1 = s2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(s2 : mem(Pow(A)))(s1 : mem(Pow(A)))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.!(x1 : mem(Pow(A)))  (x2 : mem(Pow(A))).
               IMAGE(f, x1#) = IMAGE(f, x2#) ==> x1# = x2#
   ----------------------------------------------------------------------
   IMAGE(f, s1) = IMAGE(f, s2) <=> s1 = s2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(s2 : mem(Pow(A)))(s1 : mem(Pow(A)))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.!(x1 : mem(Pow(A)))  (x2 : mem(Pow(A))).
               IMAGE(f, x1#) = IMAGE(f, x2#) ==> x1# = x2#
   3.IMAGE(f, s1) = IMAGE(f, s2)
   ----------------------------------------------------------------------
   s1 = s2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   BA(s2 : mem(Pow(A)))(s1 : mem(Pow(A)))(f : fun(A, B))
   1.!(x1 : mem(A))  (x2 : mem(A)). App(f, x1#) = App(f, x2#) ==> x1# = x2#
   2.IMAGE(f, s1) = IMAGE(f, s2)
   3.s1 = s2
   ----------------------------------------------------------------------
   s1 = s2
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          IMAGE(f#, s1#) = IMAGE(f#, s2#) <=> s1# = s2#: proofmanager.proof
> # # # # # # # # # # val Inj_IMAGE_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          IMAGE(f#, s1#) = IMAGE(f#, s2#) <=> s1# = s2#: thm
> > 
*** Emacs/HOL command completed ***

> # # # # # # # # val i1_IMAGE_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        IMAGE(i1(A#, B#), s1#) = IMAGE(i1(A#, B#), s2#) <=> s1# = s2#: thm
> > val it = PRFS []: proofmanager.proofs
> # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
               (z : fun(N, X#)).
                 Upows(n#, p#, R#, z#) ==>
                 !(n1 : mem(N)). Lt(n#, n1#) ==> FIB(p#, n1#) = Empty(X#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p : fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   ----------------------------------------------------------------------
   FIB(p, n1) = Empty(X)
   : proofmanager.proof
> Upows_def;
val it =
   {(R : rel(X, X)), (X : set), (n : mem(N)), (p : fun(X, N)),
    (z : fun(N, X))}, 
   |- Upows(n, p, R, z) <=>
      IMAGE(p, Whole(X)) = Les(n) &
      Inj(z) &
      IMAGE(z, Whole(N)) = FIB(p, O) &
      (!(n0 : mem(N)).
          Lt(n0#, n) ==>
          ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
      !(x : mem(X))  (s : mem(X)).
        Holds(R, x#, s#) <=>
        Lt(App(p, x#), n) &
        Suc(App(p, x#)) = App(p, s#) &
        ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))  (a : mem(A#))
        (sa : mem(Pow(A#))).
          Inj(i#) &
          Inj(pi#) &
          IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
          IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
          (!(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
          IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   X(R : rel(X, X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p : fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.IMAGE(p, Whole(X)) = Les(n)
   ----------------------------------------------------------------------
   FIB(p, n1) = Empty(X)
   X(R : rel(X, X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p : fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   ----------------------------------------------------------------------
   IMAGE(p, Whole(X)) = Les(n)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   X(R : rel(X, X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p : fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.IMAGE(p, Whole(X)) = Les(n)
   ----------------------------------------------------------------------
   FIB(p, n1) = Empty(X)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p : fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.IMAGE(p, Whole(X)) = Les(n)
   ----------------------------------------------------------------------
   !(x : mem(X)). ~App(p, x#) = n1
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.IMAGE(p, Whole(X)) = Les(n)
   ----------------------------------------------------------------------
   ~App(p, x) = n1
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.!(x : mem(N)). IN(x#, IMAGE(p, Whole(X))) <=> Le(x#, n)
   ----------------------------------------------------------------------
   ~App(p, x) = n1
   : proofmanager.proof
> val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.IMAGE(p, Whole(X)) = Les(n)
   ----------------------------------------------------------------------
   ~App(p, x) = n1
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.!(x : mem(N)). (?(a : mem(X)). x# = App(p, a#)) <=> Le(x#, n)
   ----------------------------------------------------------------------
   ~App(p, x) = n1
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.(?(a : mem(X)). App(p, x) = App(p, a#)) <=> Le(App(p, x), n)
   ----------------------------------------------------------------------
   ~App(p, x) = n1
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.Le(App(p, x), n)
   ----------------------------------------------------------------------
   ~App(p, x) = n1
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.Le(App(p, x), n)
   4.App(p, x) = n1
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.Le(n1, n)
   4.App(p, x) = n1
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> # val it = {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.Le(n1, n)
   4.App(p, x) = n1
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> val it =
   X(R : rel(X, X))(x : mem(X))(n1 : mem(N))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.Lt(n, n1)
   3.Le(n1, n)
   4.App(p, x) = n1
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> # val it = {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
> # poly: : error: Value or constructor (NOT_Lt) has not been declared Found near NOT_Lt
Static Errors
> find_th "NOT_LE";
val it =
   [("NOT_LESS",
     {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#)),
    ("NOT_LESS_EQ",
     {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#)),
    ("SUC_NOT_LESS_EQ", {},  |- !(a : mem(N)). ~Le(Suc(a#), a#))]:
   (string * thm) list
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n1 : mem(N)). Lt(n#, n1#) ==> FIB(p#, n1#) = Empty(X#):
   proofmanager.proof
> # # # # # # # # # # # # # # # # val Upows_FIB_n_Lt_Empty =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n1 : mem(N)). Lt(n#, n1#) ==> FIB(p#, n1#) = Empty(X#): thm
> > 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
               (z : fun(N, X#)).
                 Upows(n#, p#, R#, z#) ==>
                 !(x : mem(X#))  (s : mem(X#)).
                   Holds(R#, x#, s#) <=>
                   Lt(App(p#, x#), n#) &
                   Suc(App(p#, x#)) = App(p#, s#) &
                   ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
                   (a : mem(A#))  (sa : mem(Pow(A#))).
                     Inj(i#) &
                     Inj(pi#) &
                     IMAGE(i#, Whole(A#)) = FIB(p#, App(p#, x#)) &
                     IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, App(p#, s#)) &
                     (!(a : mem(A#))  (s : mem(Pow(A#))).
                         Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                     IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> #   C-c C-c
Process HOL killed: 9
> Loading empty hol-mode.sml
> > > use "SEARmaster.ML";
val use = fn: string -> unit
******

Loading SEAR file SEARsorts.sml

******
val fun_sort = fn: term -> term -> sort
val mem_sort = fn: term -> sort
val mk_func = fn: string -> term -> term -> term
val mk_mem = fn: string -> term -> term
val mk_rel = fn: string -> term -> term -> term
val mk_set = fn: string -> term
val rel_sort = fn: term -> term -> sort
val set_sort = set: sort
val it = (): unit
******

Loading SEAR file SEARnewspec.sml

******
val define_fsym = fn: string * (string * sort) list -> term -> thm
val define_fsym_lemma_fun =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : fun(A#, B#)).
        ?!(newfsym : fun(A#, B#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_mem =
   {}, 
   |- !(A : set)  (newfsym0 : mem(A#)).
        ?!(newfsym : mem(A#)). newfsym# = newfsym0#: thm
val define_fsym_lemma_rel =
   {}, 
   |- !(A : set)  (B : set)  (newfsym0 : rel(A#, B#)).
        ?!(newfsym : rel(A#, B#)). newfsym# = newfsym0#: thm
val funeqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : fun(A#, B#)). i# = i#) &
        (!(i : fun(A#, B#))  (i' : fun(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : fun(A#, B#))  (i' : fun(A#, B#))  (i'' : fun(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val memeqeqvth =
   {}, 
   |- !(A : set).
        (!(i : mem(A#)). i# = i#) &
        (!(i : mem(A#))  (i' : mem(A#)). i# = i'# ==> i'# = i#) &
        !(i : mem(A#))  (i' : mem(A#))  (i'' : mem(A#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val qdefine_fsym = fn: string * term frag list list -> term frag list -> thm
val qsimple_uex_spec = fn: string -> term frag list list -> thm -> thm
val quex_spec = fn: string -> term frag list list -> thm -> thm -> thm
val releqeqvth =
   {}, 
   |- !(A : set)  (B : set).
        (!(i : rel(A#, B#)). i# = i#) &
        (!(i : rel(A#, B#))  (i' : rel(A#, B#)). i# = i'# ==> i'# = i#) &
        !(i : rel(A#, B#))  (i' : rel(A#, B#))  (i'' : rel(A#, B#)).
          i# = i'# & i'# = i''# ==> i# = i''#: thm
val simple_uex_spec = fn: string -> (string * sort) list -> thm -> thm
val uex_spec = fn: string -> (string * sort) list -> thm -> thm -> thm
val it = (): unit
******

Loading SEAR file SEARrel.sml

******
val AX1 =
   {}, 
   |- !(A : set)  (B : set).
        ?!(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val Fun_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=> !(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#): thm
val R_EXT =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        (!(a : mem(A#))  (b : mem(B#)).
            Holds(R1#, a#, b#) <=> Holds(R2#, a#, b#)) <=> R1# = R2#: thm
val AX1_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#) <=> P(a#, b#): thm
val ao_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, c#)) <=>
        Holds(psi# @ phi#, a#, c#): thm
val ao_def0 =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (a : mem(A#))  (b : mem(C#)).
        (?(b : mem(B#)). Holds(phi#, a#, b#) & Holds(psi#, b#, b#)) <=>
        Holds(psi# @ phi#, a#, b#): thm
val ao_uex =
   {(A : set), (B : set), (C : set), (phi : rel(A, B)), (psi : rel(B, C))}, 
   |- ?!(R : rel(A, C)).
        !(a : mem(A))  (b : mem(C)).
          Holds(R#, a#, b#) <=>
          ?(b : mem(B)). Holds(phi, a#, b#) & Holds(psi, b#, b#): thm
val Fun_expand =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) <=>
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) &
        !(a : mem(A#))  (b1 : mem(B#))  (b2 : mem(B#)).
          Holds(R#, a#, b1#) & Holds(R#, a#, b2#) ==> b1# = b2#: thm
val id_Fun = {},  |- !(A : set). isFun(id(A#)): thm
val id_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)).
        Holds(id(A#), a#, b#) <=> a# = b#: thm
val id_uex =
   {(A : set)}, 
   |- ?!(R : rel(A, A)).
        !(a : mem(A))  (b : mem(A)). Holds(R#, a#, b#) <=> a# = b#: thm
val idL = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). id(B#) @ f# = f#:
   thm
val idR = {},  |- !(A : set)  (B : set)  (f : rel(A#, B#)). f# @ id(A#) = f#:
   thm
val Thm_2_7_ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val Thm_2_7_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val Thm_2_7_id =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#)).
        phi# @ id(A#) = phi# & id(B#) @ phi# = phi#: thm
val op_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(B#))  (b : mem(A#)).
        Holds(op(R#), a#, b#) <=> Holds(R#, b#, a#): thm
val op_uex =
   {(A : set), (B : set), (R : rel(A, B))}, 
   |- ?!(R' : rel(B, A)).
        !(a : mem(B))  (b : mem(A)). Holds(R'#, a#, b#) <=> Holds(R, b#, a#):
   thm
val ao_Fun =
   {}, 
   |- !(A : set)  (B : set)  (f : rel(A#, B#))  (C : set)  (g : rel(B#, C#)).
        isFun(f#) & isFun(g#) ==> isFun(g# @ f#): thm
val ao_assoc =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#))  (D : set)  (chi : rel(C#, D#)).
        (chi# @ psi#) @ phi# = chi# @ psi# @ phi#: thm
val op_DISTR =
   {}, 
   |- !(A : set)  (B : set)  (phi : rel(A#, B#))  (C : set)
      (psi : rel(B#, C#)). op(psi# @ phi#) = op(phi#) @ op(psi#): thm
val Refl_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> !(a : mem(A#)). Holds(R#, a#, a#): thm
val Sym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> Holds(R#, a2#, a1#): thm
val Trans_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Trans(R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#))  (a3 : mem(A#)).
          Holds(R#, a1#, a2#) & Holds(R#, a2#, a3#) ==> Holds(R#, a1#, a3#):
   thm
val ER_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) <=> Refl(R#) & Sym(R#) & Trans(R#): thm
val Sym_Trans_Rright =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Sym(R#) & Trans(R#) ==>
        !(x : mem(A#))  (y : mem(A#)).
          Holds(R#, x#, y#) ==>
          !(z : mem(A#)). Holds(R#, x#, z#) <=> Holds(R#, y#, z#): thm
val op_op =
   {},  |- !(A : set)  (B : set)  (R : rel(A#, B#)). op(op(R#)) = R#: thm
val it = (): unit
******

Loading SEAR file SEARfun.sml

******
val rel2fun =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val rel2fun_ex =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        isFun(R#) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val rel2fun_ex' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(x : mem(A#)). ?!(y : mem(B#)). Holds(R#, x#, y#)) ==>
        ?(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)).
            App(f#, a#) = b# <=> Holds(R#, a#, b#): thm
val P2fun' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val asR_Fun =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). isFun(asR(f#)): thm
val asR_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- !(a : mem(A))  (b : mem(B)). Holds(asR(f), a#, b#) <=> App(f, a#) = b#:
   thm
val asR_uex =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- ?!(R : rel(A, B)).
        !(a : mem(A))  (b : mem(B)). Holds(R#, a#, b#) <=> App(f, a#) = b#:
   thm
val FUN_EXT =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        (!(a : mem(A#)). App(f1#, a#) = App(f2#, a#)) <=> f1# = f2#: thm
val P2fun_uex =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val fun_tm_compr = fn: string * sort -> term -> thm
val fun_tm_compr_uex = fn: string * sort -> term -> thm
val qfun_compr = fn: term frag list -> term frag list -> thm
val unique_lemma =
   {},  |- !(A : set)  (a : mem(A#)). ?!(a' : mem(A#)). a'# = a#: thm
val App_Id = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_def = {},  |- !(A : set)  (a : mem(A#)). App(Id(A#), a#) = a#: thm
val Id_uex =
   {(A : set)}, 
   |- ?!(f : fun(A, A)).
        !(a : mem(A))  (b : mem(A)).
          App(f#, a#) = b# <=> Holds(id(A), a#, b#): thm
val o_ex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val o_uex =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#)).
        ?!(f : fun(A#, C#)).
          !(a : mem(A#))  (c : mem(C#)).
            App(f#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#): thm
val Inj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) <=>
        !(x1 : mem(A#))  (x2 : mem(A#)).
          App(f#, x1#) = App(f#, x2#) ==> x1# = x2#: thm
val o_def =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#))  (C : set)
      (psi : fun(B#, C#))  (a : mem(A#))  (c : mem(C#)).
        App(psi# o phi#, a#) = c# <=> Holds(asR(psi#) @ asR(phi#), a#, c#):
   thm
val Surj_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) <=> !(b : mem(B#)). ?(a : mem(A#)). App(f#, a#) = b#: thm
val Bij_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) <=> Inj(f#) & Surj(f#): thm
val Bij_op =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==> ?(f' : fun(B#, A#)). asR(f'#) = op(asR(f#)): thm
val App_App_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val App_o_l =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (a : mem(A#)). App(g# o f#, a#) = App(g#, App(f#, a#)): thm
val asR_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        asR(g# o f#) = asR(g#) @ asR(f#): thm
val asR_Id = {},  |- !(A : set). asR(Id(A#)) = id(A#): thm
val asR_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        asR(f1#) = asR(f2#) <=> f1# = f2#: thm
val Thm_2_7_bij =
   {}, 
   |- !(A : set)  (B : set)  (phi : fun(A#, B#)).
        Bij(phi#) <=>
        ?(psi : fun(B#, A#)). psi# o phi# = Id(A#) & phi# o psi# = Id(B#):
   thm
val Inj_lcancel =
   {}, 
   |- !(A : set)  (B : set)  (m : fun(A#, B#)).
        Inj(m#) ==>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, A#)).
          m# o f# = m# o g# ==> f# = g#: thm
val IdL = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Id(B#) o f# = f#:
   thm
val IdR = {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). f# o Id(A#) = f#:
   thm
val Inj_lift_R_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(R : rel(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?!(a2 : mem(A#)). Holds(R#, App(i#, a1#), App(i#, a2#))) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). Holds(R#, App(i#, a#), App(i# o f#, a#)): thm
val Inj_lift_fun_lemma =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val asR_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        Holds(asR(f#), a#, b#) <=> App(f#, a#) = b#: thm
val Inj_lift_fun_lemma' =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(f0 : fun(A0#, A0#)).
          (!(a1 : mem(A#)).
              ?(a2 : mem(A#)). App(f0# o i#, a1#) = App(i#, a2#)) ==>
          ?!(f : fun(A#, A#)).
            !(a : mem(A#)). App(i# o f#, a#) = App(f0# o i#, a#): thm
val Inj_eq_eq =
   {}, 
   |- !(X : set)  (Y : set)  (i : fun(X#, Y#)).
        Inj(i#) ==>
        !(x1 : mem(X#))  (x2 : mem(X#)).
          App(i#, x1#) = App(i#, x2#) <=> x1# = x2#: thm
val Inj_lift_fun =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?(f : fun(X#, A#)). !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#):
   thm
val Inj_lift_fun_uex =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(X : set)  (f0 : fun(X#, A0#)).
          (!(x : mem(X#)). ?(a : mem(A#)). App(f0#, x#) = App(i#, a#)) ==>
          ?!(f : fun(X#, A#)).
            !(a : mem(X#)). App(i# o f#, a#) = App(f0#, a#): thm
val o_assoc =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (D : set)  (h : fun(C#, D#)). (h# o g#) o f# = h# o g# o f#: thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val P2fun_uex0 =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). App(f#, a#) = b# <=> P(a#, b#): thm
val it = (): unit
******

Loading SEAR file SEARsetting.sml

******
val AX0 = {},  |- ?(A : set)  (a : mem(A#)). T: thm
val Tab_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) <=>
        (!(x : mem(A#))  (y : mem(B#)).
            Holds(R#, x#, y#) <=>
            ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val AX2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        ?(TR : set)  (p : fun(TR#, A#))  (q : fun(TR#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              Holds(R#, x#, y#) <=>
              ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#) &
          !(r : mem(TR#))  (s : mem(TR#)).
            App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Empty_unique =
   {}, 
   |- !(E1 : set)  (E2 : set).
        (!(a : mem(E1#)). F) & (!(a : mem(E2#)). F) ==>
        ?(i : fun(E1#, E2#))  (j : fun(E2#, E1#)).
          i# o j# = Id(E2#) & j# o i# = Id(E1#): thm
val Thm_2_2 = {},  |- ?(Empty : set). !(a : mem(Empty#)). F: thm
val Thm_2_3 =
   {},  |- ?(ONE : set)  (x : mem(ONE#)). !(x' : mem(ONE#)). x'# = x#: thm
val unique_fun_to_ONE =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#)).
        (!(a : mem(ONE#)). a# = x#) ==> !(A : set). ?!(f : fun(A#, ONE#)). T:
   thm
val ONE_unique =
   {}, 
   |- !(ONE : set)  (x : mem(ONE#))  (ONE' : set)  (x' : mem(ONE'#)).
        (!(a : mem(ONE#)). a# = x#) & (!(a : mem(ONE'#)). a# = x'#) ==>
        ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
          i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso0_REFL =
   {}, 
   |- !(A : set).
        ?(i : fun(A#, A#))  (j : fun(A#, A#)).
          i# o j# = Id(A#) & j# o i# = Id(A#): thm
val iso0_SYM =
   {}, 
   |- !(A : set)  (A' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
        ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
          i# o j# = Id(A#) & j# o i# = Id(A'#): thm
val iso0_TRANS =
   {}, 
   |- !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_uex =
   {}, 
   |- ?(ONE : set).
        (?(x : mem(ONE#)). !(a : mem(ONE#)). a# = x#) &
        !(ONE' : set).
          (?(x : mem(ONE'#)). !(a : mem(ONE'#)). a# = x#) ==>
          ?(i : fun(ONE#, ONE'#))  (j : fun(ONE'#, ONE#)).
            i# o j# = Id(ONE'#) & j# o i# = Id(ONE#): thm
val iso_Reqv =
   {}, 
   |- (!(A : set).
          ?(i : fun(A#, A#))  (j : fun(A#, A#)).
            i# o j# = Id(A#) & j# o i# = Id(A#)) &
      (!(A : set)  (A' : set).
          (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
              i# o j# = Id(A'#) & j# o i# = Id(A#)) ==>
          ?(i : fun(A'#, A#))  (j : fun(A#, A'#)).
            i# o j# = Id(A#) & j# o i# = Id(A'#)) &
      !(A : set)  (A' : set)  (A'' : set).
        (?(i : fun(A#, A'#))  (j : fun(A'#, A#)).
            i# o j# = Id(A'#) & j# o i# = Id(A#)) &
        (?(i : fun(A'#, A''#))  (j : fun(A''#, A'#)).
            i# o j# = Id(A''#) & j# o i# = Id(A'#)) ==>
        ?(i : fun(A#, A''#))  (j : fun(A''#, A#)).
          i# o j# = Id(A''#) & j# o i# = Id(A#): thm
val ONE_def = {},  |- ?(x : mem(1)). !(a : mem(1)). a# = x#: thm
val dot_uex = {},  |- ?!(x : mem(1)). x# = x#: thm
val dot_def = {},  |- !(a : mem(1)). a# = dot: thm
val dot_def0 = {},  |- dot = dot: thm
val ONE = 1: term
val Thm_2_3_5 = {},  |- !(A : set). ?!(f : rel(A#, 1)). isFun(f#): thm
val To1_ex = {},  |- !(A : set). ?!(f : fun(A#, 1)). T: thm
val dot = dot: term
val To1_uex = {},  |- !(A : set). ?!(f : fun(A#, 1)). f# = f#: thm
val To1_def = {},  |- !(A : set)  (f' : fun(A#, 1)). f'# = To1(A#): thm
val To1_def0 = {(A : set)},  |- To1(A) = To1(A): thm
val Thm_2_4_R_ver =
   {}, 
   |- !(A : set)  (R : rel(1, A#)).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)).
            Holds(R#, dot, a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Rel_Pred1 =
   {}, 
   |- !(A : set).
        ?!(R : rel(1, A#)). !(a : mem(A#)). Holds(R#, dot, a#) <=> P(a#): thm
val Tab_App_Rel =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (x : mem(A#))  (y : mem(B#)).
          App(p#, r#) = x# & App(q#, r#) = y# ==> Holds(R#, x#, y#): thm
val Thm_2_4 =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          Inj(i#) &
          !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#): thm
val Tab_mem_R =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#)). Holds(R#, App(p#, r#), App(q#, r#)): thm
val Tab_prop1 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(x : mem(A#))  (y : mem(B#)).
          Holds(R#, x#, y#) <=>
          ?(r : mem(TR#)). App(p#, r#) = x# & App(q#, r#) = y#: thm
val T_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(T0 : rel(A#, B#)).
          !(a : mem(A#))  (b : mem(B#)). Holds(T0#, a#, b#): thm
val T_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(R : rel(A#, B#)).
          (!(a : mem(A#))  (b : mem(B#)). Holds(R#, a#, b#)) &
          !(R' : rel(A#, B#)).
            (!(a : mem(A#))  (b : mem(B#)). Holds(R'#, a#, b#)) ==> R'# = R#:
   thm
val Tab_prop2 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (TR : set)
      (p : fun(TR#, A#))  (q : fun(TR#, B#)).
        isTab(R#, p#, q#) ==>
        !(r : mem(TR#))  (s : mem(TR#)).
          App(p#, r#) = App(p#, s#) & App(q#, r#) = App(q#, s#) ==> r# = s#:
   thm
val Thm_2_5 =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (T1 : set)
      (p1 : fun(T1#, A#))  (q1 : fun(T1#, B#))  (T2 : set)
      (p2 : fun(T2#, A#))  (q2 : fun(T2#, B#)).
        isTab(R#, p1#, q1#) & isTab(R#, p2#, q2#) ==>
        ?(b : fun(T1#, T2#)). Bij(b#): thm
val isPair_def =
   {(A : set), (AxB : set), (B : set), (p1 : fun(AxB, A)), (p2 : fun(AxB, B))},
   
   |- isPair(p1, p2) <=>
      !(x : mem(A))  (y : mem(B)).
        ?!(r : mem(AxB)). App(p1, r#) = x# & App(p2, r#) = y#: thm
val isPair_uex =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (p1 : fun(AB#, A#))
      (p2 : fun(AB#, B#))  (AB' : set)  (p1' : fun(AB'#, A#))
      (p2' : fun(AB'#, B#)).
        isPair(p1#, p2#) & isPair(p1'#, p2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          p1'# o i# = p1# &
          p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AxB : set)  (p1 : fun(AxB#, A#))  (p2 : fun(AxB#, B#)).
          (!(x : mem(A#))  (y : mem(B#)).
              ?(r : mem(AxB#)). App(p1#, r#) = x# & App(p2#, r#) = y#) &
          !(r : mem(AxB#))  (s : mem(AxB#)).
            App(p1#, r#) = App(p1#, s#) & App(p2#, r#) = App(p2#, s#) ==>
            r# = s#: thm
val Pr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)).
          isPair(p1#, p2#) &
          !(AB' : set)  (p1' : fun(AB'#, A#))  (p2' : fun(AB'#, B#)).
            isPair(p1'#, p2'#) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#: thm
val Cross_p12_def =
   {},  |- !(A : set)  (B : set). isPair(p1(A#, B#), p2(A#, B#)): thm
val Pr_ts_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (p1 : fun(AB#, A#))  (p2 : fun(AB#, B#)). T: thm
val isPair_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            p1# o i# = p1# & p2# o i# = p2# & p1# o j# = p1# & p2# o j# = p2#) &
      (!(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
        (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              p1'# o i# = p1# &
              p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            p1# o i# = p1'# &
            p2# o i# = p2'# & p1'# o j# = p1# & p2'# o j# = p2#) &
      !(AB : set)  (p1 : fun(AB#, A))  (p2 : fun(AB#, B))  (AB' : set)
      (p1' : fun(AB'#, A))  (p2' : fun(AB'#, B))  (AB'' : set)
      (p1'' : fun(AB''#, A))  (p2'' : fun(AB''#, B)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            p1'# o i# = p1# &
            p2'# o i# = p2# & p1# o j# = p1'# & p2# o j# = p2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            p1''# o i# = p1'# &
            p2''# o i# = p2'# & p1'# o j# = p1''# & p2'# o j# = p2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          p1''# o i# = p1# &
          p2''# o i# = p2# & p1# o j# = p1''# & p2# o j# = p2''#: thm
val p2_def =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#))  (y : mem(B#)).
            ?(r : mem(A# * B#)).
              App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#) &
        !(r : mem(A# * B#))  (s : mem(A# * B#)).
          App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
          App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val SetPr_def =
   {}, 
   |- !(A : set)  (AB : set)  (p1 : fun(AB#, A#))  (B : set)
      (p2 : fun(AB#, B#)).
        SetPr(p1#, p2#) <=>
        !(X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
          ?!(fg : fun(X#, AB#)). p1# o fg# = f# & p2# o fg# = g#: thm
val Cross = fn: term -> term -> term
val Pa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        (p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#) &
        !(fg' : fun(X#, A# * B#)).
          p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==>
          fg'# = Pa(f#, g#): thm
val Pa_def0 =
   {(A : set), (B : set), (X : set), (f : fun(X, A)), (g : fun(X, B))}, 
   |- p1(A, B) o Pa(f, g) = f & p2(A, B) o Pa(f, g) = g: thm
val Thm_2_8_SetPr =
   {},  |- !(A : set)  (B : set). SetPr(p1(A#, B#), p2(A#, B#)): thm
val p12_of_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f# & p2(A#, B#) o Pa(f#, g#) = g#: thm
val p1_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p1(A#, B#) o Pa(f#, g#) = f#: thm
val p2_of_Pa =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A#))  (g : fun(X#, B#)).
        p2(A#, B#) o Pa(f#, g#) = g#: thm
val is_Pa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (fg' : fun(X#, A# * B#)).
        p1(A#, B#) o fg'# = f# & p2(A#, B#) o fg'# = g# ==> fg'# = Pa(f#, g#):
   thm
val AX3 =
   {}, 
   |- !(A : set).
        ?(PA : set)  (e : rel(A#, PA#)).
          !(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#): thm
val Pow_uex =
   {(A : set)}, 
   |- ?(PA : set)  (e : rel(A, PA#)).
        (!(S0 : rel(1, A)).
            ?!(s : mem(PA#)).
              !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        !(PA' : set)  (e' : rel(A, PA'#)).
          (!(S0 : rel(1, A)).
              ?!(s : mem(PA'#)).
                !(x : mem(A)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
          ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val Pow_unique =
   {}, 
   |- !(A : set)  (PA : set)  (e : rel(A#, PA#))  (PA' : set)
      (e' : rel(A#, PA'#)).
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e#, x#, s#)) &
        (!(S0 : rel(1, A#)).
            ?!(s : mem(PA'#)).
              !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(e'#, x#, s#)) ==>
        ?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
          i# o j# = Id(PA'#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#: thm
val SetEz_def =
   {(A : set), (B : set), (E : set), (e : fun(E, A)), (f : fun(A, B)),
    (g : fun(A, B))}, 
   |- SetEz(f, g, e) <=>
      !(X : set)  (x : fun(X#, A)).
        f o x# = g o x# ==> ?!(x0 : fun(X#, E)). x# = e o x0#: thm
val Thm_2_10 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(M : set)  (e : fun(A#, M#))  (m : fun(M#, B#)).
          f# = m# o e# & Surj(e#) & Inj(m#): thm
val Thm_2_9_Eqlz =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (g : fun(A#, B#)).
        ?(E : set)  (e : fun(E#, A#)). SetEz(f#, g#, e#): thm
val BC0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))).
        Holds(BC0(f#), a#, b#) <=>
        !(z : mem(Z#)).
          Holds(In(Z#), z#, b#) <=> Holds(In(Y#), App(f#, z#), a#): thm
val Pow = fn: term -> term
val Pow_REFL =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#)).
        ?(i : fun(PA#, PA#))  (j : fun(PA#, PA#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e# & asR(j#) @ e# = e#: thm
val Pow_SYM =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) ==>
        ?(i : fun(PA'#, PA#))  (j : fun(PA#, PA'#)).
          i# o j# = Id(PA#) &
          j# o i# = Id(PA'#) & asR(i#) @ e'# = e# & asR(j#) @ e# = e'#: thm
val Pow_TRANS =
   {(A : set)}, 
   |- !(PA : set)  (e : rel(A, PA#))  (PA' : set)  (e' : rel(A, PA'#))
      (PA'' : set)  (e'' : rel(A, PA''#)).
        (?(i : fun(PA#, PA'#))  (j : fun(PA'#, PA#)).
            i# o j# = Id(PA'#) &
            j# o i# = Id(PA#) & asR(i#) @ e# = e'# & asR(j#) @ e'# = e#) &
        (?(i : fun(PA'#, PA''#))  (j : fun(PA''#, PA'#)).
            i# o j# = Id(PA''#) &
            j# o i# = Id(PA'#) & asR(i#) @ e'# = e''# & asR(j#) @ e''# = e'#) ==>
        ?(i : fun(PA#, PA''#))  (j : fun(PA''#, PA#)).
          i# o j# = Id(PA''#) &
          j# o i# = Id(PA#) & asR(i#) @ e# = e''# & asR(j#) @ e''# = e#: thm
val Pow_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val All0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(All0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, a#): thm
val All0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(All0(f#)): thm
val BC0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(BC0(f#)): thm
val Ex0_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))).
        Holds(Ex0(f#), a#, b#) <=>
        !(y : mem(Y#)).
          Holds(In(Y#), y#, b#) <=>
          ?(z : mem(Z#)). Holds(In(Z#), z#, a#) & App(f#, z#) = y#: thm
val Ex0_isFun =
   {},  |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#)). isFun(Ex0(f#)): thm
val In_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). Holds(In(A#), x#, s1#) <=> Holds(In(A#), x#, s2#)) ==>
        s1# = s2#: thm
val In_def =
   {}, 
   |- !(A : set)  (S0 : rel(1, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)). Holds(S0#, dot, x#) <=> Holds(In(A#), x#, s#): thm
val In_def_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (s0 : fun(A0#, A#)).
        ?!(s : mem(Pow(A#))).
          !(x : mem(A#)).
            (?(a0 : mem(A0#)). x# = App(s0#, a0#)) <=> Holds(In(A#), x#, s#):
   thm
val In_def_P =
   {}, 
   |- !(A : set).
        ?!(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> Holds(In(A#), a#, s#):
   thm
val PO_def =
   {}, 
   |- !(A : set)  (S1 : mem(Pow(A#)))  (S2 : mem(Pow(A#))).
        PO(S1#, S2#) <=>
        !(a : mem(A#)). Holds(In(A#), a#, S1#) ==> Holds(In(A#), a#, S2#):
   thm
val BC_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Y#)))
      (b : mem(Pow(Z#))). App(BC(f#), a#) = b# <=> Holds(BC0(f#), a#, b#):
   thm
val In_App_BC =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (z : mem(Z#))
      (ys : mem(Pow(Y#))).
        Holds(In(Z#), z#, App(BC(f#), ys#)) <=>
        Holds(In(Y#), App(f#, z#), ys#): thm
val Ex_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(Ex(f#), a#) = b# <=> Holds(Ex0(f#), a#, b#):
   thm
val In_App_Ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(Ex(f#), zs#)) <=>
        ?(z : mem(Z#)). Holds(In(Z#), z#, zs#) & App(f#, z#) = y#: thm
val All_def =
   {}, 
   |- !(Y : set)  (Z : set)  (f : fun(Z#, Y#))  (a : mem(Pow(Z#)))
      (b : mem(Pow(Y#))). App(All(f#), a#) = b# <=> Holds(All0(f#), a#, b#):
   thm
val In_App_All =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (y : mem(Y#))
      (zs : mem(Pow(Z#))).
        Holds(In(Y#), y#, App(All(f#), zs#)) <=>
        !(z : mem(Z#)). App(f#, z#) = y# ==> Holds(In(Z#), z#, zs#): thm
val Thm_2_11_SEx_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (zs : mem(Pow(Z#)))
      (ys : mem(Pow(Y#))).
        PO(App(Ex(f#), zs#), ys#) <=> PO(zs#, App(BC(f#), ys#)): thm
val Thm_2_11_SAll_ex =
   {}, 
   |- !(Z : set)  (Y : set)  (f : fun(Z#, Y#))  (ys : mem(Pow(Y#)))
      (zs : mem(Pow(Z#))).
        PO(App(BC(f#), ys#), zs#) <=> PO(ys#, App(All(f#), zs#)): thm
val Sub_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, R2#) <=>
        !(a : mem(A#))  (b : mem(B#)).
          Holds(R1#, a#, b#) ==> Holds(R2#, a#, b#): thm
val Meet_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Meet(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) & Holds(R2#, a#, b#): thm
val Sub_Meet =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(Meet(R1#, R2#), R1#) &
        Sub(Meet(R1#, R2#), R2#) &
        !(R0 : rel(A#, B#)).
          Sub(R0#, R1#) & Sub(R0#, R2#) ==> Sub(R0#, Meet(R1#, R2#)): thm
val Join_def =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (a : mem(A#))  (b : mem(B#)).
        Holds(Join(R1#, R2#), a#, b#) <=>
        Holds(R1#, a#, b#) | Holds(R2#, a#, b#): thm
val Sub_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#)).
        Sub(R1#, Join(R1#, R2#)) &
        Sub(R2#, Join(R1#, R2#)) &
        !(R0 : rel(A#, B#)).
          Sub(R1#, R0#) & Sub(R2#, R0#) ==> Sub(Join(R1#, R2#), R0#): thm
val MODULAR_LAW =
   {}, 
   |- !(x : set)  (y : set)  (phi : rel(x#, y#))  (z : set)
      (psi : rel(y#, z#))  (chi : rel(x#, z#)).
        Sub(Meet(psi# @ phi#, chi#), psi# @ Meet(phi#, op(psi#) @ chi#)): thm
val left_o_pres_Join =
   {}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (C : set)  (R : rel(B#, C#)).
        R# @ Join(R1#, R2#) = Join(R# @ R1#, R# @ R2#): thm
val right_o_pres_Join =
   {(C : set)}, 
   |- !(A : set)  (B : set)  (R1 : rel(A#, B#))  (R2 : rel(A#, B#))
      (R : rel(C, A#)). Join(R1#, R2#) @ R# = Join(R1# @ R#, R2# @ R#): thm
val Div_ex =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (C : set)  (s : rel(A#, C#)).
        ?(sdr : rel(B#, C#)).
          !(t : rel(B#, C#)). Sub(t#, sdr#) <=> Sub(t# @ r#, s#): thm
val MF_def = {},  |- !(A : set)  (a : mem(A#)). App(MF(a#), dot) = a#: thm
val Pair_uex =
   {}, 
   |- !(A : set)  (B : set)  (x : mem(A#))  (y : mem(B#)).
        ?!(r : mem(A# * B#)).
          App(p1(A#, B#), r#) = x# & App(p2(A#, B#), r#) = y#: thm
val Thm_2_12 =
   {}, 
   |- !(B : set)  (A : set)  (R : rel(B#, A#)).
        ?!(fR : fun(B#, Pow(A#))).
          !(y : mem(B#))  (x : mem(A#)).
            Holds(R#, y#, x#) <=> Holds(In(A#), x#, App(fR#, y#)): thm
val Thm_2_3_5_el =
   {},  |- !(A : set)  (a : mem(A#)). ?!(R : fun(1, A#)). App(R#, dot) = a#:
   thm
val Pair_App_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val Pair_def =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val Pair_component =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)).
        Pair(App(p1(A#, B#), r#), App(p2(A#, B#), r#)) = r#: thm
val Pair_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (B : set)  (b1 : mem(B#))
      (b2 : mem(B#)).
        Pair(a1#, b1#) = Pair(a2#, b2#) <=> a1# = a2# & b1# = b2#: thm
val Pair_p12 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        Pair(App(p1(A#, B#), ab#), App(p2(A#, B#), ab#)) = ab#: thm
val Ap1_def =
   {}, 
   |- !(A : set)  (X : set)  (x : mem(X#))  (B : set)  (f : fun(A# * X#, B#))
      (a : mem(A#)). App(Ap1(f#, x#), a#) = App(f#, Pair(a#, x#)): thm
val Ap1_uex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#))
      (x : mem(X#)).
        ?!(fx : fun(A#, B#)).
          !(a : mem(A#)). App(fx#, a#) = App(f#, Pair(a#, x#)): thm
val Cross_eq =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#))  (s : mem(A# * B#)).
        App(p1(A#, B#), r#) = App(p1(A#, B#), s#) &
        App(p2(A#, B#), r#) = App(p2(A#, B#), s#) ==> r# = s#: thm
val App_Pa =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (D : set)
      (g : fun(B#, D#))  (ab : mem(A# * B#)).
        App(Pa(f# o p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(f# o p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_o_p2 =
   {}, 
   |- !(B : set)  (C : set)  (f : fun(B#, C#))  (A : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p2(A#, B#), Pair(a#, b#)) = App(f#, b#): thm
val App_o_p1 =
   {}, 
   |- !(A : set)  (C : set)  (f : fun(A#, C#))  (B : set)  (a : mem(A#))
      (b : mem(B#)). App(f# o p1(A#, B#), Pair(a#, b#)) = App(f#, a#): thm
val Fst_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p1(A, B), x) = Fst(x):
   thm
val Pair_def' =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        Fst(Pair(x#, y#)) = x# & Snd(Pair(x#, y#)) = y#: thm
val Snd_def =
   {(A : set), (B : set), (x : mem(A * B))},  |- App(p2(A, B), x) = Snd(x):
   thm
val Pair_Fst_Snd =
   {}, 
   |- !(A : set)  (B : set)  (r : mem(A# * B#)). Pair(Fst(r#), Snd(r#)) = r#:
   thm
val Pair_has_comp =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# * B#)).
        ?(a : mem(A#))  (b : mem(B#)). ab# = Pair(a#, b#): thm
val p12_of_Pair =
   {}, 
   |- !(A : set)  (x : mem(A#))  (B : set)  (y : mem(B#)).
        App(p1(A#, B#), Pair(x#, y#)) = x# &
        App(p2(A#, B#), Pair(x#, y#)) = y#: thm
val dest_cross = fn: term -> term * term
val basic_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_fconv = fn: form -> thm
val mk_Pair = fn: term -> term -> term
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val Prla_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (D : set)
      (g : fun(C#, D#)). Prla(f#, g#) = Pa(f# o p1(A#, C#), g# o p2(A#, C#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Exp_ev_unique =
   {}, 
   |- !(A : set)  (B : set)  (A2B : set)  (ev : fun(A# * A2B#, B#))
      (A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
        (!(f : fun(A#, B#)).
            ?!(sf : mem(A2B'#)).
              !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
        ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
          i# o j# = Id(A2B'#) &
          j# o i# = Id(A2B#) &
          ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#: thm
val Exp_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#): thm
val Exp_ex_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A# * A2B#, B#)).
          (!(f : fun(A#, B#)).
              ?!(sf : mem(A2B#)).
                !(a : mem(A#)). App(ev#, Pair(a#, sf#)) = App(f#, a#)) &
          !(A2B' : set)  (ev' : fun(A# * A2B'#, B#)).
            (!(f : fun(A#, B#)).
                ?!(sf : mem(A2B'#)).
                  !(a : mem(A#)). App(ev'#, Pair(a#, sf#)) = App(f#, a#)) ==>
            ?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
              i# o j# = Id(A2B'#) &
              j# o i# = Id(A2B#) &
              ev'# o Prla(Id(A#), i#) = ev# & ev# o Prla(Id(A#), j#) = ev'#:
   thm
val Thm_2_13 =
   {}, 
   |- !(A : set)  (B : set).
        ?(A2B : set)  (ev : fun(A2B# * A#, B#)).
          !(f : fun(A#, B#)).
            ?!(sf : mem(A2B#)).
              !(a : mem(A#)). App(ev#, Pair(sf#, a#)) = App(f#, a#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Ev_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(sf : mem(Exp(A#, B#))).
          !(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf#)) = App(f#, a#): thm
val Exp_uex_refl =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B)).
        ?(i : fun(A2B#, A2B#))  (j : fun(A2B#, A2B#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B#) &
          ev# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_sym =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) ==>
        ?(i : fun(A2B'#, A2B#))  (j : fun(A2B#, A2B'#)).
          i# o j# = Id(A2B#) &
          j# o i# = Id(A2B'#) &
          ev# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev#: thm
val Exp_uex_trans =
   {(A : set), (B : set)}, 
   |- !(A2B : set)  (ev : fun(A * A2B#, B))  (A2B' : set)
      (ev' : fun(A * A2B'#, B))  (A2B'' : set)  (ev'' : fun(A * A2B''#, B)).
        (?(i : fun(A2B#, A2B'#))  (j : fun(A2B'#, A2B#)).
            i# o j# = Id(A2B'#) &
            j# o i# = Id(A2B#) &
            ev'# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev'#) &
        (?(i : fun(A2B'#, A2B''#))  (j : fun(A2B''#, A2B'#)).
            i# o j# = Id(A2B''#) &
            j# o i# = Id(A2B'#) &
            ev''# o Prla(Id(A), i#) = ev'# & ev'# o Prla(Id(A), j#) = ev''#) ==>
        ?(i : fun(A2B#, A2B''#))  (j : fun(A2B''#, A2B#)).
          i# o j# = Id(A2B''#) &
          j# o i# = Id(A2B#) &
          ev''# o Prla(Id(A), i#) = ev# & ev# o Prla(Id(A), j#) = ev''#: thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val Tpm_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#)) &
        !(sf' : mem(Exp(A#, B#))).
          (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
          sf'# = Tpm(f#): thm
val Tpm_def0 =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(Ev(A#, B#), Pair(a#, Tpm(f#))) = App(f#, a#): thm
val is_Tpm =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sf' : mem(Exp(A#, B#))).
        (!(a : mem(A#)). App(Ev(A#, B#), Pair(a#, sf'#)) = App(f#, a#)) ==>
        sf'# = Tpm(f#): thm
val Tp_def0 =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f: thm
val Tp_ex =
   {}, 
   |- !(A : set)  (X : set)  (B : set)  (f : fun(A# * X#, B#)).
        ?!(h : fun(X#, Exp(A#, B#))).
          Ev(A#, B#) o Pa(p1(A#, X#), h# o p2(A#, X#)) = f#: thm
val Tp_def =
   {(A : set), (B : set), (X : set), (f : fun(A * X, B))}, 
   |- Ev(A, B) o Pa(p1(A, X), Tp(f) o p2(A, X)) = f &
      !(h' : fun(X, Exp(A, B))).
        Ev(A, B) o Pa(p1(A, X), h'# o p2(A, X)) = f ==> h'# = Tp(f): thm
val is_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (h' : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), h'# o p2(A#, X#)) = f# ==> h'# = Tp(f#):
   thm
val Thm_2_14 =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        ?(B : set)  (q : fun(A#, B#)).
          Surj(q#) &
          !(x : mem(A#))  (y : mem(A#)).
            Holds(R#, x#, y#) <=> App(q#, x#) = App(q#, y#): thm
val IN_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#))).
        IN(a#, ss#) <=> Holds(In(A#), a#, ss#): thm
val IN_def_P_expand =
   {}, 
   |- !(A : set).
        ?(s : mem(Pow(A#))).
          (!(a : mem(A#)). P(a#) <=> IN(a#, s#)) &
          !(s' : mem(Pow(A#))).
            (!(a : mem(A#)). P(a#) <=> IN(a#, s'#)) ==> s'# = s#: thm
val IN_EXT =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) ==> s1# = s2#: thm
val SS_def =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) <=> !(a : mem(A#)). IN(a#, P1#) ==> IN(a#, P2#): thm
val SS_Trans =
   {}, 
   |- !(A : set)  (P1 : mem(Pow(A#)))  (P2 : mem(Pow(A#))).
        SS(P1#, P2#) ==> !(P3 : mem(Pow(A#))). SS(P2#, P3#) ==> SS(P1#, P3#):
   thm
val SS_SS_eq =
   {}, 
   |- !(A : set)  (p1 : mem(Pow(A#)))  (p2 : mem(Pow(A#))).
        SS(p1#, p2#) & SS(p2#, p1#) ==> p1# = p2#: thm
val IN_def_P_ex =
   {}, 
   |- !(A : set). ?(s : mem(Pow(A#))). !(a : mem(A#)). P(a#) <=> IN(a#, s#):
   thm
val IN_def_P =
   {}, 
   |- !(A : set). ?!(s : mem(Pow(A#))). !(a : mem(A#)). IN(a#, s#) <=> P(a#):
   thm
val AX4 =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set).
        ?!(BI : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BI#, sss#)) <=>
            !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val BI_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BI(A#), sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val N0 = N0: term
val N0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val O0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val S0_def =
   {}, 
   |- (!(n : mem(N0)). ~App(S0, n#) = O0) &
      !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) <=> n# = m#:
   thm
val BIGINTER_def =
   {(A : set), (sss : mem(Pow(Pow(A))))},  |- App(BI(A), sss) = BIGINTER(sss):
   thm
val BIGINTER_ex =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        ?(isss : mem(Pow(A#))). App(BI(A#), sss#) = isss#: thm
val IN_BIGINTER =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGINTER(sss#)) <=>
        !(ss : mem(Pow(A#))). IN(ss#, sss#) ==> IN(a#, ss#): thm
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
******

Loading SEAR file SEARreln.sml

******
val mk_App = fn: term -> term -> term
SEARreln.sml:75: warning: Matches are not exhaustive.
Found near
  case (view_form ante, view_form conseq) of
     (vConn ("&", ...), vConn (...)) =>
     let val ip1 = ... ...; val ... = ... in conj_monotone ip1 ip2 end |
     (vConn (...), ... ...) => let val ... = ...; val ... in ... ... ip2 end
     |
     (... ..., ...) => let val ... in ... ... end |
     (...) => let ... in ... end
SEARreln.sml:247: warning: Pattern is not exhaustive.
Found near
  val [fnterm, LFP] = fLFP |> #3 o dest_fun handle _ => raise ... ...
val IN_EXT_iff =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        (!(x : mem(A#)). IN(x#, s1#) <=> IN(x#, s2#)) <=> s1# = s2#: thm
val conj_monotone = fn: thm -> thm -> thm
val disj_monotone = fn: thm -> thm -> thm
val exists_monotone = fn: thm -> thm
val forall_monotone = fn: thm -> thm
val imp_induce = fn: thm -> form -> thm
val mk_LFP = fn: term -> thm
val mk_Pow = fn: term -> term
val mk_SS = fn: thm -> thm -> thm
val mk_cases = fn: thm -> thm -> thm -> thm
val mk_cond = fn: thm -> thm -> thm
val mk_fdef = fn: string -> thm -> thm
val mk_fex = fn: form -> string -> thm
val mk_ind = fn: thm -> thm
val mk_ind1 = fn: thm -> thm -> thm
val mk_monotone = fn: thm -> thm
val mk_prim = fn: thm -> thm
val mk_rules = fn: thm -> thm -> thm -> thm
val trivial_imp = fn: form -> thm
val PULL_CONJ = fn: (form -> bool) -> form -> thm option
val conj_assoc_fconv = fn: form -> thm
val conj_cossa_fconv = fn: form -> thm
val conj_swap_fconv = fn: form -> thm
val disj_imp_distr_fconv = fn: form -> thm
val exists_eq_fconv = fn: form -> thm
val forall_conj_split_fconv = fn: form -> thm
val forall_eq_fconv = fn: form -> thm
val mk_case1 = fn: thm -> thm -> thm
val mk_rules1 = fn: thm -> thm -> thm
val mk_rules2 = fn: thm -> thm
val pull_conj_fconv = fn: (form -> bool) -> form -> thm
val pull_exists_fconv1 = fn: form -> thm
SEARreln.sml:599: warning: Pattern is not exhaustive.
Found near val [qv, newtm] = conc |> dest_pred |> #2
val conj_imp_fconv = fn: form -> thm
val disj_imp_undistr_fconv = fn: form -> thm
val forall_in_eq_fconv = fn: form -> thm
val mk_incond = fn: form -> form * string
val mk_ind2 = fn: thm -> thm
val mk_rules3 = fn: thm -> thm
val remove_list_item = fn: ''a -> ''a list -> ''a list
val unpull_exists_fconv1 = fn: form -> thm
val it = (): unit
val inN's_def =
   {},  |- !(a : mem(Pow(N0))). IN(a#, inN's) <=> SS(App(inNf, a#), a#): thm
val inN_cases0 = {},  |- App(inNf, inNs) = inNs: thm
val inN_cases1 =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_incond =
   !(n : mem(N0)).
     IN(n#, inN1) <=>
     n# = O0 | ?(n0 : mem(N0)). IN(n0#, inN0) & n# = App(S0, n0#): form
val inN_ind =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_ind0 =
   {},  |- !(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> SS(inNs, ss#):
   thm
val inN_ind1 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        (!(a : mem(N0)).
            a# = O0 | (?(n0 : mem(N0)). IN(n0#, ss#) & a# = App(S0, n0#)) ==>
            IN(a#, ss#)) ==> !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#):
   thm
val inN_ind2 =
   {}, 
   |- !(ss : mem(Pow(N0))).
        IN(O0, ss#) &
        (!(n0 : mem(N0)). IN(n0#, ss#) ==> IN(App(S0, n0#), ss#)) ==>
        !(a : mem(N0)). IN(a#, inNs) ==> IN(a#, ss#): thm
val inN_rules0 = {},  |- SS(App(inNf, inNs), inNs): thm
val inN_rules1 =
   {}, 
   |- !(a : mem(N0)).
        a# = O0 | (?(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#)) ==>
        IN(a#, inNs): thm
val inN_rules2 =
   {}, 
   |- !(a : mem(N0)).
        (a# = O0 ==> IN(a#, inNs)) &
        !(n0 : mem(N0)). IN(n0#, inNs) & a# = App(S0, n0#) ==> IN(a#, inNs):
   thm
val inN_rules3 =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val inNf_def =
   {}, 
   |- !(a : mem(Pow(N0)))  (n : mem(N0)).
        IN(n#, App(inNf, a#)) <=>
        n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_ex =
   {}, 
   |- ?!(f : fun(Pow(N0), Pow(N0))).
        !(a : mem(Pow(N0)))  (n : mem(N0)).
          IN(n#, App(f#, a#)) <=>
          n# = O0 | ?(n0 : mem(N0)). IN(n0#, a#) & n# = App(S0, n0#): thm
val inNf_monotone =
   {}, 
   |- !(s1 : mem(Pow(N0)))  (s2 : mem(Pow(N0))).
        SS(s1#, s2#) ==> SS(App(inNf, s1#), App(inNf, s2#)): thm
val inNs_SS =
   {},  |- !(a : mem(Pow(N0))). SS(App(inNf, a#), a#) ==> SS(inNs, a#): thm
val inNs_cond =
   {}, 
   |- !(a : mem(N0)).
        (!(ss : mem(Pow(N0))). SS(App(inNf, ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, inNs): thm
val inNs_def = {},  |- inNs = BIGINTER(inN's): thm
val x1 = "inN0": string
val inN_cases =
   {}, 
   |- !(x : mem(N0)).
        IN(x#, inNs) <=>
        x# = O0 | ?(n0 : mem(N0)). IN(n0#, inNs) & x# = App(S0, n0#): thm
val inN_rules =
   {}, 
   |- IN(O0, inNs) &
      !(n0 : mem(N0)). IN(n0#, inNs) ==> IN(App(S0, n0#), inNs): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val N_def =
   {}, 
   |- Inj(iN) &
      !(a : mem(N0)). IN(a#, inNs) <=> ?(b : mem(N)). a# = App(iN, b#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val iN_Inj = {},  |- Inj(iN): thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val iN_inNs = {},  |- !(n : mem(N)). IN(App(iN, n#), inNs): thm
val SUC_ex_lemma =
   {},  |- !(n1 : mem(N)). ?(b : mem(N)). App(S0 o iN, n1#) = App(iN, b#):
   thm
val SUC_def = {},  |- !(a : mem(N)). App(iN o SUC, a#) = App(S0 o iN, a#):
   thm
val iN_eq_eq =
   {}, 
   |- !(x1 : mem(N))  (x2 : mem(N)).
        App(iN, x1#) = App(iN, x2#) ==> x1# = x2#: thm
val O_def = {},  |- O0 = App(iN, O): thm
val iN_ex_uex =
   {}, 
   |- !(b : mem(N0)).
        (?(a : mem(N)). App(iN, a#) = b#) <=>
        ?!(a : mem(N)). App(iN, a#) = b#: thm
val S0_eq_eq =
   {}, 
   |- !(n : mem(N0))  (m : mem(N0)). App(S0, n#) = App(S0, m#) ==> n# = m#:
   thm
val SUC_Inj = {},  |- Inj(SUC): thm
val iN_O = {},  |- !(n : mem(N)). App(iN, n#) = O0 <=> n# = O: thm
val SUC_NONZERO = {},  |- !(n : mem(N)). ~App(SUC, n#) = O: thm
val Image_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?!(im : fun(Pow(A#), Pow(B#))).
          !(sa : mem(Pow(A#)))  (b : mem(B#)).
            IN(b#, App(im#, sa#)) <=>
            ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val Image_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (sa : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Image(f#), sa#)) <=>
        ?(a : mem(A#)). IN(a#, sa#) & b# = App(f#, a#): thm
val IMAGE_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (b : mem(B#)).
        IN(b#, IMAGE(f#, s0#)) <=>
        ?(a : mem(A#)). IN(a#, s0#) & b# = App(f#, a#): thm
val IMAGE_def0 =
   {(A : set), (B : set), (f : fun(A, B)), (s0 : mem(Pow(A)))}, 
   |- IMAGE(f, s0) = App(Image(f), s0): thm
val Whole_def = {},  |- !(A : set)  (a : mem(A#)). IN(a#, Whole(A#)): thm
val IN_IMAGE_Inj =
   {}, 
   |- !(A : set)  (A0 : set)  (i : fun(A#, A0#)).
        Inj(i#) ==>
        !(s : mem(Pow(A#)))  (a : mem(A#)).
          IN(a#, s#) <=> IN(App(i#, a#), IMAGE(i#, s#)): thm
val N_ind_P =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(App(SUC, n#))) ==>
      !(n : mem(N)). P(n#): thm
val O_xor_SUC =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = App(SUC, pn#): thm
val SUC_eq_eq =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)).
        App(SUC, n1#) = App(SUC, n2#) <=> n1# = n2#: thm
val Suc_def = {},  |- !(n : mem(N)). Suc(n#) = App(SUC, n#): thm
val O_xor_Suc =
   {},  |- !(n : mem(N)). ~n# = O <=> ?(pn : mem(N)). n# = Suc(pn#): thm
val Suc_eq_eq =
   {},  |- !(n1 : mem(N))  (n2 : mem(N)). Suc(n1#) = Suc(n2#) <=> n1# = n2#:
   thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val N_induct =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Eqv_def =
   {},  |- !(A : set)  (B : set). Eqv(A#, B#) <=> ?(f : fun(A#, B#)). Bij(f#):
   thm
val Asset_def =
   {}, 
   |- !(B : set)  (bs : mem(Pow(B#)))  (B0 : set).
        Asset(bs#, B0#) <=>
        !(B1 : set)  (i : fun(B1#, B#)).
          Inj(i#) &
          (!(b : mem(B#)).
              (?(b0 : mem(B1#)). App(i#, b0#) = b#) <=> IN(b#, bs#)) ==>
          Eqv(B0#, B1#): thm
val Sg_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (a0 : mem(A#)).
        IN(a0#, App(Sg(A#), a#)) <=> a0# = a#: thm
val Sing_def = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Empty_def = {},  |- !(X : set)  (a : mem(X#)). ~IN(a#, Empty(X#)): thm
val Sing_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Sing(a1#) = Sing(a2#) <=> a1# = a2#: thm
val Sing_NONEMPTY = {},  |- !(A : set)  (a : mem(A#)). ~Sing(a#) = Empty(A#):
   thm
val iscoPr_def =
   {}, 
   |- !(A : set)  (B : set)  (AB : set)  (i1 : fun(A#, AB#))
      (i2 : fun(B#, AB#)).
        iscoPr(i1#, i2#) <=>
        !(X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
          ?!(fg : fun(AB#, X#)). fg# o i1# = f# & fg# o i2# = g#: thm
val tof_def =
   {(A : set), (B : set), (f0 : mem(Exp(A, B)))}, 
   |- !(a : mem(A)). App(Ev(A, B), Pair(a#, f0)) = App(tof(f0), a#): thm
val coPr_unique =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        iscoPr(i1#, i2#) & iscoPr(i1'#, i2'#) ==>
        ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
          i# o j# = Id(AB'#) &
          j# o i# = Id(AB#) &
          j# o i1'# = i1# &
          j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val iscoPr_ex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          iscoPr(i1#, i2#) &
          Inj(i1#) &
          Inj(i2#) &
          (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
          !(ab : mem(AB#)).
            (?(a : mem(A#)). ab# = App(i1#, a#)) |
            ?(b : mem(B#)). ab# = App(i2#, b#): thm
val coPr_REFL =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
        ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB#) &
          j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#:
   thm
val coPr_Reqv =
   {(A : set), (B : set)}, 
   |- (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#)).
          ?(i : fun(AB#, AB#))  (j : fun(AB#, AB#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB#) &
            j# o i1# = i1# & j# o i2# = i2# & i# o i1# = i1# & i# o i2# = i2#) &
      (!(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
        (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
          (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
          ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
            i# o j# = Id(AB#) &
            j# o i# = Id(AB'#) &
            j# o i1# = i1'# &
            j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#) &
      !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_SYM =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) ==>
        ?(i : fun(AB'#, AB#))  (j : fun(AB#, AB'#)).
          i# o j# = Id(AB#) &
          j# o i# = Id(AB'#) &
          j# o i1# = i1'# &
          j# o i2# = i2'# & i# o i1'# = i1# & i# o i2'# = i2#: thm
val coPr_TRANS =
   {(A : set), (B : set)}, 
   |- !(AB : set)  (i1 : fun(A, AB#))  (i2 : fun(B, AB#))  (AB' : set)
      (i1' : fun(A, AB'#))  (i2' : fun(B, AB'#))  (AB'' : set)
      (i1'' : fun(A, AB''#))  (i2'' : fun(B, AB''#)).
        (?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
            i# o j# = Id(AB'#) &
            j# o i# = Id(AB#) &
            j# o i1'# = i1# &
            j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#) &
        (?(i : fun(AB'#, AB''#))  (j : fun(AB''#, AB'#)).
            i# o j# = Id(AB''#) &
            j# o i# = Id(AB'#) &
            j# o i1''# = i1'# &
            j# o i2''# = i2'# & i# o i1'# = i1''# & i# o i2'# = i2''#) ==>
        ?(i : fun(AB#, AB''#))  (j : fun(AB''#, AB#)).
          i# o j# = Id(AB''#) &
          j# o i# = Id(AB#) &
          j# o i1''# = i1# &
          j# o i2''# = i2# & i# o i1# = i1''# & i# o i2# = i2''#: thm
val coPr_uex =
   {}, 
   |- !(A : set)  (B : set).
        ?(AB : set)  (i1 : fun(A#, AB#))  (i2 : fun(B#, AB#)).
          (iscoPr(i1#, i2#) &
            Inj(i1#) &
            Inj(i2#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1#, a#) = App(i2#, b#)) &
            !(ab : mem(AB#)).
              (?(a : mem(A#)). ab# = App(i1#, a#)) |
              ?(b : mem(B#)). ab# = App(i2#, b#)) &
          !(AB' : set)  (i1' : fun(A#, AB'#))  (i2' : fun(B#, AB'#)).
            iscoPr(i1'#, i2'#) &
            Inj(i1'#) &
            Inj(i2'#) &
            (!(a : mem(A#))  (b : mem(B#)). ~App(i1'#, a#) = App(i2'#, b#)) &
            (!(ab : mem(AB'#)).
                (?(a : mem(A#)). ab# = App(i1'#, a#)) |
                ?(b : mem(B#)). ab# = App(i2'#, b#)) ==>
            ?(i : fun(AB#, AB'#))  (j : fun(AB'#, AB#)).
              i# o j# = Id(AB'#) &
              j# o i# = Id(AB#) &
              j# o i1'# = i1# &
              j# o i2'# = i2# & i# o i1# = i1'# & i# o i2# = i2'#: thm
val coPo_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i2_def =
   {}, 
   |- !(A : set)  (B : set).
        iscoPr(i1(A#, B#), i2(A#, B#)) &
        Inj(i1(A#, B#)) &
        Inj(i2(A#, B#)) &
        (!(a : mem(A#))  (b : mem(B#)).
            ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#)) &
        !(ab : mem(A# + B#)).
          (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
          ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val coPa_def0 =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#: thm
val coPa_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A#, X#))  (g : fun(B#, X#)).
        (coPa(f#, g#) o i1(A#, B#) = f# & coPa(f#, g#) o i2(A#, B#) = g#) &
        !(fg' : fun(A# + B#, X#)).
          fg'# o i1(A#, B#) = f# & fg'# o i2(A#, B#) = g# ==>
          fg'# = coPa(f#, g#): thm
val i1_Inj = {},  |- !(A : set)  (B : set). Inj(i1(A#, B#)): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val i1_or_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        (?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) |
        ?(b : mem(B#)). ab# = App(i2(A#, B#), b#): thm
val i1_xor_i2 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(a : mem(A#)). ab# = App(i1(A#, B#), a#)) <=>
        ?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#): thm
val i2_Inj = {},  |- !(A : set)  (B : set). Inj(i2(A#, B#)): thm
val i2_xor_i1 =
   {}, 
   |- !(A : set)  (B : set)  (ab : mem(A# + B#)).
        ~(?(b' : mem(B#)). ab# = App(i2(A#, B#), b'#)) <=>
        ?(a : mem(A#)). ab# = App(i1(A#, B#), a#): thm
val it = (): unit
******

Loading SEAR file SEARpred_set.sml

******
val tof_Tpm_inv =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). tof(Tpm(f#)) = f#: thm
val Tpm_tof_inv =
   {},  |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#))). Tpm(tof(f#)) = f#:
   thm
val Tpm_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        Tpm(f1#) = Tpm(f2#) <=> f1# = f2#: thm
val tof_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (g : mem(Exp(A#, B#))).
        tof(f#) = tof(g#) <=> f# = g#: thm
val IN_Sing =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)).
        IN(a#, Sing(a0#)) <=> a# = a0#: thm
val BU_ex =
   {}, 
   |- !(A : set).
        ?!(BU : fun(Pow(Pow(A#)), Pow(A#))).
          !(sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
            IN(a#, App(BU#, sss#)) <=>
            ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val EMPTY_def = {(A : set)},  |- EMPTY(A) <=> !(x : mem(A)). F: thm
val BU_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, App(BU(A#), sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val BIGUNION_def =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#)))).
        BIGUNION(sss#) = App(BU(A#), sss#): thm
val IN_BIGUNION =
   {}, 
   |- !(A : set)  (sss : mem(Pow(Pow(A#))))  (a : mem(A#)).
        IN(a#, BIGUNION(sss#)) <=>
        ?(ss : mem(Pow(A#))). IN(ss#, sss#) & IN(a#, ss#): thm
val Inj_ex_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(b : mem(B#)).
          (?!(a : mem(A#)). App(f#, a#) = b#) <=>
          ?(a : mem(A#)). App(f#, a#) = b#: thm
val IMAGE_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#))
      (s : mem(Pow(A#))). IMAGE(g# o f#, s#) = IMAGE(g#, IMAGE(f#, s#)): thm
val ex_eq_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#))).
        (!(b : mem(B#)). IN(b#, s#) ==> ?(a : mem(A#)). b# = App(f#, a#)) ==>
        ?(s0 : mem(Pow(A#))). s# = IMAGE(f#, s0#): thm
val App_IN_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))
      (a : mem(A#)). IN(a#, s#) ==> IN(App(f#, a#), IMAGE(f#, s#)): thm
val IMAGE_BIGUNION =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(Pow(A#)))).
        IMAGE(f#, BIGUNION(ss#)) = BIGUNION(IMAGE(Image(f#), ss#)): thm
val Prla_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(C : set)  (D : set)  (g : fun(C#, D#)).
          Inj(g#) ==> Inj(Prla(f#, g#)): thm
val Id_Inj = {},  |- !(X : set). Inj(Id(X#)): thm
val App_Pa_distr =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Pa_Pair =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#))  (B : set)  (g : fun(X#, B#))
      (x : mem(X#)). App(Pa(f#, g#), x#) = Pair(App(f#, x#), App(g#, x#)):
   thm
val App_Prla =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (X : set)  (Y : set)
      (g : fun(X#, Y#))  (a : mem(A#))  (x : mem(X#)).
        App(Prla(f#, g#), Pair(a#, x#)) = Pair(App(f#, a#), App(g#, x#)): thm
val Pa_distr =
   {}, 
   |- !(A : set)  (X : set)  (a1 : fun(X#, A#))  (B : set)
      (a2 : fun(X#, B#))  (X0 : set)  (x : fun(X0#, X#)).
        Pa(a1#, a2#) o x# = Pa(a1# o x#, a2# o x#): thm
val Pa_eq_eq =
   {}, 
   |- !(A : set)  (X : set)  (f1 : fun(X#, A#))  (f2 : fun(X#, A#))
      (B : set)  (g1 : fun(X#, B#))  (g2 : fun(X#, B#)).
        Pa(f1#, g1#) = Pa(f2#, g2#) <=> f1# = f2# & g1# = g2#: thm
val p2_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(B#, C#)).
        f# o p2(A#, B#) = p2(A#, C#) o Prla(Id(A#), f#): thm
val p1_comm =
   {}, 
   |- !(A : set)  (B : set)  (C : set)  (f : fun(A#, C#)).
        f# o p1(A#, B#) = p1(C#, B#) o Prla(f#, Id(B#)): thm
val p1_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#)). p1(X#, Y#) o Prla(f#, g#) = f# o p1(A#, B#): thm
val IMAGE_Prla =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (Y : set)
      (g : fun(B#, Y#))  (x : mem(X#))  (y : mem(Y#))
      (s : mem(Pow(A# * B#))).
        IN(Pair(x#, y#), IMAGE(Prla(f#, g#), s#)) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          IN(Pair(a#, b#), s#) & x# = App(f#, a#) & y# = App(g#, b#): thm
val exists_cross_fconv = fn: form -> thm
val Image_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        App(Image(f#), s#) = IMAGE(f#, s#): thm
val IMAGE_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        IMAGE(f#, Empty(A#)) = Empty(B#): thm
val IN_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        (?(a : mem(A#)). IN(a#, s#)) <=> ~s# = Empty(A#): thm
val IMAGE_Empty_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val BIGUNION_Empty_Empty =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        BIGUNION(ss#) = Empty(A#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val BIGUNION_NONEMPTY =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        ~BIGUNION(ss#) = Empty(A#) <=>
        ?(s : mem(Pow(A#))). IN(s#, ss#) & ~s# = Empty(A#): thm
val BIGUNION_Empty_Empty' =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        Empty(A#) = BIGUNION(ss#) <=>
        !(s : mem(Pow(A#))). IN(s#, ss#) ==> s# = Empty(A#): thm
val INTER_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(INTER(A), Pair(a'#, b#))) <=> IN(a#, a'#) & IN(a#, b#):
   thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Inter_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Inter(s1, s2) = App(INTER(A), Pair(s1, s2)): thm
val UNION_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(A)))  (b : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(UNION(A), Pair(a'#, b#))) <=> IN(a#, a'#) | IN(a#, b#):
   thm
val COMPL_def =
   {(A : set)}, 
   |- !(a : mem(Pow(A)))  (a : mem(A)).
        IN(a#, App(COMPL(A), a#)) <=> ~IN(a#, a#): thm
val Compl_def =
   {(A : set), (s : mem(Pow(A)))},  |- Compl(s) = App(COMPL(A), s): thm
val IN_Compl =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Compl(s#)) <=> ~IN(a#, s#): thm
val IN_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Union(s1#, s2#)) <=> IN(a#, s1#) | IN(a#, s2#): thm
val Union_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- Union(s1, s2) = App(UNION(A), Pair(s1, s2)): thm
val m2r_def =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#))  (od : mem(Pow(A# * A#))).
        Holds(m2r(od#), a1#, a2#) <=> IN(Pair(a1#, a2#), od#): thm
val r2m_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(Pair(a1#, a2#), r2m(R#)) <=> Holds(R#, a1#, a2#): thm
val Union_Empty_Empty =
   {},  |- !(A : set). Union(Empty(A#), Empty(A#)) = Empty(A#): thm
val SS_Refl = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(s#, s#): thm
val NONE_def = {(X : set)},  |- NONE(X) = App(i2(X, 1), dot): thm
val Null_def =
   {},  |- !(X : set)  (n : mem(N)). App(Null(X#), n#) = App(i2(X#, 1), dot):
   thm
val PREIM_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(B#)))
      (a : mem(A#)).
        IN(a#, PREIM(f#, s#)) <=>
        ?(b : mem(B#)). IN(b#, s#) & App(f#, a#) = b#: thm
val SOME_def =
   {},  |- !(A : set)  (a : mem(A#)). SOME(a#) = App(i1(A#, 1), a#): thm
val Surj_Epi =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Surj(f#) ==>
        !(C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
          g1# o f# = g2# o f# ==> g1# = g2#: thm
val false_def = {},  |- false = App(i1(1, 1), dot): thm
val i1_ne_i2 =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        ~App(i1(A#, B#), a#) = App(i2(A#, B#), b#): thm
val true_def = {},  |- true = App(i2(1, 1), dot): thm
val true_ne_false = {},  |- ~true = false: thm
val true_or_false = {},  |- !(tv : mem(1 + 1)). tv# = true | tv# = false: thm
val true_xor_false = {},  |- !(tv : mem(1 + 1)). ~tv# = true <=> tv# = false:
   thm
val false_xor_true = {},  |- !(tv : mem(1 + 1)). ~tv# = false <=> tv# = true:
   thm
val tv_eq_true =
   {}, 
   |- !(tv1 : mem(1 + 1))  (tv2 : mem(1 + 1)).
        tv1# = tv2# <=> tv1# = true <=> tv2# = true: thm
val tf_eq_true =
   {}, 
   |- !(A : set)  (tf1 : fun(A#, 1 + 1))  (tf2 : fun(A#, 1 + 1)).
        tf1# = tf2# <=>
        !(a : mem(A#)). App(tf1#, a#) = true <=> App(tf2#, a#) = true: thm
val basic_fconv_tac = fn: conv -> fconv -> tactic
val depth_fconv_tac = fn: conv -> fconv -> tactic
val forall_cross_tac = fn: tactic
******

Loading SEAR file lambda.sml

******
val TAUT = {},  |- A | ~A: thm
val cond_unique_lemma =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b# = b'#: thm
val cond_unique_lemma' =
   {}, 
   |- !(A : set)  (a : mem(A#)).
        P(a#) ==>
        !(B : set)  (b : mem(B#)). ?!(b' : mem(B#)). P(a#) & b'# = b#: thm
val conj1 = fn: form -> form
val conj2 = fn: form -> form
val conjIs = fn: thm list -> thm
val disj1 = fn: form -> form
val disj2 = fn: form -> form
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val disj_neg_absorb = {},  |- A | ~A & B <=> A | B: thm
val disj_of_negconj = {},  |- ~A & ~B <=> ~(A | B): thm
val djE = fn: form * thm -> form * thm -> form * thm
val djEs = fn: (form * thm) list -> form * thm
val drop_last_cj = fn: form -> form * form
val iant = fn: form -> form
val iconc = fn: form -> form
val imp_dimp_distr = {},  |- A ==> (B <=> C) <=> A ==> B <=> A ==> C: thm
val strip_conj = fn: form -> form list
val strip_disj = fn: form -> form list
val cond_rw_fconv = fn: form -> thm
val conj_assoc_fm = fn: form -> form
val define_lambda = fn: form -> thm
val define_lambda_fun = fn: form -> thm
val nlist = fn: int -> int list
val normalise_lambda_input = fn: form -> form
val it = (): unit
val NOT_def = {},  |- App(NOT, true) = false & App(NOT, false) = true: thm
val OR_def =
   {}, 
   |- App(OR, Pair(true, true)) = true &
      App(OR, Pair(true, false)) = true &
      App(OR, Pair(false, true)) = true & App(OR, Pair(false, false)) = false:
   thm
val constf_def =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#))  (a : mem(A#)).
        App(constf(A#, b#), a#) = b#: thm
val f2r_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * B#, 1 + 1))  (a : mem(A#))
      (b : mem(B#)). Holds(f2r(f#), a#, b#) <=> App(f#, Pair(a#, b#)) = true:
   thm
val r2f_def =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = App(i2(1, 1), dot) <=> Holds(R#, a#, b#):
   thm
val r2f_def' =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(r2f(R#), Pair(a#, b#)) = true <=> Holds(R#, a#, b#): thm
val ss2f =
   {(A : set), (s : mem(Pow(A)))}, 
   |- !(a : mem(A)). App(ss2f(s), a#) = true <=> IN(a#, s): thm
val FIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : fun(A, B))}, 
   |- FIB(f, b) = PREIM(f, Sing(b)): thm
val Inj_Image_Inj =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(A#, B#)). Inj(i#) ==> Inj(Image(i#)):
   thm
val mApp_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (f : mem(Exp(A#, B#))).
        mApp(f#, a#) = App(tof(f#), a#): thm
val mFIB_def =
   {(A : set), (B : set), (b : mem(B)), (f : mem(Exp(A, B)))}, 
   |- mFIB(f, b) = PREIM(tof(f), Sing(b)): thm
val Compl_Whole = {},  |- !(A : set). Compl(Whole(A#)) = Empty(A#): thm
val Compl_Empty = {},  |- !(A : set). Compl(Empty(A#)) = Whole(A#): thm
val Inter_Compl_Compl =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J)))}, 
   |- Inter(Compl(s1), Compl(s2)) = Compl(Union(s1, s2)): thm
val neg_or_distr = {},  |- ~(A | B) <=> ~A & ~B: thm
val SS_Union =
   {}, 
   |- (!(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
          SS(a#, Union(a#, b#))) &
      !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val SS_Union1 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(a#, b#)): thm
val SS_Union2 =
   {}, 
   |- !(A : set)  (a : mem(Pow(A#)))  (b : mem(Pow(A#))).
        SS(a#, Union(b#, a#)): thm
val Ins_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (s0 : mem(Pow(X#)))  (a : mem(X#)).
        IN(a#, Ins(x0#, s0#)) <=> a# = x0# | IN(a#, s0#): thm
val Union_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Union(Sing(a#), s#) = Ins(a#, s#): thm
val SS_Ins =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(s#, Ins(a#, s#)):
   thm
val BIGINTER_Sing =
   {},  |- !(A : set)  (s : mem(Pow(A#))). BIGINTER(Sing(s#)) = s#: thm
val Whole_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Whole(A#), s#) = s#: thm
val Inter_Whole =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Whole(A#)) = s#: thm
val IN_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Inter(s1#, s2#)) <=> IN(a#, s1#) & IN(a#, s2#): thm
val Empty_SS = {},  |- !(A : set)  (s : mem(Pow(A#))). SS(Empty(A#), s#): thm
val BIGINTER_Empty = {(A : set)},  |- BIGINTER(Empty(Pow(A))) = Whole(A): thm
val BIGINTER_Ins_Empty =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#))). BIGINTER(Ins(x#, Empty(Pow(A#)))) = x#:
   thm
val Inter_same = {},  |- !(A : set)  (x : mem(Pow(A#))). Inter(x#, x#) = x#:
   thm
val BIGINTER_Ins =
   {}, 
   |- !(A : set)  (x : mem(Pow(A#)))  (xs0 : mem(Pow(Pow(A#)))).
        BIGINTER(Ins(x#, xs0#)) = Inter(x#, BIGINTER(xs0#)): thm
val imp_or_distr = {},  |- A | B ==> C <=> (A ==> C) & (B ==> C): thm
val BIGINTER_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(Pow(A#))))  (s2 : mem(Pow(Pow(A#)))).
        BIGINTER(Union(s1#, s2#)) = Inter(BIGINTER(s1#), BIGINTER(s2#)): thm
val Empty_Inter =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(Empty(A#), s#) = Empty(A#):
   thm
val Union_EMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val neg_and_distr = {},  |- ~(A & B) <=> ~A | ~B: thm
val SS_Union_split =
   {}, 
   |- !(W : set)  (A : mem(Pow(W#)))  (B : mem(Pow(W#)))  (s : mem(Pow(W#))).
        SS(s#, Union(A#, B#)) <=>
        ?(s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
          SS(s1#, A#) & SS(s2#, B#) & s# = Union(s1#, s2#): thm
val Inter_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Inter(s#, Empty(A#)) = Empty(A#):
   thm
val SS_Sing =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        SS(s#, Sing(a#)) <=> s# = Sing(a#) | s# = Empty(A#): thm
val Empty_Union =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(Empty(A#), s#) = s#: thm
val SS_Empty =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))). SS(s#, Empty(A#)) <=> s# = Empty(A#):
   thm
val disj_assoc = {},  |- (A | B) | C <=> A | B | C: thm
val Union_assoc =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Union(Union(s1#, s2#), s3#) = Union(s1#, Union(s2#, s3#)): thm
val Inter_Whole_Whole =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Whole(A#) <=> s1# = Whole(A#) & s2# = Whole(A#):
   thm
val Union_SS1 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(Union(s1#, s2#), s#) <=> SS(s1#, s#) & SS(s2#, s#): thm
val SS_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s#, Inter(s1#, s2#)) <=> SS(s#, s1#) & SS(s#, s2#): thm
val Union_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        SS(Inter(s1#, s2#), s1#) & SS(Inter(s1#, s2#), s2#): thm
val Whole_SS =
   {}, 
   |- !(A : set)  (X : mem(Pow(A#))). SS(Whole(A#), X#) ==> X# = Whole(A#):
   thm
val SS_Whole = {},  |- !(A : set)  (X : mem(Pow(A#))). SS(X#, Whole(A#)): thm
val Sing_Ins_Empty =
   {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = Ins(a#, Empty(A#)): thm
val EMPTY_Empty_Whole =
   {},  |- !(A : set). EMPTY(A#) <=> Empty(A#) = Whole(A#): thm
val NOT_EMPTY = {},  |- !(A : set). ~EMPTY(A#) <=> ?(a : mem(A#)). T: thm
val NEQ_IN =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val PSS_def =
   {(A : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(A)))}, 
   |- PSS(s1, s2) <=> SS(s1, s2) & ~s1 = s2: thm
val PSS_alt =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) <=>
        SS(s1#, s2#) & ?(a : mem(A#)). IN(a#, s2#) & ~IN(a#, s1#): thm
val Inter_Compl =
   {},  |- !(A : set)  (a : mem(Pow(A#))). Inter(a#, Compl(a#)) = Empty(A#):
   thm
val neg_iff = {},  |- ~(A <=> B) <=> A & ~B | B & ~A: thm
val Union_Empty2 =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Union(s#, Empty(A#)) = s#: thm
val Inter_eq_Empty =
   {}, 
   |- !(W : set)  (s1 : mem(Pow(W#)))  (s2 : mem(Pow(W#))).
        Inter(s1#, s2#) = Empty(W#) <=> SS(s2#, Compl(s1#)): thm
val PSS_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        PSS(s1#, s2#) ==> SS(s1#, s2#): thm
val SS_BIGUNION =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(Pow(A#)))))
      (s0 : mem(Pow(Pow(A#)))).
        IN(s0#, ss#) & SS(s#, s0#) ==> SS(s#, BIGUNION(ss#)): thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#))).
        IMAGE(f#, s#) = Empty(B#) <=> s# = Empty(A#): thm
val Del_def =
   {}, 
   |- !(X : set)  (s0 : mem(Pow(X#)))  (x0 : mem(X#))  (a : mem(X#)).
        IN(a#, Del(s0#, x0#)) <=> IN(a#, s0#) & ~a# = x0#: thm
val c31_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c31(abc) = Fst(abc): thm
val c32_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c32(abc) = Fst(Snd(abc)): thm
val c33_def =
   {(A : set), (B : set), (C : set), (abc : mem(A * B * C))}, 
   |- c33(abc) = Snd(Snd(abc)): thm
val Del_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        ~IN(x0#, xs0#) ==> Del(Ins(x0#, xs0#), x0#) = xs0#: thm
val Ins_absorb =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#))).
        IN(x0#, xs0#) ==> Ins(x0#, xs0#) = xs0#: thm
val Ins_Del =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, s#) ==> Ins(a#, Del(s#, a#)) = s#: thm
val IMAGE_eq_Empty =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
        IMAGE(f#, ss#) = Empty(B#) <=> ss# = Empty(A#): thm
val NOTIN_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        ~IN(a#, s#) ==> Del(s#, a#) = s#: thm
val Inj_IMAGE_Del =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#)))
      (a : mem(A#)).
        Inj(f#) ==>
        IMAGE(f#, Del(ss#, a#)) = Del(IMAGE(f#, ss#), App(f#, a#)): thm
val disj_not_imp = {},  |- A | ~B <=> B ==> A: thm
val exists_forall = fn: string * sort -> thm
val exists_forall_th =
   {(A : set)},  |- (?(a : mem(A)). f0(a#)) <=> ~!(a : mem(A)). ~f0(a#): thm
val not_disj_imp = {},  |- ~B | A <=> B ==> A: thm
val set_NEQ =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~s1# = s2# <=>
        (?(a : mem(A#)). IN(a#, s1#) & ~IN(a#, s2#)) |
        ?(a : mem(A#)). ~IN(a#, s1#) & IN(a#, s2#): thm
val Pa_Inj =
   {}, 
   |- !(X : set)  (A : set)  (f : fun(X#, A#)).
        Inj(f#) ==> !(B : set)  (g : fun(X#, B#)). Inj(Pa(g#, f#)): thm
val o_Inj_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_restrict =
   {}, 
   |- !(D : set)  (D0 : set)  (i1 : fun(D#, D0#)).
        Inj(i1#) ==>
        !(C : set)  (C0 : set)  (i2 : fun(C#, C0#)).
          Inj(i2#) ==>
          !(f0 : fun(D0#, C0#)).
            (!(d : mem(D#)).
                ?!(c : mem(C#)). App(f0# o i1#, d#) = App(i2#, c#)) ==>
            ?!(f : fun(D#, C#)). i2# o f# = f0# o i1#: thm
val SS_Del =
   {},  |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))). SS(Del(s#, a#), s#):
   thm
val Inj_o_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (C : set)  (g : fun(B#, C#)).
        Inj(g# o f#) ==> Inj(f#): thm
val SS_Ins_Del =
   {}, 
   |- !(A : set)  (a : mem(A#))  (ss : mem(Pow(A#)))  (G : mem(Pow(A#))).
        SS(ss#, Ins(a#, G#)) ==> SS(Del(ss#, a#), G#): thm
val SOME_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (x2 : mem(X#)).
        SOME(x1#) = SOME(x2#) <=> x1# = x2#: thm
val option_xor =
   {}, 
   |- !(A : set)  (a1 : mem(A# + 1)).
        ~a1# = NONE(A#) <=> ?!(a0 : mem(A#)). a1# = SOME(a0#): thm
val NOT_true_iff_false =
   {},  |- !(tv : mem(1 + 1)). App(NOT, tv#) = true <=> tv# = false: thm
val SOME_NOTNONE = {},  |- !(X : set)  (x : mem(X#)). ~SOME(x#) = NONE(X#):
   thm
val OM_def =
   {(A : set), (B : set), (f : fun(A, B))}, 
   |- App(OM(f), NONE(A)) = NONE(B) &
      !(a : mem(A)). App(OM(f), SOME(a#)) = SOME(App(f, a#)): thm
val Prla_split =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g1 : fun(B1#, B2#))
      (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f2# o f1#, g2# o g1#) = Prla(f2#, g2#) o Prla(f1#, g1#): thm
val Prla_lsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, g#) o Prla(f1#, Id(B1#)): thm
val Prla_lsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f1 : fun(A1#, A2#))  (A3 : set)
      (f2 : fun(A2#, A3#))  (B1 : set)  (B2 : set)  (g : fun(B1#, B2#)).
        Prla(f2# o f1#, g#) = Prla(f2#, Id(B2#)) o Prla(f1#, g#): thm
val Prla_Id =
   {},  |- !(A : set)  (B : set). Prla(Id(A#), Id(B#)) = Id(A# * B#): thm
val Prla_rsplit1 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(f#, g2#) o Prla(Id(A1#), g1#): thm
val Prla_rsplit2 =
   {}, 
   |- !(A1 : set)  (A2 : set)  (f : fun(A1#, A2#))  (B1 : set)  (B2 : set)
      (g1 : fun(B1#, B2#))  (B3 : set)  (g2 : fun(B2#, B3#)).
        Prla(f#, g2# o g1#) = Prla(Id(A2#), g2#) o Prla(f#, g1#): thm
val P2fun_uex' =
   {}, 
   |- !(A : set)  (B : set).
        (!(x : mem(A#)). ?!(y : mem(B#)). P(x#, y#)) ==>
        ?!(f : fun(A#, B#)). !(a : mem(A#)). P(a#, App(f#, a#)): thm
val Diff_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, Diff(s1#, s2#)) <=> IN(a#, s1#) & ~IN(a#, s2#): thm
val Inter_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        ~Inter(s#, Sing(a#)) = Empty(A#) <=> IN(a#, s#): thm
val Rrefl =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A)).
        ?(f : fun(B#, B#))  (g : fun(B#, B#)).
          f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#:
   thm
val Rsym =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
        ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
          f# o g# = Id(B#) &
          g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#: thm
val Rtrans =
   {(A : set)}, 
   |- !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_eqv =
   {(A : set)}, 
   |- (!(B : set)  (i : fun(B#, A)).
          ?(f : fun(B#, B#))  (g : fun(B#, B#)).
            f# o g# = Id(B#) & g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
      (!(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
          ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
            f# o g# = Id(B#) &
            g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
      !(B : set)  (i : fun(B#, A))  (B' : set)  (i' : fun(B'#, A))
      (B'' : set)  (i'' : fun(B''#, A)).
        (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
            f# o g# = Id(B'#) &
            g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
        (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
        ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
          f# o g# = Id(B''#) &
          g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val T24_ts_ex = {},  |- !(A : set). ?(B : set)  (i : fun(B#, A#)). T: thm
val Thm_2_4' =
   {}, 
   |- !(A : set).
        ?(B : set)  (i : fun(B#, A#)).
          (Inj(i#) &
            !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
          !(B' : set)  (i' : fun(B'#, A#)).
            Inj(i'#) &
            (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
            ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val Thm_2_4_unique =
   {}, 
   |- !(A : set)  (B : set)  (i : fun(B#, A#))  (B' : set)
      (i' : fun(B'#, A#)).
        (Inj(i#) & !(a : mem(A#)). P(a#) <=> ?(b : mem(B#)). a# = App(i#, b#)) &
        Inj(i'#) &
        (!(a : mem(A#)). P(a#) <=> ?(b : mem(B'#)). a# = App(i'#, b#)) ==>
        ?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
          f# o g# = Id(B'#) &
          g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#: thm
val set_spec = fn:
   term -> string -> string -> (string * sort) list -> thm -> thm
val set_spec_arg12eqr0 =
   ([("B", set), ("i", fun(B, A))], [("B'", set), ("i'", fun(B', A))],
    ?(f : fun(B, B'))  (g : fun(B', B)).
      f# o g# = Id(B') & g# o f# = Id(B) & i' o f# = i & i o g# = i'):
   (string * sort) list * (string * sort) list * form
val set_spec_eqv =
   {}, 
   |- !(A : set).
        (!(B : set)  (i : fun(B#, A#)).
            ?(f : fun(B#, B#))  (g : fun(B#, B#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B#) & i# o f# = i# & i# o g# = i#) &
        (!(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#)).
            (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
                f# o g# = Id(B'#) &
                g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) ==>
            ?(f : fun(B'#, B#))  (g : fun(B#, B'#)).
              f# o g# = Id(B#) &
              g# o f# = Id(B'#) & i# o f# = i'# & i'# o g# = i#) &
        !(B : set)  (i : fun(B#, A#))  (B' : set)  (i' : fun(B'#, A#))
        (B'' : set)  (i'' : fun(B''#, A#)).
          (?(f : fun(B#, B'#))  (g : fun(B'#, B#)).
              f# o g# = Id(B'#) &
              g# o f# = Id(B#) & i'# o f# = i# & i# o g# = i'#) &
          (?(f : fun(B'#, B''#))  (g : fun(B''#, B'#)).
              f# o g# = Id(B''#) &
              g# o f# = Id(B'#) & i''# o f# = i'# & i'# o g# = i''#) ==>
          ?(f : fun(B#, B''#))  (g : fun(B''#, B#)).
            f# o g# = Id(B''#) &
            g# o f# = Id(B#) & i''# o f# = i# & i# o g# = i''#: thm
val Diff_Empty =
   {},  |- !(A : set)  (s : mem(Pow(A#))). Diff(s#, Empty(A#)) = s#: thm
val Diff_Empty_SS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Diff(s1#, s2#) = Empty(A#) <=> SS(s1#, s2#): thm
val Ins_Union =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        Ins(a#, s#) = Union(Sing(a#), s#): thm
val Union_Empty_both_Empty =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Empty(A#) <=> s1# = Empty(A#) & s2# = Empty(A#):
   thm
val Inter_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#))).
        Inter(s1#, Union(s2#, s3#)) = Union(Inter(s1#, s2#), Inter(s1#, s3#)):
   thm
val Inter_Diff_Sing_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Sing(x#)) = Empty(A#) <=>
        IN(x#, Diff(s1#, s2#)): thm
val Diff_Ins_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s3 : mem(Pow(A#)))  (x : mem(A#)).
        ~Inter(Diff(s1#, s2#), Ins(x#, s3#)) = Empty(A#) <=>
        ~Inter(Diff(s1#, s2#), s3#) = Empty(A#) | IN(x#, Diff(s1#, s2#)): thm
val Inter_Empty2 =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Inter(s1#, s2#) = Empty(A#) ==>
        !(a : mem(A#)). IN(a#, s2#) ==> ~IN(a#, s1#): thm
val Inter_both_NONEMPTY =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        ~Inter(s1#, s2#) = Empty(A#) ==> ~s1# = Empty(A#) & ~s2# = Empty(A#):
   thm
val neg_imp_conj = {},  |- ~(A ==> B) <=> A & ~B: thm
val forall_exists_dual =
   {},  |- !(A : set). (!(a : mem(A#)). P(a#)) <=> ~?(a : mem(A#)). ~P(a#):
   thm
val neg_conj_imp = {},  |- ~(A & B) <=> A ==> ~B: thm
val it = (): unit
******

Loading SEAR file SEARNarith.sml

******
val Nind's_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        IN(a#, Nind's(f0, x0)) <=> SS(App(Nindf(f0, x0), a#), a#): thm
val Nind_cases0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- App(Nindf(f0, x0), Ninds(f0, x0)) = Ninds(f0, x0): thm
val Nind_cases1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_incond =
   !(nx : mem(N * X)).
     IN(nx#, Nind1) <=>
     nx# = Pair(O, x0) |
     ?(nx0 : mem(N * X)).
       IN(nx0#, Nind0) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): form
val Nind_ind =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), ss#), ss#) ==> SS(Ninds(f0, x0), ss#): thm
val Nind_ind1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        (!(a : mem(N * X)).
            a# = Pair(O, x0) |
            (?(nx0 : mem(N * X)).
                IN(nx0#, ss#) & a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_ind2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(N * X))).
        IN(Pair(O, x0), ss#) &
        (!(nx0 : mem(N * X)).
            IN(nx0#, ss#) ==>
            IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), ss#)) ==>
        !(a : mem(N * X)). IN(a#, Ninds(f0, x0)) ==> IN(a#, ss#): thm
val Nind_rules0 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- SS(App(Nindf(f0, x0), Ninds(f0, x0)), Ninds(f0, x0)): thm
val Nind_rules1 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        a# = Pair(O, x0) |
        (?(nx0 : mem(N * X)).
            IN(nx0#, Ninds(f0, x0)) &
            a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#)))) ==>
        IN(a#, Ninds(f0, x0)): thm
val Nind_rules2 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (a# = Pair(O, x0) ==> IN(a#, Ninds(f0, x0))) &
        !(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          a# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))) ==>
          IN(a#, Ninds(f0, x0)): thm
val Nind_rules3 =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nindf_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
        IN(nx#, App(Nindf(f0, x0), a#)) <=>
        nx# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nindf_ex =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(N * X), Pow(N * X))).
        !(a : mem(Pow(N * X)))  (nx : mem(N * X)).
          IN(nx#, App(f#, a#)) <=>
          nx# = Pair(O, x0) |
          ?(nx0 : mem(N * X)).
            IN(nx0#, a#) & nx# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))):
   thm
val Nindf_monotone =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(N * X)))  (s2 : mem(Pow(N * X))).
        SS(s1#, s2#) ==> SS(App(Nindf(f0, x0), s1#), App(Nindf(f0, x0), s2#)):
   thm
val Ninds_SS =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(N * X))).
        SS(App(Nindf(f0, x0), a#), a#) ==> SS(Ninds(f0, x0), a#): thm
val Ninds_cond =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(a : mem(N * X)).
        (!(ss : mem(Pow(N * X))).
            SS(App(Nindf(f0, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Ninds(f0, x0)): thm
val Ninds_def =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- Ninds(f0, x0) = BIGINTER(Nind's(f0, x0)): thm
val x1 = "Nind0": string
val Nind_cases =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- !(x : mem(N * X)).
        IN(x#, Ninds(f0, x0)) <=>
        x# = Pair(O, x0) |
        ?(nx0 : mem(N * X)).
          IN(nx0#, Ninds(f0, x0)) &
          x# = Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))): thm
val Nind_rules =
   {(X : set), (f0 : fun(X, X)), (x0 : mem(X))}, 
   |- IN(Pair(O, x0), Ninds(f0, x0)) &
      !(nx0 : mem(N * X)).
        IN(nx0#, Ninds(f0, x0)) ==>
        IN(Pair(Suc(Fst(nx0#)), App(f0, Snd(nx0#))), Ninds(f0, x0)): thm
val Nind_uex =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        ?!(x : mem(X#)). IN(Pair(n#, x#), Ninds(f0#, x0#)): thm
val Nrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (a : mem(N)).
        IN(Pair(a#, App(Nrec(x0#, f0#), a#)), Ninds(f0#, x0#)): thm
val Nrec_O =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        App(Nrec(x0#, f0#), O) = x0#: thm
val App_Nrec_Ninds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N))
      (x : mem(X#)).
        App(Nrec(x0#, f0#), n#) = x# <=> IN(Pair(n#, x#), Ninds(f0#, x0#)):
   thm
val Nrec_Suc =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#))  (n : mem(N)).
        App(Nrec(x0#, f0#), Suc(n#)) = App(f0#, App(Nrec(x0#, f0#), n#)): thm
val Nrec_unique =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Nrec_Suc_eqn =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f0 : fun(X#, X#)).
        Nrec(x0#, f0#) o SUC = f0# o Nrec(x0#, f0#): thm
val El_def = {},  |- !(A : set)  (a : mem(A#)). App(El(a#), dot) = a#: thm
val El_eq_eq =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). El(a#) = El(b#) <=> a# = b#:
   thm
val App_o_El =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        App(f#, a#) = App(f# o El(a#), dot): thm
val Nrec_El =
   {}, 
   |- !(X : set)  (a : mem(X#))  (f : fun(X#, X#)).
        Nrec(a#, f#) o El(O) = El(a#) &
        Nrec(a#, f#) o SUC = f# o Nrec(a#, f#) &
        !(u : fun(N, X#)).
          u# o El(O) = El(a#) & u# o SUC = f# o u# ==> u# = Nrec(a#, f#): thm
val App_El_mem =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        App(f#, a#) = b# <=> f# o El(a#) = El(b#): thm
val Nrec_O_SUC = {},  |- Nrec(O, SUC) = Id(N): thm
val comm_with_SUC_id0 =
   {}, 
   |- !(f : fun(N, N)). App(f#, O) = O & f# o SUC = SUC o f# ==> f# = Id(N):
   thm
val comm_with_SUC_id =
   {}, 
   |- !(f : fun(N, N)).
        f# o El(O) = El(O) & f# o SUC = SUC o f# ==> f# = Id(N): thm
val Thm1_case1_comm_condition =
   {}, 
   |- !(B : set)  (f0 : fun(N, B#))  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        f0# o El(O) = g# & f0# o SUC = h# o Pa(Id(N), f0#) <=>
        Pa(Id(N), f0#) o El(O) = Pa(El(O), g#) &
        Pa((SUC o p1(N, B#)), h#) o Pa(Id(N), f0#) = Pa(Id(N), f0#) o SUC:
   thm
val Dot_def = {},  |- !(A : set)  (f : fun(1, A#)). Dot(f#) = App(f#, dot):
   thm
val Dot_of_El = {},  |- !(A : set)  (a : mem(A#)). Dot(El(a#)) = a#: thm
val El_of_Dot = {},  |- !(X : set)  (f : fun(1, X#)). El(Dot(f#)) = f#: thm
val to_P_component =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#)).
        Pa(p1(A#, B#) o f#, p2(A#, B#) o f#) = f#: thm
val Thm1_case_1 =
   {}, 
   |- !(B : set)  (g : fun(1, B#))  (h : fun(N * B#, B#)).
        ?!(f : fun(N, B#)). f# o El(O) = g# & f# o SUC = h# o Pa(Id(N), f#):
   thm
val is_Nrec =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (f : fun(X#, X#))  (r : fun(N, X#)).
        App(r#, O) = x0# & r# o SUC = f# o r# ==> r# = Nrec(x0#, f#): thm
val Tp1_ex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        ?(tpf : fun(1, Exp(A#, B#))). Tp(f# o p1(A#, 1)) = tpf#: thm
val Ev_of_Tp =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#)).
        Ev(A#, B#) o Pa(p1(A#, X#), Tp(f#) o p2(A#, X#)) = f#: thm
val Tp1_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Tp(f# o p1(A#, 1)) = Tp1(f#):
   thm
val Tp_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))
      (g : fun(A# * X#, B#)). Tp(f#) = Tp(g#) <=> f# = g#: thm
val Ev_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, Exp(A#, B#)))
      (g : fun(X#, Exp(A#, B#))).
        Ev(A#, B#) o Pa(p1(A#, X#), f# o p2(A#, X#)) = Ev(A#, B#) o
          Pa(p1(A#, X#), g# o p2(A#, X#)) ==> f# = g#: thm
val to_P_eq =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, A# * B#))
      (g : fun(X#, A# * B#)).
        p1(A#, B#) o f# = p1(A#, B#) o g# & p2(A#, B#) o f# = p2(A#, B#) o g# ==>
        f# = g#: thm
val Pa_o_split =
   {}, 
   |- !(B : set)  (X : set)  (f : fun(B#, X#))  (Y : set)  (g : fun(X#, Y#))
      (A : set).
        Pa(p1(A#, B#), g# o f# o p2(A#, B#)) =
          Pa(p1(A#, X#), (g# o p2(A#, X#))) o Pa(p1(A#, B#), f# o p2(A#, B#)):
   thm
val Thm1_comm_eq_left =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))  (g : fun(A#, B#)).
        Tp(f#) o El(O) = Tp1(g#) <=>
        f# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1): thm
val Pa_p1_p2 =
   {},  |- !(A : set)  (B : set). Pa(p1(A#, B#), p2(A#, B#)) = Id(A# * B#):
   thm
val Thm1_comm_eq_right =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A# * N, B#))
      (h : fun((A# * N) * B#, B#))
      (l : fun(A# * N * Exp(A#, B#), (A# * N) * B#)).
        Pa(Pa(p1(A#, N * Exp(A#, B#)), p1(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#))), Ev(A#, B#) o
           Pa(p1(A#, N * Exp(A#, B#)), p2(N, Exp(A#, B#)) o
            p2(A#, N * Exp(A#, B#)))) = l# ==>
        (h# o Pa(Id(A# * N), f#) = f# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
          Tp((h# o l#)) o Pa(Id(N), Tp(f#)) = Tp(f#) o SUC): thm
val Ev_of_Tp_el =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(A# * X#, B#))  (P : set)
      (a : fun(P#, A#))  (x : fun(P#, X#)).
        Ev(A#, B#) o Pa(a#, Tp(f#) o x#) = f# o Pa(a#, x#): thm
val Ev_of_Tp_el' =
   {}, 
   |- !(A : set)  (B : set)  (P : set)  (f : fun(A# * P#, B#))
      (a : fun(P#, A#)). Ev(A#, B#) o Pa(a#, Tp(f#)) = f# o Pa(a#, Id(P#)):
   thm
val Tp_of_Ev =
   {(A : set), (B : set), (X : set), (f : fun(X, Exp(A, B)))}, 
   |- Tp(Ev(A, B) o Pa(p1(A, X), f o p2(A, X))) = f: thm
val Thm1 =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val Thm1_uex =
   {}, 
   |- !(A : set)  (B : set)  (g : fun(A#, B#))  (h : fun((A# * N) * B#, B#)).
        ?!(f : fun(A# * N, B#)).
          !(f0 : fun(A# * N, B#)).
            f0# o Pa(p1(A#, 1), El(O) o p2(A#, 1)) = g# o p1(A#, 1) &
            h# o Pa(Id(A# * N), f0#) = f0# o Pa(p1(A#, N), SUC o p2(A#, N)) <=>
            f0# = f#: thm
val PRE_def = {},  |- PRE o El(O) = El(O) & PRE o SUC = Id(N): thm
val Pre_def = {},  |- !(n : mem(N)). Pre(n#) = App(PRE, n#): thm
val Pre_eqn = {},  |- Pre(O) = O & !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val ADD_def =
   {}, 
   |- ADD o Pa(p1(N, 1), El(O) o To1(N * 1)) = p1(N, 1) &
      SUC o ADD = ADD o Pa(p1(N, N), SUC o p2(N, N)): thm
val Add_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Add(n1#, n2#) = App(ADD, Pair(n1#, n2#)):
   thm
val Add_O = {},  |- !(n : mem(N)). Add(n#, O) = n#: thm
val App_input_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a1 : mem(A#))
      (a2 : mem(A#)). a1# = a2# ==> App(f#, a1#) = App(f#, a2#): thm
val Add_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, Suc(n#)) = Suc(Add(m#, n#)):
   thm
val Pre_O = {},  |- Pre(O) = O: thm
val Pre_Suc = {},  |- !(n : mem(N)). Pre(Suc(n#)) = n#: thm
val SUB_def =
   {}, 
   |- SUB o Pa(p1(N, 1), El(O) o p2(N, 1)) = p1(N, 1) &
      PRE o SUB = SUB o Pa(p1(N, N), SUC o p2(N, N)): thm
val o_eq_r =
   {}, 
   |- !(A : set)  (B : set)  (f1 : fun(A#, B#))  (f2 : fun(A#, B#)).
        f1# = f2# ==> !(C : set)  (g : fun(B#, C#)). g# o f1# = g# o f2#: thm
val Sub_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Sub(n1#, n2#) = App(SUB, Pair(n1#, n2#)):
   thm
val Sub_O = {},  |- !(n : mem(N)). Sub(n#, O) = n#: thm
val Sub_Suc =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, Suc(n#)) = Pre(Sub(m#, n#)):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Le_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Pre_eq_O = {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O):
   thm
val Lt_def =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val Le_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val Lt_Le = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> Le(m#, n#):
   thm
val Lt_NE = {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) ==> ~m# = n#: thm
val Le_NE_Lt =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) & ~m# = n# ==> Lt(m#, n#):
   thm
val Lt_Le_NE =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(m#, n#) <=> Le(m#, n#) & ~m# = n#:
   thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val Sub_mono_eq =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(Suc(m#), Suc(n#)) = Sub(m#, n#):
   thm
val Add_Sub = {},  |- !(c : mem(N))  (a : mem(N)). Sub(Add(a#, c#), c#) = a#:
   thm
val Add_O2 = {},  |- !(n : mem(N)). Add(O, n#) = n#: thm
val Sub_EQ_O = {},  |- !(n : mem(N)). Sub(n#, n#) = O: thm
val Le_refl = {},  |- !(n : mem(N)). Le(n#, n#): thm
val Le_O_O = {},  |- !(n : mem(N)). Le(n#, O) ==> n# = O: thm
val o_eq_l =
   {}, 
   |- !(B : set)  (C : set)  (g1 : fun(B#, C#))  (g2 : fun(B#, C#)).
        g1# = g2# ==> !(A : set)  (f : fun(A#, B#)). g1# o f# = g2# o f#: thm
val Le_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) ==> Lt(m#, n#) | m# = n#:
   thm
val Le_Sub =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) <=> Sub(m#, n#) = O: thm
val Suc_NONZERO = {},  |- !(n : mem(N)). ~Suc(n#) = O: thm
val cancel_Sub =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Le(a#, c#) ==> (Sub(b#, a#) = Sub(c#, a#) <=> b# = c#):
   thm
val th =
   {}, 
   |- P(O) & (!(n : mem(N)). P(n#) ==> P(Suc(n#))) ==> !(n : mem(N)). P(n#):
   thm
val Sub_of_O = {},  |- !(n : mem(N)). Sub(O, n#) = O: thm
val O_LESS_EQ = {},  |- !(x : mem(N)). Le(O, x#): thm
val LESS_EQ_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val LESS_O = {},  |- !(n : mem(N)). Lt(O, Suc(n#)): thm
val LESS_MONO_EQ =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val LE_O_iff = {},  |- !(n : mem(N)). Le(n#, O) <=> n# = O: thm
val LESS_cases =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | Le(b#, a#): thm
val LESS_EQ_cases =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(m#, n#) | Le(n#, m#): thm
val Add_Suc1 =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(Suc(a#), b#) = Suc(Add(a#, b#)):
   thm
val Add_comm =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(a#, b#) = Add(b#, a#): thm
val Suc_Sub = {},  |- !(n : mem(N)). Sub(Suc(n#), n#) = Suc(O): thm
val Sub_DIFF_1 =
   {},  |- !(a : mem(N))  (b : mem(N)). Sub(a#, b#) = Suc(O) <=> a# = Suc(b#):
   thm
val Pre_O_cases =
   {},  |- !(n : mem(N)). Pre(n#) = O <=> n# = O | n# = Suc(O): thm
val Sub_Suc_O_cases =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, Suc(b#)) = O ==> a# = Suc(b#) | Sub(a#, b#) = O: thm
val Le_cases_iff =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) <=> Lt(a#, b#) | a# = b#:
   thm
val Lt_Suc_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Suc(b#)) <=> Le(a#, b#): thm
val Sub_EQ_O1 =
   {},  |- !(m : mem(N))  (n : mem(N)). Sub(m#, n#) = O <=> Le(m#, n#): thm
val NOT_Lt_O = {},  |- !(n : mem(N)). ~Lt(n#, O): thm
val strong_ind =
   {}, 
   |- (!(a : mem(N)). (!(a0 : mem(N)). Lt(a0#, a#) ==> P(a0#)) ==> P(a#)) ==>
      !(a : mem(N)). P(a#): thm
val WOP =
   {}, 
   |- !(a : mem(N)).
        P(a#) ==>
        ?(a0 : mem(N)). P(a0#) & !(a1 : mem(N)). P(a1#) ==> Le(a0#, a1#): thm
val MUL_def0 =
   {}, 
   |- MUL o Pa(p1(N, 1), El(O) o To1(N * 1)) = El(O) o To1(N * 1) &
      ADD o Pa(MUL, p1(N, N)) = MUL o Pa(p1(N, N), SUC o p2(N, N)): thm
val Mul_def =
   {}, 
   |- !(n1 : mem(N))  (n2 : mem(N)). Mul(n1#, n2#) = App(MUL, Pair(n1#, n2#)):
   thm
val App_Pa2 =
   {}, 
   |- !(A : set)  (B : set)  (D : set)  (g : fun(B#, D#))
      (ab : mem(A# * B#)).
        App(Pa(p1(A#, B#), g# o p2(A#, B#)), ab#) =
          Pair(App(p1(A#, B#), ab#), App(g# o p2(A#, B#), ab#)): thm
val App_p1_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p1(A#, B#), Pair(a#, b#)) = a#: thm
val App_p2_Pair =
   {}, 
   |- !(A : set)  (B : set)  (a : mem(A#))  (b : mem(B#)).
        App(p2(A#, B#), Pair(a#, b#)) = b#: thm
val Mul_O = {},  |- !(n : mem(N)). Mul(n#, O) = O: thm
val Mul_Suc =
   {}, 
   |- !(n : mem(N))  (n0 : mem(N)). Mul(n#, Suc(n0#)) = Add(Mul(n#, n0#), n#):
   thm
val Mul_LEFT_O = {},  |- !(m : mem(N)). Mul(O, m#) = O: thm
val Mul_LEFT_1 = {},  |- !(m : mem(N)). Mul(Suc(O), m#) = m#: thm
val Mul_RIGHT_1 = {},  |- !(m : mem(N)). Mul(m#, Suc(O)) = m#: thm
val Add_comm' =
   {},  |- !(b : mem(N))  (a : mem(N)). Add(b#, a#) = Add(a#, b#): thm
val Add_assoc =
   {}, 
   |- !(m : mem(N))  (n0 : mem(N))  (p : mem(N)).
        Add(m#, Add(n0#, p#)) = Add(Add(m#, n0#), p#): thm
val Add_eq_eq =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (a : mem(N)).
        Add(m#, a#) = Add(n#, a#) ==> m# = n#: thm
val Mul_Suc1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Mul(Suc(n#), m#) = Add(m#, Mul(n#, m#)):
   thm
val Mul_clauses =
   {}, 
   |- (!(m : mem(N)).
          Mul(O, m#) = O &
          Mul(m#, O) = O & Mul(Suc(O), m#) = m# & Mul(m#, Suc(O)) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Mul(Suc(m#), n#) = Add(Mul(m#, n#), n#) &
        Mul(m#, Suc(n#)) = Add(m#, Mul(m#, n#)): thm
val Mul_comm =
   {},  |- !(m : mem(N))  (n : mem(N)). Mul(m#, n#) = Mul(n#, m#): thm
val Add_clauses =
   {}, 
   |- (!(m : mem(N)). Add(O, m#) = m# & Add(m#, O) = m#) &
      !(m : mem(N))  (n : mem(N)).
        Add(Suc(m#), n#) = Suc(Add(m#, n#)) &
        Add(m#, Suc(n#)) = Suc(Add(m#, n#)): thm
val Nind_tac = fn: tactic
val RIGHT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Add(m#, n#), p#) = Add(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Add(m#, n#)) = Add(Mul(p#, m#), Mul(p#, n#)): thm
val Mul_assoc =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(m#, Mul(n#, p#)) = Mul(Mul(m#, n#), p#): thm
val Sub_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Sub(a#, Add(b#, c#)) = Sub(Sub(a#, b#), c#): thm
val Le_O_iff = {},  |- !(a : mem(N)). Le(a#, O) <=> a# = O: thm
val Le_Suc =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, Suc(b#)) ==> Le(a#, b#) | a# = Suc(b#): thm
val Le_Add_ex =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(n#, m#) ==> ?(p : mem(N)). Add(p#, n#) = m#: thm
val LE_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Sub(a#, b#) = O:
   thm
val LT_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Holds(LT, a#, b#) <=> Holds(LE, a#, b#) & ~a# = b#: thm
val LE_Le =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LE, a#, b#) <=> Le(a#, b#): thm
val LT_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Holds(LT, a#, b#) <=> Lt(a#, b#): thm
val LE_Trans = {},  |- Trans(LE): thm
val LESS_MONO_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(m#, n#) <=> Lt(Add(m#, p#), Add(n#, p#)): thm
val EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val LESS_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Lt(Add(m#, p#), Add(n#, p#)) <=> Lt(m#, n#): thm
val LESS_OR_EQ =
   {(m : mem(N)), (n : mem(N))},  |- Le(m, n) <=> Lt(m, n) | m = n: thm
val LESS_EQ_MONO_ADD_EQ =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(Add(m#, p#), Add(n#, p#)) <=> Le(m#, n#): thm
val Le_Add =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, c#) & Le(b#, d#) ==> Le(Add(a#, b#), Add(c#, d#)): thm
val Le_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Le(a1#, a2#) & Le(a2#, a3#) ==> Le(a1#, a3#): thm
val Asym_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Asym(R#) <=>
        !(a : mem(A#))  (b : mem(A#)).
          Holds(R#, a#, b#) & Holds(R#, b#, a#) ==> a# = b#: thm
val Lt_Suc = {},  |- !(a : mem(N)). Lt(a#, Suc(a#)): thm
val Suc_NEQ = {},  |- !(a : mem(N)). ~a# = Suc(a#): thm
val Add_Suc_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, Add(a#, Suc(b#))): thm
val LT_Trans = {},  |- Trans(LT): thm
val Lt_trans =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N)).
        Lt(a1#, a2#) & Lt(a2#, a3#) ==> Lt(a1#, a3#): thm
val LE_Asym = {},  |- Asym(LE): thm
val Le_Asym =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) ==> a# = b#:
   thm
val LESS_EQ_LESS_EQ_MONO =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N))  (q : mem(N)).
        Le(m#, p#) & Le(n#, q#) ==> Le(Add(m#, n#), Add(p#, q#)): thm
val Le_MONO_Mul =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(m#, n#) ==> Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul' =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Le(m#, n#) ==> !(p : mem(N)). Le(Mul(m#, p#), Mul(n#, p#)): thm
val Le_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Le(m#, i#) & Le(n#, j#) ==> Le(Mul(m#, n#), Mul(i#, j#)): thm
val Le_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Le(Suc(m#), Suc(n#)) <=> Le(m#, n#):
   thm
val Le_O' = {},  |- !(x : mem(N)). Le(O, x#): thm
val Sub_Suc1 =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(b#, a#) ==> Sub(Suc(a#), b#) = Suc(Sub(a#, b#)): thm
val SUB_ADD =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). Le(n#, m#) ==> Add(Sub(m#, n#), n#) = m#:
   thm
val ADD_EQ_SUB =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Le(n#, p#) ==> (Add(m#, n#) = p# <=> m# = Sub(p#, n#)): thm
val NOT_SUC_LESS_EQ_O = {},  |- !(n : mem(N)). ~Le(Suc(n#), O): thm
val NOT_SUC_LT_O = {},  |- !(n : mem(N)). ~Lt(Suc(n#), O): thm
val Lt_MONO =
   {},  |- !(m : mem(N))  (n : mem(N)). Lt(Suc(m#), Suc(n#)) <=> Lt(m#, n#):
   thm
val Lt_trichotomy =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) | a# = b# | Lt(b#, a#):
   thm
val NEQ_O_Lt = {},  |- !(a : mem(N)). ~a# = O <=> Lt(O, a#): thm
val Add_eq_O =
   {},  |- !(m : mem(N))  (n : mem(N)). Add(m#, n#) = O <=> m# = O & n# = O:
   thm
val Mul_eq_O =
   {}, 
   |- !(a : mem(N)). ~a# = O ==> !(b : mem(N)). Mul(a#, b#) = O <=> b# = O:
   thm
val Sub_Sub_O_eq =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Sub(a#, b#) = O & Sub(b#, a#) = O ==> a# = b#: thm
val NOT_LESS =
   {},  |- !(m : mem(N))  (n : mem(N)). ~Lt(m#, n#) <=> Le(n#, m#): thm
val RIGHT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(Sub(m#, n#), p#) = Sub(Mul(m#, p#), Mul(n#, p#)): thm
val LEFT_SUB_DISTR =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Mul(p#, Sub(m#, n#)) = Sub(Mul(p#, m#), Mul(p#, n#)): thm
val MULT_MONO_EQ =
   {}, 
   |- !(n : mem(N))  (m : mem(N))  (i : mem(N)).
        Mul(Suc(n#), m#) = Mul(Suc(n#), i#) <=> m# = i#: thm
val Mul_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        ~p# = O ==> (Mul(m#, p#) = Mul(n#, p#) <=> m# = n#): thm
val Lt_MONO_Mul =
   {}, 
   |- !(p : mem(N)).
        Lt(O, p#) ==>
        !(m : mem(N))  (n : mem(N)).
          Lt(m#, n#) ==> Lt(Mul(m#, p#), Mul(n#, p#)): thm
val Le_Lt_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Lt(a#, c#): thm
val Lt_O_Lt = {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) ==> Lt(O, b#):
   thm
val Lt_MONO_Mul2 =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (i : mem(N))  (j : mem(N)).
        Lt(m#, i#) & Lt(n#, j#) ==> Lt(Mul(m#, n#), Mul(i#, j#)): thm
val LESS_ADD_NONZERO =
   {},  |- !(m : mem(N))  (n : mem(N)). ~n# = O ==> Lt(m#, Add(m#, n#)): thm
val SUB_LESS =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        Lt(O, n#) & Le(n#, m#) ==> Lt(Sub(m#, n#), m#): thm
val Add_leq =
   {}, 
   |- !(a1 : mem(N))  (a2 : mem(N))  (b : mem(N)).
        a1# = a2# ==> Add(a1#, b#) = Add(a2#, b#): thm
val Add_req =
   {}, 
   |- !(a : mem(N))  (b1 : mem(N))  (b2 : mem(N)).
        b1# = b2# ==> Add(a#, b1#) = Add(a#, b2#): thm
val Add_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, b#), Add(c#, d#)): thm
val Add_split_middle =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(a#, Add(Add(b#, c#), d#)): thm
val Add_last_middle_split =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(a#, Add(b#, Add(c#, d#))) = Add(Add(a#, d#), Add(b#, c#)): thm
val Add_eq_eq_l =
   {}, 
   |- !(m : mem(N))  (n : mem(N))  (p : mem(N)).
        Add(m#, p#) = Add(n#, p#) <=> m# = n#: thm
val Add_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (m : mem(N))  (n : mem(N)).
        Add(a#, m#) = Add(a#, n#) <=> m# = n#: thm
val Lt_Sub_O =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(a#, b#) <=> Lt(O, Sub(b#, a#)):
   thm
val Lt_Le_Lt =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(a#, b#) & Le(b#, c#) ==> Lt(a#, c#): thm
val LESS_EQ_SUC = {},  |- !(n : mem(N)). Le(n#, Suc(n#)): thm
val Le_Lt_Le =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Le(a#, b#) & Lt(b#, c#) ==> Le(a#, c#): thm
val Add_Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Add(Add(a#, b#), Add(c#, d#)) = Add(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Le(c#, d#) ==> Le(Add(a#, c#), Add(b#, d#)): thm
val Le_Lt_Lt_MONO_Add2 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Le(a#, b#) & Lt(c#, d#) ==> Lt(Add(a#, c#), Add(b#, d#)): thm
val Add_Rarr =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Add(a#, Add(b#, c#)) = Add(b#, Add(a#, c#)): thm
val NOT_LESS_EQ =
   {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
val SUC_NOT_LESS_EQ = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
val Lt_Le_Suc =
   {},  |- !(a : mem(N))  (b : mem(N)). Lt(b#, a#) <=> Le(Suc(b#), a#): thm
val Le_Le_iff_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, b#) & Le(b#, a#) <=> a# = b#:
   thm
val Le_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Le(a#, b#) ==> Le(Sub(a#, c#), Sub(b#, c#)): thm
val Lt_imp_Sub_O =
   {(a : mem(N)), (b : mem(N))},  |- Lt(a, b) ==> Sub(a, b) = O: thm
val Lt_Sub_imp_Le =
   {(a : mem(N)), (b : mem(N)), (c : mem(N))}, 
   |- Lt(a, Sub(b, c)) ==> Le(c, b): thm
val Lt_MONO_Sub_hard_direction =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Lt(Sub(a#, c#), Sub(b#, c#)) & Le(c#, a#) ==> Lt(a#, b#): thm
val Lt_MONO_Sub =
   {}, 
   |- !(a : mem(N))  (c : mem(N)).
        Le(c#, a#) ==>
        !(b : mem(N)). Lt(a#, b#) <=> Lt(Sub(a#, c#), Sub(b#, c#)): thm
val Add_Le = {},  |- !(a : mem(N))  (b : mem(N)). Le(a#, Add(a#, b#)): thm
val Add_pos_Lt =
   {}, 
   |- !(a : mem(N)).
        Lt(O, a#) ==>
        !(b : mem(N))  (c : mem(N)). Add(a#, b#) = c# ==> Lt(b#, c#): thm
val Le_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Le(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Le(c#, d#) ==>
          Le(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val Lt_cross_lemma =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Lt(a#, b#) ==>
        !(c : mem(N))  (d : mem(N)).
          Lt(c#, d#) ==>
          Lt(Add(Mul(a#, d#), Mul(b#, c#)), Add(Mul(a#, c#), Mul(b#, d#))):
   thm
val num1_def = {},  |- num1 = Suc(O): thm
val num2_def = {},  |- num2 = Suc(num1): thm
val num3_def = {},  |- num3 = Suc(num2): thm
val num4_def = {},  |- num4 = Suc(num3): thm
val WOP' =
   {}, 
   |- !(s : mem(Pow(N))).
        ~s# = Empty(N) ==>
        ?(a0 : mem(N)).
          IN(a0#, s#) & !(a1 : mem(N)). IN(a1#, s#) ==> Le(a0#, a1#): thm
val division_theorem_N_ex0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Lt(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val division_theorem_N_ex =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        Le(num1, d#) ==>
        ?(q : mem(N))  (r : mem(N)).
          a# = Add(Mul(q#, d#), r#) & Le(O, r#) & Lt(r#, d#): thm
val NOT_Lt_O_O = {},  |- ~Lt(O, O): thm
val it = (): unit
******

Loading SEAR file SEARZarith.sml

******
val ZR_def =
   {}, 
   |- !(x : mem(N))  (y : mem(N))  (u : mem(N))  (v : mem(N)).
        Holds(ZR, Pair(x#, y#), Pair(u#, v#)) <=> Add(x#, v#) = Add(u#, y#):
   thm
val ZR_Refl = {},  |- Refl(ZR): thm
val ZR_Trans = {},  |- Trans(ZR): thm
val ZR_Sym = {},  |- Sym(ZR): thm
val ZR_ER = {},  |- ER(ZR): thm
val Ri_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#))  (s : mem(Pow(A#)))
      (b : mem(B#)).
        IN(b#, App(Ri(r#), s#)) <=>
        ?(a : mem(A#)). IN(a#, s#) & Holds(r#, a#, b#): thm
val Rsi_def =
   {}, 
   |- !(A : set)  (B : set)  (r : rel(A#, B#)). Rsi(r#) = Ri(r#) o Sg(A#):
   thm
val rsi_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (r : rel(A#, B#)).
        rsi(r#, a#) = App(Rsi(r#), a#): thm
val IN_rsi =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
        IN(a2#, rsi(r#, a1#)) <=> Holds(r#, a1#, a2#): thm
val ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          (!(x : mem(A#)). Holds(r#, a1#, x#) <=> Holds(r#, a2#, x#)) <=>
          Holds(r#, a1#, a2#): thm
val rsi_eq_ER =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          rsi(r#, a1#) = rsi(r#, a2#) <=> Holds(r#, a1#, a2#): thm
val Z_def =
   {}, 
   |- Inj(iZ) &
      !(a : mem(Pow(N * N))).
        (?(n : mem(N * N)). a# = rsi(ZR, n#)) <=>
        ?(b : mem(Z)). a# = App(iZ, b#): thm
val iZ_Inj = {},  |- Inj(iZ): thm
val iZ_eq_eq =
   {}, 
   |- !(x1 : mem(Z))  (x2 : mem(Z)).
        App(iZ, x1#) = App(iZ, x2#) ==> x1# = x2#: thm
val iZ_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(m : mem(N))  (n : mem(N)). App(iZ, z#) = rsi(ZR, Pair(m#, n#)): thm
val rsi_iZ =
   {}, 
   |- !(m : mem(N))  (n : mem(N)).
        ?(b : mem(Z)). rsi(ZR, Pair(m#, n#)) = App(iZ, b#): thm
val resp_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#)).
        resp(f#, r1#, r2#) <=>
        !(y : mem(A#))  (z : mem(A#)).
          Holds(r1#, y#, z#) ==> Holds(r2#, App(f#, y#), App(f#, z#)): thm
val rext_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a0 : mem(Pow(A#)))  (b0 : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a0#, b0#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a0# = rsi(r1#, a#) & b0# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val rext_def0 =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (f : fun(A#, B#))
      (r2 : rel(B#, B#))  (a : mem(Pow(A#)))  (b : mem(Pow(B#))).
        Holds(rext(f#, r1#, r2#), a#, b#) <=>
        ?(a : mem(A#))  (b : mem(B#)).
          a# = rsi(r1#, a#) & b# = rsi(r2#, b#) & App(f#, a#) = b#: thm
val prrel_def =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#))
      (a1 : mem(A#))  (b1 : mem(B#))  (a2 : mem(A#))  (b2 : mem(B#)).
        Holds(prrel(r1#, r2#), Pair(a1#, b1#), Pair(a2#, b2#)) <=>
        Holds(r1#, a1#, a2#) & Holds(r2#, b1#, b2#): thm
val main =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val ipow2_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (B : set)  (b : mem(B#))  (Q1 : set)
      (aq : mem(Q1#))  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (bq : mem(Q2#))
      (i2 : fun(Q2#, Pow(B#))).
        IN(Pair(a#, b#), App(ipow2(i1#, i2#), Pair(aq#, bq#))) <=>
        IN(a#, App(i1#, aq#)) & IN(b#, App(i2#, bq#)): thm
val addf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(addf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(a#, a'#), Add(b#, b''#)): thm
val prrel_ER_ER =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (B : set)  (r2 : rel(B#, B#)).
        ER(r1#) & ER(r2#) ==> ER(prrel(r1#, r2#)): thm
val Pow_conj_eq0 =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3#: thm
val Pow_conj_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(B#)))
      (s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#)))  (a0 : mem(A#))
      (b0 : mem(B#)).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        (!(a : mem(A#))  (b : mem(B#)).
            IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) ==>
        s1# = s3# & s2# = s4#: thm
val ipow2_Inj_Inj =
   {}, 
   |- !(Q1 : set)  (A : set)  (i1 : fun(Q1#, Pow(A#)))  (Q2 : set)  (B : set)
      (i2 : fun(Q2#, Pow(B#))).
        (!(q1 : mem(Q1#)). ?(a : mem(A#)). IN(a#, App(i1#, q1#))) &
        (!(q2 : mem(Q2#)). ?(b : mem(B#)). IN(b#, App(i2#, q2#))) &
        Inj(i1#) & Inj(i2#) ==> Inj(ipow2(i1#, i2#)): thm
val Quo_def =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quo(r#, i#) <=>
        !(s : mem(Pow(A#))).
          (?!(q : mem(Q#)). s# = App(i#, q#)) <=>
          ?(a : mem(A#)). s# = rsi(r#, a#): thm
val Inj_Quo =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Inj(i) &
      (!(s : mem(Pow(A))).
          (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#)) <=>
      Inj(i) & Quo(r, i): thm
val ER_rsi_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (a : mem(A#)).
        ER(r#) ==> IN(a#, rsi(r#, a#)): thm
val Quo_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) & Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        Quo(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val Quo_fun =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val main_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) &
        Inj(i2#) &
        (!(sa : mem(Pow(A#))).
            (?(q1 : mem(Q1#)). sa# = App(i1#, q1#)) <=>
            ?(a : mem(A#)). sa# = rsi(r1#, a#)) &
        (!(sb : mem(Pow(B#))).
            (?(q2 : mem(Q2#)). sb# = App(i2#, q2#)) <=>
            ?(b : mem(B#)). sb# = rsi(r2#, b#)) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val Inj_Quo_Z = {},  |- Inj(iZ) & Quo(ZR, iZ): thm
val Quo_fun_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (r1 : rel(A#, A#))
      (r2 : rel(B#, B#))  (Q1 : set)  (Q2 : set)  (i1 : fun(Q1#, Pow(A#)))
      (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) &
        ER(r2#) &
        resp(f#, r1#, r2#) &
        Inj(i1#) & Inj(i2#) & Quo(r1#, i1#) & Quo(r2#, i2#) ==>
        ?!(qf : fun(Q1#, Q2#)).
          !(q1 : mem(Q1#)).
            Holds(rext(f#, r1#, r2#), App(i1#, q1#), App(i2# o qf#, q1#)):
   thm
val iZ_nonempty =
   {},  |- !(z : mem(Z)). ?(ab : mem(N * N)). IN(ab#, App(iZ, z#)): thm
val addf0_resp = {},  |- resp(addf0, prrel(ZR, ZR), ZR): thm
val addz_conds =
   {}, 
   |- ER(prrel(ZR, ZR)) &
      ER(ZR) &
      resp(addf0, prrel(ZR, ZR), ZR) &
      Inj(ipow2(iZ, iZ)) &
      Inj(iZ) & Quo(prrel(ZR, ZR), ipow2(iZ, iZ)) & Quo(ZR, iZ): thm
val main_addz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(addz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(addf0, a#) = b#: thm
val main_addz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(addz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(addf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_addz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(addz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val Inj_Quo_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Inj(i#) & Quo(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). App(i#, q#) = rsi(r#, a#): thm
val Z_has_rep =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). App(iZ, z#) = rsi(ZR, Pair(a'#, b#)):
   thm
val Addz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Addz(z1#, z2#) = App(addz, Pair(z1#, z2#)): thm
val Repz_def = {},  |- !(z : mem(Z)). Repz(z#) = App(iZ, z#): thm
val Repz_rsi =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = rsi(ZR, Pair(a'#, b#)): thm
val ZC_def = {},  |- !(ab : mem(N * N)). ZC(ab#) = rsi(ZR, ab#): thm
val Repz_ZC =
   {}, 
   |- !(z : mem(Z)).
        ?(a' : mem(N))  (b : mem(N)). Repz(z#) = ZC(Pair(a'#, b#)): thm
val Addz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Addz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(a1#, a3#), Add(a2#, a4#)) = Pair(b1#, b2#): thm
val ZC_ZR =
   {}, 
   |- !(ab : mem(N * N))  (cd : mem(N * N)).
        ZC(ab#) = ZC(cd#) <=> Holds(ZR, ab#, cd#): thm
val Addz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Addz(z1#, z2#)) = ZC(Pair(Add(a1#, a3#), Add(a2#, a4#))): thm
val Repz_eq_eq =
   {},  |- !(x1 : mem(Z))  (x2 : mem(Z)). Repz(x1#) = Repz(x2#) ==> x1# = x2#:
   thm
val Repz_eq_ZR =
   {}, 
   |- !(a1 : mem(N * N))  (a2 : mem(N * N)).
        ZC(a1#) = ZC(a2#) <=> Holds(ZR, a1#, a2#): thm
val eq_ZR =
   {},  |- !(a : mem(N * N))  (b : mem(N * N)). a# = b# ==> Holds(ZR, a#, b#):
   thm
val Addz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Addz(z1#, z2#) = Addz(z2#, z1#):
   thm
val negf0_def =
   {},  |- !(a : mem(N * N)). App(negf0, a#) = Pair(Snd(a#), Fst(a#)): thm
val negf0_def1 =
   {}, 
   |- !(m : mem(N))  (n : mem(N)). App(negf0, Pair(m#, n#)) = Pair(n#, m#):
   thm
val negf0_resp = {},  |- resp(negf0, ZR, ZR): thm
val Negz_def = {},  |- !(z : mem(Z)). Negz(z#) = App(negz, z#): thm
val main_negz =
   {(z : mem(Z))}, 
   |- ?(a : mem(N * N))  (b : mem(N * N)).
        Repz(z) = ZC(a#) & Repz(App(negz, z)) = ZC(b#) & App(negf0, a#) = b#:
   thm
val Negz_char =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = ZC(Pair(a#, b#)) ==> Repz(Negz(z#)) = ZC(Pair(b#, a#)):
   thm
val main_negz1 =
   {(z : mem(Z))}, 
   |- ?(a1' : mem(N))  (a2' : mem(N)).
        Repz(z) = ZC(Pair(a1'#, a2'#)) & Repz(Negz(z)) = ZC(Pair(a2'#, a1'#)):
   thm
val mulf0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b'' : mem(N)).
        App(mulf0, Pair(Pair(a#, b#), Pair(a'#, b''#))) =
          Pair(Add(Mul(a#, a'#), Mul(b#, b''#)),
           Add(Mul(a#, b''#), Mul(b#, a'#))): thm
val mulf0_resp = {},  |- resp(mulf0, prrel(ZR, ZR), ZR): thm
val main_mulz =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a : mem((N * N) * N * N))  (b : mem(N * N)).
        (!(x : mem((N * N) * N * N)).
            IN(x#, App(ipow2(iZ, iZ), Pair(z1, z2))) <=>
            Holds(prrel(ZR, ZR), a#, x#)) &
        (!(x : mem(N * N)).
            IN(x#, App(iZ, App(mulz, Pair(z1, z2)))) <=> Holds(ZR, b#, x#)) &
        App(mulf0, a#) = b#: thm
val main_mulz1 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        (!(x1 : mem(N))  (x2 : mem(N))  (x3 : mem(N))  (x4 : mem(N)).
            IN(Pair(x1#, x2#), App(iZ, z1)) & IN(Pair(x3#, x4#), App(iZ, z2)) <=>
            IN(Pair(x1#, x2#), rsi(ZR, Pair(a1#, a2#))) &
            IN(Pair(x3#, x4#), rsi(ZR, Pair(a3#, a4#)))) &
        (!(n1 : mem(N))  (n2 : mem(N)).
            IN(Pair(n1#, n2#), App(iZ, App(mulz, Pair(z1, z2)))) <=>
            IN(Pair(n1#, n2#), rsi(ZR, Pair(b1#, b2#)))) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz2 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        App(mulf0, Pair(Pair(a1#, a2#), Pair(a3#, a4#))) = Pair(b1#, b2#):
   thm
val main_mulz3 =
   {(z1 : mem(Z)), (z2 : mem(Z))}, 
   |- ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
      (b1 : mem(N))  (b2 : mem(N)).
        App(iZ, z1) = rsi(ZR, Pair(a1#, a2#)) &
        App(iZ, z2) = rsi(ZR, Pair(a3#, a4#)) &
        App(iZ, App(mulz, Pair(z1, z2))) = rsi(ZR, Pair(b1#, b2#)) &
        Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
           Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Mulz(z1#, z2#) = App(mulz, Pair(z1#, z2#)): thm
val Mulz_char0 =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        ?(a1 : mem(N))  (a2 : mem(N))  (a3 : mem(N))  (a4 : mem(N))
        (b1 : mem(N))  (b2 : mem(N)).
          Repz(z1#) = ZC(Pair(a1#, a2#)) &
          Repz(z2#) = ZC(Pair(a3#, a4#)) &
          Repz(Mulz(z1#, z2#)) = ZC(Pair(b1#, b2#)) &
          Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))) = Pair(b1#, b2#): thm
val Mulz_char =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = ZC(Pair(a1#, a2#)) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = ZC(Pair(a3#, a4#)) ==>
          Repz(Mulz(z1#, z2#)) =
            ZC(Pair(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
              Add(Mul(a1#, a4#), Mul(a2#, a3#)))): thm
val ZC_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        ?!(z : mem(Z)). Repz(z#) = ZC(Pair(a#, b#)): thm
val ZC_Repz' =
   {},  |- !(ab : mem(N * N)). ?!(z : mem(Z)). Repz(z#) = ZC(ab#): thm
val absz_def =
   {}, 
   |- !(a' : mem(N))  (b : mem(N))  (b : mem(Z)).
        App(absz, Pair(a'#, b#)) = b# <=> Repz(b#) = ZC(Pair(a'#, b#)): thm
val Absz_def = {},  |- !(ab : mem(N * N)). Absz(ab#) = App(absz, ab#): thm
val Asz_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Asz(a#, b#) = Absz(Pair(a#, b#)): thm
val Zc_def =
   {},  |- !(a : mem(N))  (b : mem(N)). Zc(a#, b#) = ZC(Pair(a#, b#)): thm
val Absz_Repz =
   {}, 
   |- !(a : mem(N))  (b : mem(N)).
        Repz(Absz(Pair(a#, b#))) = ZC(Pair(a#, b#)): thm
val Asz_Repz =
   {},  |- !(a : mem(N))  (b : mem(N)). Repz(Asz(a#, b#)) = Zc(a#, b#): thm
val Oz_def = {},  |- Oz = Asz(O, O): thm
val En_def = {},  |- En = Suc(O): thm
val Ez_def = {},  |- Ez = Asz(En, O): thm
val Addz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Addz(z1#, z2#)) = Zc(Add(a1#, a3#), Add(a2#, a4#)): thm
val Addz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Addz(Asz(a#, b#), Asz(c#, d#)) = Asz(Add(a#, c#), Add(b#, d#)): thm
val Mulz_th0 =
   {}, 
   |- !(z1 : mem(Z))  (a1 : mem(N))  (a2 : mem(N)).
        Repz(z1#) = Zc(a1#, a2#) ==>
        !(z2 : mem(Z))  (a3 : mem(N))  (a4 : mem(N)).
          Repz(z2#) = Zc(a3#, a4#) ==>
          Repz(Mulz(z1#, z2#)) =
            Zc(Add(Mul(a1#, a3#), Mul(a2#, a4#)),
             Add(Mul(a1#, a4#), Mul(a2#, a3#))): thm
val Mulz_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Mulz(Asz(a#, b#), Asz(c#, d#)) =
          Asz(Add(Mul(a#, c#), Mul(b#, d#)), Add(Mul(a#, d#), Mul(b#, c#))):
   thm
val Negz_th0 =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) ==> Repz(Negz(z#)) = Zc(b#, a#): thm
val Negz_Asz =
   {},  |- !(a : mem(N))  (b : mem(N)). Negz(Asz(a#, b#)) = Asz(b#, a#): thm
val cases_z =
   {},  |- !(z : mem(Z)). ?(a : mem(N))  (b : mem(N)). z# = Asz(a#, b#): thm
val Addz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Addz(Addz(z1#, z2#), z3#) = Addz(z1#, Addz(z2#, z3#)): thm
val casesz =
   {}, 
   |- (!(a : mem(N))  (b : mem(N)). P(Asz(a#, b#))) <=> !(z : mem(Z)). P(z#):
   thm
SEARZarith.sml:1213: warning: Matches are not exhaustive. Found near fn [th0] => dimp_mp_l2r th0 th
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val casez_tac = fn: cont * form list * form -> goal list * validation
val Asz_eq_ZR =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Asz(a#, b#) = Asz(c#, d#) <=> Holds(ZR, Pair(a#, b#), Pair(c#, d#)):
   thm
val Addz_Negz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Negz(z#)) = Oz: thm
val Mulz_assoc =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Mulz(z1#, z2#), z3#) = Mulz(z1#, Mulz(z2#, z3#)): thm
val LDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(z1#, Addz(z2#, z3#)) = Addz(Mulz(z1#, z2#), Mulz(z1#, z3#)): thm
val Mulz_Ez = {},  |- !(z : mem(Z)). Mulz(z#, Ez) = z#: thm
val Mulz_comm =
   {},  |- !(z1 : mem(Z))  (z2 : mem(Z)). Mulz(z1#, z2#) = Mulz(z2#, z1#):
   thm
val RDISTR_Z =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Mulz(Addz(z2#, z3#), z1#) = Addz(Mulz(z2#, z1#), Mulz(z3#, z1#)): thm
val le0_def =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (a' : mem(N))  (b' : mem(N)).
        le0(Pair(a#, b#), Pair(a'#, b'#)) <=> Le(Add(a#, b'#), Add(b#, a'#)):
   thm
val Lez_def =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) <=>
        !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
          Repz(z1#) = Zc(a#, b#) & Repz(z2#) = Zc(c#, d#) ==>
          Le(Add(a#, d#), Add(b#, c#)): thm
val LEz_def =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Holds(LEz, a#, b#) <=> Lez(a#, b#):
   thm
val LEz_Refl = {},  |- Refl(LEz): thm
val Repz_Zc =
   {}, 
   |- !(z : mem(Z)). ?(a' : mem(N))  (b : mem(N)). Repz(z#) = Zc(a'#, b#):
   thm
val LEz_Trans = {},  |- Trans(LEz): thm
val LEz_Asym = {},  |- Asym(LEz): thm
val Total_def =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Total(R#) <=>
        !(a : mem(A#))  (b : mem(A#)). Holds(R#, a#, b#) | Holds(R#, b#, a#):
   thm
val Lez_resp0 =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N))  (e : mem(N))
      (f : mem(N))  (g : mem(N))  (h : mem(N)).
        Holds(ZR, Pair(a#, b#), Pair(c#, d#)) &
        Holds(ZR, Pair(e#, f#), Pair(g#, h#)) ==>
        (Le(Add(a#, f#), Add(b#, e#)) <=> Le(Add(c#, h#), Add(d#, g#))): thm
val LEz_Total = {},  |- Total(LEz): thm
val Lez_Asz =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N))  (d : mem(N)).
        Lez(Asz(a#, b#), Asz(c#, d#)) <=> Le(Add(a#, d#), Add(b#, c#)): thm
val Lez_Addz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z)).
        Lez(z1#, z2#) ==> !(z3 : mem(Z)). Lez(Addz(z1#, z3#), Addz(z2#, z3#)):
   thm
val Lez_Mulz =
   {}, 
   |- !(z1 : mem(Z))  (z2 : mem(Z))  (z3 : mem(Z)).
        Lez(z1#, z2#) & Lez(Oz, z3#) ==> Lez(Mulz(z1#, z3#), Mulz(z2#, z3#)):
   thm
val EVEN_def =
   {}, 
   |- (!(a : mem(1)). App(EVEN, O) = true) &
      !(a : mem(N)). App(EVEN, Suc(a#)) = App(NOT, App(EVEN, a#)): thm
val Even_def = {(n : mem(N))},  |- Even(n) <=> App(EVEN, n) = true: thm
val O_Even = {},  |- Even(O): thm
val Suc_Even = {},  |- !(n : mem(N)). Even(Suc(n#)) <=> ~Even(n#): thm
val Even_not_Odd = {},  |- !(n : mem(N)). Even(n#) <=> ~Odd(n#): thm
val Odd_def = {(n : mem(N))},  |- Odd(n) <=> ~Even(n): thm
val Odd_not_Even = {},  |- !(n : mem(N)). Odd(n#) <=> ~Even(n#): thm
val id_ER = {},  |- !(A : set). ER(id(A#)): thm
val Sg_Inj = {},  |- !(A : set). Inj(Sg(A#)): thm
val Quo_id_Sg = {},  |- !(A : set). Quo(id(A#), Sg(A#)): thm
val Pow_conj_eq' =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (s1 : mem(Pow(A#)))  (B : set)
      (b0 : mem(B#))  (s2 : mem(Pow(B#))).
        IN(a0#, s1#) & IN(b0#, s2#) ==>
        !(s3 : mem(Pow(A#)))  (s4 : mem(Pow(B#))).
          (!(a : mem(A#))  (b : mem(B#)).
              IN(a#, s1#) & IN(b#, s2#) <=> IN(a#, s3#) & IN(b#, s4#)) <=>
          s1# = s3# & s2# = s4#: thm
val Repz_iff_Asz =
   {}, 
   |- !(z : mem(Z))  (a : mem(N))  (b : mem(N)).
        Repz(z#) = Zc(a#, b#) <=> Asz(a#, b#) = z#: thm
val ipow2_prrel_ZR =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N)), (z1 : mem(Z)),
    (z2 : mem(Z))}, 
   |- App(ipow2(iZ, iZ), Pair(z1, z2)) =
        rsi(prrel(ZR, ZR), Pair(Pair(a, b), Pair(c, d))) <=>
      Asz(a, b) = z1 & Asz(c, d) = z2: thm
val Asz_eq_eq_r =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, b#) = Asz(a#, c#) <=> b# = c#: thm
val Ltz_def =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Lez(a#, b#) & ~a# = b#:
   thm
val N2Z_def = {},  |- !(a : mem(N)). App(N2Z, a#) = Asz(a#, O): thm
val n2z_def = {},  |- !(n : mem(N)). n2z(n#) = App(N2Z, n#): thm
val Asz_eq_eq_l =
   {}, 
   |- !(a : mem(N))  (b : mem(N))  (c : mem(N)).
        Asz(a#, c#) = Asz(b#, c#) <=> a# = b#: thm
val N2Z_Inj = {},  |- Inj(N2Z): thm
val Repz_eq_eq_iff =
   {(x1 : mem(Z)), (x2 : mem(Z))},  |- Repz(x1) = Repz(x2) <=> x1 = x2: thm
val prove_dimp_th = fn: thm -> thm
val Abv_positive_ex0 =
   {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> ?(n : mem(N)). Asz(n#, O) = z#: thm
val Lez_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Lez(Negz(z#), Negz(b#)) <=> Lez(b#, z#):
   thm
val Negz_eq_eq =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Negz(z#) = Negz(b#) <=> z# = b#: thm
val Negz_Oz = {},  |- Negz(Oz) = Oz: thm
val Abv_negative_ex0 =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> ?(n : mem(N)). Asz(O, n#) = z#: thm
val Lez_dichotomy =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Lez(z#, b#) | Lez(b#, z#): thm
val Ltz_Asz =
   {(a : mem(N)), (b : mem(N)), (c : mem(N)), (d : mem(N))}, 
   |- Ltz(Asz(a, b), Asz(c, d)) <=> Lt(Add(a, d), Add(b, c)): thm
val NOT_Lez_Ltz =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Lez(z#, b#) <=> Ltz(b#, z#): thm
val Abv_def =
   {}, 
   |- !(z : mem(Z)).
        Lez(Oz, z#) & Asz(Abv(z#), O) = z# |
        Ltz(z#, Oz) & Asz(O, Abv(z#)) = z#: thm
val Abv_nonneg = {},  |- !(z : mem(Z)). Lez(Oz, z#) ==> Asz(Abv(z#), O) = z#:
   thm
val Abv_uex =
   {}, 
   |- !(z : mem(Z)).
        ?!(n : mem(N)).
          Lez(Oz, z#) & Asz(n#, O) = z# | Ltz(z#, Oz) & Asz(O, n#) = z#: thm
val n2z_Abv = {},  |- !(a : mem(Z)). Lez(Oz, a#) ==> n2z(Abv(a#)) = a#: thm
val Oz_Mulz = {},  |- !(z : mem(Z)). Mulz(Oz, z#) = Oz: thm
val Addz_Oz = {},  |- !(z : mem(Z)). Addz(z#, Oz) = z#: thm
val Oz_Ltz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, Oz) & Ltz(b#, Oz) ==> Ltz(Oz, Mulz(z#, b#)): thm
val int1_NONZERO = {},  |- ~int1 = Oz: thm
val int1_def = {},  |- int1 = n2z(Suc(O)): thm
val Negz_Mulz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Negz(Mulz(z#, b#)):
   thm
val Ltz_Addz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Ltz(z#, b#) <=> Ltz(Addz(z#, Negz(b#)), Oz): thm
val Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(z#, Negz(b#)) = Negz(Mulz(z#, b#)):
   thm
val Mulz_int1 = {},  |- !(z : mem(Z)). Mulz(z#, int1) = z#: thm
val Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) ==> Lez(z#, b#): thm
val n2z_Oz_Lez = {},  |- !(a : mem(N)). Lez(Oz, n2z(a#)): thm
val Negz_Addz_Oz = {},  |- !(z : mem(Z)). Addz(Negz(z#), z#) = Oz: thm
val Lez_Addz_ex =
   {}, 
   |- !(z : mem(Z))  (m : mem(Z)).
        Lez(z#, m#) ==> ?(p : mem(Z)). Lez(Oz, p#) & Addz(p#, z#) = m#: thm
val Lez_Addz_2 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Lez(z#, c#) & Lez(b#, d#) ==> Lez(Addz(z#, b#), Addz(c#, d#)): thm
val Oz_Lez_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(Oz, z#) & Lez(Oz, b#) ==>
        Lez(z#, Addz(z#, b#)) & Lez(b#, Addz(z#, b#)): thm
val Oz_Ltz_Addz =
   {}, 
   |- !(z : mem(Z)). Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(b#, Addz(z#, b#)):
   thm
val int1_Asz = {},  |- int1 = Asz(Suc(O), O): thm
val Ltz_int1_Lez_Oz = {},  |- !(z : mem(Z)). Ltz(int1, z#) ==> Lez(Oz, z#):
   thm
val Lez_Oz_Addz_Lez =
   {}, 
   |- !(z : mem(Z)). Lez(z#, Oz) ==> !(a : mem(Z)). Lez(Addz(a#, z#), a#):
   thm
val Lez_Ltz_TRANS_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(z#, c#): thm
val Ltz_trans =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) ==> !(c : mem(Z)). Ltz(b#, c#) ==> Ltz(a#, c#): thm
val NOT_Ltz_Lez =
   {},  |- !(z : mem(Z))  (b : mem(Z)). ~Ltz(z#, b#) <=> Lez(b#, z#): thm
val Addz_Rarr =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = c# <=> z# = Addz(c#, Negz(b#)): thm
val Addz_eq_eq =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(z#, b#) = Addz(z#, c#) <=> b# = c#: thm
val Negz_Addz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Negz(Addz(z#, b#)) = Addz(Negz(z#), Negz(b#)): thm
val Lez_cases =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) <=> Ltz(a#, b#) | a# = b#:
   thm
val Lez_refl = {},  |- !(a : mem(Z)). Lez(a#, a#): thm
val Lez_REFL = {},  |- !(z : mem(Z)). Lez(z#, z#): thm
val Oz_Lez_int1 = {},  |- Lez(Oz, int1): thm
val Oz_Ltz_int1 = {},  |- Ltz(Oz, int1): thm
val Ltz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(Negz(z#), Negz(b#)) <=> Ltz(b#, z#):
   thm
val NEQ_Ltz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). ~a# = b# <=> Ltz(a#, b#) | Ltz(b#, a#):
   thm
val Ltz_iff_Lez_int1 =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Ltz(z#, b#) <=> Lez(Addz(z#, int1), b#):
   thm
val Negz_Mulz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), b#) = Mulz(z#, Negz(b#)):
   thm
val Oz_Addz = {},  |- !(z : mem(Z)). Addz(Oz, z#) = z#: thm
val Addz_eq_eq' =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(a#, c#) = Addz(b#, c#) <=> a# = b#: thm
val between_int1_Oz =
   {},  |- !(z : mem(Z)). Ltz(Negz(int1), z#) & Ltz(z#, int1) <=> z# = Oz:
   thm
val Addz_Negz_Oz_eq =
   {}, 
   |- !(z : mem(Z))  (z2 : mem(Z)). Addz(z#, Negz(z2#)) = Oz <=> z# = z2#:
   thm
val Negz_Negz = {},  |- !(z : mem(Z)). Negz(Negz(z#)) = z#: thm
val Ltz_iff_O_Ltz_Sub =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(a#, b#) <=> Ltz(Oz, Addz(b#, Negz(a#))): thm
val Ltz_Ltz_Mulz_Ltz =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, Mulz(z#, b#)) ==> Ltz(Oz, b#):
   thm
val Ltz_Ltz_Mulz_pos =
   {}, 
   |- !(z : mem(Z)).
        Ltz(Oz, z#) ==> !(b : mem(Z)). Ltz(Oz, b#) ==> Ltz(Oz, Mulz(z#, b#)):
   thm
val Mulz_Ltz_Ltz =
   {}, 
   |- !(a : mem(Z)).
        Ltz(Oz, a#) ==>
        !(b : mem(Z))  (c : mem(Z)).
          Ltz(Mulz(a#, b#), Mulz(a#, c#)) <=> Ltz(b#, c#): thm
val Ltz_Oz_Lez_int1 = {},  |- !(z : mem(Z)). Ltz(Oz, z#) <=> Lez(int1, z#):
   thm
val Addz_Rarr_both_sides =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z))  (c : mem(Z))  (d : mem(Z)).
        Addz(z#, b#) = Addz(c#, d#) <=>
        Addz(d#, Negz(b#)) = Addz(z#, Negz(c#)): thm
val Lez_Ltz_Addz_Ltz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)).
        Lez(z#, b#) ==>
        !(c : mem(Z))  (d : mem(Z)).
          Ltz(c#, d#) ==> Ltz(Addz(z#, c#), Addz(b#, d#)): thm
val Mulz_Negz_Negz =
   {}, 
   |- !(z : mem(Z))  (b : mem(Z)). Mulz(Negz(z#), Negz(b#)) = Mulz(z#, b#):
   thm
val Lez_asym =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Lez(a#, b#) & Lez(b#, a#) ==> a# = b#:
   thm
val Ltz_NOT_Ltz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) ==> ~Ltz(b#, a#): thm
val Abv_Negz = {},  |- !(z : mem(Z)). Abv(Negz(z#)) = Abv(z#): thm
val Abv_Oz = {},  |- Abv(Oz) = O: thm
val n2z_Abv_Negz =
   {},  |- !(z : mem(Z)). Lez(z#, Oz) ==> n2z(Abv(z#)) = Negz(z#): thm
val n2z_is_Abv =
   {},  |- !(n : mem(N))  (z : mem(Z)). n2z(n#) = z# ==> n# = Abv(z#): thm
val Le_Abv_Abv =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Lez(Oz, a#) & Lez(Oz, b#) ==> (Le(Abv(a#), Abv(b#)) <=> Lez(a#, b#)):
   thm
val division_theorem_ex0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_ex1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        ?(q : mem(Z))  (r : mem(Z)).
          a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val Lez_trans =
   {}, 
   |- !(a1 : mem(Z))  (a2 : mem(Z))  (a3 : mem(Z)).
        Lez(a1#, a2#) & Lez(a2#, a3#) ==> Lez(a1#, a3#): thm
val division_theorem_ex =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?(q : mem(Z))  (r : mem(Z)).
            a# = Addz(Mulz(q#, d#), r#) & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))):
   thm
val division_theorem_unique0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Lez(int1, d#) ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem_unique1 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        !(q1 : mem(Z))  (r1 : mem(Z))  (q2 : mem(Z))  (r2 : mem(Z)).
          a# = Addz(Mulz(q1#, d#), r1#) &
          Lez(Oz, r1#) &
          Ltz(r1#, n2z(Abv(d#))) &
          a# = Addz(Mulz(q2#, d#), r2#) &
          Lez(Oz, r2#) & Ltz(r2#, n2z(Abv(d#))) ==> q1# = q2# & r1# = r2#:
   thm
val division_theorem =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        ~d# = Oz ==>
        ?!(qr : mem(Z * Z)).
          a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
          Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val DIVRz_def =
   {}, 
   |- !(a : mem(Z * Z)).
        Snd(a#) = Oz & App(DIVRz, a#) = Pair(Oz, Oz) |
        ~Snd(a#) = Oz &
        Fst(a#) =
          Addz(Mulz(Fst(App(DIVRz, a#)), Snd(a#)), Snd(App(DIVRz, a#))) &
        Lez(Oz, Snd(App(DIVRz, a#))) &
        Ltz(Snd(App(DIVRz, a#)), n2z(Abv(Snd(a#)))): thm
val Divrz_Oz =
   {}, 
   |- !(d : mem(Z)). d# = Oz ==> !(a : mem(Z)). Divrz(a#, d#) = Pair(Oz, Oz):
   thm
val Divrz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divrz(a, d) = App(DIVRz, Pair(a, d)):
   thm
val Divrz_property0 =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        d# = Oz & Divrz(a#, d#) = Pair(Oz, Oz) |
        ~d# = Oz &
        a# = Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) &
        Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divrz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Fst(Divrz(a#, d#)), d#), Snd(Divrz(a#, d#))) = a# &
          Lez(Oz, Snd(Divrz(a#, d#))) & Ltz(Snd(Divrz(a#, d#)), n2z(Abv(d#))):
   thm
val Divz_Remz_NONZERO =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          Addz(Mulz(Divz(a#, d#), d#), Remz(a#, d#)) = a# &
          Lez(Oz, Remz(a#, d#)) & Ltz(Remz(a#, d#), n2z(Abv(d#))): thm
val Divz_Remz_Oz =
   {},  |- !(a : mem(Z)). Divz(a#, Oz) = Oz & Remz(a#, Oz) = Oz: thm
val Divz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Divz(a, d) = Fst(Divrz(a, d)): thm
val Remz_def =
   {(a : mem(Z)), (d : mem(Z))},  |- Remz(a, d) = Snd(Divrz(a, d)): thm
val Subz_Addz =
   {},  |- !(m : mem(Z))  (n : mem(Z)). Addz(Subz(m#, n#), n#) = m#: thm
val Subz_def =
   {(a : mem(Z)), (b : mem(Z))},  |- Subz(a, b) = Addz(a, Negz(b)): thm
val Mulz_Oz = {},  |- !(z : mem(Z)). Mulz(z#, Oz) = Oz: thm
val Oz_Ltz_Negz = {},  |- !(a : mem(Z)). Ltz(Oz, a#) <=> Ltz(Negz(a#), Oz):
   thm
val Ltz_Oz_Negz = {},  |- !(a : mem(Z)). Ltz(a#, Oz) <=> Ltz(Oz, Negz(a#)):
   thm
val Mulz_Ltz_Ltz_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)).
        Ltz(Mulz(a#, b#), Oz) <=>
        Ltz(Oz, a#) & Ltz(b#, Oz) | Ltz(Oz, b#) & Ltz(a#, Oz): thm
val Mulz_Oz_iff_Oz =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z)). Mulz(a#, b#) = Oz <=> a# = Oz | b# = Oz:
   thm
val Divz_Remz_unique =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z))  (q : mem(Z))  (r : mem(Z)).
          Addz(Mulz(q#, d#), r#) = a# & Lez(Oz, r#) & Ltz(r#, n2z(Abv(d#))) ==>
          q# = Divz(a#, d#) & r# = Remz(a#, d#): thm
val division_theorem' =
   {}, 
   |- !(d : mem(Z)).
        ~d# = Oz ==>
        !(a : mem(Z)).
          ?!(qr : mem(Z * Z)).
            a# = Addz(Mulz(Fst(qr#), d#), Snd(qr#)) &
            Lez(Oz, Snd(qr#)) & Ltz(Snd(qr#), n2z(Abv(d#))): thm
val Ltz_Subz =
   {},  |- !(a : mem(Z))  (b : mem(Z)). Ltz(a#, b#) <=> Ltz(Oz, Subz(b#, a#)):
   thm
val Subz_Ltz =
   {}, 
   |- !(a : mem(Z)). Ltz(Oz, a#) ==> !(b : mem(Z)). Ltz(Subz(b#, a#), b#):
   thm
val int1_Mulz = {},  |- !(z : mem(Z)). Mulz(int1, z#) = z#: thm
val Addz_Subz_Rarr =
   {}, 
   |- !(a : mem(Z))  (b : mem(Z))  (c : mem(Z)).
        Addz(Addz(a#, b#), Subz(c#, b#)) = Addz(a#, c#): thm
val Divz_pos_Remz =
   {}, 
   |- !(a : mem(Z))  (d : mem(Z)).
        Ltz(Oz, a#) & Ltz(Oz, d#) ==> Ltz(Remz(a#, d#), d#): thm
val n2z_eq_eq =
   {},  |- !(a : mem(N))  (b : mem(N)). n2z(a#) = n2z(b#) <=> a# = b#: thm
val n2z_Asz = {},  |- !(n : mem(N)). n2z(n#) = Asz(n#, O): thm
val n2z_Oz = {},  |- n2z(O) = Oz: thm
val Lez_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Lez(n2z(a#), n2z(b#)) <=> Le(a#, b#):
   thm
val Ltz_n2z =
   {},  |- !(a : mem(N))  (b : mem(N)). Ltz(n2z(a#), n2z(b#)) <=> Lt(a#, b#):
   thm
val Oz_Lez_n2z = {},  |- !(n : mem(N)). Lez(Oz, n2z(n#)): thm
val Mulz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Mulz(n2z(a#), n2z(b#)) = n2z(Mul(a#, b#)):
   thm
val Addz_n2z =
   {}, 
   |- !(a : mem(N))  (b : mem(N)). Addz(n2z(a#), n2z(b#)) = n2z(Add(a#, b#)):
   thm
val n2z_Oz_O = {},  |- !(n : mem(N)). n2z(n#) = Oz <=> n# = O: thm
val Le_num1_Lt_O = {},  |- !(a : mem(N)). Le(num1, a#) <=> Lt(O, a#): thm
val division_theorem_N_uex =
   {}, 
   |- !(d : mem(N)).
        Le(num1, d#) ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val qfun_compr = fn: term frag list -> term frag list -> thm
******

Loading SEAR file quo.sml

******
val resp1_def =
   {(A : set), (B : set), (R : rel(A, A)), (f : fun(A, B))}, 
   |- resp1(f, R) <=> resp(f, R, id(B)): thm
val resp1_property =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (R : rel(A#, A#)).
        resp1(f#, R#) <=>
        !(a1 : mem(A#))  (a2 : mem(A#)).
          Holds(R#, a1#, a2#) ==> App(f#, a1#) = App(f#, a2#): thm
val Inj_INV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          ?!(ivf : fun(B#, A#)).
            ivf# o f# = Id(A#) &
            !(b : mem(B#)).
              (!(a : mem(A#)). ~App(f#, a#) = b#) ==> App(ivf#, b#) = a0#:
   thm
val Abs_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- Abs(r, i, q0) = LINV(i, q0) o Rsi(r): thm
val Inj_LINV =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(a : mem(A#)). LINV(f#, a#) o f# = Id(A#): thm
val LINV_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(a0 : mem(A#)).
          LINV(f#, a0#) o f# = Id(A#) &
          !(b : mem(B#)).
            (!(a : mem(A#)). ~App(f#, a#) = b#) ==>
            App(LINV(f#, a0#), b#) = a0#: thm
val Quot_def =
   {(A : set), (Q : set), (i : fun(Q, Pow(A))), (r : rel(A, A))}, 
   |- Quot(r, i) <=>
      Inj(i) &
      !(s : mem(Pow(A))).
        (?(q : mem(Q)). s# = App(i, q#)) <=> ?(a : mem(A)). s# = rsi(r, a#):
   thm
val abs_def =
   {(A : set), (Q : set), (a : mem(A)), (i : fun(Q, Pow(A))), (q0 : mem(Q)),
    (r : rel(A, A))},  |- abs(r, i, q0, a) = App(Abs(r, i, q0), a): thm
val eth = {(A : set), (B : set), (a0 : mem(A))},  |- ?(f : fun(B, A)). T: thm
val fname = "LINV": string
val fun_mem_ex =
   {},  |- !(A : set)  (a0 : mem(A#))  (B : set). ?(f : fun(B#, A#)). T: thm
val qvl =
   [[QUOTE " (*#loc 80 35*)f:A->B"], [QUOTE " (*#loc 80 48*)a0:mem(A)"]]:
   term frag list list
val uexth0 =
   {(A : set), (B : set), (a0 : mem(A)), (f : fun(A, B))}, Inj(f)
   |- ?!(ivf : fun(B, A)).
        ivf# o f = Id(A) &
        !(b : mem(B)).
          (!(a : mem(A)). ~App(f, a#) = b#) ==> App(ivf#, b#) = a0: thm
val Abs_Surj =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==> !(q0 : mem(Q#)). Surj(Abs(r#, i#, q0#)): thm
val Quot_ER_Holds =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            App(i#, q1#) = rsi(r#, a1#) & App(i#, q2#) = rsi(r#, a2#) ==>
            (Holds(r#, a1#, a2#) <=> q1# = q2#): thm
val Quot_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (a1 : mem(A#))  (a2 : mem(A#)).
            abs(r#, i#, q0#, a1#) = abs(r#, i#, q0#, a2#) <=>
            Holds(r#, a1#, a2#): thm
val Quot_UMP =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ER(R#) ==>
        !(B : set)  (f : fun(A#, B#)).
          resp1(f#, R#) ==>
          !(Q : set)  (i : fun(Q#, Pow(A#))).
            Quot(R#, i#) ==>
            !(q0 : mem(Q#)).
              ?!(fb : fun(Q#, B#)).
                !(a : mem(A#)). App(fb#, abs(R#, i#, q0#, a#)) = App(f#, a#):
   thm
val Quot_Quo =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) <=> Inj(i#) & Quo(r#, i#): thm
val ER_Quot_nonempty =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(q : mem(Q#)). ?(a : mem(A#)). IN(a#, App(i#, q#)): thm
val Quot_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        Quot(prrel(r1#, r2#), ipow2(i1#, i2#)): thm
val abs_cong =
   {}, 
   |- !(A : set)  (r1 : rel(A#, A#))  (Q1 : set)  (i1 : fun(Q1#, Pow(A#)))
      (B : set)  (r2 : rel(B#, B#))  (Q2 : set)  (i2 : fun(Q2#, Pow(B#))).
        ER(r1#) & ER(r2#) & Quot(r1#, i1#) & Quot(r2#, i2#) ==>
        !(q1 : mem(Q1#))  (q2 : mem(Q2#))  (a : mem(A#))  (b : mem(B#)).
          abs(prrel(r1#, r2#), ipow2(i1#, i2#), Pair(q1#, q2#), Pair(a#, b#)) =
            Pair(abs(r1#, i1#, q1#, a#), abs(r2#, i2#, q2#, b#)): thm
val Rep_of_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(q0 : mem(Q#))  (a : mem(A#)).
          App(i#, abs(r#, i#, q0#, a#)) = rsi(r#, a#): thm
val Quot_rsi_uex =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). App(i#, q#) = rsi(r#, a#): thm
val ER_Quot_rsi_char =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q : mem(Q#))  (a : mem(A#)).
            IN(a#, App(i#, q#)) <=> App(i#, q#) = rsi(r#, a#): thm
val Quot_IN_BIGUNION_rep =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            ?(a : mem(Q#)). IN(a#, s#) & abs(r#, i#, q0#, ra#) = a#: thm
val Quot_IN_BIGUNION_abs =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q0 : mem(Q#))  (ra : mem(A#))  (s : mem(Pow(Q#))).
            IN(ra#, BIGUNION(IMAGE(i#, s#))) <=>
            IN(abs(r#, i#, q0#, ra#), s#): thm
val Quot_el_same =
   {}, 
   |- !(A : set)  (r : rel(A#, A#)).
        ER(r#) ==>
        !(Q : set)  (i : fun(Q#, Pow(A#))).
          Quot(r#, i#) ==>
          !(q1 : mem(Q#))  (q2 : mem(Q#)).
            q1# = q2# <=>
            ?(a1 : mem(A#))  (a2 : mem(A#)).
              IN(a1#, App(i#, q1#)) &
              IN(a2#, App(i#, q2#)) & Holds(r#, a1#, a2#): thm
val ER_Quot_has_mem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val ER_Quot_has_umem =
   {}, 
   |- !(A : set)  (r : rel(A#, A#))  (Q : set)  (i : fun(Q#, Pow(A#))).
        ER(r#) & Quot(r#, i#) ==>
        !(a : mem(A#)). ?!(q : mem(Q#)). IN(a#, App(i#, q#)): thm
val it = (): unit
val NONZERO_O_Lt = {},  |- !(n : mem(N)). ~n# = O <=> Lt(O, n#): thm
val DIVR_def =
   {}, 
   |- !(a : mem(N * N)).
        Snd(a#) = O & App(DIVR, a#) = Pair(O, O) |
        ~Snd(a#) = O &
        Fst(a#) = Add(Mul(Fst(App(DIVR, a#)), Snd(a#)), Snd(App(DIVR, a#))) &
        Lt(Snd(App(DIVR, a#)), Snd(a#)): thm
val Divr_O =
   {},  |- !(d : mem(N)). d# = O ==> !(a : mem(N)). Divr(a#, d#) = Pair(O, O):
   thm
val Divr_def =
   {(a : mem(N)), (d : mem(N))},  |- Divr(a, d) = App(DIVR, Pair(a, d)): thm
val Divr_property0 =
   {}, 
   |- !(a : mem(N))  (d : mem(N)).
        d# = O & Divr(a#, d#) = Pair(O, O) |
        ~d# = O &
        a# = Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) &
        Lt(Snd(Divr(a#, d#)), d#): thm
val Z2N_def = {},  |- Z2N = LINV(N2Z, O): thm
val Divr_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Fst(Divr(a#, d#)), d#), Snd(Divr(a#, d#))) = a# &
          Lt(Snd(Divr(a#, d#)), d#): thm
val Div2_def = {(n : mem(N))},  |- Div2(n) = Div(n, num2): thm
val Div_Rem_NONZERO =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          Add(Mul(Div(a#, d#), d#), Rem(a#, d#)) = a# & Lt(Rem(a#, d#), d#):
   thm
val Div_def = {(a : mem(N)), (d : mem(N))},  |- Div(a, d) = Fst(Divr(a, d)):
   thm
val Rem_def = {(a : mem(N)), (d : mem(N))},  |- Rem(a, d) = Snd(Divr(a, d)):
   thm
val num2_NONZERO = {},  |- ~num2 = O: thm
val Mul_num2 = {},  |- !(a : mem(N)). Mul(num2, a#) = Add(a#, a#): thm
val Div_Rem_num2 =
   {}, 
   |- !(a : mem(N)).
        Add(Mul(Div2(a#), num2), Rem(a#, num2)) = a# &
        Lt(Rem(a#, num2), num2): thm
val Div_Rem_unique =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N))  (q : mem(N))  (r : mem(N)).
          Add(Mul(q#, d#), r#) = a# & Lt(r#, d#) ==>
          q# = Div(a#, d#) & r# = Rem(a#, d#): thm
val division_theorem_N_uex' =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)).
          ?!(qr : mem(N * N)).
            a# = Add(Mul(Fst(qr#), d#), Snd(qr#)) & Lt(Snd(qr#), d#): thm
val Div_Rem_Mul =
   {}, 
   |- !(d : mem(N)).
        ~d# = O ==>
        !(a : mem(N)). Div(Mul(d#, a#), d#) = a# & Rem(Mul(d#, a#), d#) = O:
   thm
val Div2_Mul = {},  |- !(n : mem(N)). Div2(Mul(num2, n#)) = n#: thm
val num1_Lt_num2 = {},  |- Lt(num1, num2): thm
val Div2_Suc_Mul_num2 =
   {}, 
   |- !(n : mem(N)).
        Div2(Suc(Mul(num2, n#))) = n# & Rem(Suc(Mul(num2, n#)), num2) = num1:
   thm
val Even_Suc = {},  |- !(a : mem(N)). Even(Suc(a#)) <=> ~Even(a#): thm
val num2_Mul_Even = {},  |- !(a : mem(N)). Even(Mul(num2, a#)): thm
val Suc_num2_Mul_Odd = {},  |- !(a : mem(N)). Odd(Suc(Mul(num2, a#))): thm
val O_Even = {},  |- Even(O): thm
val O_NEQ_num1 = {},  |- ~O = num1: thm
val O_NEQ_num2 = {},  |- ~O = num2: thm
val O_NEQ_num3 = {},  |- ~O = num3: thm
val O_NEQ_num4 = {},  |- ~O = num4: thm
val num1_NEQ_num4 = {},  |- ~num1 = num4: thm
val num1_NEQ_num3 = {},  |- ~num1 = num3: thm
val num1_NEQ_num2 = {},  |- ~num1 = num2: thm
val num2_NEQ_num3 = {},  |- ~num2 = num3: thm
val num2_NEQ_num4 = {},  |- ~num2 = num4: thm
val num4_NEQ_num3 = {},  |- ~num4 = num3: thm
val Div_of_O = {},  |- !(n : mem(N)). Div(O, n#) = O & Rem(O, n#) = O: thm
val Even_Sub_num2 = {},  |- !(a : mem(N)). Even(a#) ==> Even(Sub(a#, num2)):
   thm
val Odd_num1 = {},  |- Odd(num1): thm
val Lt_num2 = {},  |- !(a : mem(N)). Lt(a#, num2) <=> a# = O | a# = num1: thm
val Even_Div2 =
   {}, 
   |- !(a : mem(N)).
        Even(a#) <=> Mul(Div2(a#), num2) = a# & Rem(a#, num2) = O: thm
val Odd_Div2 =
   {}, 
   |- !(a : mem(N)).
        Odd(a#) <=> Suc(Mul(Div2(a#), num2)) = a# & Rem(a#, num2) = num1: thm
val it = (): unit
******

Loading SEAR file SEARFiniteness.sml

******
val FI's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). IN(a#, FI's(X)) <=> SS(App(FIf(X), a#), a#):
   thm
val FI_cases0 = {(X : set)},  |- App(FIf(X), FIs(X)) = FIs(X): thm
val FI_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_incond =
   !(xs : mem(Pow(X))).
     IN(xs#, FIs1) <=>
     xs# = Empty(X) |
     ?(xs0 : mem(Pow(X)))  (x : mem(X)). IN(xs0#, FIs0) & xs# = Ins(x#, xs0#):
   form
val FI_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> SS(FIs(X), ss#):
   thm
val FI_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        (!(a : mem(Pow(X))).
            a# = Empty(X) |
            (?(xs0 : mem(Pow(X)))  (x : mem(X)).
                IN(xs0#, ss#) & a# = Ins(x#, xs0#)) ==> IN(a#, ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X)))).
        IN(Empty(X), ss#) &
        (!(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, ss#) ==> IN(Ins(x#, xs0#), ss#)) ==>
        !(a : mem(Pow(X))). IN(a#, FIs(X)) ==> IN(a#, ss#): thm
val FI_rules0 = {(X : set)},  |- SS(App(FIf(X), FIs(X)), FIs(X)): thm
val FI_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        a# = Empty(X) |
        (?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#)) ==> IN(a#, FIs(X)): thm
val FI_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (a# = Empty(X) ==> IN(a#, FIs(X))) &
        !(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & a# = Ins(x#, xs0#) ==> IN(a#, FIs(X)): thm
val FI_rules3 =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val FIf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
        IN(xs#, App(FIf(X), a#)) <=>
        xs# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X)), Pow(Pow(X)))).
        !(a : mem(Pow(Pow(X))))  (xs : mem(Pow(X))).
          IN(xs#, App(f#, a#)) <=>
          xs# = Empty(X) |
          ?(xs0 : mem(Pow(X)))  (x : mem(X)).
            IN(xs0#, a#) & xs# = Ins(x#, xs0#): thm
val FIf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X))))  (s2 : mem(Pow(Pow(X)))).
        SS(s1#, s2#) ==> SS(App(FIf(X), s1#), App(FIf(X), s2#)): thm
val FIs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X)))). SS(App(FIf(X), a#), a#) ==> SS(FIs(X), a#):
   thm
val FIs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X))).
        (!(ss : mem(Pow(Pow(X)))). SS(App(FIf(X), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, FIs(X)): thm
val FIs_def = {(X : set)},  |- FIs(X) = BIGINTER(FI's(X)): thm
val x1 = "FIs0": string
val FI_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X))).
        IN(x#, FIs(X)) <=>
        x# = Empty(X) |
        ?(xs0 : mem(Pow(X)))  (x : mem(X)).
          IN(xs0#, FIs(X)) & x# = Ins(x#, xs0#): thm
val FI_rules =
   {(X : set)}, 
   |- IN(Empty(X), FIs(X)) &
      !(xs0 : mem(Pow(X)))  (x : mem(X)).
        IN(xs0#, FIs(X)) ==> IN(Ins(x#, xs0#), FIs(X)): thm
val Fin_def =
   {},  |- !(X : set)  (A : mem(Pow(X#))). Fin(A#) <=> IN(A#, FIs(X#)): thm
val Cd's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))).
        IN(a#, Cd's(X)) <=> SS(App(Cdf(X), a#), a#): thm
val Cd_cases0 = {(X : set)},  |- App(Cdf(X), Cds(X)) = Cds(X): thm
val Cd_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_incond =
   !(xsn : mem(Pow(X) * N)).
     IN(xsn#, Cds1) <=>
     xsn# = Pair(Empty(X), O) |
     ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
       IN(xsn0#, Cds0) &
       ~IN(x#, Fst(xsn0#)) &
       xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): form
val Cd_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        SS(App(Cdf(X), ss#), ss#) ==> SS(Cds(X), ss#): thm
val Cd_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        (!(a : mem(Pow(X) * N)).
            a# = Pair(Empty(X), O) |
            (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
                IN(xsn0#, ss#) &
                ~IN(x#, Fst(xsn0#)) &
                a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(X) * N))).
        IN(Pair(Empty(X), O), ss#) &
        (!(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, ss#) & ~IN(x#, Fst(xsn0#)) ==>
            IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), ss#)) ==>
        !(a : mem(Pow(X) * N)). IN(a#, Cds(X)) ==> IN(a#, ss#): thm
val Cd_rules0 = {(X : set)},  |- SS(App(Cdf(X), Cds(X)), Cds(X)): thm
val Cd_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        a# = Pair(Empty(X), O) |
        (?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, Cds(X)) &
            ~IN(x#, Fst(xsn0#)) &
            a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#)))) ==>
        IN(a#, Cds(X)): thm
val Cd_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (a# = Pair(Empty(X), O) ==> IN(a#, Cds(X))) &
        !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          a# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))) ==> IN(a#, Cds(X)):
   thm
val Cd_rules3 =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cdf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
        IN(xsn#, App(Cdf(X), a#)) <=>
        xsn# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, a#) &
          ~IN(x#, Fst(xsn0#)) &
          xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(X) * N), Pow(Pow(X) * N))).
        !(a : mem(Pow(Pow(X) * N)))  (xsn : mem(Pow(X) * N)).
          IN(xsn#, App(f#, a#)) <=>
          xsn# = Pair(Empty(X), O) |
          ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
            IN(xsn0#, a#) &
            ~IN(x#, Fst(xsn0#)) &
            xsn# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cdf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(X) * N)))  (s2 : mem(Pow(Pow(X) * N))).
        SS(s1#, s2#) ==> SS(App(Cdf(X), s1#), App(Cdf(X), s2#)): thm
val Cds_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(X) * N))). SS(App(Cdf(X), a#), a#) ==> SS(Cds(X), a#):
   thm
val Cds_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(X) * N)).
        (!(ss : mem(Pow(Pow(X) * N))).
            SS(App(Cdf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, Cds(X)):
   thm
val Cds_def = {(X : set)},  |- Cds(X) = BIGINTER(Cd's(X)): thm
val x1 = "Cds0": string
val Cd_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(X) * N)).
        IN(x#, Cds(X)) <=>
        x# = Pair(Empty(X), O) |
        ?(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
          IN(xsn0#, Cds(X)) &
          ~IN(x#, Fst(xsn0#)) &
          x# = Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))): thm
val Cd_rules =
   {(X : set)}, 
   |- IN(Pair(Empty(X), O), Cds(X)) &
      !(xsn0 : mem(Pow(X) * N))  (x : mem(X)).
        IN(xsn0#, Cds(X)) ==>
        ~IN(x#, Fst(xsn0#)) ==>
        IN(Pair(Ins(x#, Fst(xsn0#)), Suc(Snd(xsn0#))), Cds(X)): thm
val Cds_ind =
   {}, 
   |- !(X : set)  (ss : mem(Pow(Pow(X#) * N))).
        IN(Pair(Empty(X#), O), ss#) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            IN(Pair(xs0#, n0#), ss#) & ~IN(x#, xs0#) ==>
            IN(Pair(Ins(x#, xs0#), Suc(n0#)), ss#)) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> IN(Pair(xs#, n#), ss#): thm
val Cd_induct0 =
   {}, 
   |- !(X : set).
        P(Pair(Empty(X#), O)) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(Pair(xs0#, n0#)) & ~IN(x#, xs0#) ==>
            P(Pair(Ins(x#, xs0#), Suc(n0#)))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(Pair(xs#, n#)): thm
val Cd_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)).
          IN(Pair(xs#, n#), Cds(X#)) ==> P(xs#, n#): thm
val Fin_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#)) &
        (!(xs0 : mem(Pow(X#)))  (x : mem(X#)). P(xs0#) ==> P(Ins(x#, xs0#))) ==>
        !(xs : mem(Pow(X#))). Fin(xs#) ==> P(xs#): thm
val Cdr_def =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) <=> IN(Pair(xs#, n#), Cds(X#)): thm
val Cdr_induct =
   {}, 
   |- !(X : set).
        P(Empty(X#), O) &
        (!(xs0 : mem(Pow(X#)))  (n0 : mem(N))  (x : mem(X#)).
            P(xs0#, n0#) & ~IN(x#, xs0#) ==> P(Ins(x#, xs0#), Suc(n0#))) ==>
        !(xs : mem(Pow(X#)))  (n : mem(N)). Cdr(xs#, n#) ==> P(xs#, n#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs0#, n#) ==>
        !(x : mem(X#)). ~IN(x#, xs0#) ==> Cdr(Ins(x#, xs0#), Suc(n#)): thm
val Ins_NONEMPTY =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs : mem(Pow(X#))).
        ~Ins(x0#, xs#) = Empty(X#): thm
val IN_Ins_SND =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (x : mem(X#)).
        IN(x#, Ins(x0#, xs0#)) & ~x# = x0# ==> IN(x#, xs0#): thm
val Cdr_Empty_unique =
   {},  |- !(X : set)  (n : mem(N)). Cdr(Empty(X#), n#) ==> n# = O: thm
val Del_Ins_SWAP =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        ~x0# = x# ==>
        !(xs : mem(Pow(X#))). Del(Ins(x0#, xs#), x#) = Ins(x0#, Del(xs#, x#)):
   thm
val Cdr_Ins =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (xs0 : mem(Pow(X#)))  (n : mem(N)).
        Cdr(Ins(x0#, xs0#), n#) <=>
        ?(a : mem(Pow(X#)))  (b : mem(N))  (x : mem(X#)).
          Cdr(a#, b#) &
          ~IN(x#, a#) & Ins(x0#, xs0#) = Ins(x#, a#) & n# = Suc(b#): thm
val Cdr_Empty = {},  |- !(X : set). Cdr(Empty(X#), O): thm
val Cdr_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#)))  (n : mem(N)).
        Cdr(xs#, n#) ==>
        Cdr(xs#, n#) &
        !(x : mem(X#)). IN(x#, xs#) ==> Cdr(Del(xs#, x#), Pre(n#)): thm
val Fin_Card =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> ?!(n : mem(N)). Cdr(xs#, n#): thm
val CARD_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        Holds(CARD(X#), a#, b#) <=> Fin(a#) & Cdr(a#, b#) | ~Fin(a#) & b# = O:
   thm
val CARD_unique =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        ?!(n : mem(N)). Holds(CARD(X#), xs#, n#): thm
val Cd0_def =
   {}, 
   |- !(X : set)  (a : mem(Pow(X#)))  (b : mem(N)).
        App(Cd0(X#), a#) = b# <=> Holds(CARD(X#), a#, b#): thm
val Card_def =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Card(xs#) = App(Cd0(X#), xs#):
   thm
val Del_Empty =
   {},  |- !(X : set)  (x : mem(X#)). Del(Empty(X#), x#) = Empty(X#): thm
val Ins_eq_eq =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (s1 : mem(Pow(A#)))  (a2 : mem(A#))
      (s2 : mem(Pow(A#))).
        ~IN(a1#, s1#) &
        ~IN(a2#, s2#) &
        ~IN(a1#, s2#) & ~IN(a2#, s1#) & Ins(a1#, s1#) = Ins(a2#, s2#) ==>
        a1# = a2# & s1# = s2#: thm
val Fin_Empty = {},  |- !(X : set). Fin(Empty(X#)): thm
val Fin_Ins =
   {}, 
   |- !(X : set)  (xs0 : mem(Pow(X#))).
        Fin(xs0#) ==> !(x : mem(X#)). Fin(Ins(x#, xs0#)): thm
val Fin_Ins_Ins =
   {}, 
   |- !(A : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        Fin(Ins(a1#, Ins(a2#, Empty(A#)))): thm
val Fin_Del0 =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> Fin(xs#) & !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Fin_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(x : mem(X#)). Fin(Del(xs#, x#)): thm
val Card_Fin =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==> !(n : mem(N)). Card(xs#) = n# <=> Cdr(xs#, n#): thm
val Card_Empty = {},  |- !(X : set). Card(Empty(X#)) = O: thm
val Cdr_Card =
   {},  |- !(X : set)  (xs : mem(Pow(X#))). Fin(xs#) ==> Cdr(xs#, Card(xs#)):
   thm
val Card_Ins =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). ~IN(x#, xs#) ==> Card(Ins(x#, xs#)) = Suc(Card(xs#)):
   thm
val Card_Del =
   {}, 
   |- !(X : set)  (xs : mem(Pow(X#))).
        Fin(xs#) ==>
        !(x : mem(X#)). IN(x#, xs#) ==> Card(Del(xs#, x#)) = Pre(Card(xs#)):
   thm
val IN_App_IMAGE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A#))).
        IN(a#, s#) ==>
        !(B : set)  (f : fun(A#, B#)). IN(App(f#, a#), IMAGE(f#, s#)): thm
val Fin_SS =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Fin(s#) ==> !(t : mem(Pow(A#))). SS(t#, s#) ==> Fin(t#): thm
val Fin_Union =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(Union(s1#, s2#)) <=> Fin(s1#) & Fin(s2#): thm
val Ins_Ins_Fin =
   {(A : set), (s1 : mem(A)), (s2 : mem(A))}, 
   |- Fin(Ins(s1, Ins(s2, Empty(A)))): thm
val Fin_Sing = {},  |- !(A : set)  (a : mem(A#)). Fin(Sing(a#)): thm
val it = (): unit
******

Loading SEAR file SEARList.sml

******
val isL's_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        IN(a#, isL's(X)) <=> SS(App(isLf(X), a#), a#): thm
val isL_cases0 = {(X : set)},  |- App(isLf(X), isLs(X)) = isLs(X): thm
val isL_cases1 =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_incond =
   !(ls : mem(Pow(N * X))).
     IN(ls#, isLs1) <=>
     ls# = Empty(N * X) |
     ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
       IN(ls0#, isLs0) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): form
val isL_ind =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind0 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), ss#), ss#) ==> SS(isLs(X), ss#): thm
val isL_ind1 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        (!(a : mem(Pow(N * X))).
            a# = Empty(N * X) |
            (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
                IN(ls0#, ss#) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_ind2 =
   {(X : set)}, 
   |- !(ss : mem(Pow(Pow(N * X)))).
        IN(Empty(N * X), ss#) &
        (!(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, ss#) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), ss#)) ==>
        !(a : mem(Pow(N * X))). IN(a#, isLs(X)) ==> IN(a#, ss#): thm
val isL_rules0 = {(X : set)},  |- SS(App(isLf(X), isLs(X)), isLs(X)): thm
val isL_rules1 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        a# = Empty(N * X) |
        (?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#)) ==>
        IN(a#, isLs(X)): thm
val isL_rules2 =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (a# = Empty(N * X) ==> IN(a#, isLs(X))) &
        !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & a# = Ins(Pair(Card(ls0#), x#), ls0#) ==>
          IN(a#, isLs(X)): thm
val isL_rules3 =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val isLf_def =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
        IN(ls#, App(isLf(X), a#)) <=>
        ls# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_ex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Pow(N * X)), Pow(Pow(N * X)))).
        !(a : mem(Pow(Pow(N * X))))  (ls : mem(Pow(N * X))).
          IN(ls#, App(f#, a#)) <=>
          ls# = Empty(N * X) |
          ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
            IN(ls0#, a#) & ls# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isLf_monotone =
   {(X : set)}, 
   |- !(s1 : mem(Pow(Pow(N * X))))  (s2 : mem(Pow(Pow(N * X)))).
        SS(s1#, s2#) ==> SS(App(isLf(X), s1#), App(isLf(X), s2#)): thm
val isLs_SS =
   {(X : set)}, 
   |- !(a : mem(Pow(Pow(N * X)))).
        SS(App(isLf(X), a#), a#) ==> SS(isLs(X), a#): thm
val isLs_cond =
   {(X : set)}, 
   |- !(a : mem(Pow(N * X))).
        (!(ss : mem(Pow(Pow(N * X)))).
            SS(App(isLf(X), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isLs(X)):
   thm
val isLs_def = {(X : set)},  |- isLs(X) = BIGINTER(isL's(X)): thm
val x1 = "isLs0": string
val isL_cases =
   {(X : set)}, 
   |- !(x : mem(Pow(N * X))).
        IN(x#, isLs(X)) <=>
        x# = Empty(N * X) |
        ?(ls0 : mem(Pow(N * X)))  (x : mem(X)).
          IN(ls0#, isLs(X)) & x# = Ins(Pair(Card(ls0#), x#), ls0#): thm
val isL_rules =
   {(X : set)}, 
   |- IN(Empty(N * X), isLs(X)) &
      !(ls0 : mem(Pow(N * X)))  (x : mem(X)).
        IN(ls0#, isLs(X)) ==> IN(Ins(Pair(Card(ls0#), x#), ls0#), isLs(X)):
   thm
val List_def =
   {}, 
   |- !(X : set).
        Inj(iL(X#)) &
        !(a : mem(Pow(N * X#))).
          IN(a#, isLs(X#)) <=> ?(b : mem(List(X#))). a# = App(iL(X#), b#):
   thm
val iL_Inj = {},  |- !(X : set). Inj(iL(X#)): thm
val isL_def =
   {},  |- !(X : set)  (l : mem(Pow(N * X#))). isL(l#) <=> IN(l#, isLs(X#)):
   thm
val isL_induct =
   {}, 
   |- !(X : set).
        P(Empty(N * X#)) &
        (!(ls0 : mem(Pow(N * X#)))  (x : mem(X#)).
            P(ls0#) ==> P(Ins(Pair(Card(ls0#), x#), ls0#))) ==>
        !(l : mem(Pow(N * X#))). isL(l#) ==> P(l#): thm
val isL_Empty = {},  |- !(X : set). isL(Empty(N * X#)): thm
val isL_Ins =
   {}, 
   |- !(X : set)  (ls0 : mem(Pow(N * X#))).
        isL(ls0#) ==> !(x : mem(X#)). isL(Ins(Pair(Card(ls0#), x#), ls0#)):
   thm
val Repl_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Repl(l#) = App(iL(X#), l#): thm
val Nil_def = {},  |- !(X : set). Repl(Nil(X#)) = Empty(N * X#): thm
val cons0_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- cons0(x, l) = Ins(Pair(Card(l), x), l): thm
val cons1_def =
   {(X : set), (l : mem(Pow(N * X))), (x : mem(X))}, 
   |- App(cons1(X), Pair(x, l)) = Ins(Pair(Card(l), x), l): thm
val iL_isL = {},  |- !(X : set)  (l : mem(List(X#))). isL(App(iL(X#), l#)):
   thm
val isL_Repl =
   {}, 
   |- !(X : set)  (a : mem(Pow(N * X#))).
        isL(a#) <=> ?(b : mem(List(X#))). a# = Repl(b#): thm
val CONS_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Ins(Pair(Card(Repl(l#)), x#), Repl(l#)) =
          Repl(App(CONS(X#), Pair(x#, l#))): thm
val lift_cond2 =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val lift_cond2' =
   {(X : set)}, 
   |- !(xl1 : mem(X * List(X))).
        ?!(l2 : mem(List(X))).
          App(cons1(X) o Prla(Id(X), iL(X)), xl1#) = App(iL(X), l2#): thm
val Cons_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Cons(x#, l#) = App(CONS(X#), Pair(x#, l#)): thm
val Repl_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Repl(Cons(x#, l#)) = Ins(Pair(Card(Repl(l#)), x#), Repl(l#)): thm
val Repl_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(List(X#)))  (l2 : mem(List(X#))).
        Repl(l1#) = Repl(l2#) <=> l1# = l2#: thm
val Cons_NONNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(List(X#))). ~Cons(x#, l#) = Nil(X#):
   thm
val Repl_Empty_uex =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        Repl(l#) = Empty(N * X#) <=> l# = Nil(X#): thm
val List_induct =
   {}, 
   |- !(X : set).
        P(Nil(X#)) &
        (!(l : mem(List(X#))). P(l#) ==> !(x : mem(X#)). P(Cons(x#, l#))) ==>
        !(l : mem(List(X#))). P(l#): thm
val Fin_Repl = {},  |- !(X : set)  (l : mem(List(X#))). Fin(Repl(l#)): thm
val isL_Card_NOTIN0 =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (n : mem(N))  (x : mem(X#)).
        IN(Pair(n#, x#), Repl(l#)) ==> Lt(n#, Card(Repl(l#))): thm
val CONS_Inj = {},  |- !(X : set). Inj(CONS(X#)): thm
val Cons_eq_eq =
   {}, 
   |- !(X : set)  (x1 : mem(X#))  (l1 : mem(List(X#)))  (x2 : mem(X#))
      (l2 : mem(List(X#))).
        Cons(x1#, l1#) = Cons(x2#, l2#) <=> x1# = x2# & l1# = l2#: thm
val Cons_or_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        l# = Nil(X#) |
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Cons_xor_Nil =
   {}, 
   |- !(X : set)  (l : mem(List(X#))).
        ~l# = Nil(X#) <=>
        ?(x0 : mem(X#))  (l0 : mem(List(X#))). l# = Cons(x0#, l0#): thm
val Lind's_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        IN(a#, Lind's(a0, f0)) <=> SS(App(Lindf(a0, f0), a#), a#): thm
val Lind_cases0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- App(Lindf(a0, f0), Linds(a0, f0)) = Linds(a0, f0): thm
val Lind_cases1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_incond =
   !(p : mem(List(X) * A)).
     IN(p#, Lind1) <=>
     p# = Pair(Nil(X), a0) |
     ?(p0 : mem(List(X) * A))  (x : mem(X)).
       IN(p0#, Lind0) &
       p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): form
val Lind_ind =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), ss#), ss#) ==> SS(Linds(a0, f0), ss#): thm
val Lind_ind1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        (!(a : mem(List(X) * A)).
            a# = Pair(Nil(X), a0) |
            (?(p0 : mem(List(X) * A))  (x : mem(X)).
                IN(p0#, ss#) &
                a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
            IN(a#, ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_ind2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(ss : mem(Pow(List(X) * A))).
        IN(Pair(Nil(X), a0), ss#) &
        (!(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, ss#) ==>
            IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))), ss#)) ==>
        !(a : mem(List(X) * A)). IN(a#, Linds(a0, f0)) ==> IN(a#, ss#): thm
val Lind_rules0 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- SS(App(Lindf(a0, f0), Linds(a0, f0)), Linds(a0, f0)): thm
val Lind_rules1 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        a# = Pair(Nil(X), a0) |
        (?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, Linds(a0, f0)) &
            a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#))))) ==>
        IN(a#, Linds(a0, f0)): thm
val Lind_rules2 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (a# = Pair(Nil(X), a0) ==> IN(a#, Linds(a0, f0))) &
        !(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          a# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))) ==>
          IN(a#, Linds(a0, f0)): thm
val Lind_rules3 =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lindf_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
        IN(p#, App(Lindf(a0, f0), a#)) <=>
        p# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, a#) &
          p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_ex =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- ?!(f : fun(Pow(List(X) * A), Pow(List(X) * A))).
        !(a : mem(Pow(List(X) * A)))  (p : mem(List(X) * A)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Nil(X), a0) |
          ?(p0 : mem(List(X) * A))  (x : mem(X)).
            IN(p0#, a#) &
            p# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lindf_monotone =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(s1 : mem(Pow(List(X) * A)))  (s2 : mem(Pow(List(X) * A))).
        SS(s1#, s2#) ==> SS(App(Lindf(a0, f0), s1#), App(Lindf(a0, f0), s2#)):
   thm
val Linds_SS =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(Pow(List(X) * A))).
        SS(App(Lindf(a0, f0), a#), a#) ==> SS(Linds(a0, f0), a#): thm
val Linds_cond =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(a : mem(List(X) * A)).
        (!(ss : mem(Pow(List(X) * A))).
            SS(App(Lindf(a0, f0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, Linds(a0, f0)): thm
val Linds_def =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- Linds(a0, f0) = BIGINTER(Lind's(a0, f0)): thm
val x1 = "Lind0": string
val Lind_cases =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- !(x : mem(List(X) * A)).
        IN(x#, Linds(a0, f0)) <=>
        x# = Pair(Nil(X), a0) |
        ?(p0 : mem(List(X) * A))  (x : mem(X)).
          IN(p0#, Linds(a0, f0)) &
          x# = Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))): thm
val Lind_rules =
   {(A : set), (X : set), (a0 : mem(A)), (f0 : fun(X * A, A))}, 
   |- IN(Pair(Nil(X), a0), Linds(a0, f0)) &
      !(p0 : mem(List(X) * A))  (x : mem(X)).
        IN(p0#, Linds(a0, f0)) ==>
        IN(Pair(Cons(x#, Fst(p0#)), App(f0, Pair(x#, Snd(p0#)))),
         Linds(a0, f0)): thm
val Lind_uex =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#))). ?!(a : mem(A#)). IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_def =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (a : mem(List(X#))).
        IN(Pair(a#, App(Lrec(a0#, f0#), a#)), Linds(a0#, f0#)): thm
val Lrec_Nil =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        App(Lrec(a0#, f0#), Nil(X#)) = a0#: thm
val App_Lrec_Linds =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (a : mem(A#)).
        App(Lrec(a0#, f0#), l#) = a# <=> IN(Pair(l#, a#), Linds(a0#, f0#)):
   thm
val Lrec_Cons =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#))
      (l : mem(List(X#)))  (x : mem(X#)).
        App(Lrec(a0#, f0#), Cons(x#, l#)) =
          App(f0#, Pair(x#, App(Lrec(a0#, f0#), l#))): thm
val Lrec_unique =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f : fun(X# * A#, A#))
      (r : fun(List(X#), A#)).
        App(r#, Nil(X#)) = a0# & r# o CONS(X#) = f# o Prla(Id(X#), r#) ==>
        r# = Lrec(a0#, f#): thm
val Lrec_Cons_eqn =
   {}, 
   |- !(A : set)  (a0 : mem(A#))  (X : set)  (f0 : fun(X# * A#, A#)).
        Lrec(a0#, f0#) o CONS(X#) = f0# o Prla(Id(X#), Lrec(a0#, f0#)): thm
val LENGTH_def = {},  |- !(X : set). LENGTH(X#) = Lrec(O, SUC o p2(X#, N)):
   thm
val Length_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Length(l#) = App(LENGTH(X#), l#):
   thm
val Length_Nil = {},  |- !(X : set). Length(Nil(X#)) = O: thm
val Length_Cons =
   {}, 
   |- !(A : set)  (a : mem(A#))  (l : mem(List(A#))).
        Length(Cons(a#, l#)) = Suc(Length(l#)): thm
val HD_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        App(HD(X#), Cons(x#, l#)) = SOME(x#): thm
val HD_Nil = {(X : set)},  |- App(HD(X), Nil(X)) = NONE(X): thm
val HD_def =
   {},  |- !(X : set). HD(X#) = Lrec(NONE(X#), i1(X#, 1) o p1(X#, X# + 1)):
   thm
val Hd_Cons =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (x : mem(X#)).
        Hd(Cons(x#, l#)) = SOME(x#): thm
val Hd_def =
   {},  |- !(X : set)  (l : mem(List(X#))). Hd(l#) = App(HD(X#), l#): thm
val TL_Nil = {(X : set)},  |- App(TL(X), Nil(X)) = Nil(X): thm
val TL_def =
   {}, 
   |- !(X : set)  (a : mem(List(X#))).
        a# = Nil(X#) & App(TL(X#), a#) = Nil(X#) |
        ~a# = Nil(X#) & ?(x : mem(X#)). a# = Cons(x#, App(TL(X#), a#)): thm
val TL_ex =
   {(X : set)}, 
   |- !(l : mem(List(X))).
        ?!(tl : mem(List(X))).
          l# = Nil(X) & tl# = Nil(X) |
          ~l# = Nil(X) & ?(x : mem(X)). l# = Cons(x#, tl#): thm
val TL_Cons =
   {(X : set)}, 
   |- !(x : mem(X))  (tl : mem(List(X))). App(TL(X), Cons(x#, tl#)) = tl#:
   thm
val ELn_Nil = {(X : set)},  |- App(ELn(X), O) = Tpm(HD(X)): thm
val ELn_def =
   {(X : set)}, 
   |- ELn(X) = Nrec(Tpm(HD(X)), Ap1(MO(List(X), List(X), X + 1), Tpm(TL(X)))):
   thm
val Eln_Map =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(n : mem(N))  (l : mem(List(X))).
        Lt(n#, Length(l#)) ==> Eln(n#, Map(f, l#)) = App(OM(f), Eln(n#, l#)):
   thm
val Eln_O = {(X : set)},  |- !(a : mem(List(X))). Eln(O, a#) = Hd(a#): thm
val Eln_Suc =
   {(X : set)}, 
   |- !(n : mem(N))  (a : mem(List(X))). Eln(Suc(n#), a#) = Eln(n#, Tl(a#)):
   thm
val Eln_def =
   {(X : set), (l : mem(List(X))), (n : mem(N))}, 
   |- Eln(n, l) = App(tof(App(ELn(X), n)), l): thm
val MAP_Cons =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(l : mem(List(X)))  (x : mem(X)).
        App(MAP(f), Cons(x#, l#)) = Cons(App(f, x#), App(MAP(f), l#)): thm
val MAP_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        App(MAP(f#), Nil(X#)) = Nil(Y#): thm
val MAP_def =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)).
        MAP(f#) = Lrec(Nil(Y#), CONS(Y#) o Prla(f#, Id(List(Y#)))): thm
val MO_def =
   {(A : set), (B : set), (C : set), (fm : mem(Exp(A, B))),
    (gm : mem(Exp(B, C)))},  |- App(MO(A, B, C), Pair(gm, fm)) = mo(gm, fm):
   thm
val Map_Cons =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#))  (l : mem(List(X#)))
      (x : mem(X#)). Map(f#, Cons(x#, l#)) = Cons(App(f#, x#), Map(f#, l#)):
   thm
val Map_Nil =
   {}, 
   |- !(X : set)  (Y : set)  (f : fun(X#, Y#)). Map(f#, Nil(X#)) = Nil(Y#):
   thm
val Map_def =
   {}, 
   |- !(X : set)  (l : mem(List(X#)))  (Y : set)  (f : fun(X#, Y#)).
        Map(f#, l#) = App(MAP(f#), l#): thm
val Tl_Cons =
   {}, 
   |- !(X : set)  (x : mem(X#))  (tl : mem(List(X#))).
        Tl(Cons(x#, tl#)) = tl#: thm
val Tl_Nil = {},  |- !(X : set). Tl(Nil(X#)) = Nil(X#): thm
val Tl_def = {(X : set), (l : mem(List(X)))},  |- Tl(l) = App(TL(X), l): thm
val mo_def =
   {}, 
   |- !(A : set)  (B : set)  (f : mem(Exp(A#, B#)))  (C : set)
      (g : mem(Exp(B#, C#))). mo(g#, f#) = Tpm(tof(g#) o tof(f#)): thm
val it = (): unit
******

Loading SEAR file SEARfm.sml

******
val InjA_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjA(A#), a#)) <=> a# = SOME(a#): thm
val InjN_def =
   {}, 
   |- !(A : set)  (a : mem(N))  (n : mem(N))  (a : mem(A# + 1)).
        IN(Pair(n#, a#), App(InjN(A#), a#)) <=> n# = a#: thm
val InjUU0_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * A)))  (b : mem(Pow(N * A)))  (n : mem(N))
      (a : mem(A)).
        IN(Pair(n#, a#), App(InjUU0(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val injUU0_char =
   {}, 
   |- (!(n : mem(N)).
          Even(n#) ==>
          !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
          (a : mem(A#)).
            IN(Pair(n#, a#), injUU0(u1#, u2#)) <=>
            IN(Pair(Div2(n#), a#), u1#)) &
      !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val injUU0_def =
   {(A : set), (u1 : mem(Pow(N * A))), (u2 : mem(Pow(N * A)))}, 
   |- injUU0(u1, u2) = App(InjUU0(A), Pair(u1, u2)): thm
val InjUU0_Inj = {},  |- !(A : set). Inj(InjUU0(A#)): thm
val injUU0_Even =
   {}, 
   |- !(n : mem(N)).
        Even(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u1#):
   thm
val injUU0_Odd =
   {}, 
   |- !(n : mem(N)).
        Odd(n#) ==>
        !(A : set)  (u1 : mem(Pow(N * A#)))  (u2 : mem(Pow(N * A#)))
        (a : mem(A#)).
          IN(Pair(n#, a#), injUU0(u1#, u2#)) <=> IN(Pair(Div2(n#), a#), u2#):
   thm
val F0_def = {(A : set)},  |- F0(A) = injN(A, O): thm
val InjA_Inj = {},  |- !(A : set). Inj(InjA(A#)): thm
val InjUU_Inj = {},  |- !(A : set). Inj(InjUU(A#)): thm
val InjUU_def =
   {(A : set)}, 
   |- !(a' : mem(Pow(N * (A + 1))))  (b : mem(Pow(N * (A + 1))))
      (n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), App(InjUU(A), Pair(a'#, b#))) <=>
        Even(n#) & IN(Pair(Div2(n#), a#), a'#) |
        Odd(n#) & IN(Pair(Div2(n#), a#), b#): thm
val InjUU_def0 = {},  |- !(A : set). InjUU(A#) = InjUU0(A# + 1): thm
val injA_def = {(A : set), (a : mem(A))},  |- injA(a) = App(InjA(A), a): thm
val injN_def = {(A : set), (n : mem(N))},  |- injN(A, n) = App(InjN(A), n):
   thm
val VAR0_Inj = {},  |- !(A : set). Inj(VAR0(A#)): thm
val VAR0_def =
   {(A : set)}, 
   |- VAR0(A) = InjUU(A) o Pa(El(injN(A, num1)) o To1(A), InjA(A)): thm
val NEG0_Inj = {},  |- !(A : set). Inj(NEG0(A#)): thm
val NEG0_def =
   {(A : set)}, 
   |- NEG0(A) = InjUU(A) o
        Pa(El(injN(A, num2)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Var0_def = {(A : set), (a : mem(A))},  |- Var0(a) = App(VAR0(A), a): thm
val DISJ0_Inj = {},  |- !(A : set). Inj(DISJ0(A#)): thm
val DISJ0_def =
   {(A : set)}, 
   |- DISJ0(A) = InjUU(A) o
        Pa(El(injN(A, num3)) o To1(Pow((N * (A + 1))) * Pow(N * (A + 1))),
         InjUU(A)): thm
val Neg0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- Neg0(f0) = App(NEG0(A), f0):
   thm
val DIAM0_Inj = {},  |- !(A : set). Inj(DIAM0(A#)): thm
val DIAM0_def =
   {(A : set)}, 
   |- DIAM0(A) = InjUU(A) o
        Pa(El(injN(A, num4)) o To1(Pow(N * (A + 1))), Id(Pow(N * (A + 1)))):
   thm
val Disj0_def =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- Disj0(f1, f2) = App(DISJ0(A), Pair(f1, f2)): thm
val Diam0_def =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- Diam0(f0) = App(DIAM0(A), f0): thm
val f =
   (nas = F0 ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_cl =
   (nas = F0(A) ==> IN(nas, isfms)) &
   (!(p : mem(A)). nas = Var0(p#) ==> IN(nas, isfms)) &
   (!(f0 : mem(Pow(N * (A + 1)))).
       IN(f0#, isfms) & nas = Neg0(f0#) ==> IN(nas, isfms)) &
   (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
       IN(f1#, isfms) & IN(f2#, isfms) & nas = Disj0(f1#, f2#) ==>
       IN(nas, isfms)) &
   !(f0 : mem(Pow(N * (A + 1)))).
     IN(f0#, isfms) & nas = Diam0(f0#) ==> IN(nas, isfms): form
val isfm_incond =
   !(nas : mem(Pow(N * (A + 1)))).
     IN(nas#, isfms1) <=>
     nas# = F0(A) |
     (?(p : mem(A)). nas# = Var0(p#)) |
     (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Neg0(f0#)) |
     (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
         IN(f1#, isfms0) & IN(f2#, isfms0) & nas# = Disj0(f1#, f2#)) |
     ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms0) & nas# = Diam0(f0#): form
val x1 = "isfms0": string
val isfmf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(Pow(N * (A + 1))), Pow(Pow(N * (A + 1))))).
        !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
          IN(nas#, App(f#, a#)) <=>
          nas# = F0(A) |
          (?(p : mem(A)). nas# = Var0(p#)) |
          (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
          (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
              IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
          ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1)))))  (nas : mem(Pow(N * (A + 1)))).
        IN(nas#, App(isfmf(A), a#)) <=>
        nas# = F0(A) |
        (?(p : mem(A)). nas# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, a#) & IN(f2#, a#) & nas# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, a#) & nas# = Diam0(f0#): thm
val isfmf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(Pow(N * (A + 1)))))  (s2 : mem(Pow(Pow(N * (A + 1))))).
        SS(s1#, s2#) ==> SS(App(isfmf(A), s1#), App(isfmf(A), s2#)): thm
val isfm's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        IN(a#, isfm's(A)) <=> SS(App(isfmf(A), a#), a#): thm
val isfms_def = {(A : set)},  |- isfms(A) = BIGINTER(isfm's(A)): thm
val isfms_cond =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (!(ss : mem(Pow(Pow(N * (A + 1))))).
            SS(App(isfmf(A), ss#), ss#) ==> IN(a#, ss#)) <=> IN(a#, isfms(A)):
   thm
val isfms_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), a#), a#) ==> SS(isfms(A), a#): thm
val isfm_rules0 = {(A : set)},  |- SS(App(isfmf(A), isfms(A)), isfms(A)): thm
val isfm_cases0 = {(A : set)},  |- App(isfmf(A), isfms(A)) = isfms(A): thm
val isfm_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        SS(App(isfmf(A), ss#), ss#) ==> SS(isfms(A), ss#): thm
val isfm_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (!(a : mem(Pow(N * (A + 1)))).
            a# = F0(A) |
            (?(p : mem(A)). a# = Var0(p#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Neg0(f0#)) |
            (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj0(f1#, f2#)) |
            (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) & a# = Diam0(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases1 =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules1 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        a# = F0(A) |
        (?(p : mem(A)). a# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & a# = Diam0(f0#)) ==>
        IN(a#, isfms(A)): thm
val isfm_rules2 =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (a# = F0(A) ==> IN(a#, isfms(A))) &
        (!(p : mem(A)). a# = Var0(p#) ==> IN(a#, isfms(A))) &
        (!(f0 : mem(Pow(N * (A + 1)))).
            IN(f0#, isfms(A)) & a# = Neg0(f0#) ==> IN(a#, isfms(A))) &
        (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & a# = Disj0(f1#, f2#) ==>
            IN(a#, isfms(A))) &
        !(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) & a# = Diam0(f0#) ==> IN(a#, isfms(A)): thm
val isfm_rules3 =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(Pow(N * (A + 1))))).
        (((IN(F0(A), ss#) & !(p : mem(A)). IN(Var0(p#), ss#)) &
            !(f0 : mem(Pow(N * (A + 1)))).
              IN(f0#, ss#) ==> IN(Neg0(f0#), ss#)) &
          !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj0(f1#, f2#), ss#)) &
        (!(f0 : mem(Pow(N * (A + 1)))). IN(f0#, ss#) ==> IN(Diam0(f0#), ss#)) ==>
        !(a : mem(Pow(N * (A + 1)))). IN(a#, isfms(A)) ==> IN(a#, ss#): thm
val isfm_cases =
   {(A : set)}, 
   |- !(x : mem(Pow(N * (A + 1)))).
        IN(x#, isfms(A)) <=>
        x# = F0(A) |
        (?(p : mem(A)). x# = Var0(p#)) |
        (?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Neg0(f0#)) |
        (?(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
            IN(f1#, isfms(A)) & IN(f2#, isfms(A)) & x# = Disj0(f1#, f2#)) |
        ?(f0 : mem(Pow(N * (A + 1)))). IN(f0#, isfms(A)) & x# = Diam0(f0#):
   thm
val isfm_rules =
   {(A : set)}, 
   |- IN(F0(A), isfms(A)) &
      (!(p : mem(A)). IN(Var0(p#), isfms(A))) &
      (!(f0 : mem(Pow(N * (A + 1)))).
          IN(f0#, isfms(A)) ==> IN(Neg0(f0#), isfms(A))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          IN(f1#, isfms(A)) ==>
          IN(f2#, isfms(A)) ==> IN(Disj0(f1#, f2#), isfms(A))) &
      !(f0 : mem(Pow(N * (A + 1)))).
        IN(f0#, isfms(A)) ==> IN(Diam0(f0#), isfms(A)): thm
val isfm_def =
   {}, 
   |- !(A : set)  (f : mem(Pow(N * (A# + 1)))).
        isfm(f#) <=> IN(f#, isfms(A#)): thm
val isfm_induct =
   {}, 
   |- !(A : set).
        P(F0(A#)) &
        (!(p : mem(A#)). P(Var0(p#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Neg0(f0#))) &
        (!(f1 : mem(Pow(N * (A# + 1))))  (f2 : mem(Pow(N * (A# + 1)))).
            P(f1#) & P(f2#) ==> P(Disj0(f1#, f2#))) &
        (!(f0 : mem(Pow(N * (A# + 1)))). P(f0#) ==> P(Diam0(f0#))) ==>
        !(f0 : mem(Pow(N * (A# + 1)))). isfm(f0#) ==> P(f0#): thm
val isfm_F0 = {},  |- !(A : set). isfm(F0(A#)): thm
val isfm_Diam0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val isfm_Neg0 =
   {(A : set)}, 
   |- !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#)): thm
val isfm_Var0 = {},  |- !(A : set)  (p : mem(A#)). isfm(Var0(p#)): thm
val isfm_clauses =
   {(A : set)}, 
   |- isfm(F0(A)) &
      (!(p : mem(A)). isfm(Var0(p#))) &
      (!(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Neg0(f0#))) &
      (!(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
          isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#))) &
      !(f0 : mem(Pow(N * (A + 1)))). isfm(f0#) ==> isfm(Diam0(f0#)): thm
val form_def =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). a# = App(repf(A), b#): thm
val isfm_Disj0 =
   {(A : set)}, 
   |- !(f1 : mem(Pow(N * (A + 1))))  (f2 : mem(Pow(N * (A + 1)))).
        isfm(f1#) ==> isfm(f2#) ==> isfm(Disj0(f1#, f2#)): thm
val repf_Inj = {(A : set)},  |- Inj(repf(A)): thm
val Bot_def = {(A : set)},  |- Repf(Bot(A)) = F0(A): thm
val Repf_def =
   {},  |- !(A : set)  (f : mem(form(A#))). Repf(f#) = App(repf(A#), f#): thm
val VAR_def =
   {(A : set)},  |- !(a : mem(A)). App(repf(A) o VAR(A), a#) = Var0(a#): thm
val flip_fconv = fn: form -> thm
val form_def' =
   {(A : set)}, 
   |- Inj(repf(A)) &
      !(a : mem(Pow(N * (A + 1)))).
        isfm(a#) <=> ?(b : mem(form(A))). App(repf(A), b#) = a#: thm
val repf_isfm = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Repf(f0#)): thm
val VAR_VAR0 = {},  |- !(A : set). repf(A#) o VAR(A#) = VAR0(A#): thm
val VAR_Inj = {},  |- !(A : set). Inj(VAR(A#)): thm
val NEG_NEG0 = {},  |- !(A : set). repf(A#) o NEG(A#) = NEG0(A#) o repf(A#):
   thm
val NEG_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(NEG(A), a#)) = Neg0(Repf(a#)): thm
val Neg0_Repf = {(A : set)},  |- !(f0 : mem(form(A))). isfm(Neg0(Repf(f0#))):
   thm
val NEG_Inj = {},  |- !(A : set). Inj(NEG(A#)): thm
val DIAM_def =
   {(A : set)}, 
   |- !(a : mem(form(A))). Repf(App(DIAM(A), a#)) = Diam0(Repf(a#)): thm
val Diam0_Repf =
   {(A : set)},  |- !(f0 : mem(form(A))). isfm(Diam0(Repf(f0#))): thm
val form_def_uex =
   {(A : set)}, 
   |- !(a : mem(Pow(N * (A + 1)))).
        (?!(b : mem(form(A))). a# = Repf(b#)) <=> isfm(a#): thm
val DISJ_DISJ0 =
   {}, 
   |- !(A : set). repf(A#) o DISJ(A#) = DISJ0(A#) o Prla(repf(A#), repf(A#)):
   thm
val DISJ_def =
   {(A : set)}, 
   |- !(a' : mem(form(A)))  (b : mem(form(A))).
        Repf(App(DISJ(A), Pair(a'#, b#))) = Disj0(Repf(a'#), Repf(b#)): thm
val DISJ_Inj = {},  |- !(A : set). Inj(DISJ(A#)): thm
val DIAM_DIAM0 =
   {},  |- !(A : set). repf(A#) o DIAM(A#) = DIAM0(A#) o repf(A#): thm
val DIAM_Inj = {},  |- !(A : set). Inj(DIAM(A#)): thm
val Diam_def =
   {(A : set), (f : mem(form(A)))},  |- Diam(f) = App(DIAM(A), f): thm
val Disj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Disj(f1, f2) = App(DISJ(A), Pair(f1, f2)): thm
val Neg_def = {(A : set), (f : mem(form(A)))},  |- Neg(f) = App(NEG(A), f):
   thm
val Var_def = {(A : set), (a : mem(A))},  |- Var(a) = App(VAR(A), a): thm
val Var_eq_eq =
   {(A : set)}, 
   |- !(p1 : mem(A))  (p2 : mem(A)). Var(p1#) = Var(p2#) <=> p1# = p2#: thm
val Neg_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Neg(f1#) = Neg(f2#) <=> f1# = f2#: thm
val Diam_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Diam(f1#) = Diam(f2#) <=> f1# = f2#: thm
val Disj_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A)))  (g1 : mem(form(A)))
      (g2 : mem(form(A))).
        Disj(f1#, f2#) = Disj(g1#, g2#) <=> f1# = g1# & f2# = g2#: thm
val Repf_eq_eq =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        Repf(f1#) = Repf(f2#) <=> f1# = f2#: thm
val form_induct =
   {}, 
   |- !(A : set).
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Neg(f0#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f0 : mem(form(A#))). P(f0#) ==> P(Diam(f0#))) ==>
        !(f0 : mem(form(A#))). P(f0#): thm
val fmind's_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        IN(a#, fmind's(djf, dmf, nf, vf, x0)) <=>
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#): thm
val fmind_cases0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)) =
        fminds(djf, dmf, nf, vf, x0): thm
val fmind_cases1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_incond =
   !(p : mem(form(A) * X)).
     IN(p#, fmind1) <=>
     p# = Pair(Bot(A), x0) |
     (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
     (?(p0 : mem(form(A) * X)).
         IN(p0#, fmind0) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
     ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
       IN(p1#, fmind0) &
       IN(p2#, fmind0) &
       p# =
         Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))):
   form
val fmind_ind =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), ss#): thm
val fmind_ind1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (!(a : mem(form(A) * X)).
            a# = Pair(Bot(A), x0) |
            (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
            (?(p0 : mem(form(A) * X)).
                IN(p0#, ss#) & a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
            (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
                IN(p1#, ss#) &
                IN(p2#, ss#) &
                a# =
                  Pair(Disj(Fst(p1#), Fst(p2#)),
                   App(djf, Pair(Snd(p1#), Snd(p2#))))) ==> IN(a#, ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_ind2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(ss : mem(Pow(form(A) * X))).
        (((IN(Pair(Bot(A), x0), ss#) &
              !(a' : mem(A)). IN(Pair(Var(a'#), App(vf, a'#)), ss#)) &
            !(p0 : mem(form(A) * X)).
              IN(p0#, ss#) ==>
              IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))), ss#)) &
          !(p0 : mem(form(A) * X)).
            IN(p0#, ss#) ==>
            IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))), ss#)) &
        (!(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, ss#) & IN(p2#, ss#) ==>
            IN(Pair(Disj(Fst(p1#), Fst(p2#)),
              App(djf, Pair(Snd(p1#), Snd(p2#)))), ss#)) ==>
        !(a : mem(form(A) * X)).
          IN(a#, fminds(djf, dmf, nf, vf, x0)) ==> IN(a#, ss#): thm
val fmind_rules0 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- SS(App(fmindf(djf, dmf, nf, vf, x0), fminds(djf, dmf, nf, vf, x0)),
       fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules1 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        a# = Pair(Bot(A), x0) |
        (?(a : mem(A)). a# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        (?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
            IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
            a# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#))))) ==>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules2 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (a# = Pair(Bot(A), x0) ==> IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(a' : mem(A)).
            a# = Pair(Var(a'#), App(vf, a'#)) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        (!(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            a# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))) ==>
            IN(a#, fminds(djf, dmf, nf, vf, x0))) &
        !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          a# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))) ==>
          IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fmind_rules3 =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val fmindf_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
        IN(p#, App(fmindf(djf, dmf, nf, vf, x0), a#)) <=>
        p# = Pair(Bot(A), x0) |
        (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, a#) &
          IN(p2#, a#) &
          p# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_ex =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- ?!(f : fun(Pow(form(A) * X), Pow(form(A) * X))).
        !(a : mem(Pow(form(A) * X)))  (p : mem(form(A) * X)).
          IN(p#, App(f#, a#)) <=>
          p# = Pair(Bot(A), x0) |
          (?(a : mem(A)). p# = Pair(Var(a#), App(vf, a#))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
          (?(p0 : mem(form(A) * X)).
              IN(p0#, a#) & p# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
          ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
            IN(p1#, a#) &
            IN(p2#, a#) &
            p# =
              Pair(Disj(Fst(p1#), Fst(p2#)),
               App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmindf_monotone =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(s1 : mem(Pow(form(A) * X)))  (s2 : mem(Pow(form(A) * X))).
        SS(s1#, s2#) ==>
        SS(App(fmindf(djf, dmf, nf, vf, x0), s1#),
         App(fmindf(djf, dmf, nf, vf, x0), s2#)): thm
val fminds_SS =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(Pow(form(A) * X))).
        SS(App(fmindf(djf, dmf, nf, vf, x0), a#), a#) ==>
        SS(fminds(djf, dmf, nf, vf, x0), a#): thm
val fminds_cond =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(a : mem(form(A) * X)).
        (!(ss : mem(Pow(form(A) * X))).
            SS(App(fmindf(djf, dmf, nf, vf, x0), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, fminds(djf, dmf, nf, vf, x0)): thm
val fminds_def =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- fminds(djf, dmf, nf, vf, x0) = BIGINTER(fmind's(djf, dmf, nf, vf, x0)):
   thm
val x1 = "fmind0": string
val fmind_cases =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- !(x : mem(form(A) * X)).
        IN(x#, fminds(djf, dmf, nf, vf, x0)) <=>
        x# = Pair(Bot(A), x0) |
        (?(a : mem(A)). x# = Pair(Var(a#), App(vf, a#))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Neg(Fst(p0#)), App(nf, Snd(p0#)))) |
        (?(p0 : mem(form(A) * X)).
            IN(p0#, fminds(djf, dmf, nf, vf, x0)) &
            x# = Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#)))) |
        ?(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
          IN(p1#, fminds(djf, dmf, nf, vf, x0)) &
          IN(p2#, fminds(djf, dmf, nf, vf, x0)) &
          x# =
            Pair(Disj(Fst(p1#), Fst(p2#)),
             App(djf, Pair(Snd(p1#), Snd(p2#)))): thm
val fmind_rules =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (nf : fun(X, X)), (vf : fun(A, X)), (x0 : mem(X))}, 
   |- IN(Pair(Bot(A), x0), fminds(djf, dmf, nf, vf, x0)) &
      (!(a' : mem(A)).
          IN(Pair(Var(a'#), App(vf, a'#)), fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Neg(Fst(p0#)), App(nf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      (!(p0 : mem(form(A) * X)).
          IN(p0#, fminds(djf, dmf, nf, vf, x0)) ==>
          IN(Pair(Diam(Fst(p0#)), App(dmf, Snd(p0#))),
           fminds(djf, dmf, nf, vf, x0))) &
      !(p1 : mem(form(A) * X))  (p2 : mem(form(A) * X)).
        IN(p1#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(p2#, fminds(djf, dmf, nf, vf, x0)) ==>
        IN(Pair(Disj(Fst(p1#), Fst(p2#)), App(djf, Pair(Snd(p1#), Snd(p2#)))),
         fminds(djf, dmf, nf, vf, x0)): thm
val IN_F0 =
   {(A : set)}, 
   |- !(n : mem(N))  (a : mem(A + 1)). IN(Pair(n#, a#), F0(A)) <=> n# = O:
   thm
val IN_Var0 =
   {(A : set), (a0 : mem(A))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Var0(a0)) <=>
        Even(n#) & Div2(n#) = num1 | Odd(n#) & a# = SOME(a0): thm
val IN_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Neg0(f0)) <=>
        Even(n#) & Div2(n#) = num2 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Diam0(f0)) <=>
        Even(n#) & Div2(n#) = num4 | Odd(n#) & IN(Pair(Div2(n#), a#), f0):
   thm
val IN_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- !(n : mem(N))  (a : mem(A + 1)).
        IN(Pair(n#, a#), Disj0(f1, f2)) <=>
        Even(n#) & Div2(n#) = num3 |
        Odd(n#) &
        (Even(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f1) |
          Odd(Div2(n#)) & IN(Pair(Div2(Div2(n#)), a#), f2)): thm
val F0_NOT_Var0 = {(A : set), (p : mem(A))},  |- ~F0(A) = Var0(p): thm
val Bot_NOT_Var = {(A : set), (p : mem(A))},  |- ~Bot(A) = Var(p): thm
val F0_NOT_Disj0 =
   {(A : set), (f1 : mem(Pow(N * (A + 1)))), (f2 : mem(Pow(N * (A + 1))))}, 
   |- ~F0(A) = Disj0(f1, f2): thm
val Bot_NOT_Disj =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Bot(A) = Disj(f1, f2): thm
val F0_NOT_Neg0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Neg0(f0): thm
val Bot_NOT_Neg = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Neg(f): thm
val F0_NOT_Diam0 =
   {(A : set), (f0 : mem(Pow(N * (A + 1))))},  |- ~F0(A) = Diam0(f0): thm
val Bot_NOT_Diam = {(A : set), (f : mem(form(A)))},  |- ~Bot(A) = Diam(f):
   thm
val Bot_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Bot(A#) = Var(p#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Neg(f#)) &
        (!(f : mem(form(A#))). ~Bot(A#) = Diam(f#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Bot(A#) = Disj(f1#, f2#): thm
val InjN_Inj = {},  |- !(A : set). Inj(InjN(A#)): thm
val Var0_NOT_Diam0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Diam0(f0): thm
val VAR_def' =
   {(A : set)},  |- !(a : mem(A)). Repf(App(VAR(A), a#)) = Var0(a#): thm
val Var_NOT_Diam =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Diam(f): thm
val Var0_NOT_Disj0 =
   {(A : set), (a : mem(A)), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Var0(a) = Disj0(f1, f2): thm
val Var_NOT_Disj =
   {(A : set), (a : mem(A)), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- ~Var(a) = Disj(f1, f2): thm
val Var0_NOT_Neg0 =
   {(A : set), (a : mem(A)), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Var0(a) = Neg0(f0): thm
val Var_NOT_Neg =
   {(A : set), (a : mem(A)), (f : mem(form(A)))},  |- ~Var(a) = Neg(f): thm
val Var_NOT =
   {}, 
   |- !(A : set).
        (!(p : mem(A#)). ~Var(p#) = Bot(A#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Neg(f#)) &
        (!(p : mem(A#))  (f : mem(form(A#))). ~Var(p#) = Diam(f#)) &
        !(p : mem(A#))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Var(p#) = Disj(f1#, f2#): thm
val Neg0_NOT_Diam0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f0 : mem(Pow(N * (A + 1))))}, 
   |- ~Neg0(f) = Diam0(f0): thm
val Neg_NOT_Diam =
   {(A : set), (f : mem(form(A))), (f0 : mem(form(A)))}, 
   |- ~Neg(f) = Diam(f0): thm
val Neg0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Neg0(f) = Disj0(f1, f2): thm
val Neg_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Neg(f) = Disj(f1, f2): thm
val Neg_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Neg(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Neg(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Neg(f#) = Diam(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Neg(f#) = Disj(f1#, f2#): thm
val Diam0_NOT_Disj0 =
   {(A : set), (f : mem(Pow(N * (A + 1)))), (f1 : mem(Pow(N * (A + 1)))),
    (f2 : mem(Pow(N * (A + 1))))},  |- ~Diam0(f) = Disj0(f1, f2): thm
val Diam_NOT_Disj =
   {(A : set), (f : mem(form(A))), (f1 : mem(form(A))), (f2 : mem(form(A)))},
    |- ~Diam(f) = Disj(f1, f2): thm
val Diam_NOT =
   {}, 
   |- !(A : set).
        (!(f : mem(form(A#))). ~Diam(f#) = Bot(A#)) &
        (!(f : mem(form(A#)))  (p : mem(A#)). ~Diam(f#) = Var(p#)) &
        (!(f : mem(form(A#)))  (f0 : mem(form(A#))). ~Diam(f#) = Neg(f0#)) &
        !(f : mem(form(A#)))  (f1 : mem(form(A#)))  (f2 : mem(form(A#))).
          ~Diam(f#) = Disj(f1#, f2#): thm
val Disj_NOT =
   {}, 
   |- !(A : set).
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            ~Disj(f1#, f2#) = Bot(A#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (p : mem(A#)).
            ~Disj(f1#, f2#) = Var(p#)) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f0 : mem(form(A#))).
            ~Disj(f1#, f2#) = Diam(f0#)) &
        !(f1 : mem(form(A#)))  (f2 : mem(form(A#)))  (f : mem(form(A#))).
          ~Disj(f1#, f2#) = Neg(f#): thm
val fmind_Neg =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Neg(f), App(nf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_Disj =
   {}, 
   |- !(A : set)  (f1 : mem(form(A#)))  (X : set)  (djf : fun(X# * X#, X#))
      (dmf : fun(X#, X#))  (nf : fun(X#, X#))  (vf : fun(A#, X#))
      (x0 : mem(X#))  (x1 : mem(X#)).
        IN(Pair(f1#, x1#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
        !(f2 : mem(form(A#)))  (x2 : mem(X#)).
          IN(Pair(f2#, x2#), fminds(djf#, dmf#, nf#, vf#, x0#)) ==>
          IN(Pair(Disj(f1#, f2#), App(djf#, Pair(x1#, x2#))),
           fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmind_Diam =
   {(A : set), (X : set), (djf : fun(X * X, X)), (dmf : fun(X, X)),
    (f : mem(form(A))), (nf : fun(X, X)), (vf : fun(A, X)), (x : mem(X)),
    (x0 : mem(X))}, 
   |- IN(Pair(f, x), fminds(djf, dmf, nf, vf, x0)) ==>
      IN(Pair(Diam(f), App(dmf, x)), fminds(djf, dmf, nf, vf, x0)): thm
val fmind_uex =
   {(X : set)}, 
   |- !(A : set)  (x0 : mem(X))  (vf : fun(A#, X))  (nf : fun(X, X))
      (djf : fun(X * X, X))  (dmf : fun(X, X))  (f : mem(form(A#))).
        ?!(x : mem(X)). IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)):
   thm
val fmrec_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (a : mem(form(A#))).
        IN(Pair(a#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), a#)),
       fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val App_fmrec_fminds =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#))
      (f : mem(form(A#)))  (x : mem(X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#) = x# <=>
        IN(Pair(f#, x#), fminds(djf#, dmf#, nf#, vf#, x0#)): thm
val fmrec_clauses =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (A : set)  (vf : fun(A#, X#))
      (nf : fun(X#, X#))  (djf : fun(X# * X#, X#))  (dmf : fun(X#, X#)).
        App(fmrec(x0#, vf#, nf#, djf#, dmf#), Bot(A#)) = x0# &
        (!(p : mem(A#)).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Var(p#)) = App(vf#, p#)) &
        (!(f : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Neg(f#)) =
              App(nf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            App(fmrec(x0#, vf#, nf#, djf#, dmf#), Disj(f1#, f2#)) =
              App(djf#,
               Pair(App(fmrec(x0#, vf#, nf#, djf#, dmf#), f1#),
                App(fmrec(x0#, vf#, nf#, djf#, dmf#), f2#)))) &
        !(f : mem(form(A#))).
          App(fmrec(x0#, vf#, nf#, djf#, dmf#), Diam(f#)) =
            App(dmf#, App(fmrec(x0#, vf#, nf#, djf#, dmf#), f#)): thm
val it = (): unit
******

Loading SEAR file SEARUF.sml

******
val Inter_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val Inter_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#)))  (Y : mem(Pow(J#))).
          IN(X#, L#) & IN(Y#, L#) ==> IN(Inter(X#, Y#), L#): thm
val filter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- filter(L) <=>
      ~EMPTY(J) &
      IN(Whole(J), L) &
      (!(X : mem(Pow(J)))  (Y : mem(Pow(J))).
          IN(X#, L) & IN(Y#, L) ==> IN(Inter(X#, Y#), L)) &
      !(X : mem(Pow(J))).
        IN(X#, L) ==> !(Y : mem(Pow(J))). SS(X#, Y#) ==> IN(Y#, L): thm
val ufilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). ~IN(Compl(X#), L) <=> IN(X#, L): thm
val ufilter_filter =
   {},  |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> filter(L#):
   thm
val SS_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        filter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val SS_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))).
          IN(X#, L#) ==> !(Y : mem(Pow(J#))). SS(X#, Y#) ==> IN(Y#, L#): thm
val Whole_IN_filter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). filter(L#) ==> IN(Whole(J#), L#):
   thm
val Whole_IN_ufilter =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> IN(Whole(J#), L#):
   thm
val Empty_NOTIN_UF =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))). ufilter(L#) ==> ~IN(Empty(J#), L#):
   thm
val IN_UF_NONEMPTY =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==> !(X : mem(Pow(J#))). IN(X#, L#) ==> ~X# = Empty(J#):
   thm
val Repu_def = {(J : set), (u : mem(UFs(J)))},  |- Repu(u) = App(iUF(J), u):
   thm
val Repu_ufilter = {},  |- !(A : set)  (u : mem(UFs(A#))). ufilter(Repu(u#)):
   thm
val UFs_def =
   {(J : set)}, 
   |- Inj(iUF(J)) &
      !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = App(iUF(J), b#): thm
val from_UFs =
   {(J : set)}, 
   |- !(a : mem(Pow(Pow(J)))).
        ufilter(a#) <=> ?(b : mem(UFs(J))). a# = Repu(b#): thm
val Empty_NOTIN_UFs =
   {},  |- !(J : set)  (u : mem(UFs(J#))). ~IN(Empty(J#), Repu(u#)): thm
val ufilter_alt =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- ufilter(L) <=>
      filter(L) & !(X : mem(Pow(J))). IN(Compl(X#), L) <=> ~IN(X#, L): thm
val Compl_Repu =
   {(J : set), (X : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Compl(X), Repu(u)) <=> ~IN(X, Repu(u)): thm
val Union_Repu =
   {(J : set), (s1 : mem(Pow(J))), (s2 : mem(Pow(J))), (u : mem(UFs(J)))}, 
   |- IN(Union(s1, s2), Repu(u)) <=> IN(s1, Repu(u)) | IN(s2, Repu(u)): thm
val CUI_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- CUI(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        IN(BIGINTER(ss0#), ss): thm
val CUI_iff_binary =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#)))).
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) <=>
        !(s : mem(Pow(Pow(W#)))).
          SS(s#, A#) & Fin(s#) & ~s# = Empty(Pow(W#)) ==>
          IN(BIGINTER(s#), A#): thm
val FIP_def =
   {(A : set), (ss : mem(Pow(Pow(A))))}, 
   |- FIP(ss) <=>
      !(ss0 : mem(Pow(Pow(A)))).
        SS(ss0#, ss) & Fin(ss0#) & ~ss0# = Empty(Pow(A)) ==>
        ~BIGINTER(ss0#) = Empty(A): thm
val FIP_CUI_lemma =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        ~IN(Empty(W#), A#) & ~IN(Empty(W#), B#): thm
val FIP_closed_under_Inter =
   {}, 
   |- !(W : set)  (A : mem(Pow(Pow(W#))))  (B : mem(Pow(Pow(W#)))).
        ~A# = Empty(Pow(W#)) &
        ~B# = Empty(Pow(W#)) &
        (!(a1 : mem(Pow(W#))).
            IN(a1#, A#) ==>
            !(a2 : mem(Pow(W#))). IN(a2#, A#) ==> IN(Inter(a1#, a2#), A#)) &
        (!(b1 : mem(Pow(W#))).
            IN(b1#, B#) ==>
            !(b2 : mem(Pow(W#))). IN(b2#, B#) ==> IN(Inter(b1#, b2#), B#)) &
        (!(a : mem(Pow(W#))).
            IN(a#, A#) ==>
            !(b : mem(Pow(W#))). IN(b#, B#) ==> ~Inter(a#, b#) = Empty(W#)) ==>
        FIP(Union(A#, B#)): thm
val IN_gfilter =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(x : mem(Pow(A))).
        IN(x#, gfilter(s)) <=>
        !(ss : mem(Pow(Pow(A)))). SS(s, ss#) & filter(ss#) ==> IN(x#, ss#):
   thm
val gfilter_def =
   {(A : set), (s : mem(Pow(Pow(A))))},  |- gfilter(s) = BIGINTER(gfss(s)):
   thm
val gfilter_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter(s#)): thm
val gfilter_ind =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#))))  (ss : mem(Pow(Pow(A#)))).
        SS(s#, ss#) & filter(ss#) ==>
        !(x : mem(Pow(A#))). IN(x#, gfilter(s#)) ==> IN(x#, ss#): thm
val gfss_def =
   {(A : set), (s0 : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(Pow(A)))). IN(a#, gfss(s0)) <=> SS(s0, a#) & filter(a#):
   thm
val SS_gfilter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter(s#)): thm
val pfilter_def =
   {(J : set), (L : mem(Pow(Pow(J))))}, 
   |- pfilter(L) <=> filter(L) & ~L = Whole(Pow(J)): thm
val gfilter1_def =
   {(A : set), (s : mem(Pow(Pow(A))))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, gfilter1(s)) <=>
        a# = Whole(A) |
        ?(ss : mem(Pow(Pow(A)))).
          SS(ss#, s) &
          Fin(ss#) & ~ss# = Empty(Pow(A)) & SS(BIGINTER(ss#), a#): thm
val gfilter1_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==> !(s : mem(Pow(Pow(A#)))). filter(gfilter1(s#)): thm
val SS_gfilter1 =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). SS(s#, gfilter1(s#)): thm
val CUI_filter =
   {},  |- !(A : set)  (L : mem(Pow(Pow(A#)))). filter(L#) ==> CUI(L#): thm
val gfilter_gfilter1 =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) ==> gfilter(s#) = gfilter1(s#): thm
val Empty_NOTIN_pfilter =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) <=> filter(s#) & ~IN(Empty(A#), s#): thm
val FIP_Empty_NOTIN_gfilter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))). FIP(s#) ==> ~IN(Empty(A#), gfilter(s#)):
   thm
val FIP_PSUBSET_proper_filter =
   {}, 
   |- !(A : set).
        ~EMPTY(A#) ==>
        !(s : mem(Pow(Pow(A#)))).
          FIP(s#) ==> ?(v : mem(Pow(Pow(A#)))). pfilter(v#) & SS(s#, v#): thm
val filter_Whole = {},  |- !(J : set). ~EMPTY(J#) ==> filter(Whole(Pow(J#))):
   thm
val filter_Empty_Whole =
   {}, 
   |- !(J : set).
        ~EMPTY(J#) ==>
        !(L : mem(Pow(Pow(J#)))).
          filter(L#) & IN(Empty(J#), L#) <=> L# = Whole(Pow(J#)): thm
val ufilter_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        ufilter(u#) ==>
        !(s : mem(Pow(Pow(J#)))).
          filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#)): thm
val CUI_Empty_NOTIN_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        CUI(s#) & ~IN(Empty(W#), s#) ==> FIP(s#): thm
val pfilter_FIP =
   {},  |- !(W : set)  (s : mem(Pow(Pow(W#)))). pfilter(s#) ==> FIP(s#): thm
val pfilter_filter =
   {},  |- !(A : set)  (s : mem(Pow(Pow(A#)))). pfilter(s#) ==> filter(s#):
   thm
val pfilter_INSERT_FIP =
   {}, 
   |- !(W : set)  (s : mem(Pow(Pow(W#)))).
        pfilter(s#) ==>
        !(b : mem(Pow(W#))).
          ~IN(b#, s#) & ~IN(Compl(b#), s#) ==> FIP(Ins(b#, s#)): thm
val maximal_ufilter =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        (!(s : mem(Pow(Pow(J#)))).
            filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) ==> ufilter(u#):
   thm
val chain_def =
   {(A : set), (R : rel(A, A)), (t : mem(Pow(A)))}, 
   |- chain(t, R) <=>
      !(a1 : mem(A))  (a2 : mem(A)).
        IN(a1#, t) & IN(a2#, t) ==> Holds(R, a1#, a2#) | Holds(R, a2#, a1#):
   thm
val ismax_def =
   {(A : set), (R : rel(A, A)), (m : mem(A))}, 
   |- ismax(R, m) <=> !(x : mem(A)). Holds(R, m, x#) ==> x# = m: thm
val ptorder_def =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> Trans(R) & Refl(R) & Asym(R): thm
val ubound_def =
   {(A : set), (R : rel(A, A)), (s : mem(Pow(A))), (x : mem(A))}, 
   |- ubound(s, R, x) <=> !(y : mem(A)). IN(y#, s) ==> Holds(R, y#, x): thm
******

Loading SEAR file zorns.sml

******
val AC =
   {}, 
   |- !(A : set)  (B : set)  (R : rel(A#, B#)).
        (!(a : mem(A#)). ?(b : mem(B#)). Holds(R#, a#, b#)) ==>
        ?(f : fun(A#, B#)). !(a : mem(A#)). Holds(R#, a#, App(f#, a#)): thm
val antisym_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        antisym(r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, x#), r#) ==> x# = y#: thm
val chain0_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        chain0(s#, r#) <=>
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==>
          IN(Pair(x#, y#), r#) | IN(Pair(y#, x#), r#): thm
val domain_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, domain(r#)) <=> ?(y : mem(A#)). IN(Pair(a#, y#), r#): thm
val ischoice_def =
   {(A : set), (f : fun(Pow(A), A)), (s : mem(Pow(Pow(A))))}, 
   |- ischoice(f, s) <=>
      ~IN(Empty(A), s) &
      !(s0 : mem(Pow(A))). IN(s0#, s) ==> IN(App(f, s0#), s0#): thm
val ischoice_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        ~EMPTY(A#) & ~IN(Empty(A#), s#) ==>
        ?(f : fun(Pow(A#), A#)). ischoice(f#, s#): thm
val maximal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, maximal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(a#, x'#), r#) ==> a# = x'#:
   thm
val minimal_elements_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (xs : mem(Pow(A#)))
      (a : mem(A#)).
        IN(a#, minimal_elements(xs#, r#)) <=>
        IN(a#, xs#) &
        !(x' : mem(A#)). IN(x'#, xs#) & IN(Pair(x'#, a#), r#) ==> a# = x'#:
   thm
val partial_order_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        partial_order(r#, s#) <=>
        SS(domain(r#), s#) &
        SS(range(r#), s#) & transitive(r#) & reflexive(r#, s#) & antisym(r#):
   thm
val range_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(A#)).
        IN(a#, range(r#)) <=> ?(x : mem(A#)). IN(Pair(x#, a#), r#): thm
val reflexive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#))).
        reflexive(r#, s#) <=>
        !(x : mem(A#)). IN(x#, s#) ==> IN(Pair(x#, x#), r#): thm
val transitive_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#))).
        transitive(r#) <=>
        !(x : mem(A#))  (y : mem(A#))  (z : mem(A#)).
          IN(Pair(x#, y#), r#) & IN(Pair(y#, z#), r#) ==>
          IN(Pair(x#, z#), r#): thm
val upper_bounds_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (s : mem(Pow(A#)))  (a : mem(A#)).
        IN(a#, upper_bounds(s#, r#)) <=>
        IN(a#, range(r#)) &
        !(y : mem(A#)). IN(y#, s#) ==> IN(Pair(y#, a#), r#): thm
val fchains_def =
   {(A : set), (f : fun(Pow(A), A)), (r : mem(Pow(A * A)))}, 
   |- !(a : mem(Pow(A))).
        IN(a#, fchains(r, f)) <=>
        chain0(a#, r) &
        ~a# = Empty(A) &
        !(C : mem(Pow(A))).
          chain0(C#, r) &
          SS(C#, a#) & ~Inter(Diff(upper_bounds(C#, r), C#), a#) = Empty(A) ==>
          IN(App(f, Diff(upper_bounds(C#, r), C#)),
           minimal_elements(Inter(Diff(upper_bounds(C#, r), C#), a#), r)):
   thm
val hatclass_def =
   {}, 
   |- !(A : set)  (r : mem(Pow(A# * A#)))  (a : mem(Pow(A#))).
        IN(a#, hatclass(r#)) <=>
        ~a# = Empty(A#) &
        ?(C : mem(Pow(A#))). a# = Diff(upper_bounds(C#, r#), C#): thm
val lemma1 =
   {(A : set)}, 
   |- !(x : mem(A))  (s : mem(Pow(A)))  (r : mem(Pow(A * A))).
        chain0(s#, r#) & IN(x#, s#) ==>
        IN(x#, domain(r#)) & IN(x#, range(r#)): thm
val lemma2 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A)))  (x : mem(A))  (x' : mem(A)).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        IN(k1#, fchains(r#, f#)) &
        IN(k2#, fchains(r#, f#)) & IN(x#, k1#) & IN(x'#, k2#) & ~IN(x'#, k1#) ==>
        IN(Pair(x#, x'#), r#): thm
val lemma3 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), A))  (r : mem(Pow(A * A)))  (k1 : mem(Pow(A)))
      (k2 : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) & IN(k1#, fchains(r#, f#)) & IN(k2#, fchains(r#, f#)) ==>
        SS(k1#, k2#) | SS(k2#, k1#): thm
val lemma4 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A)).
        ischoice(f#, hatclass(r#)) & antisym(r#) & transitive(r#) ==>
        chain0(BIGUNION(fchains(r#, f#)), r#) &
        !(x : mem(A))  (x' : mem(A))  (k : mem(Pow(A))).
          IN(Pair(x'#, x#), r#) &
          IN(x'#, BIGUNION(fchains(r#, f#))) &
          IN(x#, BIGUNION(fchains(r#, f#))) &
          IN(k#, fchains(r#, f#)) & IN(x#, k#) ==> IN(x'#, k#): thm
val lemma5 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) & ~range(r#) = Empty(A) & reflexive(r#, s#) ==>
        IN(Sing(App(f#, range(r#))), fchains(r#, f#)): thm
val lemma6 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (k : mem(Pow(A)))
      (x : mem(A))  (C : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        transitive(r#) &
        antisym(r#) &
        IN(k#, fchains(r#, f#)) &
        IN(x#, k#) &
        chain0(C#, r#) &
        IN(x#, Diff(upper_bounds(C#, r#), C#)) &
        SS(C#, BIGUNION(fchains(r#, f#))) ==>
        IN(App(f#, Diff(upper_bounds(C#, r#), C#)), k#) &
        IN(Pair(App(f#, Diff(upper_bounds(C#, r#), C#)), x#), r#): thm
val lemma7 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        IN(BIGUNION(fchains(r#, f#)), fchains(r#, f#)): thm
val lemma8 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A)))
      (k : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        reflexive(r#, s#) &
        antisym(r#) &
        transitive(r#) &
        IN(k#, fchains(r#, f#)) & ~Diff(upper_bounds(k#, r#), k#) = Empty(A) ==>
        IN(Ins(App(f#, Diff(upper_bounds(k#, r#), k#)), k#), fchains(r#, f#)):
   thm
val upper_bounds_lem =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A)))  (x1 : mem(A))
      (x2 : mem(A)).
        transitive(r#) &
        IN(x1#, upper_bounds(s#, r#)) & IN(Pair(x1#, x2#), r#) ==>
        IN(x2#, upper_bounds(s#, r#)): thm
val lemma9 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (f : fun(Pow(A), A))  (s : mem(Pow(A))).
        ischoice(f#, hatclass(r#)) &
        SS(range(r#), s#) &
        ~range(r#) = Empty(A) &
        antisym(r#) & reflexive(r#, s#) & transitive(r#) ==>
        SS(upper_bounds(BIGUNION(fchains(r#, f#)), r#),
         maximal_elements(s#, r#)): thm
val zorns_lemma0 =
   {(A : set)}, 
   |- !(r : mem(Pow(A * A)))  (s : mem(Pow(A))).
        ~s# = Empty(A) &
        partial_order(r#, s#) &
        (!(t : mem(Pow(A))).
            chain0(t#, r#) ==> ~upper_bounds(t#, r#) = Empty(A)) ==>
        ?(x : mem(A)). IN(x#, maximal_elements(s#, r#)): thm
val Trans_transitive =
   {},  |- !(A : set)  (R : rel(A#, A#)). Trans(R#) <=> transitive(r2m(R#)):
   thm
val Refl_reflexive =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        Refl(R#) <=> reflexive(r2m(R#), Whole(A#)): thm
val Asym_antisym =
   {},  |- !(A : set)  (R : rel(A#, A#)). Asym(R#) <=> antisym(r2m(R#)): thm
val ptorder_partial_order =
   {(A : set), (R : rel(A, A))}, 
   |- ptorder(R) <=> partial_order(r2m(R), Whole(A)): thm
val zorns_lemma =
   {}, 
   |- !(A : set)  (R : rel(A#, A#)).
        ~EMPTY(A#) & ptorder(R#) ==>
        (!(c : mem(Pow(A#))).
            chain(c#, R#) & ~c# = Empty(A#) ==>
            ?(ub : mem(A#)). ubound(c#, R#, ub#)) ==>
        ?(m : mem(A#)). ismax(R#, m#): thm
val it = (): unit
val ufilter_iff_maximal =
   {}, 
   |- !(J : set)  (u : mem(Pow(Pow(J#)))).
        pfilter(u#) ==>
        ((!(s : mem(Pow(Pow(J#)))).
              filter(s#) & PSS(u#, s#) ==> s# = Whole(Pow(J#))) <=>
          ufilter(u#)): thm
val UNION_chain_filter_filter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> filter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          filter(BIGUNION(ss#)): thm
val UNION_chain_pfilter_pfilter =
   {}, 
   |- !(W : set).
        ~EMPTY(W#) ==>
        !(ss : mem(Pow(Pow(Pow(W#))))).
          ~ss# = Empty(Pow(Pow(W#))) &
          (!(s : mem(Pow(Pow(W#)))). IN(s#, ss#) ==> pfilter(s#)) &
          (!(a : mem(Pow(Pow(W#))))  (b : mem(Pow(Pow(W#)))).
              IN(a#, ss#) & IN(b#, ss#) ==> SS(a#, b#) | SS(b#, a#)) ==>
          pfilter(BIGUNION(ss#)): thm
val ufilter_thm =
   {}, 
   |- !(A : set)  (s : mem(Pow(Pow(A#)))).
        pfilter(s#) ==> ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(s#, u#):
   thm
val ufilter_thm_coro =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==>
        ?(u : mem(Pow(Pow(A#)))). ufilter(u#) & SS(ss#, u#): thm
val Prop_5_3 =
   {}, 
   |- !(A : set)  (ss : mem(Pow(Pow(A#)))).
        FIP(ss#) & ~EMPTY(A#) ==> ?(u : mem(UFs(A#))). SS(ss#, Repu(u#)): thm
val FIP_Sing =
   {},  |- !(W : set)  (a : mem(Pow(W#))). ~a# = Empty(W#) ==> FIP(Sing(a#)):
   thm
val it = (): unit
******

Loading SEAR file SEARmmmt.sml

******
val Rm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w1 : mem(W)), (w2 : mem(W))}, 
   |- Rm(M, w1, w2) <=> IN(Pair(w1, w2), Rof(M)): thm
val Rof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Rof(M#) = Fst(M#): thm
val Vof_def =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#)))).
        Vof(M#) = tof(Snd(M#)): thm
val HAT_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(A))  (w : mem(W)).
        IN(w#, App(HAT(M), a#)) <=> IN(a#, App(Vof(M), w#)): thm
val satis_def0 =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A))), (w : mem(W))}, 
   |- satis(M, w, f) <=> IN(w, App(satisf(M), f)): thm
val satis_dmf =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(Pow(W)))  (w : mem(W)).
        IN(w#, App(sdmf(M), a#)) <=>
        ?(w0 : mem(W)). IN(w0#, a#) & Rm(M, w#, w0#): thm
val satisf_clause =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- App(satisf(M), Bot(A)) = Empty(W) &
      (!(p : mem(A)). App(satisf(M), Var(p#)) = App(HAT(M), p#)) &
      (!(f : mem(form(A))).
          App(satisf(M), Neg(f#)) = App(COMPL(W), App(satisf(M), f#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          App(satisf(M), Disj(f1#, f2#)) =
            App(UNION(W), Pair(App(satisf(M), f1#), App(satisf(M), f2#)))) &
      !(f : mem(form(A))).
        App(satisf(M), Diam(f#)) = App(sdmf(M), App(satisf(M), f#)): thm
val satisf_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- satisf(M) = fmrec(Empty(W), HAT(M), COMPL(W), UNION(W), sdmf(M)): thm
val satis_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))}, 
   |- ~satis(M, w, Bot(A)) &
      (!(a : mem(A)). satis(M, w, Var(a#)) <=> IN(a#, App(Vof(M), w))) &
      (!(f : mem(form(A))). satis(M, w, Neg(f#)) <=> ~satis(M, w, f#)) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          satis(M, w, Disj(f1#, f2#)) <=> satis(M, w, f1#) | satis(M, w, f2#)) &
      !(f : mem(form(A))).
        satis(M, w, Diam(f#)) <=>
        ?(v : mem(W)). Rm(M, w, v#) & satis(M, v#, f#): thm
val SATIS_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (fs : mem(Pow(form(A)))), (w : mem(W))}, 
   |- SATIS(M, w, fs) <=> !(f : mem(form(A))). IN(f#, fs) ==> satis(M, w, f#):
   thm
val Top_def = {(A : set)},  |- Top(A) = Neg(Bot(A)): thm
val Conj_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- Conj(f1, f2) = Neg(Disj(Neg(f1), Neg(f2))): thm
val satis_Conj =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f1 : mem(form(A)))  (f2 : mem(form(A))).
        satis(M#, w#, Conj(f1#, f2#)) <=>
        satis(M#, w#, f1#) & satis(M#, w#, f2#): thm
val PE's_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). IN(a#, PE's(A)) <=> SS(App(PEf(A), a#), a#):
   thm
val PE_cases0 = {(A : set)},  |- App(PEf(A), PEs(A)) = PEs(A): thm
val PE_cases1 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_incond =
   !(f : mem(form(A))).
     IN(f#, PEs1) <=>
     f# = Top(A) |
     f# = Bot(A) |
     (?(p : mem(A)). f# = Var(p#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Conj(f1#, f2#)) |
     (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
         IN(f1#, PEs0) & IN(f2#, PEs0) & f# = Disj(f1#, f2#)) |
     ?(f0 : mem(form(A))). IN(f0#, PEs0) & f# = Diam(f0#): form
val PE_ind0 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind1 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        (!(a : mem(form(A))).
            a# = Top(A) |
            a# = Bot(A) |
            (?(p : mem(A)). a# = Var(p#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Conj(f1#, f2#)) |
            (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
                IN(f1#, ss#) & IN(f2#, ss#) & a# = Disj(f1#, f2#)) |
            (?(f0 : mem(form(A))). IN(f0#, ss#) & a# = Diam(f0#)) ==>
            IN(a#, ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_ind2 =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). IN(a#, PEs(A)) ==> IN(a#, ss#): thm
val PE_rules0 = {(A : set)},  |- SS(App(PEf(A), PEs(A)), PEs(A)): thm
val PE_rules1 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        a# = Top(A) |
        a# = Bot(A) |
        (?(p : mem(A)). a# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#)) |
        (?(f0 : mem(form(A))). IN(f0#, PEs(A)) & a# = Diam(f0#)) ==>
        IN(a#, PEs(A)): thm
val PE_rules2 =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (a# = Top(A) ==> IN(a#, PEs(A))) &
        (a# = Bot(A) ==> IN(a#, PEs(A))) &
        (!(p : mem(A)). a# = Var(p#) ==> IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Conj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & a# = Disj(f1#, f2#) ==>
            IN(a#, PEs(A))) &
        !(f0 : mem(form(A))).
          IN(f0#, PEs(A)) & a# = Diam(f0#) ==> IN(a#, PEs(A)): thm
val PE_rules3 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PEf_def =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A))))  (f : mem(form(A))).
        IN(f#, App(PEf(A), a#)) <=>
        f# = Top(A) |
        f# = Bot(A) |
        (?(p : mem(A)). f# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_ex =
   {(A : set)}, 
   |- ?!(f : fun(Pow(form(A)), Pow(form(A)))).
        !(a : mem(Pow(form(A))))  (f : mem(form(A))).
          IN(f#, App(f#, a#)) <=>
          f# = Top(A) |
          f# = Bot(A) |
          (?(p : mem(A)). f# = Var(p#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Conj(f1#, f2#)) |
          (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, a#) & IN(f2#, a#) & f# = Disj(f1#, f2#)) |
          ?(f0 : mem(form(A))). IN(f0#, a#) & f# = Diam(f0#): thm
val PEf_monotone =
   {(A : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==> SS(App(PEf(A), s1#), App(PEf(A), s2#)): thm
val PEs_SS =
   {(A : set)}, 
   |- !(a : mem(Pow(form(A)))). SS(App(PEf(A), a#), a#) ==> SS(PEs(A), a#):
   thm
val PEs_cond =
   {(A : set)}, 
   |- !(a : mem(form(A))).
        (!(ss : mem(Pow(form(A)))). SS(App(PEf(A), ss#), ss#) ==> IN(a#, ss#)) <=>
        IN(a#, PEs(A)): thm
val PEs_def = {(A : set)},  |- PEs(A) = BIGINTER(PE's(A)): thm
val x1 = "PEs0": string
val PE_cases0 =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        IN(x#, PEs(A)) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, PEs(A)) & IN(f2#, PEs(A)) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). IN(f0#, PEs(A)) & x# = Diam(f0#): thm
val PE_rules0 =
   {(A : set)}, 
   |- IN(Top(A), PEs(A)) &
      IN(Bot(A), PEs(A)) &
      (!(p : mem(A)). IN(Var(p#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Conj(f1#, f2#), PEs(A))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          IN(f1#, PEs(A)) ==> IN(f2#, PEs(A)) ==> IN(Disj(f1#, f2#), PEs(A))) &
      !(f0 : mem(form(A))). IN(f0#, PEs(A)) ==> IN(Diam(f0#), PEs(A)): thm
val PE_def0 = {(A : set), (f : mem(form(A)))},  |- PE(f) <=> IN(f, PEs(A)):
   thm
val PE_ind =
   {(A : set)}, 
   |- !(ss : mem(Pow(form(A)))).
        ((((IN(Top(A), ss#) & IN(Bot(A), ss#)) &
              !(p : mem(A)). IN(Var(p#), ss#)) &
            !(f1 : mem(form(A)))  (f2 : mem(form(A))).
              IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Conj(f1#, f2#), ss#)) &
          !(f1 : mem(form(A)))  (f2 : mem(form(A))).
            IN(f1#, ss#) & IN(f2#, ss#) ==> IN(Disj(f1#, f2#), ss#)) &
        (!(f0 : mem(form(A))). IN(f0#, ss#) ==> IN(Diam(f0#), ss#)) ==>
        !(a : mem(form(A))). PE(a#) ==> IN(a#, ss#): thm
val PE_cases =
   {(A : set)}, 
   |- !(x : mem(form(A))).
        PE(x#) <=>
        x# = Top(A) |
        x# = Bot(A) |
        (?(p : mem(A)). x# = Var(p#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Conj(f1#, f2#)) |
        (?(f1 : mem(form(A)))  (f2 : mem(form(A))).
            PE(f1#) & PE(f2#) & x# = Disj(f1#, f2#)) |
        ?(f0 : mem(form(A))). PE(f0#) & x# = Diam(f0#): thm
val PE_rules =
   {(A : set)}, 
   |- PE(Top(A)) &
      PE(Bot(A)) &
      (!(p : mem(A)). PE(Var(p#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#))) &
      (!(f1 : mem(form(A)))  (f2 : mem(form(A))).
          PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#))) &
      !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val PE_induct =
   {}, 
   |- !(A : set).
        P(Top(A#)) &
        P(Bot(A#)) &
        (!(p : mem(A#)). P(Var(p#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Conj(f1#, f2#))) &
        (!(f1 : mem(form(A#)))  (f2 : mem(form(A#))).
            P(f1#) & P(f2#) ==> P(Disj(f1#, f2#))) &
        (!(f : mem(form(A#))). P(f#) ==> P(Diam(f#))) ==>
        !(f : mem(form(A#))). PE(f#) ==> P(f#): thm
val satis_Bot =
   {}, 
   |- !(A : set)  (W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
      (w : mem(W#)). ~satis(M#, w#, Bot(A#)): thm
val satis_Top =
   {(W : set)}, 
   |- !(A : set)  (M : mem(Pow((W * W)) * Exp(W, Pow(A#))))  (w : mem(W)).
        satis(M#, w#, Top(A#)): thm
val PUS_Var = {},  |- !(A : set)  (p : mem(A#)). PUS(Var(p#)): thm
val PUS_def =
   {(A : set), (f : mem(form(A)))}, 
   |- PUS(f) <=>
      !(W1 : set)  (W2 : set)  (R : rel(W1#, W2#))
      (M1 : mem(Pow((W1# * W1#)) * Exp(W1#, Pow(A))))
      (M2 : mem(Pow((W2# * W2#)) * Exp(W2#, Pow(A)))).
        Sim(R#, M1#, M2#) ==>
        !(w1 : mem(W1#))  (w2 : mem(W2#)).
          Holds(R#, w1#, w2#) ==> satis(M1#, w1#, f) ==> satis(M2#, w2#, f):
   thm
val Sim_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (R : rel(W1, W2)),
    (W1 : set), (W2 : set)}, 
   |- Sim(R, M1, M2) <=>
      !(w1 : mem(W1))  (w2 : mem(W2)).
        Holds(R, w1#, w2#) ==>
        (!(p : mem(A)).
            IN(p#, App(Vof(M1), w1#)) ==> IN(p#, App(Vof(M2), w2#))) &
        !(v : mem(W1)).
          Rm(M1, w1#, v#) ==>
          ?(v' : mem(W2)). Holds(R, v#, v'#) & Rm(M2, w2#, v'#): thm
val PUS_Top = {},  |- !(A : set). PUS(Top(A#)): thm
val PUS_Bot = {},  |- !(A : set). PUS(Bot(A#)): thm
val Thm_6_25_r2l0 =
   {},  |- !(A : set)  (f : mem(form(A#))). PE(f#) ==> PUS(f#): thm
val EQV_def =
   {(A : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- EQV(f1, f2) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, f1) <=> satis(M#, w#, f2): thm
val Thm_6_25_r2l =
   {}, 
   |- !(A : set)  (f : mem(form(A#)))  (f0 : mem(form(A#))).
        PE(f0#) & EQV(f#, f0#) ==> PUS(f#): thm
val Fsab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Fsab(fs, X, M) <=>
      !(ss : mem(Pow(form(A)))). Fin(ss#) & SS(ss#, fs) ==> Sab(ss#, X, M):
   thm
val Msat_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- Msat(M) <=>
      !(w : mem(W))  (fs : mem(Pow(form(A)))).
        Fsab(fs#, Sucm(M, w#), M) ==> Sab(fs#, Sucm(M, w#), M): thm
val Sab_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W))), (fs : mem(Pow(form(A))))}, 
   |- Sab(fs, X, M) <=> ?(x : mem(W)). IN(x#, X) & SATIS(M, x#, fs): thm
val Sucm_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (w : mem(W))},  |- !(a : mem(W)). IN(a#, Sucm(M, w)) <=> Rm(M, w, a#):
   thm
val Tat_def =
   {(A : set), (W : set), (a : mem(A)), (f0 : fun(W, Pow(A)))}, 
   |- !(a' : mem(W)). IN(a'#, Tat(f0, a)) <=> IN(a, App(f0, a'#)): thm
val fun_mem_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(f : fun(A#, B#)). P(f#)) <=> ?(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val mem_fun_ex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?(m : mem(Exp(A#, B#))). P(m#)) <=> ?(f : fun(A#, B#)). P(Tpm(f#)):
   thm
val fun_mem_uex_iff =
   {}, 
   |- !(A : set)  (B : set).
        (?!(f : fun(A#, B#)). P(f#)) <=> ?!(m : mem(Exp(A#, B#))). P(tof(m#)):
   thm
val UE_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- UE(M) = Pair(ueR(M), ueV(M)): thm
val csee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, csee(M, X)) <=> ?(v : mem(W)). Rm(M, a#, v#) & IN(v#, X): thm
val osee_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (X : mem(Pow(W)))}, 
   |- !(a : mem(W)).
        IN(a#, osee(M, X)) <=> !(v : mem(W)). Rm(M, a#, v#) ==> IN(v#, X):
   thm
val ueR_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a' : mem(UFs(W)))  (b : mem(UFs(W))).
        IN(Pair(a'#, b#), ueR(M)) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(b#)) ==> IN(csee(M, X#), Repu(a'#)):
   thm
val ueV_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(u : mem(UFs(W)))  (a : mem(A)).
        IN(a#, App(tof(ueV(M)), u#)) <=> IN(Tat(Vof(M), a#), Repu(u#)): thm
val ufilter_Compl =
   {}, 
   |- !(J : set)  (L : mem(Pow(Pow(J#)))).
        ufilter(L#) ==>
        !(X : mem(Pow(J#))). ~IN(Compl(X#), L#) <=> IN(X#, L#): thm
val exists_forall_dual =
   {},  |- !(A : set). (?(a : mem(A#)). P(a#)) <=> ~!(a : mem(A#)). ~P(a#):
   thm
val Prop_5_4_1 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        csee(M#, X#) = Compl(osee(M#, Compl(X#))): thm
val Prop_5_4_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W))).
        osee(M#, X#) = Compl(csee(M#, Compl(X#))): thm
val Prop_5_6 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val MEQ_def =
   {(A : set), (M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A)))),
    (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))), (W1 : set), (W2 : set),
    (w1 : mem(W1)), (w2 : mem(W2))}, 
   |- MEQ(M1, w1, M2, w2) <=>
      !(f : mem(form(A))). satis(M1, w1, f#) <=> satis(M2, w2, f#): thm
val pufilter_def =
   {(A : set), (a : mem(A))}, 
   |- !(a' : mem(Pow(A))). IN(a'#, pufilter(a)) <=> IN(a, a'#): thm
val pufilter_filter =
   {},  |- !(A : set)  (a : mem(A#)). filter(pufilter(a#)): thm
val ueR_alt =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (v : mem(UFs(W))).
        Rm(UE(M#), u#, v#) <=>
        !(Y : mem(Pow(W))). IN(osee(M#, Y#), Repu(u#)) ==> IN(Y#, Repu(v#)):
   thm
val pufilter_ufilter =
   {},  |- !(A : set)  (a : mem(A#)). ufilter(pufilter(a#)): thm
val Repu_eq_eq =
   {}, 
   |- !(W : set)  (u1 : mem(UFs(W#)))  (u2 : mem(UFs(W#))).
        Repu(u1#) = Repu(u2#) ==> u1# = u2#: thm
val Pft_def =
   {(W : set), (w0 : mem(W))}, 
   |- !(ws : mem(Pow(W))). IN(ws#, Repu(Pft(w0))) <=> IN(w0, ws#): thm
val Prop_5_5_2 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (X : mem(Pow(W)))
      (Y : mem(Pow(W))).
        osee(M#, Inter(X#, Y#)) = Inter(osee(M#, X#), osee(M#, Y#)): thm
val SW_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set)}, 
   |- !(a : mem(form(A)))  (w : mem(W)).
        IN(w#, App(SW(M), a#)) <=> satis(M, w#, a#): thm
val Sw_def =
   {(A : set), (M : mem(Pow((W * W)) * Exp(W, Pow(A)))), (W : set),
    (f : mem(form(A)))},  |- Sw(M, f) = App(SW(M), f): thm
val Sw_Bot =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Sw(M#, Bot(A)) = Empty(W):
   thm
val Sw_Var =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        Sw(M#, Var(p#)) = App(HAT(M#), p#): thm
val Vof_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Vof(UE(M#)) = tof(ueV(M#)):
   thm
val HAT_Tat =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (p : mem(A)).
        App(HAT(M#), p#) = Tat(Vof(M#), p#): thm
val Sw_Neg =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        Sw(M#, Neg(f#)) = Compl(Sw(M#, f#)): thm
val Sw_Disj =
   {(A : set), (W : set), (f1 : mem(form(A))), (f2 : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        Sw(M#, Disj(f1, f2)) = Union(Sw(M#, f1), Sw(M#, f2)): thm
val Rm_UE =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (u : mem(UFs(W)))
      (u' : mem(UFs(W))).
        Rm(UE(M#), u#, u'#) <=>
        !(X : mem(Pow(W))). IN(X#, Repu(u'#)) ==> IN(csee(M#, X#), Repu(u#)):
   thm
val csee_Sw_DIAM =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (f : mem(form(A))).
        csee(M#, Sw(M#, f#)) = Sw(M#, Diam(f#)): thm
val Prop_5_8 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
      (phi : mem(form(A)))  (u : mem(UFs(W#))).
        IN(Sw(M#, phi#), Repu(u#)) <=> satis(UE(M#), u#, phi#): thm
val Prop_5_7 =
   {(A : set)}, 
   |- !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        MEQ(M#, w#, UE(M#), Pft(w#)): thm
val SATIS_Sing =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (f : mem(form(A))). SATIS(M#, w#, Sing(f#)) <=> satis(M#, w#, f#): thm
val Fin_Inter =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Fin(s1#) | Fin(s2#) ==> Fin(Inter(s1#, s2#)): thm
val SATIS_Union =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W))
      (s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SATIS(M#, w#, Union(s1#, s2#)) <=>
        SATIS(M#, w#, s1#) & SATIS(M#, w#, s2#): thm
val only_see_whole_world =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))).
        osee(M#, Whole(W)) = Whole(W): thm
val SATIS_Empty =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        SATIS(M#, w#, Empty(form(A))): thm
val BIGCONJ_EXISTS =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        ?(ff : mem(form(A))).
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val SS_Union_of =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#)))
      (s : mem(Pow(A#))).
        SS(s1#, s#) & SS(s2#, s#) ==> SS(Union(s1#, s2#), s#): thm
val Prop_5_9 =
   {(A : set), (W : set)}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A)))). Msat(UE(M#)): thm
val PE_BIGCONJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). satis(M#, w#, ff#) <=> SATIS(M#, w#, s#): thm
val PE_Conj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Conj(f1#, f2#)): thm
val PE_BIGDISJ =
   {(A : set)}, 
   |- !(s : mem(Pow(form(A)))).
        Fin(s#) ==>
        (!(f : mem(form(A))). IN(f#, s#) ==> PE(f#)) ==>
        ?(ff : mem(form(A))).
          PE(ff#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)).
            satis(M#, w#, ff#) <=>
            ?(f : mem(form(A))). IN(f#, s#) & satis(M#, w#, f#): thm
val PE_Disj =
   {(A : set)}, 
   |- !(f1 : mem(form(A)))  (f2 : mem(form(A))).
        PE(f1#) ==> PE(f2#) ==> PE(Disj(f1#, f2#)): thm
val PE_Diam =
   {(A : set)},  |- !(f0 : mem(form(A))). PE(f0#) ==> PE(Diam(f0#)): thm
val Thm_6_22 =
   {(A : set), (W1 : set), (W2 : set)}, 
   |- !(M1 : mem(Pow((W1 * W1)) * Exp(W1, Pow(A))))
      (M2 : mem(Pow((W2 * W2)) * Exp(W2, Pow(A)))).
        Msat(M1#) & Msat(M2#) ==>
        !(w1 : mem(W1))  (w2 : mem(W2)).
          (!(f : mem(form(A))).
              PE(f#) ==> satis(M1#, w1#, f#) ==> satis(M2#, w2#, f#)) ==>
          ?(R : rel(W1, W2)). Sim(R#, M1#, M2#) & Holds(R#, w1#, w2#): thm
val ENT_def =
   {(A : set), (phis : mem(Pow(form(A)))), (psi : mem(form(A)))}, 
   |- ENT(phis, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        SATIS(M#, w#, phis) ==> satis(M#, w#, psi): thm
val MCOMPACT_def =
   {}, 
   |- MCOMPACT <=>
      !(A : set)  (fs : mem(Pow(form(A#)))).
        (!(ffs : mem(Pow(form(A#)))).
            SS(ffs#, fs#) & Fin(ffs#) ==>
            ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
            (w : mem(W#)). SATIS(M#, w#, ffs#)) ==>
        ?(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A#))))
        (w : mem(W#)). SATIS(M#, w#, fs#): thm
val satis_Neg =
   {(A : set), (W : set), (f : mem(form(A)))}, 
   |- !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
        satis(M#, w#, Neg(f)) <=> ~satis(M#, w#, f): thm
val Ent_def =
   {(A : set), (phi : mem(form(A))), (psi : mem(form(A)))}, 
   |- Ent(phi, psi) <=>
      !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))  (w : mem(W#)).
        satis(M#, w#, phi) ==> satis(M#, w#, psi): thm
val SATIS_SS =
   {(A : set), (W : set)}, 
   |- !(s1 : mem(Pow(form(A))))  (s2 : mem(Pow(form(A)))).
        SS(s1#, s2#) ==>
        !(M : mem(Pow((W * W)) * Exp(W, Pow(A))))  (w : mem(W)).
          SATIS(M#, w#, s2#) ==> SATIS(M#, w#, s1#): thm
val Thm_6_24 =
   {(A : set)}, 
   |- MCOMPACT ==>
      !(fs : mem(Pow(form(A))))  (phi : mem(form(A))).
        ENT(fs#, phi#) ==>
        ?(ffs : mem(Pow(form(A)))).
          SS(ffs#, fs#) & Fin(ffs#) & ENT(ffs#, phi#): thm
val Fin_ENT_PE =
   {(A : set)}, 
   |- !(fs : mem(Pow(form(A)))).
        Fin(fs#) & (!(f : mem(form(A))). IN(f#, fs#) ==> PE(f#)) ==>
        ?(phi : mem(form(A))).
          PE(phi#) &
          !(W : set)  (M : mem(Pow((W# * W#)) * Exp(W#, Pow(A))))
          (w : mem(W#)). SATIS(M#, w#, fs#) <=> satis(M#, w#, phi#): thm
val PEC_def =
   {(A : set), (f : mem(form(A)))}, 
   |- !(a : mem(form(A))). IN(a#, PEC(f)) <=> PE(a#) & Ent(f, a#): thm
val SATIS_PEC =
   {(A : set), (W : set)}, 
   |- !(f : mem(form(A)))  (M : mem(Pow((W * W)) * Exp(W, Pow(A))))
      (w : mem(W)). satis(M#, w#, f#) ==> SATIS(M#, w#, PEC(f#)): thm
val Del_Fin =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (a : mem(A#)).
        Fin(Del(s#, a#)) ==> Fin(s#): thm
val Fin_Inj0 =
   {}, 
   |- !(B : set)  (s : mem(Pow(B#))).
        Fin(s#) ==>
        !(A : set)  (f : fun(A#, B#))  (ss : mem(Pow(A#))).
          s# = IMAGE(f#, ss#) ==> Inj(f#) ==> Fin(ss#): thm
val Fin_Inj =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(ss : mem(Pow(A#))). Fin(IMAGE(f#, ss#)) ==> Fin(ss#):
   thm
val Thm_6_25_iff =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) <=> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val Thm_6_25_l2r =
   {}, 
   |- MCOMPACT ==>
      !(A : set)  (f : mem(form(A#))).
        PUS(f#) ==> ?(f0 : mem(form(A#))). PE(f0#) & EQV(f#, f0#): thm
val it = (): unit
******

Loading SEAR file SEARllist.sml

******
val IN_gfp =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (a : mem(A)).
        IN(a#, gfp(f#)) <=>
        ?(sa : mem(Pow(A))). SS(sa#, App(f#, sa#)) & IN(a#, sa#): thm
val gfp_def =
   {}, 
   |- !(A : set)  (f : fun(Pow(A#), Pow(A#))). gfp(f#) = BIGUNION(prims(f#)):
   thm
val prims_def =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- !(a : mem(Pow(A))). IN(a#, prims(f)) <=> SS(a#, App(f, a#)): thm
val weak_coind =
   {}, 
   |- !(A : set)  (sa : mem(Pow(A#)))  (a : mem(A#))
      (f : fun(Pow(A#), Pow(A#))).
        IN(a#, sa#) & SS(sa#, App(f#, sa#)) ==> IN(a#, gfp(f#)): thm
val SS_gfp_fgfp =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(gfp(f), App(f, gfp(f))): thm
val monotone_def =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(Pow(A#), Pow(B#))).
        monotone(f#) <=>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          SS(s1#, s2#) ==> SS(App(f#, s1#), App(f#, s2#)): thm
val rules0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> SS(App(f, gfp(f)), gfp(f)): thm
val cases0 =
   {(A : set), (f : fun(Pow(A), Pow(A)))}, 
   |- monotone(f) ==> gfp(f) = App(f, gfp(f)): thm
val coind0 =
   {(A : set)}, 
   |- !(f : fun(Pow(A), Pow(A)))  (sa : mem(Pow(A))).
        SS(sa#, App(f#, sa#)) ==> SS(sa#, gfp(f#)): thm
val lcons0_def =
   {}, 
   |- !(X : set)  (f0 : fun(N, X# + 1))  (x : mem(X#)).
        App(lcons0(x#, f0#), O) = SOME(x#) &
        !(n : mem(N)). App(lcons0(x#, f0#), Suc(n#)) = App(f0#, n#): thm
val llf_uex =
   {(X : set)}, 
   |- ?!(f : fun(Pow(Exp(N, X + 1)), Pow(Exp(N, X + 1)))).
        !(gs : mem(Pow(Exp(N, X + 1))))  (g : mem(Exp(N, X + 1))).
          IN(g#, App(f#, gs#)) <=>
          g# = Tpm(Null(X)) |
          ?(h : mem(X))  (t : fun(N, X + 1)).
            g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_def =
   {}, 
   |- !(X : set)  (gs : mem(Pow(Exp(N, X# + 1))))  (g : mem(Exp(N, X# + 1))).
        IN(g#, App(llf(X#), gs#)) <=>
        g# = Tpm(Null(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          g# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), gs#): thm
val llf_monotone = {},  |- !(X : set). monotone(llf(X#)): thm
val islls_def = {(X : set)},  |- islls(X) = gfp(llf(X)): thm
val llist_def1 =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          IN(a#, islls(X#)) <=>
          ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_Inj = {},  |- !(X : set). Inj(repll(X#)): thm
val isll_def =
   {}, 
   |- !(X : set)  (l : mem(Exp(N, X# + 1))). isll(l#) <=> IN(l#, islls(X#)):
   thm
val ll_cases = {},  |- !(X : set). islls(X#) = App(llf(X#), islls(X#)): thm
val ll_coind =
   {}, 
   |- !(X : set)  (sa : mem(Pow(Exp(N, X# + 1)))).
        (!(a : mem(Exp(N, X# + 1))).
            IN(a#, sa#) ==>
            a# = Tpm(Null(X#)) |
            ?(h : mem(X#))  (t : fun(N, X# + 1)).
              a# = Tpm(lcons0(h#, t#)) & IN(Tpm(t#), sa#)) ==>
        !(a : mem(Exp(N, X# + 1))). IN(a#, sa#) ==> IN(a#, islls(X#)): thm
val ll_rules =
   {}, 
   |- !(X : set).
        IN(Tpm(Null(X#)), islls(X#)) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          IN(Tpm(t#), islls(X#)) ==> IN(Tpm(lcons0(h#, t#)), islls(X#)): thm
val isll_lnil = {},  |- !(X : set). isll(Tpm(Null(X#))): thm
val isll_shift =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val Repll_def =
   {},  |- !(X : set)  (l : mem(llist(X#))). Repll(l#) = App(repll(X#), l#):
   thm
val LNil_def = {},  |- !(X : set). Repll(LNil(X#)) = Tpm(Null(X#)): thm
val llist_def =
   {}, 
   |- !(X : set).
        Inj(repll(X#)) &
        !(a : mem(Exp(N, X# + 1))).
          isll(a#) <=> ?(b : mem(llist(X#))). a# = App(repll(X#), b#): thm
val repll_isll =
   {},  |- !(X : set)  (ll : mem(llist(X#))). isll(App(repll(X#), ll#)): thm
val isll_Repll =
   {}, 
   |- !(X : set)  (a : mem(Exp(N, X# + 1))).
        isll(a#) <=> ?(b : mem(llist(X#))). a# = Repll(b#): thm
val Repll_eq_eq =
   {}, 
   |- !(X : set)  (l1 : mem(llist(X#)))  (l2 : mem(llist(X#))).
        Repll(l1#) = Repll(l2#) <=> l1# = l2#: thm
val Repll_isll = {},  |- !(X : set)  (ll : mem(llist(X#))). isll(Repll(ll#)):
   thm
val isll_lcons0 =
   {}, 
   |- !(X : set)  (t : fun(N, X# + 1)).
        isll(Tpm(t#)) ==> !(h : mem(X#)). isll(Tpm(lcons0(h#, t#))): thm
val isll_rules =
   {}, 
   |- !(X : set).
        isll(Tpm(Null(X#))) &
        !(h : mem(X#))  (t : fun(N, X# + 1)).
          isll(Tpm(t#)) ==> isll(Tpm(lcons0(h#, t#))): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LCons_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#)))  (x : mem(X#)).
        Repll(LCons(x#, ll#)) = Tpm(lcons0(x#, tof(Repll(ll#)))): thm
val Repll_lnil_uex =
   {}, 
   |- !(X : set)  (l : mem(llist(X#))).
        Repll(l#) = Tpm(Null(X#)) <=> l# = LNil(X#): thm
val FPB_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- App(FPB(f), NONE(B * A)) = NONE(B * A) &
      !(b : mem(B))  (a : mem(A)).
        App(FPB(f), SOME(Pair(b#, a#))) = App(f, b#): thm
val FP_def =
   {(X : set), (f : fun(X, X))}, 
   |- !(x : mem(X)).
        App(FP(f), Pair(O, x#)) = x# &
        !(n : mem(N)).
          App(FP(f), Pair(Suc(n#), x#)) = App(FP(f), Pair(n#, App(f, x#))):
   thm
val OB_def =
   {(A : set), (B : set)}, 
   |- !(f : fun(A, B + 1)).
        App(OB(A, B), Pair(NONE(A), Tpm(f#))) = NONE(B) &
        !(a : mem(A)). App(OB(A, B), Pair(SOME(a#), Tpm(f#))) = App(f#, a#):
   thm
val lnil_def = {(X : set)},  |- lnil(X) = Tpm(Null(X)): thm
val toabs_char0 =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)).
        (App(f#, z#) = NONE(B * A) ==> toabs(f#, z#) = Null(A)) &
        !(b : mem(B))  (a : mem(A)).
          App(f#, z#) = SOME(Pair(b#, a#)) ==>
          toabs(f#, z#) = lcons0(a#, toabs(f#, b#)): thm
val toabs_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1)), (z : mem(B))}, 
   |- !(n : mem(N)).
        App(toabs(f, z), n#) =
          App(OM(p2(B, A)), App(FP(FPB(f)), Pair(n#, App(f, z)))): thm
val toabs_isll =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (z : mem(B)). isll(Tpm(toabs(f#, z#))): thm
val toabs_unique =
   {(A : set), (B : set)}, 
   |- !(f : fun(B, B * A + 1))  (g : fun(B, Exp(N, A + 1))).
        (!(z : mem(B)).
            (App(f#, z#) = NONE(B * A) ==> App(g#, z#) = Tpm(Null(A))) &
            !(b : mem(B))  (a : mem(A)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(g#, z#) = Tpm(lcons0(a#, tof(App(g#, b#))))) ==>
        !(z : mem(B)). App(g#, z#) = Tpm(toabs(f#, z#)): thm
val llcr0_def =
   {(A : set), (B : set), (f : fun(B, B * A + 1))}, 
   |- !(z : mem(B)). App(llcr0(f), z#) = Tpm(toabs(f, z#)): thm
val llrec0_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, Exp(N, A# + 1))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = Tpm(Null(A#))) &
            (!(b : mem(B#))  (a : mem(A#)).
                App(f#, z#) = SOME(Pair(b#, a#)) ==>
                App(cr#, z#) = Tpm(lcons0(a#, tof(App(cr#, b#))))) &
            isll(App(cr#, z#)): thm
val llcr_uex =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(B#, B# * A# + 1)).
        ?!(cr : fun(B#, llist(A#))).
          !(z : mem(B#)).
            (App(f#, z#) = NONE(B# * A#) ==> App(cr#, z#) = LNil(A#)) &
            !(b : mem(B#))  (a : mem(A#)).
              App(f#, z#) = SOME(Pair(b#, a#)) ==>
              App(cr#, z#) = LCons(a#, App(cr#, b#)): thm
val CB_def =
   {(X : set)}, 
   |- !(R : mem(Pow(llist(X) * llist(X))))  (ll1 : mem(llist(X)))
      (ll2 : mem(llist(X))).
        IN(Pair(ll1#, ll2#), App(CB(X), R#)) <=>
        ll1# = LNil(X) & ll2# = LNil(X) |
        ?(l01 : mem(llist(X)))  (l02 : mem(llist(X)))  (x : mem(X)).
          IN(Pair(l01#, l02#), R#) &
          ll1# = LCons(x#, l01#) & ll2# = LCons(x#, l02#): thm
val CB_monotone = {(X : set)},  |- monotone(CB(X)): thm
val CB_cases = {},  |- !(X : set). gfp(CB(X#)) = App(CB(X#), gfp(CB(X#))):
   thm
val CB_rules0 =
   {}, 
   |- !(X : set).
        IN(Pair(LNil(X#), LNil(X#)), gfp(CB(X#))) &
        !(l01 : mem(llist(X#)))  (l02 : mem(llist(X#))).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          !(x : mem(X#)).
            IN(Pair(LCons(x#, l01#), LCons(x#, l02#)), gfp(CB(X#))): thm
val CB_rules00 =
   {}, 
   |- !(X : set).
        (!(b : mem(llist(X#)))  (a' : mem(llist(X#))).
            a'# = LNil(X#) ==>
            b# = LNil(X#) ==> IN(Pair(a'#, b#), gfp(CB(X#)))) &
        !(a' : mem(llist(X#)))  (b : mem(llist(X#)))  (l01 : mem(llist(X#)))
        (l02 : mem(llist(X#)))  (x : mem(X#)).
          IN(Pair(l01#, l02#), gfp(CB(X#))) ==>
          a'# = LCons(x#, l01#) ==>
          b# = LCons(x#, l02#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val CB_coind0 =
   {}, 
   |- !(X : set)  (sa : mem(Pow(llist(X#) * llist(X#)))).
        (!(a' : mem(llist(X#)))  (b : mem(llist(X#))).
            IN(Pair(a'#, b#), sa#) ==>
            a'# = LNil(X#) & b# = LNil(X#) |
            ?(l01 : mem(llist(X#)))  (l02 : mem(llist(X#)))  (x : mem(X#)).
              IN(Pair(l01#, l02#), sa#) &
              a'# = LCons(x#, l01#) & b# = LCons(x#, l02#)) ==>
        !(a' : mem(llist(X#)))  (b : mem(llist(X#))).
          IN(Pair(a'#, b#), sa#) ==> IN(Pair(a'#, b#), gfp(CB(X#))): thm
val LHD_THM =
   {(X : set)}, 
   |- LHD(LNil(X)) = NONE(X) &
      !(h : mem(X))  (t : mem(llist(X))). LHD(LCons(h#, t#)) = SOME(h#): thm
val LHD_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))). LHD(ll#) = App(tof(Repll(ll#)), O):
   thm
val LNTH_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). LNTH(n#, ll1#) = LNTH(n#, ll2#)) <=> ll1# = ll2#: thm
val LNTH_def =
   {}, 
   |- !(A : set)  (ll : mem(llist(A#)))  (n : mem(N)).
        LNTH(n#, ll#) = App(tof(Repll(ll#)), n#): thm
val Repll_n_EQ =
   {}, 
   |- !(A : set)  (ll1 : mem(llist(A#)))  (ll2 : mem(llist(A#))).
        (!(n : mem(N)). App(tof(Repll(ll1#)), n#) = App(tof(Repll(ll2#)), n#)) <=>
        ll1# = ll2#: thm
val isll_cases0 =
   {}, 
   |- !(X : set)  (x : mem(Exp(N, X# + 1))).
        isll(x#) <=>
        x# = Repll(LNil(X#)) |
        ?(h : mem(X#))  (t : fun(N, X# + 1)).
          x# = Tpm(lcons0(h#, t#)) & isll(Tpm(t#)): thm
val LCons_NONLNIL =
   {}, 
   |- !(X : set)  (x : mem(X#))  (l : mem(llist(X#))).
        ~LCons(x#, l#) = LNil(X#): thm
val LTL_def =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        (LHD(ll#) = NONE(X#) ==> LTL(ll#) = NONE(llist(X#))) &
        !(hd : mem(X#)).
          LHD(ll#) = SOME(hd#) ==>
          ?(ltl0 : mem(llist(X#))).
            LTL(ll#) = SOME(ltl0#) &
            !(n : mem(N)).
              App(tof(Repll(ltl0#)), n#) = App(tof(Repll(ll#)), Suc(n#)): thm
val LCons_xor_LNil =
   {}, 
   |- !(X : set)  (ll : mem(llist(X#))).
        ~ll# = LNil(X#) <=>
        ?(h : mem(X#))  (t : mem(llist(X#))). ll# = LCons(h#, t#): thm
val LTL_THM =
   {(X : set)}, 
   |- LTL(LNil(X)) = NONE(llist(X)) &
      !(h : mem(X))  (t : mem(llist(X))). LTL(LCons(h#, t#)) = SOME(t#): thm
val LNTH_THM =
   {}, 
   |- !(X : set).
        (!(n : mem(N)). LNTH(n#, LNil(X#)) = NONE(X#)) &
        (!(h : mem(X#))  (t : mem(llist(X#))).
            LNTH(O, LCons(h#, t#)) = SOME(h#)) &
        !(n : mem(N))  (h : mem(X#))  (t : mem(llist(X#))).
          LNTH(Suc(n#), LCons(h#, t#)) = LNTH(n#, t#): thm
val gfp_CB =
   {}, 
   |- !(X : set)  (g1 : mem(llist(X#)))  (g2 : mem(llist(X#))).
        IN(Pair(g1#, g2#), gfp(CB(X#))) <=> g1# = g2#: thm
val LLIST_BISIMULATION0 =
   {(X : set)}, 
   |- !(ll1 : mem(llist(X)))  (ll2 : mem(llist(X))).
        ll1# = ll2# <=>
        ?(R : mem(Pow(llist(X) * llist(X)))).
          IN(Pair(ll1#, ll2#), R#) &
          !(ll3 : mem(llist(X)))  (ll4 : mem(llist(X))).
            IN(Pair(ll3#, ll4#), R#) ==>
            ll3# = LNil(X) & ll4# = LNil(X) |
            ?(h : mem(X))  (t1 : mem(llist(X)))  (t2 : mem(llist(X))).
              IN(Pair(t1#, t2#), R#) &
              ll3# = LCons(h#, t1#) & ll4# = LCons(h#, t2#): thm
val lcons0_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : fun(N, X + 1))
      (t2 : fun(N, X + 1)).
        lcons0(h1#, t1#) = lcons0(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LCons_eq_eq =
   {(X : set)}, 
   |- !(h1 : mem(X))  (h2 : mem(X))  (t1 : mem(llist(X)))
      (t2 : mem(llist(X))).
        LCons(h1#, t1#) = LCons(h2#, t2#) <=> h1# = h2# & t1# = t2#: thm
val LMAP_def =
   {(X : set), (Y : set), (f : fun(X, Y))}, 
   |- !(z : mem(llist(X))).
        (App(lmapf(f), z#) = NONE(llist(X) * Y) ==>
          App(LMAP(f), z#) = LNil(Y)) &
        !(b : mem(llist(X)))  (a : mem(Y)).
          App(lmapf(f), z#) = SOME(Pair(b#, a#)) ==>
          App(LMAP(f), z#) = LCons(a#, App(LMAP(f), b#)): thm
val LMap_def =
   {(X : set), (Y : set), (f : fun(X, Y)), (l : mem(llist(X)))}, 
   |- LMap(f, l) = App(LMAP(f), l): thm
val f_ex0 =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(l : mem(llist(X))).
        ?!(opv : mem(llist(X) * A + 1)).
          l# = LNil(X) & opv# = NONE(llist(X) * A) |
          ?(lh : mem(X))  (lt : mem(llist(X))).
            l# = LCons(lh#, lt#) & opv# = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LNil =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A)). App(lmapf(f#), LNil(X)) = NONE(llist(X) * A): thm
val lmapf_def =
   {(A : set), (X : set), (f : fun(X, A))}, 
   |- !(a : mem(llist(X))).
        a# = LNil(X) & App(lmapf(f), a#) = NONE(llist(X) * A) |
        ?(lh : mem(X))  (lt : mem(llist(X))).
          a# = LCons(lh#, lt#) &
          App(lmapf(f), a#) = SOME(Pair(lt#, App(f, lh#))): thm
val lmapf_LCons =
   {(A : set), (X : set)}, 
   |- !(f : fun(X, A))  (lh : mem(X))  (lt : mem(llist(X))).
        App(lmapf(f#), LCons(lh#, lt#)) = SOME(Pair(lt#, App(f#, lh#))): thm
val LMAP_LNil =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y)). App(LMAP(f#), LNil(X)) = LNil(Y): thm
val LMAP_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        App(LMAP(f#), LCons(lh#, lt#)) =
          LCons(App(f#, lh#), App(LMAP(f#), lt#)): thm
val LMap_LNil =
   {(X : set), (Y : set)},  |- !(f : fun(X, Y)). LMap(f#, LNil(X)) = LNil(Y):
   thm
val LMap_LCons =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (lh : mem(X))  (lt : mem(llist(X))).
        LMap(f#, LCons(lh#, lt#)) = LCons(App(f#, lh#), LMap(f#, lt#)): thm
val LMap_functorial =
   {(X : set), (Y : set)}, 
   |- !(f : fun(X, Y))  (g : fun(Z, X))  (ll : mem(llist(Z))).
        LMap(f#, LMap(g#, ll#)) = LMap(f# o g#, ll#): thm
val it = (): unit
******

Loading SEAR file SEARGrp.sml

******
val Grp_def =
   {}, 
   |- !(G : set).
        Inj(iG(G#)) &
        !(a : mem(Exp((G# * G#), G#) * Exp(G#, G#) * G#)).
          isgrp(a#) <=> ?(b : mem(Grp(G#))). a# = App(iG(G#), b#): thm
val RepG_def = {(G : set), (g : mem(Grp(G)))},  |- RepG(g) = App(iG(G), g):
   thm
val RepG_isgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isgrp(RepG(g#)): thm
val asc_def =
   {(A : set), (m : fun(A * A, A))}, 
   |- asc(m) <=>
      !(a1 : mem(A))  (a2 : mem(A))  (a3 : mem(A)).
        mul(m, mul(m, a1#, a2#), a3#) = mul(m, a1#, mul(m, a2#, a3#)): thm
val isgrp_def =
   {(G : set), (g : mem(Exp((G * G), G) * Exp(G, G) * G))}, 
   |- isgrp(g) <=>
      asc(tof(c31(g))) &
      isunit(tof(c31(g)), c33(g)) & isinv(tof(c31(g)), tof(c32(g)), c33(g)):
   thm
val isinv_def =
   {(A : set), (e : mem(A)), (i : fun(A, A)), (m : fun(A * A, A))}, 
   |- isinv(m, i, e) <=>
      !(a : mem(A)). mul(m, App(i, a#), a#) = e & mul(m, a#, App(i, a#)) = e:
   thm
val isunit_def =
   {(A : set), (e : mem(A)), (m : fun(A * A, A))}, 
   |- isunit(m, e) <=> !(a : mem(A)). mul(m, e, a#) = a# & mul(m, a#, e) = a#:
   thm
val mul_def =
   {(G : set), (g1 : mem(G)), (g2 : mem(G)), (m : fun(G * G, G))}, 
   |- mul(m, g1, g2) = App(m, Pair(g1, g2)): thm
val Rnsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rnsg(g#)): thm
val eof_def = {(G : set), (g : mem(Grp(G)))},  |- eof(g) = c33(RepG(g)): thm
val ginv_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G))}, 
   |- ginv(g, x) = App(iof(g), x): thm
val gmul_def =
   {(G : set), (g : mem(Grp(G))), (x : mem(G)), (y : mem(G))}, 
   |- gmul(g, x, y) = mul(mof(g), x, y): thm
val iof_def = {(G : set), (g : mem(Grp(G)))},  |- iof(g) = tof(c32(RepG(g))):
   thm
val isghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (f : fun(G1#, G2#))
      (g2 : mem(Grp(G2#))).
        isghom(f#, g1#, g2#) <=>
        !(a : mem(G1#))  (b : mem(G1#)).
          App(f#, gmul(g1#, a#, b#)) = gmul(g2#, App(f#, a#), App(f#, b#)):
   thm
val isnml_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(sgrp(g)))}, 
   |- isnml(h) <=> !(a : mem(G)). rcs(h, a#) = lcs(a#, h): thm
val issgrp_def =
   {(G : set), (g : mem(Grp(G))), (h : mem(Pow(G)))}, 
   |- issgrp(h, g) <=>
      IN(eof(g), h) &
      (!(a : mem(G))  (b : mem(G)).
          IN(a#, h) & IN(b#, h) ==> IN(gmul(g, a#, b#), h)) &
      !(a : mem(G)). IN(a#, h) ==> IN(ginv(g, a#), h): thm
val lcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, lcs(a, H)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, a, h#): thm
val lsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (x : mem(G#))
      (a : mem(G#)).
        IN(a#, lsmul(g#, x#, s#)) <=>
        ?(y : mem(G#)). IN(y#, s#) & a# = gmul(g#, x#, y#): thm
val mof_def = {(G : set), (g : mem(Grp(G)))},  |- mof(g) = tof(c31(RepG(g))):
   thm
val nsg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(sgrp(g))).
        (?(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#) <=>
        ?!(a : mem(nsgrp(g))). App(Rnsg(g), a#) = b#: thm
val nsg_uex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(sgrp(g#))).
        isnml(a#) ==> ?!(a : mem(nsgrp(g#))). App(Rnsg(g#), a#) = a#: thm
val nsgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))).
        Inj(Rnsg(g#)) &
        !(a : mem(sgrp(g#))).
          isnml(a#) <=> ?(b : mem(nsgrp(g#))). a# = App(Rnsg(g#), b#): thm
val rcs_def =
   {(G : set), (H : mem(sgrp(g))), (a : mem(G)), (g : mem(Grp(G)))}, 
   |- !(a' : mem(G)).
        IN(a'#, rcs(H, a)) <=>
        ?(h : mem(G)). IN(h#, rsg(H)) & a'# = gmul(g, h#, a): thm
val rcs_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        rcs(H#, a#) = rsmul(g#, rsg(H#), a#): thm
val rsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        rsg(H#) = App(Rsg(g#), H#): thm
val rsmul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (y : mem(G#))
      (a : mem(G#)).
        IN(a#, rsmul(g#, s#, y#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = gmul(g#, x#, y#): thm
val sgrp_def =
   {(G : set), (g : mem(Grp(G)))}, 
   |- Inj(Rsg(g)) &
      !(a : mem(Pow(G))).
        issgrp(a#, g) <=> ?(b : mem(sgrp(g))). a# = App(Rsg(g), b#): thm
val lcs_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (a : mem(G#)).
        lcs(a#, H#) = lsmul(g#, a#, rsg(H#)): thm
val Rsg_Inj = {},  |- !(G : set)  (g : mem(Grp(G#))). Inj(Rsg(g#)): thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val sg_ex_uex =
   {(G : set), (g : mem(Grp(G)))}, 
   |- !(b : mem(Pow(G))).
        (?(a : mem(sgrp(g))). App(Rsg(g), a#) = b#) <=>
        ?!(a : mem(sgrp(g))). App(Rsg(g), a#) = b#: thm
val sg_uex =
   {}, 
   |- !(G : set)  (a : mem(Pow(G#)))  (g : mem(Grp(G#))).
        issgrp(a#, g#) ==> ?!(a : mem(sgrp(g#))). App(Rsg(g#), a#) = a#: thm
val gmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, a#, eof(g#)) = a# & gmul(g#, eof(g#), a#) = a#: thm
val gmul_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        gmul(g#, ginv(g#, a#), a#) = eof(g#) &
        gmul(g#, a#, ginv(g#, a#)) = eof(g#): thm
val asc_mof = {},  |- !(G : set)  (g : mem(Grp(G#))). asc(mof(g#)): thm
val gmul_assoc =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (c : mem(G#)).
        gmul(g#, gmul(g#, a#, b#), c#) = gmul(g#, a#, gmul(g#, b#, c#)): thm
val gmul_lcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, x#, y#) = gmul(g#, x#, z#) <=> y# = z#: thm
val gmul_rcancel =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (x : mem(G#))  (y : mem(G#))
      (z : mem(G#)). gmul(g#, y#, x#) = gmul(g#, z#, x#) <=> y# = z#: thm
val is_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        a1# = ginv(g#, a#) <=>
        gmul(g#, a#, a1#) = eof(g#) | gmul(g#, a1#, a#) = eof(g#): thm
val ginv_e =
   {},  |- !(G : set)  (g : mem(Grp(G#))). ginv(g#, eof(g#)) = eof(g#): thm
val e_sgrp =
   {},  |- !(G : set)  (g : mem(Grp(G#))). issgrp(Sing(eof(g#)), g#): thm
val esg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#))). App(Rsg(g#), esg(g#)) = Sing(eof(g#)):
   thm
val rsg_esg =
   {},  |- !(G : set)  (g : mem(Grp(G#))). rsg(esg(g#)) = Sing(eof(g#)): thm
val e_nsgrp = {},  |- !(G : set)  (g : mem(Grp(G#))). isnml(esg(g#)): thm
val ensg_def =
   {},  |- !(G : set)  (g : mem(Grp(G#))). App(Rnsg(g#), ensg(g#)) = esg(g#):
   thm
val nsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(sgrp(g#))).
        nsg(h#) = App(LINV(Rnsg(g#), ensg(g#)), h#): thm
val qgR_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        Holds(qgR(H#), a#, b#) <=> lcs(a#, rnsg(H#)) = lcs(b#, rnsg(H#)): thm
val rnsg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rnsg(H#) = App(Rnsg(g#), H#): thm
val qgR_Refl =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Refl(qgR(H#)):
   thm
val qgR_Sym =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Sym(qgR(H#)):
   thm
val qgR_Trans =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Trans(qgR(H#)):
   thm
val qgR_ER =
   {},  |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). ER(qgR(H#)):
   thm
val css_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Inj(Rcss(H#)) &
        !(a : mem(Pow(G#))).
          (?(a : mem(G#)). a# = rsi(qgR(H#), a#)) <=>
          ?(b : mem(css(H#))). a# = App(Rcss(H#), b#): thm
val Rcss_Inj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Inj(Rcss(H#)):
   thm
val rcss_def =
   {(G : set), (H : mem(nsgrp(g))), (cs : mem(css(H))), (g : mem(Grp(G)))}, 
   |- rcss(cs) = App(Rcss(H), cs): thm
val rcss_eq_eq =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (a : mem(css(H#)))  (b : mem(css(H#))). rcss(a#) = rcss(b#) <=> a# = b#:
   thm
val mem_css_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ?!(a : mem(css(H#))). rcss(a#) = rsi(qgR(H#), eof(g#)): thm
val Quot_qgR_Rcss =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(qgR(H#), Rcss(H#)): thm
val cs_def =
   {}, 
   |- !(G : set)  (a : mem(G#))  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        cs(a#, H#) = abs(qgR(H#), Rcss(H#), ecs(H#), a#): thm
val ecs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        rcss(ecs(H#)) = rsi(qgR(H#), eof(g#)): thm
val rcss_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcss(cs(a#, H#)) = rsi(qgR(H#), a#): thm
val nsgrp_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val nsgrp_swap_l2r =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, a#, h#) = gmul(g#, h#, a#): thm
val smul_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, smul(g#, s1#, s2#)) <=>
        ?(x : mem(G#))  (y : mem(G#)).
          IN(x#, s1#) & IN(y#, s2#) & a# = gmul(g#, x#, y#): thm
val nsgrp_swap_r2l =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(rnsg(H#))) ==>
        !(a : mem(G#)).
          ?(h : mem(G#)).
            IN(h#, rsg(rnsg(H#))) & gmul(g#, h#, a#) = gmul(g#, a#, h#): thm
val rsg_issgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        issgrp(rsg(H#), g#): thm
val e_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        IN(eof(g#), rsg(H#)): thm
val gmul_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h1 : mem(G#)).
        IN(h1#, rsg(H#)) ==>
        !(h2 : mem(G#)). IN(h2#, rsg(H#)) ==> IN(gmul(g#, h1#, h2#), rsg(H#)):
   thm
val ginv_IN_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#)))  (h : mem(G#)).
        IN(h#, rsg(H#)) ==> IN(ginv(g#, h#), rsg(H#)): thm
val gmul_lcs_smul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        lcs(gmul(g#, a#, b#), rnsg(H#)) =
          smul(g#, lcs(a#, rnsg(H#)), lcs(b#, rnsg(H#))): thm
val mof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o mof(g#),
       prrel(qgR(H#), qgR(H#))): thm
val prrel_qgR_ER =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ER(prrel(qgR(H#), qgR(H#))): thm
val qgR_Rcss_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        Quot(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#))): thm
val qgR_Rcss_abs_cong =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        abs(prrel(qgR(H#), qgR(H#)), ipow2(Rcss(H#), Rcss(H#)),
           Pair(ecs(H#), ecs(H#)), Pair(a#, b#)) =
          Pair(abs(qgR(H#), Rcss(H#), ecs(H#), a#),
           abs(qgR(H#), Rcss(H#), ecs(H#), b#)): thm
val ginv_oneside =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (a1 : mem(G#)).
        gmul(g#, a#, a1#) = eof(g#) <=> gmul(g#, a1#, a#) = eof(g#): thm
val mulcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        mul(mulcs(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val sinv_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, sinv(g#, s#)) <=>
        ?(x : mem(G#)). IN(x#, s#) & a# = ginv(g#, x#): thm
val is_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        a# = eof(g#) <=>
        (?(x : mem(G#)). gmul(g#, a#, x#) = x#) |
        ?(x : mem(G#)). gmul(g#, x#, a#) = x#: thm
val ginv_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#)).
        ginv(g#, gmul(g#, a#, b#)) = gmul(g#, ginv(g#, b#), ginv(g#, a#)):
   thm
val ginv_ginv =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#)).
        ginv(g#, ginv(g#, a#)) = a#: thm
val ginv_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        lcs(ginv(g#, a#), rnsg(H#)) = sinv(g#, lcs(a#, rnsg(H#))): thm
val iof_resp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        resp1(Abs(qgR(H#), Rcss(H#), ecs(H#)) o iof(g#), qgR(H#)): thm
val invcs_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(invcs(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_Surj =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). Surj(qmap(H#)):
   thm
val qmap_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qmap(H#) = Abs(qgR(H#), Rcss(H#), ecs(H#)): thm
val css_rep_ex =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))
      (b : mem(css(H#))). ?(a : mem(G#)). b# = cs(a#, H#): thm
val ecs_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        ecs(H#) = cs(eof(g#), H#): thm
val mulcs_invcs_ecs_isgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isgrp(Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#)))): thm
val mof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        mof(qgrp(H#)) = mulcs(H#): thm
val qgrp_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        RepG(qgrp(H#)) = Pair(Tpm(mulcs(H#)), Pair(Tpm(invcs(H#)), ecs(H#))):
   thm
val iof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        iof(qgrp(H#)) = invcs(H#): thm
val eof_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        eof(qgrp(H#)) = ecs(H#): thm
val gmul_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        gmul(qgrp(H#), cs(a#, H#), cs(b#, H#)) = cs(gmul(g#, a#, b#), H#):
   thm
val ginv_qgrp =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : set). ginv(qgrp(H#), cs(a#, H#)) = cs(ginv(g#, a#), H#): thm
val qmap_cs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        App(qmap(H#), a#) = cs(a#, H#): thm
val qmap_isghom =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        isghom(qmap(H#), g#, qgrp(H#)): thm
val constf_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        isghom(constf(G1#, eof(g2#)), g1#, g2#): thm
val ghom_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)) &
        !(a : mem(Exp(G1#, G2#))).
          isghom(tof(a#), g1#, g2#) <=>
          ?(b : mem(ghom(g1#, g2#))). a# = App(ih(g1#, g2#), b#): thm
val ghom_ex_uex =
   {(G1 : set), (G2 : set), (g1 : mem(Grp(G1))), (g2 : mem(Grp(G2)))}, 
   |- !(b : mem(Exp(G1, G2))).
        (?(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#) <=>
        ?!(a : mem(ghom(g1, g2))). App(ih(g1, g2), a#) = b#: thm
val ghom_uex =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (a : mem(Exp(G1#, G2#))).
        isghom(tof(a#), g1#, g2#) ==>
        ?!(a : mem(ghom(g1#, g2#))). App(ih(g1#, g2#), a#) = a#: thm
val ih_Inj =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        Inj(ih(g1#, g2#)): thm
val eghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#))).
        App(ih(g1#, g2#), eghm(g1#, g2#)) = Tpm(constf(G1#, eof(g2#))): thm
val ghm_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : fun(G1#, G2#)).
        ghm(h#, g1#, g2#) = App(LINV(ih(g1#, g2#), eghm(g1#, g2#)), Tpm(h#)):
   thm
val homfun_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (h : mem(ghom(g1#, g2#))). homfun(h#) = tof(App(ih(g1#, g2#), h#)): thm
val isghom_homfun_ghm =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : fun(G1#, G2#)).
        isghom(f#, g1#, g2#) <=> homfun(ghm(f#, g1#, g2#)) = f#: thm
val IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#)).
        IN(x#, kers(f#)) <=> App(homfun(f#), x#) = eof(g2#): thm
val ker_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). ker(f#) = nsg(sg(kers(f#), g1#)): thm
val kers_def =
   {(G1 : set), (G2 : set), (f : mem(ghom(g1, g2))), (g1 : mem(Grp(G1))),
    (g2 : mem(Grp(G2)))},  |- kers(f) = PREIM(homfun(f), Sing(eof(g2))): thm
val sg_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (h : mem(Pow(G#))).
        sg(h#, g#) = App(LINV(Rsg(g#), esg(g#)), h#): thm
val homfun_isghom =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isghom(homfun(f#), g1#, g2#): thm
val homfun_gmul =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (x : mem(G1#))  (y : mem(G1#)).
        App(homfun(f#), gmul(g1#, x#, y#)) =
          gmul(g2#, App(homfun(f#), x#), App(homfun(f#), y#)): thm
val homfun_e =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). App(homfun(f#), eof(g1#)) = eof(g2#): thm
val homfun_ginv =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a : mem(G1#)).
        App(homfun(f#), ginv(g1#, a#)) = ginv(g2#, App(homfun(f#), a#)): thm
val e_IN_kers =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). IN(eof(g1#), kers(f#)): thm
val kers_issgrp =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). issgrp(kers(f#), g1#): thm
val cjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (h : mem(G))}, 
   |- cjg(g, a, h) = gmul(g, a, gmul(g, h, ginv(g, a))): thm
val lsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (b : mem(G#))
      (s : mem(Pow(G#))).
        lsmul(g#, a#, lsmul(g#, b#, s#)) = lsmul(g#, gmul(g#, a#, b#), s#):
   thm
val qhom_def =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        qhom(H#) = ghm(qmap(H#), g#, qgrp(H#)): thm
val rsmul_gmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        rsmul(g#, rsmul(g#, s#, a#), b#) = rsmul(g#, s#, gmul(g#, a#, b#)):
   thm
val lsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        lsmul(g#, eof(g#), s#) = s#: thm
val rsmul_e =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s : mem(Pow(G#))).
        rsmul(g#, s#, eof(g#)) = s#: thm
val lsmul_rsmul_comm =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#)))
      (b : mem(G#)).
        rsmul(g#, lsmul(g#, a#, s#), b#) = lsmul(g#, a#, rsmul(g#, s#, b#)):
   thm
val isnml_alt =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). scjg(g#, a#, rsg(H#)) = rsg(H#): thm
val scjg_def =
   {(G : set), (a : mem(G)), (g : mem(Grp(G))), (s : mem(Pow(G)))}, 
   |- scjg(g, a, s) = lsmul(g, a, rsmul(g, s, ginv(g, a))): thm
val scjg_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (H : mem(Pow(G#)))
      (x : mem(G#)).
        IN(x#, scjg(g#, a#, H#)) <=>
        ?(h : mem(G#)). IN(h#, H#) & x# = cjg(g#, a#, h#): thm
val SS_scjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (a : mem(G#))  (s : mem(Pow(G#))).
        SS(scjg(g#, a#, s#), s#) <=>
        !(x : mem(G#)). IN(x#, s#) ==> IN(cjg(g#, a#, x#), s#): thm
val SS_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(rsmul(g#, s1#, a#), rsmul(g#, s2#, a#)): thm
val SS_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        !(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val isnml_cjg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> !(a : mem(G#)). SS(scjg(g#, a#, rsg(H#)), rsg(H#)): thm
val IN_gmul_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#)).
        IN(a#, H#) <=>
        !(b : mem(G#)). IN(gmul(g#, a#, b#), rsmul(g#, H#, b#)): thm
val IN_gmul_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (b : mem(G#)).
        IN(b#, H#) <=>
        !(a : mem(G#)). IN(gmul(g#, a#, b#), lsmul(g#, a#, H#)): thm
val gmul_IN_rsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val gmul_IN_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#)))  (a : mem(G#))
      (b : mem(G#)).
        IN(gmul(g#, a#, b#), H#) <=> IN(a#, rsmul(g#, H#, ginv(g#, b#))): thm
val rnsg_isnml =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))). isnml(rnsg(H#)):
   thm
val rnsg_rcs_lcs =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#)).
        rcs(rnsg(H#), a#) = lcs(a#, rnsg(H#)): thm
val SS_ex_lsmul =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (s1 : mem(Pow(G#)))
      (s2 : mem(Pow(G#))).
        SS(s1#, s2#) <=>
        ?(a : mem(G#)). SS(lsmul(g#, a#, s1#), lsmul(g#, a#, s2#)): thm
val same_cs_cond =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#)))  (a : mem(G#))
      (b : mem(G#)).
        cs(a#, H#) = cs(b#, H#) <=>
        IN(gmul(g#, a#, ginv(g#, b#)), rsg(rnsg(H#))): thm
val sg_rsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        sg(rsg(H#), g#) = H#: thm
val nsg_rnsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(nsgrp(g#))).
        nsg(rnsg(H#)) = H#: thm
val issgrp_rsg_sg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(Pow(G#))).
        issgrp(H#, g#) <=> rsg(sg(H#, g#)) = H#: thm
val isnml_rnsg_nsg =
   {}, 
   |- !(G : set)  (g : mem(Grp(G#)))  (H : mem(sgrp(g#))).
        isnml(H#) <=> rnsg(nsg(H#)) = H#: thm
val sg_kers_isnml =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). isnml(sg(kers(f#), g1#)): thm
val rsg_rnsg_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rsg(rnsg(ker(f#))) = kers(f#): thm
val rgh_def =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). rgh(f#) = App(ih(g1#, g2#), f#): thm
val rgh_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        rgh(f1#) = rgh(f2#) <=> f1# = f2#: thm
val homfun_eq_eq =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f1 : mem(ghom(g1#, g2#)))  (f2 : mem(ghom(g1#, g2#))).
        homfun(f1#) = homfun(f2#) <=> f1# = f2#: thm
val homfun_eq_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#)))  (a1 : mem(G1#))  (a2 : mem(G1#)).
        App(homfun(f#), a1#) = App(homfun(f#), a2#) <=>
        App(homfun(f#), gmul(g1#, ginv(g1#, a1#), a2#)) = eof(g2#): thm
val homfun_resp1_qgR_ker =
   {}, 
   |- !(G1 : set)  (g1 : mem(Grp(G1#)))  (G2 : set)  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))). resp1(homfun(f#), qgR(ker(f#))): thm
val first_iso_thm =
   {}, 
   |- !(G1 : set)  (G2 : set)  (g1 : mem(Grp(G1#)))  (g2 : mem(Grp(G2#)))
      (f : mem(ghom(g1#, g2#))).
        ?!(fb : mem(ghom(qgrp(ker(f#)), g2#))).
          Inj(homfun(fb#)) & homfun(fb#) o qmap(ker(f#)) = homfun(f#): thm
val it = (): unit
******

Loading SEAR file SEARexamplecol.sml

******
val AX5 =
   {}, 
   |- !(A : set).
        ?(B : set)  (p : fun(B#, A#))  (Y : set)  (M : rel(B#, Y#)).
          (!(S : set)  (i : fun(S#, Y#))  (b : mem(B#)).
              isset(i#, rsi(M#, b#)) ==> P(App(p#, b#), S#)) &
          !(a : mem(A#))  (X : set).
            P(a#, X#) ==> ?(b : mem(B#)). App(p#, b#) = a#: thm
val cardeq_REFL = {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, s#): thm
val cardeq_def =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=>
      ?(R : rel(A, B)).
        (!(a : mem(A)).
            IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R#, a#, b#)) &
        !(b : mem(B)).
          IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R#, a#, b#): thm
val isset_def =
   {(A : set), (B : set), (bs : mem(Pow(B))), (i : fun(A, B))}, 
   |- isset(i, bs) <=> Inj(i) & IMAGE(i, Whole(A)) = bs: thm
val cardeq_SYM =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(s2#, s1#): thm
val cardeq_TRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#))).
          cardeq(s2#, s3#) ==> cardeq(s1#, s3#): thm
val restrict_def =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (R : rel(A#, B#))
      (s2 : mem(Pow(B#)))  (a : mem(A#))  (b : mem(B#)).
        Holds(restrict(R#, s1#, s2#), a#, b#) <=>
        IN(a#, s1#) & IN(b#, s2#) & Holds(R#, a#, b#): thm
val cardeq_Whole_Inj_ex =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set).
        cardeq(s#, Whole(B#)) ==>
        ?(i : fun(B#, A#)). Inj(i#) & IMAGE(i#, Whole(B#)) = s#: thm
val cardeq_Inj_IMAGE =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> cardeq(Whole(A#), IMAGE(f#, Whole(A#))): thm
val Inj_Image =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)). Inj(f#) ==> Inj(Image(f#)):
   thm
val IMAGE_INJ_cardeq =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#)))
      (f : fun(A#, B#)).
        INJ(f#, s1#, s2#) ==>
        !(s01 : mem(Pow(A#))).
          SS(s01#, s1#) ==> cardeq(s01#, IMAGE(f#, s01#)): thm
val INJ_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#)))  (B : set)  (f : fun(A#, B#))
      (t : mem(Pow(B#))).
        INJ(f#, s#, t#) <=>
        (!(x : mem(A#)). IN(x#, s#) ==> IN(App(f#, x#), t#)) &
        !(x : mem(A#))  (y : mem(A#)).
          IN(x#, s#) & IN(y#, s#) ==> App(f#, x#) = App(f#, y#) ==> x# = y#:
   thm
val Inj_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). INJ(f#, s#, IMAGE(f#, s#)): thm
val INJ_SS_dom =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(A#))). SS(s#, s1#) ==> INJ(f#, s#, s2#): thm
val INJ_SS_cod =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(s : mem(Pow(B#))). SS(s2#, s#) ==> INJ(f#, s1#, s#): thm
val o_INJ_INJ =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(B#))).
        INJ(f#, s1#, s2#) ==>
        !(C : set)  (g : fun(B#, C#))  (s3 : mem(Pow(C#))).
          INJ(g#, s2#, s3#) ==> INJ(g# o f#, s1#, s3#): thm
val cardeq_Inj_IMAGE_gen =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(s : mem(Pow(A#))). cardeq(s#, IMAGE(f#, s#)): thm
val INJ_INS_NONE =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X# + 1)))).
        (!(s0 : mem(Pow(X# + 1))). IN(s0#, s#) ==> ~IN(NONE(X#), s0#)) ==>
        INJ(INS(NONE(X#)), s#, IMAGE(INS(NONE(X#)), s#)): thm
val INS_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (a : mem(Pow(X#))).
        App(INS(x0#), a#) = Ins(x0#, a#): thm
val POW_Whole_Pow = {},  |- !(A : set). POW(Whole(A#)) = Whole(Pow(A#)): thm
val POW_def =
   {}, 
   |- !(A : set)  (s0 : mem(Pow(A#)))  (a : mem(Pow(A#))).
        IN(a#, POW(s0#)) <=> SS(a#, s0#): thm
val cardeq_POW_Whole_Pow =
   {},  |- !(A : set). cardeq(POW(Whole(A#)), Whole(Pow(A#))): thm
val FIB_constf =
   {}, 
   |- !(A : set)  (B : set)  (b : mem(B#)).
        FIB(constf(A#, b#), b#) = Whole(A#): thm
val nPow_def =
   {}, 
   |- !(A : set)  (B : set)  (n : mem(N)).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)).
          cardeq(FIB(f#, O), Whole(A#)) &
          cardeq(FIB(f#, n#), Whole(B#)) &
          !(n0 : mem(N)).
            Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPow_O = {},  |- !(A : set). nPow(O, A#, A#): thm
val OE_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- OE(f, b0) = coPa(f, El(b0)): thm
val Sg_Sing = {},  |- !(A : set)  (a : mem(A#)). Sing(a#) = App(Sg(A#), a#):
   thm
val Sgf_def =
   {(A : set), (B : set), (b0 : mem(B)), (f : fun(A, B))}, 
   |- (!(a : mem(A)). App(Sgf(f, b0), Sing(a#)) = App(f, a#)) &
      !(s : mem(Pow(A))).
        (!(a : mem(A)). ~s# = Sing(a#)) ==> App(Sgf(f, b0), s#) = b0: thm
val content_Sing =
   {}, 
   |- !(X : set)  (x0 : mem(X#))  (x : mem(X#)).
        App(content(x0#), Sing(x#)) = x#: thm
val content_def =
   {}, 
   |- !(X : set)  (x0 : mem(X#)).
        (!(s : mem(Pow(X#)))  (x : mem(X#)).
            s# = Sing(x#) ==> App(content(x0#), s#) = x#) &
        !(s : mem(Pow(X#))).
          (!(x : mem(X#)). ~s# = Sing(x#)) ==> App(content(x0#), s#) = x0#:
   thm
val ctt_def =
   {}, 
   |- !(X : set)  (s : mem(Pow(X#)))  (x0 : mem(X#)).
        ctt(s#, x0#) = App(content(x0#), s#): thm
val PREIM_i1_Sing_SOME =
   {(X : set), (x0 : mem(X))},  |- PREIM(i1(X, 1), Sing(SOME(x0))) = Sing(x0):
   thm
val IMAGE_Sing =
   {(A : set), (B : set), (a : mem(A)), (f : fun(A, B))}, 
   |- IMAGE(f, Sing(a)) = Sing(App(f, a)): thm
val ctt_Sing =
   {},  |- !(A : set)  (a0 : mem(A#))  (a : mem(A#)). ctt(Sing(a#), a0#) = a#:
   thm
val Sing_SOME_NEQ_Ins_NONE =
   {}, 
   |- !(A : set)  (a : mem(A#))  (s : mem(Pow(A# + 1))).
        ~Sing(SOME(a#)) = Ins(NONE(A#), s#): thm
val SS_Ri_restrict =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (a : mem(Pow(A#)))  (B : set)
      (R : rel(A#, B#))  (s2 : mem(Pow(B#))).
        SS(App(Ri(restrict(R#, s1#, s2#)), a#), s2#): thm
val biunique_def =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) <=>
      (!(a : mem(A)).
          IN(a#, s1) ==> ?!(b : mem(B)). IN(b#, s2) & Holds(R, a#, b#)) &
      !(b : mem(B)).
        IN(b#, s2) ==> ?!(a : mem(A)). IN(a#, s1) & Holds(R, a#, b#): thm
val nPow_Suc_ex_lemma =
   {}, 
   |- !(C : set)  (X : set)  (i : fun(C#, Pow(X#))).
        Inj(i#) ==>
        !(B : set)  (f : fun(X#, B#))  (bs : mem(Pow(B#)))  (b0 : mem(B#)).
          (!(x : mem(X#)). ~App(f#, x#) = b0#) ==>
          ~IN(b0#, bs#) ==>
          !(b1 : mem(B#)).
            ~b1# = b0# & ~IN(b1#, bs#) ==>
            ?(f1 : fun(Pow(X# + 1), B#)).
              (!(b : mem(B#)).
                  IN(b#, bs#) ==>
                  FIB(f1#, b#) = IMAGE(Sg(X# + 1) o i1(X#, 1), FIB(f#, b#))) &
              FIB(f1#, b0#) =
                IMAGE(INS(NONE(X#)) o Image(i1(X#, 1)) o i#, Whole(C#)): thm
val biunique_op =
   {(A : set), (B : set)}, 
   |- !(R : rel(A, B))  (s1 : mem(Pow(A)))  (s2 : mem(Pow(B))).
        biunique(R#, s1#, s2#) ==> biunique(op(R#), s2#, s1#): thm
val biunique_Ri_restrict =
   {(A : set), (B : set), (R : rel(A, B)), (s1 : mem(Pow(A))),
    (s2 : mem(Pow(B)))}, 
   |- biunique(R, s1, s2) ==>
      !(s : mem(Pow(A))).
        SS(s#, s1) ==>
        App(Ri(restrict(op(R), s2, s1)), App(Ri(restrict(R, s1, s2)), s#)) =
          s#: thm
val cardeq_POW =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==> cardeq(POW(s1#), POW(s2#)): thm
val cardeq_biunique =
   {(A : set), (B : set), (s1 : mem(Pow(A))), (s2 : mem(Pow(B)))}, 
   |- cardeq(s1, s2) <=> ?(R : rel(A, B)). biunique(R#, s1, s2): thm
val cardeq_BITRANS =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (B : set)  (s2 : mem(Pow(B#))).
        cardeq(s1#, s2#) ==>
        !(C : set)  (s3 : mem(Pow(C#)))  (D : set)  (s4 : mem(Pow(D#))).
          cardeq(s3#, s4#) ==> (cardeq(s1#, s3#) <=> cardeq(s2#, s4#)): thm
val NONE_NOTIN_IMAGE_i1 =
   {}, 
   |- !(X : set)  (s : mem(Pow(Pow(X#))))  (s0 : mem(Pow(X# + 1))).
        IN(s0#, IMAGE(Image(i1(X#, 1)), s#)) ==> ~IN(NONE(X#), s0#): thm
val shrink_IMAGE =
   {}, 
   |- !(X : set)  (B : set)  (f0 : fun(X#, B#))  (s : mem(Pow(B#)))
      (b0 : mem(B#)).
        ~IN(b0#, s#) ==>
        (!(b : mem(B#)).
            IN(b#, s#) ==> FIB(shrink(f0#, s#, b0#), b#) = FIB(f0#, b#)) &
        !(x : mem(X#)).
          ~IN(App(f0#, x#), s#) ==> App(shrink(f0#, s#, b0#), x#) = b0#: thm
val shrink_def =
   {(B : set), (X : set), (b0 : mem(B)), (f0 : fun(X, B)), (s : mem(Pow(B)))},
   
   |- !(a : mem(X)).
        (IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = App(f0, a#)) &
        (~IN(App(f0, a#), s) ==> App(shrink(f0, s, b0), a#) = b0): thm
val nPow_shrink_IMAGE_ex =
   {(A : set), (An : set), (n : mem(N))}, 
   |- nPow(n, A, An) ==>
      ?(X : set)  (f : fun(X#, N)).
        cardeq(FIB(f#, O), Whole(A)) &
        cardeq(FIB(f#, n), Whole(An)) &
        (!(n0 : mem(N)).
            Lt(n0#, n) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#)))) &
        !(x : mem(X#)). ~App(f#, x#) = Suc(n): thm
val nPow_Suc =
   {(n : mem(N))}, 
   |- !(A : set)  (An : set). nPow(n, A#, An#) ==> nPow(Suc(n), A#, Pow(An#)):
   thm
val nPow_ex =
   {},  |- !(A : set)  (n : mem(N)). ?(An : set). nPow(n#, A#, An#): thm
val cardeq_m2s =
   {},  |- !(A : set)  (s : mem(Pow(A#))). cardeq(s#, Whole(m2s(s#))): thm
val m2s_def =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        Inj(minc(s#)) &
        !(a : mem(A#)).
          IN(a#, s#) <=> ?(b : mem(m2s(s#))). a# = App(minc(s#), b#): thm
val nPowf_def =
   {}, 
   |- !(A : set)  (B : set)  (X : set)  (f : fun(X#, N))  (n : mem(N)).
        nPowf(n#, A#, B#, f#) <=>
        cardeq(FIB(f#, O), Whole(A#)) &
        cardeq(FIB(f#, n#), Whole(B#)) &
        !(n0 : mem(N)).
          Lt(n0#, n#) ==> cardeq(POW(FIB(f#, n0#)), FIB(f#, Suc(n0#))): thm
val nPowf_Preds =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> ?(B0 : set). nPowf(n0#, A#, B0#, f#):
   thm
val nPowf_Preds_FIB =
   {(X : set)}, 
   |- !(A : set)  (n : mem(N))  (B : set)  (f : fun(X, N)).
        nPowf(n#, A#, B#, f#) ==>
        !(n0 : mem(N)). Le(n0#, n#) ==> nPowf(n0#, A#, m2s(FIB(f#, n0#)), f#):
   thm
val nPow_nPowf =
   {}, 
   |- !(A : set)  (n : mem(N))  (B : set).
        nPow(n#, A#, B#) <=>
        ?(X : set)  (f : fun(X#, N)). nPowf(n#, A#, B#, f#): thm
val nPow_unique =
   {}, 
   |- !(A : set)  (n : mem(N))  (An1 : set)  (An2 : set).
        nPow(n#, A#, An1#) & nPow(n#, A#, An2#) ==>
        cardeq(Whole(An1#), Whole(An2#)): thm
val nPow_uex =
   {}, 
   |- !(A : set)  (n : mem(N)).
        ?(An : set).
          nPow(n#, A#, An#) &
          !(An1 : set).
            nPow(n#, A#, An1#) ==> cardeq(Whole(An#), Whole(An1#)): thm
val Pn_def = {},  |- !(A : set)  (n : mem(N)). nPow(n#, A#, Pn(A#, n#)): thm
val cardeq_Whole_REFL = {},  |- !(An : set). cardeq(Whole(An#), Whole(An#)):
   thm
val cardeq_Whole_SYM =
   {}, 
   |- !(An : set)  (An' : set).
        cardeq(Whole(An#), Whole(An'#)) ==> cardeq(Whole(An'#), Whole(An#)):
   thm
val cardeq_Whole_TRANS =
   {}, 
   |- !(An : set)  (An' : set)  (An'' : set).
        cardeq(Whole(An#), Whole(An'#)) & cardeq(Whole(An'#), Whole(An''#)) ==>
        cardeq(Whole(An#), Whole(An''#)): thm
val isset_minc = {},  |- !(A : set)  (s : mem(Pow(A#))). isset(minc(s#), s#):
   thm
val large_ex =
   {}, 
   |- !(A : set).
        ?(P : set). !(n : mem(N)). ?(i : fun(Pn(A#, n#), P#)). Inj(i#): thm
val nPow_ts_ex = {},  |- !(A : set)  (n : mem(N)). ?(An : set). T: thm
val it = (): unit
val it = (): unit
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holVDXUw3Script.sml

******
val Inj_same_IMAGE =
   {}, 
   |- !(X : set)  (A1 : set)  (i1 : fun(A1#, X#))  (A2 : set)
      (i2 : fun(A2#, X#)).
        Inj(i1#) & Inj(i2#) & IMAGE(i1#, Whole(A1#)) = IMAGE(i2#, Whole(A2#)) ==>
        ?(f : fun(A1#, A2#))  (g : fun(A2#, A1#)).
          f# o g# = Id(A2#) &
          g# o f# = Id(A1#) & i2# o f# = i1# & i1# o g# = i2#: thm
val Inj_same_IMAGE_unique =
   {}, 
   |- !(X : set)  (A1 : set)  (i1 : fun(A1#, X#))  (A2 : set)
      (i2 : fun(A2#, X#)).
        Inj(i1#) & Inj(i2#) & IMAGE(i1#, Whole(A1#)) = IMAGE(i2#, Whole(A2#)) ==>
        ?!(f : fun(A1#, A2#)). i2# o f# = i1#: thm
val Bij_Inj =
   {},  |- !(A : set)  (B : set)  (f : fun(A#, B#)). Bij(f#) ==> Inj(f#): thm
val ex_mem_eq =
   {}, 
   |- (!(A : set)  (a : mem(A#)). ?(a0 : mem(A#)). a# = a0#) &
      (!(A : set)  (a : mem(A#)). ?(a0 : mem(A#)). a0# = a#) &
      (!(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
          ?(a0 : mem(A#)). App(f#, a0#) = App(f#, a#)) &
      !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#)).
        ?(a0 : mem(A#)). App(f#, a#) = App(f#, a0#): thm
val Inj_Pow_EXT =
   {}, 
   |- !(X : set)  (A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
      (R : rel(X#, X#)).
        Inj(i#) &
        Inj(pi#) &
        (!(ax : mem(X#))  (sx : mem(X#)).
            (?(a : mem(A#)). ax# = App(i#, a#)) &
            (?(s : mem(Pow(A#))). sx# = App(pi#, s#)) ==>
            (Holds(R#, ax#, sx#) <=>
              ?(a : mem(A#))  (s : mem(Pow(A#))).
                IN(a#, s#) & App(i#, a#) = ax# & App(pi#, s#) = sx#)) ==>
        !(sx1 : mem(X#))  (sx2 : mem(X#)).
          IN(sx1#, IMAGE(pi#, Whole(Pow(A#)))) &
          IN(sx2#, IMAGE(pi#, Whole(Pow(A#)))) ==>
          (sx1# = sx2# <=>
            !(ax : mem(X#)).
              IN(ax#, IMAGE(i#, Whole(A#))) ==>
              (Holds(R#, ax#, sx1#) <=> Holds(R#, ax#, sx2#))): thm
val Les_O_Sing = {},  |- Les(O) = Sing(O): thm
val Les_def =
   {},  |- !(n : mem(N))  (a : mem(N)). IN(a#, Les(n#)) <=> Le(a#, n#): thm
val Upows_def =
   {(R : rel(X, X)), (X : set), (n : mem(N)), (p : fun(X, N)),
    (z : fun(N, X))}, 
   |- Upows(n, p, R, z) <=>
      IMAGE(p, Whole(X)) = Les(n) &
      Inj(z) &
      IMAGE(z, Whole(N)) = FIB(p, O) &
      (!(n0 : mem(N)).
          Lt(n0#, n) ==>
          ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
      !(x : mem(X))  (s : mem(X)).
        Holds(R, x#, s#) <=>
        Lt(App(p, x#), n) &
        Suc(App(p, x#)) = App(p, s#) &
        ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))  (a : mem(A#))
        (sa : mem(Pow(A#))).
          Inj(i#) &
          Inj(pi#) &
          IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
          IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
          (!(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
          IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
val constf_iff_Sing =
   {}, 
   |- !(A : set).
        (?(a : mem(A#)). T) ==>
        !(B : set)  (f : fun(A#, B#))  (b : mem(B#)).
          IMAGE(f#, Whole(A#)) = Sing(b#) <=> f# = constf(A#, b#): thm
val IMAGE_constf =
   {}, 
   |- !(A : set)  (s : mem(Pow(A#))).
        ~s# = Empty(A#) ==>
        !(X : set)  (x : mem(X#)). IMAGE(constf(A#, x#), s#) = Sing(x#): thm
val Upows_O =
   {(R : rel(X, X)), (X : set), (p : fun(X, N)), (z : fun(N, X))}, 
   |- Upows(O, p, R, z) <=>
      IMAGE(z, Whole(N)) = FIB(p, O) &
      p = constf(X, O) &
      (!(x1 : mem(X))  (x2 : mem(X)). ~Holds(R, x1#, x2#)) & Bij(z): thm
val IMAGE_Id =
   {},  |- !(A : set)  (s : mem(Pow(A#))). IMAGE(Id(A#), s#) = s#: thm
val REmpty_def =
   {}, 
   |- !(A : set)  (a : mem(A#))  (b : mem(A#)). ~Holds(REmpty(A#), a#, b#):
   thm
val Id_Surj = {},  |- !(A : set). Surj(Id(A#)): thm
val Bij_Id = {},  |- !(A : set). Bij(Id(A#)): thm
val Upows_O_ex = {},  |- Upows(O, constf(N, O), REmpty(N), Id(N)): thm
val Apr_def =
   {}, 
   |- !(A : set)  (X : set)  (R0 : rel(X#, X#))  (f : fun(X#, A#))
      (a : mem(A#))  (b : mem(A#)).
        Holds(Apr(f#, R0#), a#, b#) <=>
        ?(x1 : mem(X#))  (x2 : mem(X#)).
          App(f#, x1#) = a# & App(f#, x2#) = b# & Holds(R0#, x1#, x2#): thm
val Inj_Pow_choice_independence =
   {}, 
   |- !(X : set)  (A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
      (R : rel(X#, X#)).
        Inj(i#) &
        Inj(pi#) &
        (!(ax : mem(X#))  (sx : mem(X#)).
            (?(a : mem(A#)). ax# = App(i#, a#)) &
            (?(s : mem(Pow(A#))). sx# = App(pi#, s#)) ==>
            (Holds(R#, ax#, sx#) <=>
              ?(a : mem(A#))  (s : mem(Pow(A#))).
                IN(a#, s#) & App(i#, a#) = ax# & App(pi#, s#) = sx#)) ==>
        !(A1 : set)  (i1 : fun(A1#, X#))  (pi1 : fun(Pow(A1#), X#)).
          Inj(i1#) &
          Inj(pi1#) &
          (!(ax : mem(X#))  (sx : mem(X#)).
              (?(a1 : mem(A1#)). ax# = App(i1#, a1#)) &
              (?(s1 : mem(Pow(A1#))). sx# = App(pi1#, s1#)) ==>
              (Holds(R#, ax#, sx#) <=>
                ?(a1 : mem(A1#))  (s1 : mem(Pow(A1#))).
                  IN(a1#, s1#) & App(i1#, a1#) = ax# & App(pi1#, s1#) = sx#)) &
          IMAGE(i#, Whole(A#)) = IMAGE(i1#, Whole(A1#)) &
          IMAGE(pi#, Whole(Pow(A#))) = IMAGE(pi1#, Whole(Pow(A1#))) ==>
          ?(f : fun(A#, A1#)).
            Bij(f#) & i1# o f# = i# & pi1# o Image(f#) = pi#: thm
val Upow_choice_independence =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n0 : mem(N)).
          Lt(n0#, n#) ==>
          ?(uA : set)  (ui : fun(uA#, X#))  (upi : fun(Pow(uA#), X#)).
            Inj(ui#) &
            Inj(upi#) &
            IMAGE(ui#, Whole(uA#)) = FIB(p#, n0#) &
            IMAGE(upi#, Whole(Pow(uA#))) = FIB(p#, Suc(n0#)) &
            (!(a : mem(uA#))  (s : mem(Pow(uA#))).
                Holds(R#, App(ui#, a#), App(upi#, s#)) <=> IN(a#, s#)) &
            !(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#)).
              Inj(i#) &
              Inj(pi#) &
              IMAGE(i#, Whole(A#)) = FIB(p#, n0#) &
              IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, Suc(n0#)) &
              (!(a : mem(A#))  (s : mem(Pow(A#))).
                  Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) ==>
              ?(f : fun(uA#, A#)).
                Bij(f#) & i# o f# = ui# & pi# o Image(f#) = upi#: thm
val FIB_PREIM_FIB =
   {}, 
   |- !(A1 : set)  (A2 : set)  (i : fun(A1#, A2#))  (X : set)
      (p1 : fun(A1#, X#))  (p2 : fun(A2#, X#)).
        p2# o i# = p1# ==>
        !(x : mem(X#)). FIB(p1#, x#) = PREIM(i#, FIB(p2#, x#)): thm
val Image_Id = {},  |- !(A : set). Image(Id(A#)) = Id(Pow(A#)): thm
val Upows_p1_O_iff_z1 =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(x : mem(X#)). (?(n : mem(N)). x# = App(z#, n#)) <=> App(p#, x#) = O:
   thm
val Upows_Le_n =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==> !(x : mem(X#)). Le(App(p#, x#), n#): thm
val Upows_Lt_i_ex =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n0 : mem(N)).
          Lt(n0#, n#) ==>
          ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p#, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#): thm
val IMAGE_eq_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s : mem(Pow(A#)))  (C : set)
      (p : fun(B#, C#))  (c : mem(C#)).
        IMAGE(f#, s#) = FIB(p#, c#) <=>
        !(b : mem(B#)).
          (?(a : mem(A#)). IN(a#, s#) & App(f#, a#) = b#) <=>
          App(p#, b#) = c#: thm
val Inj_Inj_o =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==> !(C : set)  (g : fun(B#, C#)). Inj(g#) ==> Inj(g# o f#):
   thm
val Inj_o_comm =
   {}, 
   |- !(X1 : set)  (X2 : set)  (f : fun(X1#, X2#)).
        Bij(f#) ==>
        !(B : set)  (p1 : fun(X1#, B#))  (p2 : fun(X2#, B#)).
          p2# o f# = p1# ==>
          !(A : set)  (i : fun(A#, X1#))  (b : mem(B#)).
            IMAGE(i#, Whole(A#)) = FIB(p1#, b#) ==>
            IMAGE(f# o i#, Whole(A#)) = FIB(p2#, b#): thm
val Inj_Apr =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
          Holds(Apr(f#, R#), App(f#, a1#), App(f#, a2#)) <=>
          Holds(R#, a1#, a2#): thm
val Bij_Apr =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Bij(f#) ==>
        !(R : rel(A#, A#))  (a1 : mem(A#))  (a2 : mem(A#)).
          Holds(Apr(f#, R#), App(f#, a1#), App(f#, a2#)) <=>
          Holds(R#, a1#, a2#): thm
val Upows_iso_unique =
   {}, 
   |- !(n : mem(N))  (X1 : set)  (p1 : fun(X1#, N))  (R1 : rel(X1#, X1#))
      (z1 : fun(N, X1#))  (X2 : set)  (p2 : fun(X2#, N))
      (R2 : rel(X2#, X2#))  (z2 : fun(N, X2#)).
        Upows(n#, p1#, R1#, z1#) & Upows(n#, p2#, R2#, z2#) ==>
        !(f1 : fun(X1#, X2#))  (f2 : fun(X1#, X2#)).
          Bij(f1#) &
          Bij(f2#) &
          p2# o f1# = p1# &
          R2# = Apr(f1#, R1#) &
          f1# o z1# = z2# &
          p2# o f2# = p1# & R2# = Apr(f2#, R1#) & f2# o z1# = z2# ==>
          f1# = f2#: thm
val IMAGE_Union =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (s1 : mem(Pow(A#)))
      (s2 : mem(Pow(A#))).
        IMAGE(f#, Union(s1#, s2#)) = Union(IMAGE(f#, s1#), IMAGE(f#, s2#)):
   thm
val IMAGE_coPa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (g : fun(B#, X#))
      (s : mem(Pow(A# + B#))).
        IMAGE(coPa(f#, g#), s#) =
          Union(IMAGE(f#, PREIM(i1(A#, B#), s#)),
           IMAGE(g#, PREIM(i2(A#, B#), s#))): thm
val PREIM_i12_Whole =
   {}, 
   |- !(A : set)  (B : set).
        PREIM(i1(A#, B#), Whole(A# + B#)) = Whole(A#) &
        PREIM(i2(A#, B#), Whole(A# + B#)) = Whole(B#): thm
val IMAGE_coPa_Whole =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (g : fun(B#, X#)).
        IMAGE(coPa(f#, g#), Whole(A# + B#)) =
          Union(IMAGE(f#, Whole(A#)), IMAGE(g#, Whole(B#))): thm
val Les_Suc = {},  |- !(n : mem(N)). Les(Suc(n#)) = Ins(Suc(n#), Les(n#)):
   thm
val Upows_z_Inj =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)). Upows(n#, p#, R#, z#) ==> Inj(z#): thm
val Upows_IMAGE_p =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==> IMAGE(p#, Whole(X#)) = Les(n#): thm
val Pow_NOT_EMPTY = {},  |- !(A : set). ?(s : mem(Pow(A#))). T: thm
val Union_comm =
   {}, 
   |- !(A : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        Union(s1#, s2#) = Union(s2#, s1#): thm
val EXISTS_EQN_FCONV = fn: form -> thm
val IN_FIB =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#))  (a : mem(A#))  (b : mem(B#)).
        IN(a#, FIB(f#, b#)) <=> App(f#, a#) = b#: thm
val FIB_constf_Empty =
   {}, 
   |- !(B : set)  (b0 : mem(B#))  (b : mem(B#)).
        ~b# = b0# ==> !(A : set). FIB(constf(A#, b0#), b#) = Empty(A#): thm
val Upows_IMAGE_z =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==> IMAGE(z#, Whole(N)) = FIB(p#, O): thm
val NOT_Suc_Le = {},  |- !(a : mem(N)). ~Le(Suc(a#), a#): thm
val NOT_ex_F = {},  |- !(A : set). (?(a : mem(A#)). F) <=> F: thm
val i1_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (a1 : mem(A#))  (a2 : mem(A#)).
        App(i1(A#, B#), a1#) = App(i1(A#, B#), a2#) <=> a1# = a2#: thm
val i2_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (b1 : mem(B#))  (b2 : mem(B#)).
        App(i2(A#, B#), b1#) = App(i2(A#, B#), b2#) <=> b1# = b2#: thm
val FIB_coPa =
   {}, 
   |- !(A : set)  (X : set)  (f : fun(A#, X#))  (B : set)  (g : fun(B#, X#))
      (x : mem(X#)).
        FIB(coPa(f#, g#), x#) =
          Union(IMAGE(i1(A#, B#), FIB(f#, x#)),
           IMAGE(i2(A#, B#), FIB(g#, x#))): thm
val Inj_IMAGE_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (f : fun(A#, B#)).
        Inj(f#) ==>
        !(s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
          IMAGE(f#, s1#) = IMAGE(f#, s2#) <=> s1# = s2#: thm
val i1_IMAGE_eq_eq =
   {}, 
   |- !(A : set)  (B : set)  (s1 : mem(Pow(A#)))  (s2 : mem(Pow(A#))).
        IMAGE(i1(A#, B#), s1#) = IMAGE(i1(A#, B#), s2#) <=> s1# = s2#: thm
val Upows_FIB_n_Lt_Empty =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(n1 : mem(N)). Lt(n#, n1#) ==> FIB(p#, n1#) = Empty(X#): thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> # val it =
   {(R : rel(X, X)), (X : set), (n : mem(N)), (p : fun(X, N)),
    (z : fun(N, X))}, 
   |- Upows(n, p, R, z) <=>
      IMAGE(p, Whole(X)) = Les(n) &
      Inj(z) &
      IMAGE(z, Whole(N)) = FIB(p, O) &
      (!(n0 : mem(N)).
          Lt(n0#, n) ==>
          ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
      !(x : mem(X))  (s : mem(X)).
        Holds(R, x#, s#) <=>
        Lt(App(p, x#), n) &
        Suc(App(p, x#)) = App(p, s#) &
        ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))  (a : mem(A#))
        (sa : mem(Pow(A#))).
          Inj(i#) &
          Inj(pi#) &
          IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
          IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
          (!(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
          IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
> val it = PRFS []: proofmanager.proofs
> # # # # # # # # # # # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
               (z : fun(N, X#)).
                 Upows(n#, p#, R#, z#) ==>
                 !(x : mem(X#))  (s : mem(X#)).
                   Holds(R#, x#, s#) <=>
                   Lt(App(p#, x#), n#) &
                   Suc(App(p#, x#)) = App(p#, s#) &
                   ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
                   (a : mem(A#))  (sa : mem(Pow(A#))).
                     Inj(i#) &
                     Inj(pi#) &
                     IMAGE(i#, Whole(A#)) = FIB(p#, App(p#, x#)) &
                     IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, App(p#, s#)) &
                     (!(a : mem(A#))  (s : mem(Pow(A#))).
                         Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                     IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(s : mem(X))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   ----------------------------------------------------------------------
   Holds(R, x, s) <=>
             Lt(App(p, x), n) &
             Suc(App(p, x)) = App(p, s) &
             ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
             (a : mem(A#))  (sa : mem(Pow(A#))).
               Inj(i#) &
               Inj(pi#) &
               IMAGE(i#, Whole(A#)) = FIB(p, App(p, x)) &
               IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s)) &
               (!(a : mem(A#))  (s : mem(Pow(A#))).
                   Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
               IN(a#, sa#) & App(i#, a#) = x & App(pi#, sa#) = s
   : proofmanager.proof
> # val it =
   {(R : rel(X, X)), (X : set), (n : mem(N)), (p : fun(X, N)),
    (z : fun(N, X))}, 
   |- Upows(n, p, R, z) <=>
      IMAGE(p, Whole(X)) = Les(n) &
      Inj(z) &
      IMAGE(z, Whole(N)) = FIB(p, O) &
      (!(n0 : mem(N)).
          Lt(n0#, n) ==>
          ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
      !(x : mem(X))  (s : mem(X)).
        Holds(R, x#, s#) <=>
        Lt(App(p, x#), n) &
        Suc(App(p, x#)) = App(p, s#) &
        ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))  (a : mem(A#))
        (sa : mem(Pow(A#))).
          Inj(i#) &
          Inj(pi#) &
          IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
          IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
          (!(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
          IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
> # poly: : error: Value or constructor (Upows_alt) has not been declared Found near Upows_alt
Static Errors
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(s : mem(X))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.IMAGE(p, Whole(X)) = Les(n) &
             Inj(z) &
             IMAGE(z, Whole(N)) = FIB(p, O) &
             (!(n0 : mem(N)).
                 Lt(n0#, n) ==>
                 ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
                   Inj(i#) &
                   Inj(pi#) &
                   IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
                   IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
                   !(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
             !(x : mem(X))  (s : mem(X)).
               Holds(R, x#, s#) <=>
               Lt(App(p, x#), n) &
               Suc(App(p, x#)) = App(p, s#) &
               ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
               (a : mem(A#))  (sa : mem(Pow(A#))).
                 Inj(i#) &
                 Inj(pi#) &
                 IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
                 IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
                 (!(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                 IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#
   ----------------------------------------------------------------------
   Holds(R, x, s) <=>
             Lt(App(p, x), n) &
             Suc(App(p, x)) = App(p, s) &
             ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
             (a : mem(A#))  (sa : mem(Pow(A#))).
               Inj(i#) &
               Inj(pi#) &
               IMAGE(i#, Whole(A#)) = FIB(p, App(p, x)) &
               IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s)) &
               (!(a : mem(A#))  (s : mem(Pow(A#))).
                   Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
               IN(a#, sa#) & App(i#, a#) = x & App(pi#, sa#) = s
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(s : mem(X))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.IMAGE(p, Whole(X)) = Les(n) &
             Inj(z) &
             IMAGE(z, Whole(N)) = FIB(p, O) &
             (!(n0 : mem(N)).
                 Lt(n0#, n) ==>
                 ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
                   Inj(i#) &
                   Inj(pi#) &
                   IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
                   IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
                   !(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
             !(x : mem(X))  (s : mem(X)).
               Holds(R, x#, s#) <=>
               Lt(App(p, x#), n) &
               Suc(App(p, x#)) = App(p, s#) &
               ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
               (a : mem(A#))  (sa : mem(Pow(A#))).
                 Inj(i#) &
                 Inj(pi#) &
                 IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
                 IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
                 (!(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                 IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#
   ----------------------------------------------------------------------
   Lt(App(p, x), n) &
             Suc(App(p, x)) = App(p, s) &
             (?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
               (a : mem(A#))  (sa : mem(Pow(A#))).
                 Inj(i#) &
                 Inj(pi#) &
                 IMAGE(i#, Whole(A#)) = FIB(p, App(p, x)) &
                 IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s)) &
                 (!(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                 IN(a#, sa#) & App(i#, a#) = x & App(pi#, sa#) = s) <=>
             Lt(App(p, x), n) &
             Suc(App(p, x)) = App(p, s) &
             ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
             (a : mem(A#))  (sa : mem(Pow(A#))).
               Inj(i#) &
               Inj(pi#) &
               IMAGE(i#, Whole(A#)) = FIB(p, App(p, x)) &
               IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s)) &
               (!(a : mem(A#))  (s : mem(Pow(A#))).
                   Lt(App(p, App(i#, a#)), n) &
                   Suc(App(p, App(i#, a#))) = App(p, App(pi#, s#)) &
                   (?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
                     (a : mem(A#))  (sa : mem(Pow(A#))).
                       Inj(i#) &
                       Inj(pi#) &
                       IMAGE(i#, Whole(A#)) = FIB(p, App(p, App(i#, a#))) &
                       IMAGE(pi#, Whole(Pow(A#))) =
                         FIB(p, App(p, App(pi#, s#))) &
                       (!(a : mem(A#))  (s : mem(Pow(A#))).
                           Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                       IN(a#, sa#) &
                       App(i#, a#) = App(i#, a#) &
                       App(pi#, sa#) = App(pi#, s#)) <=> IN(a#, s#)) &
               IN(a#, sa#) & App(i#, a#) = x & App(pi#, sa#) = s
   : proofmanager.proof
> val it =
   X(R : rel(X, X))(x : mem(X))(s : mem(X))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.IMAGE(p, Whole(X)) = Les(n) &
             Inj(z) &
             IMAGE(z, Whole(N)) = FIB(p, O) &
             (!(n0 : mem(N)).
                 Lt(n0#, n) ==>
                 ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
                   Inj(i#) &
                   Inj(pi#) &
                   IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
                   IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
                   !(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
             !(x : mem(X))  (s : mem(X)).
               Holds(R, x#, s#) <=>
               Lt(App(p, x#), n) &
               Suc(App(p, x#)) = App(p, s#) &
               ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
               (a : mem(A#))  (sa : mem(Pow(A#))).
                 Inj(i#) &
                 Inj(pi#) &
                 IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
                 IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
                 (!(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                 IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#
   ----------------------------------------------------------------------
   Holds(R, x, s) <=>
             Lt(App(p, x), n) &
             Suc(App(p, x)) = App(p, s) &
             ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
             (a : mem(A#))  (sa : mem(Pow(A#))).
               Inj(i#) &
               Inj(pi#) &
               IMAGE(i#, Whole(A#)) = FIB(p, App(p, x)) &
               IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s)) &
               (!(a : mem(A#))  (s : mem(Pow(A#))).
                   Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
               IN(a#, sa#) & App(i#, a#) = x & App(pi#, sa#) = s
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(s : mem(X))(n : mem(N))(z : fun(N, X))(p :
      fun(X, N))
   1.Upows(n, p, R, z)
   2.IMAGE(p, Whole(X)) = Les(n)
   3.Inj(z)
   4.IMAGE(z, Whole(N)) = FIB(p, O)
   5.!(n0 : mem(N)).
               Lt(n0#, n) ==>
               ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
                 Inj(i#) &
                 Inj(pi#) &
                 IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
                 IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
                 !(a : mem(A#))  (s : mem(Pow(A#))).
                   Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)
   6.!(x : mem(X))  (s : mem(X)).
               Holds(R, x#, s#) <=>
               Lt(App(p, x#), n) &
               Suc(App(p, x#)) = App(p, s#) &
               ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
               (a : mem(A#))  (sa : mem(Pow(A#))).
                 Inj(i#) &
                 Inj(pi#) &
                 IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
                 IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
                 (!(a : mem(A#))  (s : mem(Pow(A#))).
                     Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
                 IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#
   ----------------------------------------------------------------------
   Holds(R, x, s) <=>
             Lt(App(p, x), n) &
             Suc(App(p, x)) = App(p, s) &
             ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))
             (a : mem(A#))  (sa : mem(Pow(A#))).
               Inj(i#) &
               Inj(pi#) &
               IMAGE(i#, Whole(A#)) = FIB(p, App(p, x)) &
               IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s)) &
               (!(a : mem(A#))  (s : mem(Pow(A#))).
                   Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
               IN(a#, sa#) & App(i#, a#) = x & App(pi#, sa#) = s
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(x : mem(X#))  (s : mem(X#)).
          Holds(R#, x#, s#) <=>
          Lt(App(p#, x#), n#) &
          Suc(App(p#, x#)) = App(p#, s#) &
          ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
          (a : mem(A#))  (sa : mem(Pow(A#))).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p#, App(p#, x#)) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, App(p#, s#)) &
            (!(a : mem(A#))  (s : mem(Pow(A#))).
                Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
            IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#:
   proofmanager.proof
> ******

Loading SEAR file /var/folders/9w/ql5hx6p10fb3fgd9xvcn76p00000gn/T/holPqlEjJScript.sml

******
val Upows_R =
   {}, 
   |- !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
      (z : fun(N, X#)).
        Upows(n#, p#, R#, z#) ==>
        !(x : mem(X#))  (s : mem(X#)).
          Holds(R#, x#, s#) <=>
          Lt(App(p#, x#), n#) &
          Suc(App(p#, x#)) = App(p#, s#) &
          ?(A : set)  (i : fun(A#, X#))  (pi : fun(Pow(A#), X#))
          (a : mem(A#))  (sa : mem(Pow(A#))).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p#, App(p#, x#)) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p#, App(p#, s#)) &
            (!(a : mem(A#))  (s : mem(Pow(A#))).
                Holds(R#, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
            IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
val it = (): unit
> 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(a : mem(N))  (b : mem(N)). Le(Suc(a#), b#) <=> Lt(a#, b#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   
   
   ----------------------------------------------------------------------
   !(a : mem(N))  (b : mem(N)). ~Lt(b#, Suc(a#)) <=> Lt(a#, b#)
   : proofmanager.proof
> # val it = {},  |- !(a : mem(N)). Lt(a#, Suc(a#)): thm
> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(a : mem(N))  (b : mem(N)). Le(Suc(a#), b#) <=> Lt(a#, b#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   
   ----------------------------------------------------------------------
   Le(Suc(a), b) <=> Lt(a, b)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   ----------------------------------------------------------------------
   Le(Suc(a), b)
   (b : mem(N))(a : mem(N))
   1.Le(Suc(a), b)
   ----------------------------------------------------------------------
   Lt(a, b)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   1.Le(Suc(a), b)
   ----------------------------------------------------------------------
   ?(b' : mem(N)). Le(b'#, b) & Lt(a, b'#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   1.Le(Suc(a), b)
   ----------------------------------------------------------------------
   Le(Suc(a), b) & Lt(a, Suc(a))
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   ----------------------------------------------------------------------
   Le(Suc(a), b)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.~Le(Suc(a), b)
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> # val it = {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.Lt(b, Suc(a))
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.~Le(Suc(a), b)
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.Le(b, a)
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 2 subgoals:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.Le(b, a)
   3.Lt(a, a)
   ----------------------------------------------------------------------
   F
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.Le(b, a)
   ----------------------------------------------------------------------
   Lt(a, a)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.Le(b, a)
   ----------------------------------------------------------------------
   ?(b : mem(N)). Le(b#, a) & Lt(a, b#)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.Le(b, a)
   ----------------------------------------------------------------------
   Le(b, a) & Lt(a, b)
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 
Remaining subgoals:
val it =
   (b : mem(N))(a : mem(N))
   1.Lt(a, b)
   2.Le(b, a)
   3.Lt(a, a)
   ----------------------------------------------------------------------
   F
   : proofmanager.proof
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it =
   PROVED!{},  |- !(a : mem(N))  (b : mem(N)). Le(Suc(a#), b#) <=> Lt(a#, b#):
   proofmanager.proof
> # # # # # # # # # # # val Suc_Le_Lt =
   {},  |- !(a : mem(N))  (b : mem(N)). Le(Suc(a#), b#) <=> Lt(a#, b#): thm
> > 
*** Emacs/HOL command completed ***

> val it = PRFS []: proofmanager.proofs
> # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : mem(N)). ~Le(Suc(n#), n#)]: proofmanager.proofs
> val it = (): unit
> # val it = {},  |- !(a : mem(N))  (b : mem(N)). ~Le(a#, b#) <=> Lt(b#, a#): thm
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # val it = PROVED!{},  |- !(n : mem(N)). ~Le(Suc(n#), n#): proofmanager.proof
> # # # # # val NOT_Le_Suc = {},  |- !(n : mem(N)). ~Le(Suc(n#), n#): thm
> > val it = PRFS []: proofmanager.proofs
> # # # val it =
   PRFS
    [
     
     ----------------------------------------------------------------------
     !(n : mem(N))  (X : set)  (p : fun(X#, N))  (R : rel(X#, X#))
               (z : fun(N, X#)).
                 Upows(n#, p#, R#, z#) ==>
                 !(x : mem(X#)). ~App(p#, x#) = n# <=> Lt(App(p#, x#), n#)]:
   proofmanager.proofs
> val it = (): unit
> Loading proofManagerLib
> Loading Feedback
> Loading Feedback
> Loading Feedback
> # 1 subgoal:
val it =
   X(R : rel(X, X))(x : mem(X))(n : mem(N))(z : fun(N, X))(p : fun(X, N))
   1.Upows(n, p, R, z)
   ----------------------------------------------------------------------
   ~App(p, x) = n <=> Lt(App(p, x), n)
   : proofmanager.proof
> Upows_def;
val it =
   {(R : rel(X, X)), (X : set), (n : mem(N)), (p : fun(X, N)),
    (z : fun(N, X))}, 
   |- Upows(n, p, R, z) <=>
      IMAGE(p, Whole(X)) = Les(n) &
      Inj(z) &
      IMAGE(z, Whole(N)) = FIB(p, O) &
      (!(n0 : mem(N)).
          Lt(n0#, n) ==>
          ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X)).
            Inj(i#) &
            Inj(pi#) &
            IMAGE(i#, Whole(A#)) = FIB(p, n0#) &
            IMAGE(pi#, Whole(Pow(A#))) = FIB(p, Suc(n0#)) &
            !(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
      !(x : mem(X))  (s : mem(X)).
        Holds(R, x#, s#) <=>
        Lt(App(p, x#), n) &
        Suc(App(p, x#)) = App(p, s#) &
        ?(A : set)  (i : fun(A#, X))  (pi : fun(Pow(A#), X))  (a : mem(A#))
        (sa : mem(Pow(A#))).
          Inj(i#) &
          Inj(pi#) &
          IMAGE(i#, Whole(A#)) = FIB(p, App(p, x#)) &
          IMAGE(pi#, Whole(Pow(A#))) = FIB(p, App(p, s#)) &
          (!(a : mem(A#))  (s : mem(Pow(A#))).
              Holds(R, App(i#, a#), App(pi#, s#)) <=> IN(a#, s#)) &
          IN(a#, sa#) & App(i#, a#) = x# & App(pi#, sa#) = s#: thm
> 